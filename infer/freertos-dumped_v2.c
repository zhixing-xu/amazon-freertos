#include <assert.h>
#include <ctype.h>
#include <math.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <sys/socket.h>
#include <time.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// #anon_enum$ECP_TYPE_NONE=0$ECP_TYPE_SHORT_WEIERSTRASS=1$ECP_TYPE_MONTGOMERY=2
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 111
enum anonymous$86 { ECP_TYPE_NONE=0, ECP_TYPE_SHORT_WEIERSTRASS=1, ECP_TYPE_MONTGOMERY=2 };

// #anon_enum$JSMN_UNDEFINED=0$JSMN_OBJECT=1$JSMN_ARRAY=2$JSMN_STRING=3$JSMN_PRIMITIVE=4
// file ..\..\..\..\lib\third_party\jsmn\jsmn.h line 42
enum anonymous$52 { JSMN_UNDEFINED=0, JSMN_OBJECT=1, JSMN_ARRAY=2, JSMN_STRING=3, JSMN_PRIMITIVE=4 };

// #anon_enum$MBEDTLS_CIPHER_ID_NONE=0$MBEDTLS_CIPHER_ID_NULL=1$MBEDTLS_CIPHER_ID_AES=2$MBEDTLS_CIPHER_ID_DES=3$MBEDTLS_CIPHER_ID_3DES=4$MBEDTLS_CIPHER_ID_CAMELLIA=5$MBEDTLS_CIPHER_ID_BLOWFISH=6$MBEDTLS_CIPHER_ID_ARC4=7
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/cipher.h line 78
enum anonymous$9 { MBEDTLS_CIPHER_ID_NONE=0, MBEDTLS_CIPHER_ID_NULL=1, MBEDTLS_CIPHER_ID_AES=2, MBEDTLS_CIPHER_ID_DES=3, MBEDTLS_CIPHER_ID_3DES=4, MBEDTLS_CIPHER_ID_CAMELLIA=5, MBEDTLS_CIPHER_ID_BLOWFISH=6, MBEDTLS_CIPHER_ID_ARC4=7 };

// #anon_enum$MBEDTLS_CIPHER_NONE=0$MBEDTLS_CIPHER_NULL=1$MBEDTLS_CIPHER_AES_128_ECB=2$MBEDTLS_CIPHER_AES_192_ECB=3$MBEDTLS_CIPHER_AES_256_ECB=4$MBEDTLS_CIPHER_AES_128_CBC=5$MBEDTLS_CIPHER_AES_192_CBC=6$MBEDTLS_CIPHER_AES_256_CBC=7$MBEDTLS_CIPHER_AES_128_CFB128=8$MBEDTLS_CIPHER_AES_192_CFB128=9$MBEDTLS_CIPHER_AES_256_CFB128=10$MBEDTLS_CIPHER_AES_128_CTR=11$MBEDTLS_CIPHER_AES_192_CTR=12$MBEDTLS_CIPHER_AES_256_CTR=13$MBEDTLS_CIPHER_AES_128_GCM=14$MBEDTLS_CIPHER_AES_192_GCM=15$MBEDTLS_CIPHER_AES_256_GCM=16$MBEDTLS_CIPHER_CAMELLIA_128_ECB=17$MBEDTLS_CIPHER_CAMELLIA_192_ECB=18$MBEDTLS_CIPHER_CAMELLIA_256_ECB=19$MBEDTLS_CIPHER_CAMELLIA_128_CBC=20$MBEDTLS_CIPHER_CAMELLIA_192_CBC=21$MBEDTLS_CIPHER_CAMELLIA_256_CBC=22$MBEDTLS_CIPHER_CAMELLIA_128_CFB128=23$MBEDTLS_CIPHER_CAMELLIA_192_CFB128=24$MBEDTLS_CIPHER_CAMELLIA_256_CFB128=25$MBEDTLS_CIPHER_CAMELLIA_128_CTR=26$MBEDTLS_CIPHER_CAMELLIA_192_CTR=27$MBEDTLS_CIPHER_CAMELLIA_256_CTR=28$MBEDTLS_CIPHER_CAMELLIA_128_GCM=29$MBEDTLS_CIPHER_CAMELLIA_192_GCM=30$MBEDTLS_CIPHER_CAMELLIA_256_GCM=31$MBEDTLS_CIPHER_DES_ECB=32$MBEDTLS_CIPHER_DES_CBC=33$MBEDTLS_CIPHER_DES_EDE_ECB=34$MBEDTLS_CIPHER_DES_EDE_CBC=35$MBEDTLS_CIPHER_DES_EDE3_ECB=36$MBEDTLS_CIPHER_DES_EDE3_CBC=37$MBEDTLS_CIPHER_BLOWFISH_ECB=38$MBEDTLS_CIPHER_BLOWFISH_CBC=39$MBEDTLS_CIPHER_BLOWFISH_CFB64=40$MBEDTLS_CIPHER_BLOWFISH_CTR=41$MBEDTLS_CIPHER_ARC4_128=42$MBEDTLS_CIPHER_AES_128_CCM=43$MBEDTLS_CIPHER_AES_192_CCM=44$MBEDTLS_CIPHER_AES_256_CCM=45$MBEDTLS_CIPHER_CAMELLIA_128_CCM=46$MBEDTLS_CIPHER_CAMELLIA_192_CCM=47$MBEDTLS_CIPHER_CAMELLIA_256_CCM=48
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/cipher.h line 96
enum anonymous$15 { MBEDTLS_CIPHER_NONE=0, MBEDTLS_CIPHER_NULL=1, MBEDTLS_CIPHER_AES_128_ECB=2, MBEDTLS_CIPHER_AES_192_ECB=3, MBEDTLS_CIPHER_AES_256_ECB=4, MBEDTLS_CIPHER_AES_128_CBC=5, MBEDTLS_CIPHER_AES_192_CBC=6, MBEDTLS_CIPHER_AES_256_CBC=7, MBEDTLS_CIPHER_AES_128_CFB128=8, MBEDTLS_CIPHER_AES_192_CFB128=9, MBEDTLS_CIPHER_AES_256_CFB128=10, MBEDTLS_CIPHER_AES_128_CTR=11, MBEDTLS_CIPHER_AES_192_CTR=12, MBEDTLS_CIPHER_AES_256_CTR=13, MBEDTLS_CIPHER_AES_128_GCM=14, MBEDTLS_CIPHER_AES_192_GCM=15, MBEDTLS_CIPHER_AES_256_GCM=16, MBEDTLS_CIPHER_CAMELLIA_128_ECB=17, MBEDTLS_CIPHER_CAMELLIA_192_ECB=18, MBEDTLS_CIPHER_CAMELLIA_256_ECB=19, MBEDTLS_CIPHER_CAMELLIA_128_CBC=20, MBEDTLS_CIPHER_CAMELLIA_192_CBC=21, MBEDTLS_CIPHER_CAMELLIA_256_CBC=22, MBEDTLS_CIPHER_CAMELLIA_128_CFB128=23, MBEDTLS_CIPHER_CAMELLIA_192_CFB128=24, MBEDTLS_CIPHER_CAMELLIA_256_CFB128=25, MBEDTLS_CIPHER_CAMELLIA_128_CTR=26, MBEDTLS_CIPHER_CAMELLIA_192_CTR=27, MBEDTLS_CIPHER_CAMELLIA_256_CTR=28, MBEDTLS_CIPHER_CAMELLIA_128_GCM=29, MBEDTLS_CIPHER_CAMELLIA_192_GCM=30, MBEDTLS_CIPHER_CAMELLIA_256_GCM=31, MBEDTLS_CIPHER_DES_ECB=32, MBEDTLS_CIPHER_DES_CBC=33, MBEDTLS_CIPHER_DES_EDE_ECB=34, MBEDTLS_CIPHER_DES_EDE_CBC=35, MBEDTLS_CIPHER_DES_EDE3_ECB=36, MBEDTLS_CIPHER_DES_EDE3_CBC=37, MBEDTLS_CIPHER_BLOWFISH_ECB=38, MBEDTLS_CIPHER_BLOWFISH_CBC=39, MBEDTLS_CIPHER_BLOWFISH_CFB64=40, MBEDTLS_CIPHER_BLOWFISH_CTR=41, MBEDTLS_CIPHER_ARC4_128=42, MBEDTLS_CIPHER_AES_128_CCM=43, MBEDTLS_CIPHER_AES_192_CCM=44, MBEDTLS_CIPHER_AES_256_CCM=45, MBEDTLS_CIPHER_CAMELLIA_128_CCM=46, MBEDTLS_CIPHER_CAMELLIA_192_CCM=47, MBEDTLS_CIPHER_CAMELLIA_256_CCM=48 };

// #anon_enum$MBEDTLS_ECDH_OURS=0$MBEDTLS_ECDH_THEIRS=1
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/ecdh.h line 47
enum anonymous$6 { MBEDTLS_ECDH_OURS=0, MBEDTLS_ECDH_THEIRS=1 };

// #anon_enum$MBEDTLS_ECP_DP_NONE=0$MBEDTLS_ECP_DP_SECP192R1=1$MBEDTLS_ECP_DP_SECP224R1=2$MBEDTLS_ECP_DP_SECP256R1=3$MBEDTLS_ECP_DP_SECP384R1=4$MBEDTLS_ECP_DP_SECP521R1=5$MBEDTLS_ECP_DP_BP256R1=6$MBEDTLS_ECP_DP_BP384R1=7$MBEDTLS_ECP_DP_BP512R1=8$MBEDTLS_ECP_DP_CURVE25519=9$MBEDTLS_ECP_DP_CURVE448=10$MBEDTLS_ECP_DP_SECP192K1=11$MBEDTLS_ECP_DP_SECP224K1=12$MBEDTLS_ECP_DP_SECP256K1=13
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\ecp.h line 64
enum anonymous$64 { MBEDTLS_ECP_DP_NONE=0, MBEDTLS_ECP_DP_SECP192R1=1, MBEDTLS_ECP_DP_SECP224R1=2, MBEDTLS_ECP_DP_SECP256R1=3, MBEDTLS_ECP_DP_SECP384R1=4, MBEDTLS_ECP_DP_SECP521R1=5, MBEDTLS_ECP_DP_BP256R1=6, MBEDTLS_ECP_DP_BP384R1=7, MBEDTLS_ECP_DP_BP512R1=8, MBEDTLS_ECP_DP_CURVE25519=9, MBEDTLS_ECP_DP_CURVE448=10, MBEDTLS_ECP_DP_SECP192K1=11, MBEDTLS_ECP_DP_SECP224K1=12, MBEDTLS_ECP_DP_SECP256K1=13 };

// #anon_enum$MBEDTLS_KEY_EXCHANGE_NONE=0$MBEDTLS_KEY_EXCHANGE_RSA=1$MBEDTLS_KEY_EXCHANGE_DHE_RSA=2$MBEDTLS_KEY_EXCHANGE_ECDHE_RSA=3$MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA=4$MBEDTLS_KEY_EXCHANGE_PSK=5$MBEDTLS_KEY_EXCHANGE_DHE_PSK=6$MBEDTLS_KEY_EXCHANGE_RSA_PSK=7$MBEDTLS_KEY_EXCHANGE_ECDHE_PSK=8$MBEDTLS_KEY_EXCHANGE_ECDH_RSA=9$MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA=10$MBEDTLS_KEY_EXCHANGE_ECJPAKE=11
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/ssl_ciphersuites.h line 238
enum anonymous$62 { MBEDTLS_KEY_EXCHANGE_NONE=0, MBEDTLS_KEY_EXCHANGE_RSA=1, MBEDTLS_KEY_EXCHANGE_DHE_RSA=2, MBEDTLS_KEY_EXCHANGE_ECDHE_RSA=3, MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA=4, MBEDTLS_KEY_EXCHANGE_PSK=5, MBEDTLS_KEY_EXCHANGE_DHE_PSK=6, MBEDTLS_KEY_EXCHANGE_RSA_PSK=7, MBEDTLS_KEY_EXCHANGE_ECDHE_PSK=8, MBEDTLS_KEY_EXCHANGE_ECDH_RSA=9, MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA=10, MBEDTLS_KEY_EXCHANGE_ECJPAKE=11 };

// #anon_enum$MBEDTLS_MD_NONE=0$MBEDTLS_MD_MD2=1$MBEDTLS_MD_MD4=2$MBEDTLS_MD_MD5=3$MBEDTLS_MD_SHA1=4$MBEDTLS_MD_SHA224=5$MBEDTLS_MD_SHA256=6$MBEDTLS_MD_SHA384=7$MBEDTLS_MD_SHA512=8$MBEDTLS_MD_RIPEMD160=9
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\md.h line 56
enum anonymous$69 { MBEDTLS_MD_NONE=0, MBEDTLS_MD_MD2=1, MBEDTLS_MD_MD4=2, MBEDTLS_MD_MD5=3, MBEDTLS_MD_SHA1=4, MBEDTLS_MD_SHA224=5, MBEDTLS_MD_SHA256=6, MBEDTLS_MD_SHA384=7, MBEDTLS_MD_SHA512=8, MBEDTLS_MD_RIPEMD160=9 };

// #anon_enum$MBEDTLS_MODE_NONE=0$MBEDTLS_MODE_ECB=1$MBEDTLS_MODE_CBC=2$MBEDTLS_MODE_CFB=3$MBEDTLS_MODE_OFB=4$MBEDTLS_MODE_CTR=5$MBEDTLS_MODE_GCM=6$MBEDTLS_MODE_STREAM=7$MBEDTLS_MODE_CCM=8
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/cipher.h line 149
enum anonymous$11 { MBEDTLS_MODE_NONE=0, MBEDTLS_MODE_ECB=1, MBEDTLS_MODE_CBC=2, MBEDTLS_MODE_CFB=3, MBEDTLS_MODE_OFB=4, MBEDTLS_MODE_CTR=5, MBEDTLS_MODE_GCM=6, MBEDTLS_MODE_STREAM=7, MBEDTLS_MODE_CCM=8 };

// #anon_enum$MBEDTLS_OPERATION_NONE=-1$MBEDTLS_DECRYPT=0$MBEDTLS_ENCRYPT=1
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/cipher.h line 171
enum anonymous$13 { MBEDTLS_OPERATION_NONE=-1, MBEDTLS_DECRYPT=0, MBEDTLS_ENCRYPT=1 };

// #anon_enum$MBEDTLS_PADDING_PKCS7=0$MBEDTLS_PADDING_ONE_AND_ZEROS=1$MBEDTLS_PADDING_ZEROS_AND_LEN=2$MBEDTLS_PADDING_ZEROS=3$MBEDTLS_PADDING_NONE=4
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/cipher.h line 162
enum anonymous$12 { MBEDTLS_PADDING_PKCS7=0, MBEDTLS_PADDING_ONE_AND_ZEROS=1, MBEDTLS_PADDING_ZEROS_AND_LEN=2, MBEDTLS_PADDING_ZEROS=3, MBEDTLS_PADDING_NONE=4 };

// #anon_enum$MBEDTLS_PK_DEBUG_NONE=0$MBEDTLS_PK_DEBUG_MPI=1$MBEDTLS_PK_DEBUG_ECP=2
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/pk.h line 100
enum anonymous$65 { MBEDTLS_PK_DEBUG_NONE=0, MBEDTLS_PK_DEBUG_MPI=1, MBEDTLS_PK_DEBUG_ECP=2 };

// #anon_enum$MBEDTLS_PK_NONE=0$MBEDTLS_PK_RSA=1$MBEDTLS_PK_ECKEY=2$MBEDTLS_PK_ECKEY_DH=3$MBEDTLS_PK_ECDSA=4$MBEDTLS_PK_RSA_ALT=5$MBEDTLS_PK_RSASSA_PSS=6
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/pk.h line 76
enum anonymous$67 { MBEDTLS_PK_NONE=0, MBEDTLS_PK_RSA=1, MBEDTLS_PK_ECKEY=2, MBEDTLS_PK_ECKEY_DH=3, MBEDTLS_PK_ECDSA=4, MBEDTLS_PK_RSA_ALT=5, MBEDTLS_PK_RSASSA_PSS=6 };

// #anon_enum$MCAST_INCLUDE=0$MCAST_EXCLUDE=1
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\ws2ipdef.h line 707
enum anonymous$77 { MCAST_INCLUDE=0, MCAST_EXCLUDE=1 };

// #anon_enum$eARPCacheMiss=0$eARPCacheHit=1$eCantSendPacket=2
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_ARP.h line 50
enum anonymous$85 { eARPCacheMiss=0, eARPCacheHit=1, eCantSendPacket=2 };

// #anon_enum$eIngest_Result_FileComplete=-1$eIngest_Result_SigCheckFail=-2$eIngest_Result_FileCloseFail=-3$eIngest_Result_NullContext=-4$eIngest_Result_BadFileHandle=-5$eIngest_Result_UnexpectedBlock=-6$eIngest_Result_BlockOutOfRange=-7$eIngest_Result_BadData=-8$eIngest_Result_WriteBlockFailed=-9$eIngest_Result_Continue=0
// file ..\..\..\..\lib\include\private\aws_ota_agent_internal.h line 38
enum anonymous$24 { eIngest_Result_FileComplete=-1, eIngest_Result_SigCheckFail=-2, eIngest_Result_FileCloseFail=-3, eIngest_Result_NullContext=-4, eIngest_Result_BadFileHandle=-5, eIngest_Result_UnexpectedBlock=-6, eIngest_Result_BlockOutOfRange=-7, eIngest_Result_BadData=-8, eIngest_Result_WriteBlockFailed=-9, eIngest_Result_Continue=0 };

// #anon_enum$eJobParamType_StringCopy=0$eJobParamType_StringInJobDoc=1$eJobParamType_Object=2$eJobParamType_Array=3$eJobParamType_UInt32=4$eJobParamType_Base64=5$eJobParamType_Ident=6
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 185
enum anonymous$25 { eJobParamType_StringCopy=0, eJobParamType_StringInJobDoc=1, eJobParamType_Object=2, eJobParamType_Array=3, eJobParamType_UInt32=4, eJobParamType_Base64=5, eJobParamType_Ident=6 };

// #anon_enum$eJobStatus_InProgress=0$eJobStatus_Failed=1$eJobStatus_Succeeded=2$eJobStatus_Rejected=3$eJobStatus_FailedWithVal=4$eJobStatusLast=4$eNumJobStatusMappings=5
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 158
enum anonymous$26 { eJobStatus_InProgress=0, eJobStatus_Failed=1, eJobStatus_Succeeded=2, eJobStatus_Rejected=3, eJobStatus_FailedWithVal=4, eJobStatusLast=4, eNumJobStatusMappings=5 };

// #anon_enum$eMQTTAgentPublish=0$eMQTTAgentDisconnect=1
// file ..\..\..\..\lib\include\aws_mqtt_agent.h line 77
enum anonymous$43 { eMQTTAgentPublish=0, eMQTTAgentDisconnect=1 };

// #anon_enum$eMQTTAgentSuccess=0$eMQTTAgentFailure=1$eMQTTAgentTimeout=2$eMQTTAgentAPICalledFromCallback=3
// file ..\..\..\..\lib\include\aws_mqtt_agent.h line 59
enum anonymous$41 { eMQTTAgentSuccess=0, eMQTTAgentFailure=1, eMQTTAgentTimeout=2, eMQTTAgentAPICalledFromCallback=3 };

// #anon_enum$eMQTTCONNCouldNotBeSent=2$eMQTTCONNACKConnectionAccepted=4$eMQTTCONNACKConnectionRejected=6$eMQTTDISCONNSent=8$eMQTTDISCONNCouldNotBeSent=10$eMQTTPUBCouldNotBeSent=12$eMQTTPUBSent=14$eMQTTPUBACKReceived=16$eMQTTSUBCouldNotBeSent=18$eMQTTSUBACKSubscriptionAccepted=20$eMQTTSUBACKSubscriptionRejected=22$eMQTTUNSUBCouldNotBeSent=24$eMQTTUNSUBACKReceived=26$eMQTTBufferAdded=28$eMQTTBufferCouldNotBeAdded=30$eMQTTOperationTimedOut=32$eMQTTClientGotDisconnected=34
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 149
enum anonymous$35 { eMQTTCONNCouldNotBeSent=2, eMQTTCONNACKConnectionAccepted=4, eMQTTCONNACKConnectionRejected=6, eMQTTDISCONNSent=8, eMQTTDISCONNCouldNotBeSent=10, eMQTTPUBCouldNotBeSent=12, eMQTTPUBSent=14, eMQTTPUBACKReceived=16, eMQTTSUBCouldNotBeSent=18, eMQTTSUBACKSubscriptionAccepted=20, eMQTTSUBACKSubscriptionRejected=22, eMQTTUNSUBCouldNotBeSent=24, eMQTTUNSUBACKReceived=26, eMQTTBufferAdded=28, eMQTTBufferCouldNotBeAdded=30, eMQTTOperationTimedOut=32, eMQTTClientGotDisconnected=34 };

// #anon_enum$eMQTTConnACKConnectionAccepted=0$eMQTTConnACKUnacceptableProtocolVersion=1$eMQTTConnACKIdentifierRejected=2$eMQTTConnACKServerUnavailable=3$eMQTTConnACKBadUsernameOrPassword=4$eMQTTConnACKUnauthorized=5
// file d:\tuttle\freertos\lib\include\aws_mqtt_lib.h line 176
enum anonymous$37 { eMQTTConnACKConnectionAccepted=0, eMQTTConnACKUnacceptableProtocolVersion=1, eMQTTConnACKIdentifierRejected=2, eMQTTConnACKServerUnavailable=3, eMQTTConnACKBadUsernameOrPassword=4, eMQTTConnACKUnauthorized=5 };

// #anon_enum$eMQTTDisconnectReasonMalformedPacket=0$eMQTTDisconnectReasonBrokerRefusedConnection=1$eMQTTDisconnectReasonUserRequest=2$eMQTTDisconnectReasonConnectTimeout=3
// file d:\tuttle\freertos\lib\include\aws_mqtt_lib.h line 142
enum anonymous$36 { eMQTTDisconnectReasonMalformedPacket=0, eMQTTDisconnectReasonBrokerRefusedConnection=1, eMQTTDisconnectReasonUserRequest=2, eMQTTDisconnectReasonConnectTimeout=3 };

// #anon_enum$eMQTTFalse=0$eMQTTTrue=1
// file d:\tuttle\freertos\lib\include\aws_mqtt_lib.h line 65
enum anonymous$46 { eMQTTFalse=0, eMQTTTrue=1 };

// #anon_enum$eMQTTNotConnected=0$eMQTTConnectionInProgress=1$eMQTTConnected=2
// file d:\tuttle\freertos\lib\include\aws_mqtt_lib.h line 163
enum anonymous$33 { eMQTTNotConnected=0, eMQTTConnectionInProgress=1, eMQTTConnected=2 };

// #anon_enum$eMQTTPublish=0$eMQTTConnACK=1$eMQTTUnexpectedConnACK=2$eMQTTPubACK=3$eMQTTUnexpectedPubACK=4$eMQTTSubACK=5$eMQTTUnexpectedSubACK=6$eMQTTUnSubACK=7$eMQTTUnexpectedUnSubACK=8$eMQTTClientDisconnected=9$eMQTTPacketDropped=10$eMQTTTimeout=11$eMQTTPingTimeout=12
// file d:\tuttle\freertos\lib\include\aws_mqtt_lib.h line 119
enum anonymous$34 { eMQTTPublish=0, eMQTTConnACK=1, eMQTTUnexpectedConnACK=2, eMQTTPubACK=3, eMQTTUnexpectedPubACK=4, eMQTTSubACK=5, eMQTTUnexpectedSubACK=6, eMQTTUnSubACK=7, eMQTTUnexpectedUnSubACK=8, eMQTTClientDisconnected=9, eMQTTPacketDropped=10, eMQTTTimeout=11, eMQTTPingTimeout=12 };

// #anon_enum$eMQTTQoS0=0$eMQTTQoS1=1$eMQTTQoS2=2
// file d:\tuttle\freertos\lib\include\aws_mqtt_lib.h line 153
enum anonymous$47 { eMQTTQoS0=0, eMQTTQoS1=1, eMQTTQoS2=2 };

// #anon_enum$eMQTTRxMessageStore=0$eMQTTRxMessageDrop=1
// file d:\tuttle\freertos\lib\include\aws_mqtt_lib.h line 106
enum anonymous$40 { eMQTTRxMessageStore=0, eMQTTRxMessageDrop=1 };

// #anon_enum$eMQTTRxNextBytePacketType=0$eMQTTRxNextBytePacketLength=1$eMQTTRxNextByteMessage=2
// file d:\tuttle\freertos\lib\include\aws_mqtt_lib.h line 93
enum anonymous$38 { eMQTTRxNextBytePacketType=0, eMQTTRxNextBytePacketLength=1, eMQTTRxNextByteMessage=2 };

// #anon_enum$eMQTTServiceSocket=0$eMQTTConnectRequest=1$eMQTTDisconnectRequest=2$eMQTTSubscribeRequest=3$eMQTTUnsubscribeRequest=4$eMQTTPublishRequest=5
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 133
enum anonymous$39 { eMQTTServiceSocket=0, eMQTTConnectRequest=1, eMQTTDisconnectRequest=2, eMQTTSubscribeRequest=3, eMQTTUnsubscribeRequest=4, eMQTTPublishRequest=5 };

// #anon_enum$eMQTTSubACKSuccessQos0=0$eMQTTSubACKSuccessQos1=1$eMQTTSubACKSuccessQos2=2$eMQTTSubACKFailure=128
// file d:\tuttle\freertos\lib\include\aws_mqtt_lib.h line 192
enum anonymous$48 { eMQTTSubACKSuccessQos0=0, eMQTTSubACKSuccessQos1=1, eMQTTSubACKSuccessQos2=2, eMQTTSubACKFailure=128 };

// #anon_enum$eMQTTSuccess=0$eMQTTFailure=1$eMQTTClientAlreadyConnected=2$eMQTTClientConnectionInProgress=3$eMQTTClientNotConnected=4$eMQTTNoFreeBuffer=5$eMQTTSendFailed=6$eMQTTMalformedPacketReceived=7$eMQTTSubscriptionManagerFull=8
// file d:\tuttle\freertos\lib\include\aws_mqtt_lib.h line 74
enum anonymous$44 { eMQTTSuccess=0, eMQTTFailure=1, eMQTTClientAlreadyConnected=2, eMQTTClientConnectionInProgress=3, eMQTTClientNotConnected=4, eMQTTNoFreeBuffer=5, eMQTTSendFailed=6, eMQTTMalformedPacketReceived=7, eMQTTSubscriptionManagerFull=8 };

// #anon_enum$eMQTTTopicFilterTypeInvalid=0$eMQTTTopicFilterTypeSimple=1$eMQTTTopicFilterTypeWildCard=2
// file d:\tuttle\freertos\lib\include\aws_mqtt_lib.h line 203
enum anonymous$45 { eMQTTTopicFilterTypeInvalid=0, eMQTTTopicFilterTypeSimple=1, eMQTTTopicFilterTypeWildCard=2 };

// #anon_enum$eNoAction=0$eSetBits=1$eIncrement=2$eSetValueWithOverwrite=3$eSetValueWithoutOverwrite=4
// file ..\..\..\..\lib\include\task.h line 81
enum anonymous$56 { eNoAction=0, eSetBits=1, eIncrement=2, eSetValueWithOverwrite=3, eSetValueWithoutOverwrite=4 };

// #anon_enum$eNoEvent=-1$eNetworkDownEvent=0$eNetworkRxEvent=1$eARPTimerEvent=2$eStackTxEvent=3$eDHCPEvent=4$eTCPTimerEvent=5$eTCPAcceptEvent=6$eTCPNetStat=7$eSocketBindEvent=8$eSocketCloseEvent=9$eSocketSelectEvent=10$eSocketSignalEvent=11
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP_Private.h line 242
enum anonymous$61 { eNoEvent=-1, eNetworkDownEvent=0, eNetworkRxEvent=1, eARPTimerEvent=2, eStackTxEvent=3, eDHCPEvent=4, eTCPTimerEvent=5, eTCPAcceptEvent=6, eTCPNetStat=7, eSocketBindEvent=8, eSocketCloseEvent=9, eSocketSelectEvent=10, eSocketSignalEvent=11 };

// #anon_enum$eOTA_AgentState_NotReady=0$eOTA_AgentState_Ready=1$eOTA_AgentState_ShuttingDown=2
// file ..\..\..\..\lib\include\aws_ota_agent.h line 53
enum anonymous$27 { eOTA_AgentState_NotReady=0, eOTA_AgentState_Ready=1, eOTA_AgentState_ShuttingDown=2 };

// #anon_enum$eOTA_ImageState_Unknown=0$eOTA_ImageState_Testing=1$eOTA_ImageState_Accepted=2$eOTA_ImageState_Rejected=3$eOTA_ImageState_Aborted=4$eOTA_ImageState_Last=4
// file ..\..\..\..\lib\include\aws_ota_agent.h line 118
enum anonymous$28 { eOTA_ImageState_Unknown=0, eOTA_ImageState_Testing=1, eOTA_ImageState_Accepted=2, eOTA_ImageState_Rejected=3, eOTA_ImageState_Aborted=4, eOTA_ImageState_Last=4 };

// #anon_enum$eOTA_JobParseErr_None=0$eOTA_JobParseErr_OutOfMemory=1$eOTA_JobParseErr_FieldTooLarge=2$eOTA_JobParseErr_FieldTypeMismatch=3$eOTA_JobParseErr_Base64Decode=4$eOTA_JobParseErr_InvalidNumChar=5$eOTA_JobParseErr_DuplicatesNotAllowed=6$eOTA_JobParseErr_BusyWithExistingJob=7$eOTA_JobParseErr_MalformedJobDoc=8$eOTA_JobParseErr_ZeroFileSize=9
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 198
enum anonymous$23 { eOTA_JobParseErr_None=0, eOTA_JobParseErr_OutOfMemory=1, eOTA_JobParseErr_FieldTooLarge=2, eOTA_JobParseErr_FieldTypeMismatch=3, eOTA_JobParseErr_Base64Decode=4, eOTA_JobParseErr_InvalidNumChar=5, eOTA_JobParseErr_DuplicatesNotAllowed=6, eOTA_JobParseErr_BusyWithExistingJob=7, eOTA_JobParseErr_MalformedJobDoc=8, eOTA_JobParseErr_ZeroFileSize=9 };

// #anon_enum$eReleaseBuffer=0$eProcessBuffer=1$eReturnEthernetFrame=2$eFrameConsumed=3
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP_Private.h line 234
enum anonymous$60 { eReleaseBuffer=0, eProcessBuffer=1, eReturnEthernetFrame=2, eFrameConsumed=3 };

// #anon_enum$eRunning=0$eReady=1$eBlocked=2$eSuspended=3$eDeleted=4$eInvalid=5
// file ..\..\..\..\lib\include\task.h line 70
enum anonymous$55 { eRunning=0, eReady=1, eBlocked=2, eSuspended=3, eDeleted=4, eInvalid=5 };

// #anon_enum$eWaitingSendFirstDiscover=0$eWaitingOffer=1$eWaitingAcknowledge=2$eLeasedAddress=3$eNotUsingLeasedAddress=4
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DHCP.c line 153
enum anonymous$102 { eWaitingSendFirstDiscover=0, eWaitingOffer=1, eWaitingAcknowledge=2, eLeasedAddress=3, eNotUsingLeasedAddress=4 };

// ST[vU64'xTail'|vU64'xHead'|U64'xLength'|U64'xTriggerLevelBytes'|v*{V}$V$'xTaskWaitingToReceive'|v*{V}$V$'xTaskWaitingToSend'|*{U8}$U8$'pucBuffer'|U8'ucFlags'|U24'$pad8'|U32'uxStreamBufferNumber']
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 141
struct xSTREAM_BUFFER;

// tag-#anon#ST[*{S32(*{V}$V$|*{U8}$U8$|U64|*{U64}$U64$)->S32}$S32(*{V}$V$|*{U8}$U8$|U64|*{U64}$U64$)->S32$'f_source'|*{V}$V$'p_source'|U64'size'|U64'threshold'|S32'strong'|U32'$pad5']
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/entropy.h line 110
struct anonymous$71;

// tag-#anon#ST[*{SYM#tag-mbedtls_x509_crt#}$SYM#tag-mbedtls_x509_crt#$'crt'|U32'flags'|U32'$pad2']
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 83
struct anonymous$110;

// tag-#anon#ST[*{U8}$U8$'buf'|U64'buflen'|*{U8}$U8$'info']
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/pem.h line 54
struct anonymous$93;

// tag-#anon#ST[*{U8}$U8$'pacFilepath'|SYM#tag-#anon#UN[S32'iFileHandle'|*{SYM#tag-_iobuf#}$SYM#tag-_iobuf#$'pstFile'|*{U8}$U8$'pucFile']#'$anon0'|*{V}$V$'pvRequestTimer'|U32'iFileSize'|U32'iBlocksRemaining'|U16'usSigSize'|U16'$pad6'|U32'ulFileAttributes'|U32'ulServerFileID'|U32'ulRequestMomentum'|*{U8}$U8$'pacJobName'|*{U8}$U8$'pacStreamName'|*{U8}$U8$'pacSignature'|*{U8}$U8$'pacRxBlockBitmap'|*{U8}$U8$'pacCertFilepath'|U32'ulUpdaterVersion'|U32'$pad16']
// file ..\..\..\..\lib\include\aws_ota_agent.h line 134
struct anonymous$29;

// tag-#anon#ST[*{V}$V$'key'|*{S32(*{V}$V$|S32|*{U64}$U64$|*{cU8}$cU8$|*{U8}$U8$|U64)->S32}$S32(*{V}$V$|S32|*{U64}$U64$|*{cU8}$cU8$|*{U8}$U8$|U64)->S32$'decrypt_func'|*{S32(*{V}$V$|*{S32(*{V}$V$|*{U8}$U8$|U64)->S32}$S32(*{V}$V$|*{U8}$U8$|U64)->S32$|*{V}$V$|S32|SYM##anon_enum$MBEDTLS_MD_NONE=0$MBEDTLS_MD_MD2=1$MBEDTLS_MD_MD4=2$MBEDTLS_MD_MD5=3$MBEDTLS_MD_SHA1=4$MBEDTLS_MD_SHA224=5$MBEDTLS_MD_SHA256=6$MBEDTLS_MD_SHA384=7$MBEDTLS_MD_SHA512=8$MBEDTLS_MD_RIPEMD160=9#|U32|*{cU8}$cU8$|*{U8}$U8$)->S32}$S32(*{V}$V$|*{S32(*{V}$V$|*{U8}$U8$|U64)->S32}$S32(*{V}$V$|*{U8}$U8$|U64)->S32$|*{V}$V$|S32|SYM##anon_enum$MBEDTLS_MD_NONE=0$MBEDTLS_MD_MD2=1$MBEDTLS_MD_MD4=2$MBEDTLS_MD_MD5=3$MBEDTLS_MD_SHA1=4$MBEDTLS_MD_SHA224=5$MBEDTLS_MD_SHA256=6$MBEDTLS_MD_SHA384=7$MBEDTLS_MD_SHA512=8$MBEDTLS_MD_RIPEMD160=9#|U32|*{cU8}$cU8$|*{U8}$U8$)->S32$'sign_func'|*{U64(*{V}$V$)->U64}$U64(*{V}$V$)->U64$'key_len_func']
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/pk_internal.h line 89
struct anonymous$94;

// tag-#anon#ST[*{V}$V$'pvThread']
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 84
struct anonymous$76;

// tag-#anon#ST[*{V}$V$'xTaskHandle'|ARR15{S8}$S8$'cTaskName'|U8'$pad2']
// file ..\..\..\common\shadow\aws_shadow_lightbulb_on_off.c line 131
struct anonymous$128;

// tag-#anon#ST[*{V}$V$'xTaskToNotify'|U32'ulDataLength'|ARR128{S8}$S8$'pcUpdateBuffer'|U32'$pad3']
// file ..\..\..\common\shadow\aws_shadow_lightbulb_on_off.c line 123
struct anonymous$127;

// tag-#anon#ST[*{cS8}$cS8$'asn1'|U64'asn1_len'|*{cS8}$cS8$'name'|*{cS8}$cS8$'description']
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/oid.h line 391
struct anonymous$0;

// tag-#anon#ST[*{cS8}$cS8$'pcGroupName'|*{cS8}$cS8$'pcCoreAddress'|U8'ucInterface'|U56'$pad3']
// file ..\..\..\..\lib\include\aws_greengrass_discovery.h line 45
struct anonymous$49;

// tag-#anon#ST[*{cS8}$cS8$'pcHostAddress'|*{S8}$S8$'pcCertificate'|U32'ulCertificateSize'|U16'usPort'|U16'$pad4']
// file ..\..\..\..\lib\include\aws_greengrass_discovery.h line 59
struct anonymous$53;

// tag-#anon#ST[*{cS8}$cS8$'pcSrcKey'|cU8'bRequired'|U24'$pad2'|cU32'ulDestOffset'|cSYM##anon_enum$eJobParamType_StringCopy=0$eJobParamType_StringInJobDoc=1$eJobParamType_Object=2$eJobParamType_Array=3$eJobParamType_UInt32=4$eJobParamType_Base64=5$eJobParamType_Ident=6#'eModelParamType'|cSYM##anon_enum$JSMN_UNDEFINED=0$JSMN_OBJECT=1$JSMN_ARRAY=2$JSMN_STRING=3$JSMN_PRIMITIVE=4#'eJasmineType']
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 218
struct anonymous$20;

// tag-#anon#ST[*{cS8}$cS8$'pszName'|*{S64(...)->S64}$S64(...)->S64$'pfAddress']
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\wspiapi.h line 863
struct anonymous$109;

// tag-#anon#ST[*{cSYM#tag-#anon#ST[SYM##anon_enum$MBEDTLS_CIPHER_NONE=0$MBEDTLS_CIPHER_NULL=1$MBEDTLS_CIPHER_AES_128_ECB=2$MBEDTLS_CIPHER_AES_192_ECB=3$MBEDTLS_CIPHER_AES_256_ECB=4$MBEDTLS_CIPHER_AES_128_CBC=5$MBEDTLS_CIPHER_AES_192_CBC=6$MBEDTLS_CIPHER_AES_256_CBC=7$MBEDTLS_CIPHER_AES_128_CFB128=8$MBEDTLS_CIPHER_AES_192_CFB128=9$MBEDTLS_CIPHER_AES_256_CFB128=10$MBEDTLS_CIPHER_AES_128_CTR=11$MBEDTLS_CIPHER_AES_192_CTR=12$MBEDTLS_CIPHER_AES_256_CTR=13$MBEDTLS_CIPHER_AES_128_GCM=14$MBEDTLS_CIPHER_AES_192_GCM=15$MBEDTLS_CIPHER_AES_256_GCM=16$MBEDTLS_CIPHER_CAMELLIA_128_ECB=17$MBEDTLS_CIPHER_CAMELLIA_192_ECB=18$MBEDTLS_CIPHER_CAMELLIA_256_ECB=19$MBEDTLS_CIPHER_CAMELLIA_128_CBC=20$MBEDTLS_CIPHER_CAMELLIA_192_CBC=21$MBEDTLS_CIPHER_CAMELLIA_256_CBC=22$MBEDTLS_CIPHER_CAMELLIA_128_CFB128=23$MBEDTLS_CIPHER_CAMELLIA_192_CFB128=24$MBEDTLS_CIPHER_CAMELLIA_256_CFB128=25$MBEDTLS_CIPHER_CAMELLIA_128_CTR=26$MBEDTLS_CIPHER_CAMELLIA_192_CTR=27$MBEDTLS_CIPHER_CAMELLIA_256_CTR=28$MBEDTLS_CIPHER_CAMELLIA_128_GCM=29$MBEDTLS_CIPHER_CAMELLIA_192_GCM=30$MBEDTLS_CIPHER_CAMELLIA_256_GCM=31$MBEDTLS_CIPHER_DES_ECB=32$MBEDTLS_CIPHER_DES_CBC=33$MBEDTLS_CIPHER_DES_EDE_ECB=34$MBEDTLS_CIPHER_DES_EDE_CBC=35$MBEDTLS_CIPHER_DES_EDE3_ECB=36$MBEDTLS_CIPHER_DES_EDE3_CBC=37$MBEDTLS_CIPHER_BLOWFISH_ECB=38$MBEDTLS_CIPHER_BLOWFISH_CBC=39$MBEDTLS_CIPHER_BLOWFISH_CFB64=40$MBEDTLS_CIPHER_BLOWFISH_CTR=41$MBEDTLS_CIPHER_ARC4_128=42$MBEDTLS_CIPHER_AES_128_CCM=43$MBEDTLS_CIPHER_AES_192_CCM=44$MBEDTLS_CIPHER_AES_256_CCM=45$MBEDTLS_CIPHER_CAMELLIA_128_CCM=46$MBEDTLS_CIPHER_CAMELLIA_192_CCM=47$MBEDTLS_CIPHER_CAMELLIA_256_CCM=48#'type'|SYM##anon_enum$MBEDTLS_MODE_NONE=0$MBEDTLS_MODE_ECB=1$MBEDTLS_MODE_CBC=2$MBEDTLS_MODE_CFB=3$MBEDTLS_MODE_OFB=4$MBEDTLS_MODE_CTR=5$MBEDTLS_MODE_GCM=6$MBEDTLS_MODE_STREAM=7$MBEDTLS_MODE_CCM=8#'mode'|U32'key_bitlen'|U32'$pad3'|*{cS8}$cS8$'name'|U32'iv_size'|S32'flags'|U32'block_size'|U32'$pad8'|*{cSYM#tag-mbedtls_cipher_base_t#}$cSYM#tag-mbedtls_cipher_base_t#$'base']#}$cSYM#tag-#anon#ST[SYM##anon_enum$MBEDTLS_CIPHER_NONE=0$MBEDTLS_CIPHER_NULL=1$MBEDTLS_CIPHER_AES_128_ECB=2$MBEDTLS_CIPHER_AES_192_ECB=3$MBEDTLS_CIPHER_AES_256_ECB=4$MBEDTLS_CIPHER_AES_128_CBC=5$MBEDTLS_CIPHER_AES_192_CBC=6$MBEDTLS_CIPHER_AES_256_CBC=7$MBEDTLS_CIPHER_AES_128_CFB128=8$MBEDTLS_CIPHER_AES_192_CFB128=9$MBEDTLS_CIPHER_AES_256_CFB128=10$MBEDTLS_CIPHER_AES_128_CTR=11$MBEDTLS_CIPHER_AES_192_CTR=12$MBEDTLS_CIPHER_AES_256_CTR=13$MBEDTLS_CIPHER_AES_128_GCM=14$MBEDTLS_CIPHER_AES_192_GCM=15$MBEDTLS_CIPHER_AES_256_GCM=16$MBEDTLS_CIPHER_CAMELLIA_128_ECB=17$MBEDTLS_CIPHER_CAMELLIA_192_ECB=18$MBEDTLS_CIPHER_CAMELLIA_256_ECB=19$MBEDTLS_CIPHER_CAMELLIA_128_CBC=20$MBEDTLS_CIPHER_CAMELLIA_192_CBC=21$MBEDTLS_CIPHER_CAMELLIA_256_CBC=22$MBEDTLS_CIPHER_CAMELLIA_128_CFB128=23$MBEDTLS_CIPHER_CAMELLIA_192_CFB128=24$MBEDTLS_CIPHER_CAMELLIA_256_CFB128=25$MBEDTLS_CIPHER_CAMELLIA_128_CTR=26$MBEDTLS_CIPHER_CAMELLIA_192_CTR=27$MBEDTLS_CIPHER_CAMELLIA_256_CTR=28$MBEDTLS_CIPHER_CAMELLIA_128_GCM=29$MBEDTLS_CIPHER_CAMELLIA_192_GCM=30$MBEDTLS_CIPHER_CAMELLIA_256_GCM=31$MBEDTLS_CIPHER_DES_ECB=32$MBEDTLS_CIPHER_DES_CBC=33$MBEDTLS_CIPHER_DES_EDE_ECB=34$MBEDTLS_CIPHER_DES_EDE_CBC=35$MBEDTLS_CIPHER_DES_EDE3_ECB=36$MBEDTLS_CIPHER_DES_EDE3_CBC=37$MBEDTLS_CIPHER_BLOWFISH_ECB=38$MBEDTLS_CIPHER_BLOWFISH_CBC=39$MBEDTLS_CIPHER_BLOWFISH_CFB64=40$MBEDTLS_CIPHER_BLOWFISH_CTR=41$MBEDTLS_CIPHER_ARC4_128=42$MBEDTLS_CIPHER_AES_128_CCM=43$MBEDTLS_CIPHER_AES_192_CCM=44$MBEDTLS_CIPHER_AES_256_CCM=45$MBEDTLS_CIPHER_CAMELLIA_128_CCM=46$MBEDTLS_CIPHER_CAMELLIA_192_CCM=47$MBEDTLS_CIPHER_CAMELLIA_256_CCM=48#'type'|SYM##anon_enum$MBEDTLS_MODE_NONE=0$MBEDTLS_MODE_ECB=1$MBEDTLS_MODE_CBC=2$MBEDTLS_MODE_CFB=3$MBEDTLS_MODE_OFB=4$MBEDTLS_MODE_CTR=5$MBEDTLS_MODE_GCM=6$MBEDTLS_MODE_STREAM=7$MBEDTLS_MODE_CCM=8#'mode'|U32'key_bitlen'|U32'$pad3'|*{cS8}$cS8$'name'|U32'iv_size'|S32'flags'|U32'block_size'|U32'$pad8'|*{cSYM#tag-mbedtls_cipher_base_t#}$cSYM#tag-mbedtls_cipher_base_t#$'base']#$'cipher_info'|S32'key_bitlen'|SYM##anon_enum$MBEDTLS_OPERATION_NONE=-1$MBEDTLS_DECRYPT=0$MBEDTLS_ENCRYPT=1#'operation'|*{V(*{U8}$U8$|U64|U64)->V}$V(*{U8}$U8$|U64|U64)->V$'add_padding'|*{S32(*{U8}$U8$|U64|*{U64}$U64$)->S32}$S32(*{U8}$U8$|U64|*{U64}$U64$)->S32$'get_padding'|ARR16{U8}$U8$'unprocessed_data'|U64'unprocessed_len'|ARR16{U8}$U8$'iv'|U64'iv_size'|*{V}$V$'cipher_ctx']
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/cipher.h line 245
struct anonymous$14;

// tag-#anon#ST[*{cSYM#tag-mbedtls_md_info_t#}$cSYM#tag-mbedtls_md_info_t#$'md_info'|*{V}$V$'md_ctx'|*{V}$V$'hmac_ctx']
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\md.h line 83
struct anonymous$3;

// tag-#anon#ST[*{cSYM#tag-mbedtls_pk_info_t#}$cSYM#tag-mbedtls_pk_info_t#$'pk_info'|*{V}$V$'pk_ctx']
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/pk.h line 128
struct anonymous$70;

// tag-#anon#ST[ARR16{U8}$U8$'counter'|S32'reseed_counter'|S32'prediction_resistance'|U64'entropy_len'|S32'reseed_interval'|U32'$pad5'|SYM#tag-#anon#ST[S32'nr'|U32'$pad1'|*{U32}$U32$'rk'|ARR68{U32}$U32$'buf']#'aes_ctx'|*{S32(*{V}$V$|*{U8}$U8$|U64)->S32}$S32(*{V}$V$|*{U8}$U8$|U64)->S32$'f_entropy'|*{V}$V$'p_entropy']
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/ctr_drbg.h line 106
struct anonymous$63;

// tag-#anon#ST[ARR2{U32}$U32$'total'|ARR5{U32}$U32$'state'|ARR64{U8}$U8$'buffer']
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/sha1.h line 58
struct anonymous$68;

// tag-#anon#ST[ARR2{U32}$U32$'total'|ARR8{U32}$U32$'state'|ARR64{U8}$U8$'buffer'|S32'is224']
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/sha256.h line 53
struct anonymous$72;

// tag-#anon#ST[ARR2{U8}$U8$'ucFillPacket'|ARR70{U8}$U8$'ucLastPacket']
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP_Private.h line 477
struct anonymous$98;

// tag-#anon#ST[ARR7{U16}$U16$'indexOfNextAvailableHandle'|ARR7{U16}$U16$'lowestIndexOfClass'|ARR7{U16}$U16$'highestIndexOfClass'|ARR7{U16}$U16$'handleCountWaterMarksOfClass'|ARR850{U8}$U8$'objectHandles']
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\Include\trcRecorder.h line 856
struct anonymous$112;

// tag-#anon#ST[BF1{U32}$U32$'bHasInit'|BF1{U32}$U32$'bSendFullSize'|BF1{U32}$U32$'bTimeStamps'|BF29{U29}$U29$'$bit_field_pad3']
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_TCP_WIN.h line 96
struct anonymous$100;

// tag-#anon#ST[BF1{U32}$U32$'bMssChange'|BF1{U32}$U32$'bPassAccept'|BF1{U32}$U32$'bPassQueued'|BF1{U32}$U32$'bReuseSocket'|BF1{U32}$U32$'bCloseAfterSend'|BF1{U32}$U32$'bUserShutdown'|BF1{U32}$U32$'bCloseRequested'|BF1{U32}$U32$'bLowWater'|BF1{U32}$U32$'bWinChange'|BF1{U32}$U32$'bSendKeepAlive'|BF1{U32}$U32$'bWaitKeepAlive'|BF1{U32}$U32$'bConnPrepared'|BF1{U32}$U32$'bFinAccepted'|BF1{U32}$U32$'bFinSent'|BF1{U32}$U32$'bFinRecv'|BF1{U32}$U32$'bFinAcked'|BF1{U32}$U32$'bFinLast'|BF1{U32}$U32$'bRxStopped'|BF1{U32}$U32$'bMallocError'|BF1{U32}$U32$'bWinScaling'|BF12{U12}$U12$'$bit_field_pad20']
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP_Private.h line 496
struct anonymous$104;

// tag-#anon#ST[BF8{U32}$U32$'ucTransmitCount'|BF8{U32}$U32$'ucDupAckCount'|BF1{U32}$U32$'bOutstanding'|BF1{U32}$U32$'bAcked'|BF1{U32}$U32$'bIsForRx'|BF13{U13}$U13$'$bit_field_pad5']
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_TCP_WIN.h line 54
struct anonymous$95;

// tag-#anon#ST[S32'accumulator_started'|SYM#tag-#anon#ST[ARR2{U32}$U32$'total'|ARR8{U32}$U32$'state'|ARR64{U8}$U8$'buffer'|S32'is224']#'accumulator'|S32'source_count'|U32'$pad3'|ARR20{SYM#tag-#anon#ST[*{S32(*{V}$V$|*{U8}$U8$|U64|*{U64}$U64$)->S32}$S32(*{V}$V$|*{U8}$U8$|U64|*{U64}$U64$)->S32$'f_source'|*{V}$V$'p_source'|U64'size'|U64'threshold'|S32'strong'|U32'$pad5']#}$SYM#tag-#anon#ST[*{S32(*{V}$V$|*{U8}$U8$|U64|*{U64}$U64$)->S32}$S32(*{V}$V$|*{U8}$U8$|U64|*{U64}$U64$)->S32$'f_source'|*{V}$V$'p_source'|U64'size'|U64'threshold'|S32'strong'|U32'$pad5']#$'source']
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/entropy.h line 123
struct anonymous$83;

// tag-#anon#ST[S32'nr'|U32'$pad1'|*{U32}$U32$'rk'|ARR68{U32}$U32$'buf']
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\aes.h line 73
struct anonymous$18;

// tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\bignum.h line 180
struct anonymous$17;

// tag-#anon#ST[S32'ver'|U32'$pad1'|U64'len'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'N'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'E'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'D'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'P'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Q'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'DP'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'DQ'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'QP'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'RN'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'RP'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'RQ'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Vi'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Vf'|S32'padding'|S32'hash_id']
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\rsa.h line 94
struct anonymous$1;

// tag-#anon#ST[S8'dummy']
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/platform.h line 304
struct anonymous$75;

// tag-#anon#ST[SYM##anon_enum$JSMN_UNDEFINED=0$JSMN_OBJECT=1$JSMN_ARRAY=2$JSMN_STRING=3$JSMN_PRIMITIVE=4#'type'|S32'start'|S32'end'|S32'size'|S32'parent']
// file ..\..\..\..\lib\third_party\jsmn\jsmn.h line 65
struct anonymous$51;

// tag-#anon#ST[SYM##anon_enum$MBEDTLS_CIPHER_NONE=0$MBEDTLS_CIPHER_NULL=1$MBEDTLS_CIPHER_AES_128_ECB=2$MBEDTLS_CIPHER_AES_192_ECB=3$MBEDTLS_CIPHER_AES_256_ECB=4$MBEDTLS_CIPHER_AES_128_CBC=5$MBEDTLS_CIPHER_AES_192_CBC=6$MBEDTLS_CIPHER_AES_256_CBC=7$MBEDTLS_CIPHER_AES_128_CFB128=8$MBEDTLS_CIPHER_AES_192_CFB128=9$MBEDTLS_CIPHER_AES_256_CFB128=10$MBEDTLS_CIPHER_AES_128_CTR=11$MBEDTLS_CIPHER_AES_192_CTR=12$MBEDTLS_CIPHER_AES_256_CTR=13$MBEDTLS_CIPHER_AES_128_GCM=14$MBEDTLS_CIPHER_AES_192_GCM=15$MBEDTLS_CIPHER_AES_256_GCM=16$MBEDTLS_CIPHER_CAMELLIA_128_ECB=17$MBEDTLS_CIPHER_CAMELLIA_192_ECB=18$MBEDTLS_CIPHER_CAMELLIA_256_ECB=19$MBEDTLS_CIPHER_CAMELLIA_128_CBC=20$MBEDTLS_CIPHER_CAMELLIA_192_CBC=21$MBEDTLS_CIPHER_CAMELLIA_256_CBC=22$MBEDTLS_CIPHER_CAMELLIA_128_CFB128=23$MBEDTLS_CIPHER_CAMELLIA_192_CFB128=24$MBEDTLS_CIPHER_CAMELLIA_256_CFB128=25$MBEDTLS_CIPHER_CAMELLIA_128_CTR=26$MBEDTLS_CIPHER_CAMELLIA_192_CTR=27$MBEDTLS_CIPHER_CAMELLIA_256_CTR=28$MBEDTLS_CIPHER_CAMELLIA_128_GCM=29$MBEDTLS_CIPHER_CAMELLIA_192_GCM=30$MBEDTLS_CIPHER_CAMELLIA_256_GCM=31$MBEDTLS_CIPHER_DES_ECB=32$MBEDTLS_CIPHER_DES_CBC=33$MBEDTLS_CIPHER_DES_EDE_ECB=34$MBEDTLS_CIPHER_DES_EDE_CBC=35$MBEDTLS_CIPHER_DES_EDE3_ECB=36$MBEDTLS_CIPHER_DES_EDE3_CBC=37$MBEDTLS_CIPHER_BLOWFISH_ECB=38$MBEDTLS_CIPHER_BLOWFISH_CBC=39$MBEDTLS_CIPHER_BLOWFISH_CFB64=40$MBEDTLS_CIPHER_BLOWFISH_CTR=41$MBEDTLS_CIPHER_ARC4_128=42$MBEDTLS_CIPHER_AES_128_CCM=43$MBEDTLS_CIPHER_AES_192_CCM=44$MBEDTLS_CIPHER_AES_256_CCM=45$MBEDTLS_CIPHER_CAMELLIA_128_CCM=46$MBEDTLS_CIPHER_CAMELLIA_192_CCM=47$MBEDTLS_CIPHER_CAMELLIA_256_CCM=48#'type'|SYM##anon_enum$MBEDTLS_MODE_NONE=0$MBEDTLS_MODE_ECB=1$MBEDTLS_MODE_CBC=2$MBEDTLS_MODE_CFB=3$MBEDTLS_MODE_OFB=4$MBEDTLS_MODE_CTR=5$MBEDTLS_MODE_GCM=6$MBEDTLS_MODE_STREAM=7$MBEDTLS_MODE_CCM=8#'mode'|U32'key_bitlen'|U32'$pad3'|*{cS8}$cS8$'name'|U32'iv_size'|S32'flags'|U32'block_size'|U32'$pad8'|*{cSYM#tag-mbedtls_cipher_base_t#}$cSYM#tag-mbedtls_cipher_base_t#$'base']
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/cipher.h line 207
struct anonymous$10;

// tag-#anon#ST[SYM##anon_enum$MBEDTLS_CIPHER_NONE=0$MBEDTLS_CIPHER_NULL=1$MBEDTLS_CIPHER_AES_128_ECB=2$MBEDTLS_CIPHER_AES_192_ECB=3$MBEDTLS_CIPHER_AES_256_ECB=4$MBEDTLS_CIPHER_AES_128_CBC=5$MBEDTLS_CIPHER_AES_192_CBC=6$MBEDTLS_CIPHER_AES_256_CBC=7$MBEDTLS_CIPHER_AES_128_CFB128=8$MBEDTLS_CIPHER_AES_192_CFB128=9$MBEDTLS_CIPHER_AES_256_CFB128=10$MBEDTLS_CIPHER_AES_128_CTR=11$MBEDTLS_CIPHER_AES_192_CTR=12$MBEDTLS_CIPHER_AES_256_CTR=13$MBEDTLS_CIPHER_AES_128_GCM=14$MBEDTLS_CIPHER_AES_192_GCM=15$MBEDTLS_CIPHER_AES_256_GCM=16$MBEDTLS_CIPHER_CAMELLIA_128_ECB=17$MBEDTLS_CIPHER_CAMELLIA_192_ECB=18$MBEDTLS_CIPHER_CAMELLIA_256_ECB=19$MBEDTLS_CIPHER_CAMELLIA_128_CBC=20$MBEDTLS_CIPHER_CAMELLIA_192_CBC=21$MBEDTLS_CIPHER_CAMELLIA_256_CBC=22$MBEDTLS_CIPHER_CAMELLIA_128_CFB128=23$MBEDTLS_CIPHER_CAMELLIA_192_CFB128=24$MBEDTLS_CIPHER_CAMELLIA_256_CFB128=25$MBEDTLS_CIPHER_CAMELLIA_128_CTR=26$MBEDTLS_CIPHER_CAMELLIA_192_CTR=27$MBEDTLS_CIPHER_CAMELLIA_256_CTR=28$MBEDTLS_CIPHER_CAMELLIA_128_GCM=29$MBEDTLS_CIPHER_CAMELLIA_192_GCM=30$MBEDTLS_CIPHER_CAMELLIA_256_GCM=31$MBEDTLS_CIPHER_DES_ECB=32$MBEDTLS_CIPHER_DES_CBC=33$MBEDTLS_CIPHER_DES_EDE_ECB=34$MBEDTLS_CIPHER_DES_EDE_CBC=35$MBEDTLS_CIPHER_DES_EDE3_ECB=36$MBEDTLS_CIPHER_DES_EDE3_CBC=37$MBEDTLS_CIPHER_BLOWFISH_ECB=38$MBEDTLS_CIPHER_BLOWFISH_CBC=39$MBEDTLS_CIPHER_BLOWFISH_CFB64=40$MBEDTLS_CIPHER_BLOWFISH_CTR=41$MBEDTLS_CIPHER_ARC4_128=42$MBEDTLS_CIPHER_AES_128_CCM=43$MBEDTLS_CIPHER_AES_192_CCM=44$MBEDTLS_CIPHER_AES_256_CCM=45$MBEDTLS_CIPHER_CAMELLIA_128_CCM=46$MBEDTLS_CIPHER_CAMELLIA_192_CCM=47$MBEDTLS_CIPHER_CAMELLIA_256_CCM=48#'type'|U32'$pad1'|*{cSYM#tag-#anon#ST[SYM##anon_enum$MBEDTLS_CIPHER_NONE=0$MBEDTLS_CIPHER_NULL=1$MBEDTLS_CIPHER_AES_128_ECB=2$MBEDTLS_CIPHER_AES_192_ECB=3$MBEDTLS_CIPHER_AES_256_ECB=4$MBEDTLS_CIPHER_AES_128_CBC=5$MBEDTLS_CIPHER_AES_192_CBC=6$MBEDTLS_CIPHER_AES_256_CBC=7$MBEDTLS_CIPHER_AES_128_CFB128=8$MBEDTLS_CIPHER_AES_192_CFB128=9$MBEDTLS_CIPHER_AES_256_CFB128=10$MBEDTLS_CIPHER_AES_128_CTR=11$MBEDTLS_CIPHER_AES_192_CTR=12$MBEDTLS_CIPHER_AES_256_CTR=13$MBEDTLS_CIPHER_AES_128_GCM=14$MBEDTLS_CIPHER_AES_192_GCM=15$MBEDTLS_CIPHER_AES_256_GCM=16$MBEDTLS_CIPHER_CAMELLIA_128_ECB=17$MBEDTLS_CIPHER_CAMELLIA_192_ECB=18$MBEDTLS_CIPHER_CAMELLIA_256_ECB=19$MBEDTLS_CIPHER_CAMELLIA_128_CBC=20$MBEDTLS_CIPHER_CAMELLIA_192_CBC=21$MBEDTLS_CIPHER_CAMELLIA_256_CBC=22$MBEDTLS_CIPHER_CAMELLIA_128_CFB128=23$MBEDTLS_CIPHER_CAMELLIA_192_CFB128=24$MBEDTLS_CIPHER_CAMELLIA_256_CFB128=25$MBEDTLS_CIPHER_CAMELLIA_128_CTR=26$MBEDTLS_CIPHER_CAMELLIA_192_CTR=27$MBEDTLS_CIPHER_CAMELLIA_256_CTR=28$MBEDTLS_CIPHER_CAMELLIA_128_GCM=29$MBEDTLS_CIPHER_CAMELLIA_192_GCM=30$MBEDTLS_CIPHER_CAMELLIA_256_GCM=31$MBEDTLS_CIPHER_DES_ECB=32$MBEDTLS_CIPHER_DES_CBC=33$MBEDTLS_CIPHER_DES_EDE_ECB=34$MBEDTLS_CIPHER_DES_EDE_CBC=35$MBEDTLS_CIPHER_DES_EDE3_ECB=36$MBEDTLS_CIPHER_DES_EDE3_CBC=37$MBEDTLS_CIPHER_BLOWFISH_ECB=38$MBEDTLS_CIPHER_BLOWFISH_CBC=39$MBEDTLS_CIPHER_BLOWFISH_CFB64=40$MBEDTLS_CIPHER_BLOWFISH_CTR=41$MBEDTLS_CIPHER_ARC4_128=42$MBEDTLS_CIPHER_AES_128_CCM=43$MBEDTLS_CIPHER_AES_192_CCM=44$MBEDTLS_CIPHER_AES_256_CCM=45$MBEDTLS_CIPHER_CAMELLIA_128_CCM=46$MBEDTLS_CIPHER_CAMELLIA_192_CCM=47$MBEDTLS_CIPHER_CAMELLIA_256_CCM=48#'type'|SYM##anon_enum$MBEDTLS_MODE_NONE=0$MBEDTLS_MODE_ECB=1$MBEDTLS_MODE_CBC=2$MBEDTLS_MODE_CFB=3$MBEDTLS_MODE_OFB=4$MBEDTLS_MODE_CTR=5$MBEDTLS_MODE_GCM=6$MBEDTLS_MODE_STREAM=7$MBEDTLS_MODE_CCM=8#'mode'|U32'key_bitlen'|U32'$pad3'|*{cS8}$cS8$'name'|U32'iv_size'|S32'flags'|U32'block_size'|U32'$pad8'|*{cSYM#tag-mbedtls_cipher_base_t#}$cSYM#tag-mbedtls_cipher_base_t#$'base']#}$cSYM#tag-#anon#ST[SYM##anon_enum$MBEDTLS_CIPHER_NONE=0$MBEDTLS_CIPHER_NULL=1$MBEDTLS_CIPHER_AES_128_ECB=2$MBEDTLS_CIPHER_AES_192_ECB=3$MBEDTLS_CIPHER_AES_256_ECB=4$MBEDTLS_CIPHER_AES_128_CBC=5$MBEDTLS_CIPHER_AES_192_CBC=6$MBEDTLS_CIPHER_AES_256_CBC=7$MBEDTLS_CIPHER_AES_128_CFB128=8$MBEDTLS_CIPHER_AES_192_CFB128=9$MBEDTLS_CIPHER_AES_256_CFB128=10$MBEDTLS_CIPHER_AES_128_CTR=11$MBEDTLS_CIPHER_AES_192_CTR=12$MBEDTLS_CIPHER_AES_256_CTR=13$MBEDTLS_CIPHER_AES_128_GCM=14$MBEDTLS_CIPHER_AES_192_GCM=15$MBEDTLS_CIPHER_AES_256_GCM=16$MBEDTLS_CIPHER_CAMELLIA_128_ECB=17$MBEDTLS_CIPHER_CAMELLIA_192_ECB=18$MBEDTLS_CIPHER_CAMELLIA_256_ECB=19$MBEDTLS_CIPHER_CAMELLIA_128_CBC=20$MBEDTLS_CIPHER_CAMELLIA_192_CBC=21$MBEDTLS_CIPHER_CAMELLIA_256_CBC=22$MBEDTLS_CIPHER_CAMELLIA_128_CFB128=23$MBEDTLS_CIPHER_CAMELLIA_192_CFB128=24$MBEDTLS_CIPHER_CAMELLIA_256_CFB128=25$MBEDTLS_CIPHER_CAMELLIA_128_CTR=26$MBEDTLS_CIPHER_CAMELLIA_192_CTR=27$MBEDTLS_CIPHER_CAMELLIA_256_CTR=28$MBEDTLS_CIPHER_CAMELLIA_128_GCM=29$MBEDTLS_CIPHER_CAMELLIA_192_GCM=30$MBEDTLS_CIPHER_CAMELLIA_256_GCM=31$MBEDTLS_CIPHER_DES_ECB=32$MBEDTLS_CIPHER_DES_CBC=33$MBEDTLS_CIPHER_DES_EDE_ECB=34$MBEDTLS_CIPHER_DES_EDE_CBC=35$MBEDTLS_CIPHER_DES_EDE3_ECB=36$MBEDTLS_CIPHER_DES_EDE3_CBC=37$MBEDTLS_CIPHER_BLOWFISH_ECB=38$MBEDTLS_CIPHER_BLOWFISH_CBC=39$MBEDTLS_CIPHER_BLOWFISH_CFB64=40$MBEDTLS_CIPHER_BLOWFISH_CTR=41$MBEDTLS_CIPHER_ARC4_128=42$MBEDTLS_CIPHER_AES_128_CCM=43$MBEDTLS_CIPHER_AES_192_CCM=44$MBEDTLS_CIPHER_AES_256_CCM=45$MBEDTLS_CIPHER_CAMELLIA_128_CCM=46$MBEDTLS_CIPHER_CAMELLIA_192_CCM=47$MBEDTLS_CIPHER_CAMELLIA_256_CCM=48#'type'|SYM##anon_enum$MBEDTLS_MODE_NONE=0$MBEDTLS_MODE_ECB=1$MBEDTLS_MODE_CBC=2$MBEDTLS_MODE_CFB=3$MBEDTLS_MODE_OFB=4$MBEDTLS_MODE_CTR=5$MBEDTLS_MODE_GCM=6$MBEDTLS_MODE_STREAM=7$MBEDTLS_MODE_CCM=8#'mode'|U32'key_bitlen'|U32'$pad3'|*{cS8}$cS8$'name'|U32'iv_size'|S32'flags'|U32'block_size'|U32'$pad8'|*{cSYM#tag-mbedtls_cipher_base_t#}$cSYM#tag-mbedtls_cipher_base_t#$'base']#$'info']
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/cipher_internal.h line 96
struct anonymous$7;

// tag-#anon#ST[SYM##anon_enum$MBEDTLS_ECP_DP_NONE=0$MBEDTLS_ECP_DP_SECP192R1=1$MBEDTLS_ECP_DP_SECP224R1=2$MBEDTLS_ECP_DP_SECP256R1=3$MBEDTLS_ECP_DP_SECP384R1=4$MBEDTLS_ECP_DP_SECP521R1=5$MBEDTLS_ECP_DP_BP256R1=6$MBEDTLS_ECP_DP_BP384R1=7$MBEDTLS_ECP_DP_BP512R1=8$MBEDTLS_ECP_DP_CURVE25519=9$MBEDTLS_ECP_DP_CURVE448=10$MBEDTLS_ECP_DP_SECP192K1=11$MBEDTLS_ECP_DP_SECP224K1=12$MBEDTLS_ECP_DP_SECP256K1=13#'grp_id'|U16'tls_id'|U16'bit_size'|*{cS8}$cS8$'name']
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/ecp.h line 92
struct anonymous$2;

// tag-#anon#ST[SYM##anon_enum$MBEDTLS_ECP_DP_NONE=0$MBEDTLS_ECP_DP_SECP192R1=1$MBEDTLS_ECP_DP_SECP224R1=2$MBEDTLS_ECP_DP_SECP256R1=3$MBEDTLS_ECP_DP_SECP384R1=4$MBEDTLS_ECP_DP_SECP521R1=5$MBEDTLS_ECP_DP_BP256R1=6$MBEDTLS_ECP_DP_BP384R1=7$MBEDTLS_ECP_DP_BP512R1=8$MBEDTLS_ECP_DP_CURVE25519=9$MBEDTLS_ECP_DP_CURVE448=10$MBEDTLS_ECP_DP_SECP192K1=11$MBEDTLS_ECP_DP_SECP224K1=12$MBEDTLS_ECP_DP_SECP256K1=13#'id'|U32'$pad1'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'P'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'A'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'B'|SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#'G'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'N'|U64'pbits'|U64'nbits'|U32'h'|U32'$pad10'|*{S32(*{SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#}$SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#$)->S32}$S32(*{SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#}$SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#$)->S32$'modp'|*{S32(*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#}$SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#$|*{V}$V$)->S32}$S32(*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#}$SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#$|*{V}$V$)->S32$'t_pre'|*{S32(*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#}$SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#$|*{V}$V$)->S32}$S32(*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#}$SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#$|*{V}$V$)->S32$'t_post'|*{V}$V$'t_data'|*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#}$SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#$'T'|U64'T_size']
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\ecp.h line 141
struct anonymous$78;

// tag-#anon#ST[SYM##anon_enum$MBEDTLS_PK_DEBUG_NONE=0$MBEDTLS_PK_DEBUG_MPI=1$MBEDTLS_PK_DEBUG_ECP=2#'type'|U32'$pad1'|*{cS8}$cS8$'name'|*{V}$V$'value']
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/pk.h line 110
struct anonymous$92;

// tag-#anon#ST[SYM#tag-#anon#ST[*{cS8}$cS8$'asn1'|U64'asn1_len'|*{cS8}$cS8$'name'|*{cS8}$cS8$'description']#'descriptor'|*{cS8}$cS8$'short_name']
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 159
struct anonymous$89;

// tag-#anon#ST[SYM#tag-#anon#ST[*{cS8}$cS8$'asn1'|U64'asn1_len'|*{cS8}$cS8$'name'|*{cS8}$cS8$'description']#'descriptor'|S32'ext_type'|U32'$pad2']
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 254
struct anonymous$90;

// tag-#anon#ST[SYM#tag-#anon#ST[*{cS8}$cS8$'asn1'|U64'asn1_len'|*{cS8}$cS8$'name'|*{cS8}$cS8$'description']#'descriptor'|SYM##anon_enum$MBEDTLS_CIPHER_NONE=0$MBEDTLS_CIPHER_NULL=1$MBEDTLS_CIPHER_AES_128_ECB=2$MBEDTLS_CIPHER_AES_192_ECB=3$MBEDTLS_CIPHER_AES_256_ECB=4$MBEDTLS_CIPHER_AES_128_CBC=5$MBEDTLS_CIPHER_AES_192_CBC=6$MBEDTLS_CIPHER_AES_256_CBC=7$MBEDTLS_CIPHER_AES_128_CFB128=8$MBEDTLS_CIPHER_AES_192_CFB128=9$MBEDTLS_CIPHER_AES_256_CFB128=10$MBEDTLS_CIPHER_AES_128_CTR=11$MBEDTLS_CIPHER_AES_192_CTR=12$MBEDTLS_CIPHER_AES_256_CTR=13$MBEDTLS_CIPHER_AES_128_GCM=14$MBEDTLS_CIPHER_AES_192_GCM=15$MBEDTLS_CIPHER_AES_256_GCM=16$MBEDTLS_CIPHER_CAMELLIA_128_ECB=17$MBEDTLS_CIPHER_CAMELLIA_192_ECB=18$MBEDTLS_CIPHER_CAMELLIA_256_ECB=19$MBEDTLS_CIPHER_CAMELLIA_128_CBC=20$MBEDTLS_CIPHER_CAMELLIA_192_CBC=21$MBEDTLS_CIPHER_CAMELLIA_256_CBC=22$MBEDTLS_CIPHER_CAMELLIA_128_CFB128=23$MBEDTLS_CIPHER_CAMELLIA_192_CFB128=24$MBEDTLS_CIPHER_CAMELLIA_256_CFB128=25$MBEDTLS_CIPHER_CAMELLIA_128_CTR=26$MBEDTLS_CIPHER_CAMELLIA_192_CTR=27$MBEDTLS_CIPHER_CAMELLIA_256_CTR=28$MBEDTLS_CIPHER_CAMELLIA_128_GCM=29$MBEDTLS_CIPHER_CAMELLIA_192_GCM=30$MBEDTLS_CIPHER_CAMELLIA_256_GCM=31$MBEDTLS_CIPHER_DES_ECB=32$MBEDTLS_CIPHER_DES_CBC=33$MBEDTLS_CIPHER_DES_EDE_ECB=34$MBEDTLS_CIPHER_DES_EDE_CBC=35$MBEDTLS_CIPHER_DES_EDE3_ECB=36$MBEDTLS_CIPHER_DES_EDE3_CBC=37$MBEDTLS_CIPHER_BLOWFISH_ECB=38$MBEDTLS_CIPHER_BLOWFISH_CBC=39$MBEDTLS_CIPHER_BLOWFISH_CFB64=40$MBEDTLS_CIPHER_BLOWFISH_CTR=41$MBEDTLS_CIPHER_ARC4_128=42$MBEDTLS_CIPHER_AES_128_CCM=43$MBEDTLS_CIPHER_AES_192_CCM=44$MBEDTLS_CIPHER_AES_256_CCM=45$MBEDTLS_CIPHER_CAMELLIA_128_CCM=46$MBEDTLS_CIPHER_CAMELLIA_192_CCM=47$MBEDTLS_CIPHER_CAMELLIA_256_CCM=48#'cipher_alg'|U32'$pad2']
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 539
struct anonymous$59;

// tag-#anon#ST[SYM#tag-#anon#ST[*{cS8}$cS8$'asn1'|U64'asn1_len'|*{cS8}$cS8$'name'|*{cS8}$cS8$'description']#'descriptor'|SYM##anon_enum$MBEDTLS_ECP_DP_NONE=0$MBEDTLS_ECP_DP_SECP192R1=1$MBEDTLS_ECP_DP_SECP224R1=2$MBEDTLS_ECP_DP_SECP256R1=3$MBEDTLS_ECP_DP_SECP384R1=4$MBEDTLS_ECP_DP_SECP521R1=5$MBEDTLS_ECP_DP_BP256R1=6$MBEDTLS_ECP_DP_BP384R1=7$MBEDTLS_ECP_DP_BP512R1=8$MBEDTLS_ECP_DP_CURVE25519=9$MBEDTLS_ECP_DP_CURVE448=10$MBEDTLS_ECP_DP_SECP192K1=11$MBEDTLS_ECP_DP_SECP224K1=12$MBEDTLS_ECP_DP_SECP256K1=13#'grp_id'|U32'$pad2']
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 451
struct anonymous$91;

// tag-#anon#ST[SYM#tag-#anon#ST[*{cS8}$cS8$'asn1'|U64'asn1_len'|*{cS8}$cS8$'name'|*{cS8}$cS8$'description']#'descriptor'|SYM##anon_enum$MBEDTLS_MD_NONE=0$MBEDTLS_MD_MD2=1$MBEDTLS_MD_MD4=2$MBEDTLS_MD_MD5=3$MBEDTLS_MD_SHA1=4$MBEDTLS_MD_SHA224=5$MBEDTLS_MD_SHA256=6$MBEDTLS_MD_SHA384=7$MBEDTLS_MD_SHA512=8$MBEDTLS_MD_RIPEMD160=9#'md_alg'|SYM##anon_enum$MBEDTLS_PK_NONE=0$MBEDTLS_PK_RSA=1$MBEDTLS_PK_ECKEY=2$MBEDTLS_PK_ECKEY_DH=3$MBEDTLS_PK_ECDSA=4$MBEDTLS_PK_RSA_ALT=5$MBEDTLS_PK_RSASSA_PSS=6#'pk_alg']
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 309
struct anonymous;

// tag-#anon#ST[SYM#tag-#anon#ST[*{cS8}$cS8$'asn1'|U64'asn1_len'|*{cS8}$cS8$'name'|*{cS8}$cS8$'description']#'descriptor'|SYM##anon_enum$MBEDTLS_MD_NONE=0$MBEDTLS_MD_MD2=1$MBEDTLS_MD_MD4=2$MBEDTLS_MD_MD5=3$MBEDTLS_MD_SHA1=4$MBEDTLS_MD_SHA224=5$MBEDTLS_MD_SHA256=6$MBEDTLS_MD_SHA384=7$MBEDTLS_MD_SHA512=8$MBEDTLS_MD_RIPEMD160=9#'md_alg'|U32'$pad2']
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 568
struct anonymous$84;

// tag-#anon#ST[SYM#tag-#anon#ST[*{cS8}$cS8$'asn1'|U64'asn1_len'|*{cS8}$cS8$'name'|*{cS8}$cS8$'description']#'descriptor'|SYM##anon_enum$MBEDTLS_MD_NONE=0$MBEDTLS_MD_MD2=1$MBEDTLS_MD_MD4=2$MBEDTLS_MD_MD5=3$MBEDTLS_MD_SHA1=4$MBEDTLS_MD_SHA224=5$MBEDTLS_MD_SHA256=6$MBEDTLS_MD_SHA384=7$MBEDTLS_MD_SHA512=8$MBEDTLS_MD_RIPEMD160=9#'md_hmac'|U32'$pad2']
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 632
struct anonymous$88;

// tag-#anon#ST[SYM#tag-#anon#ST[*{cS8}$cS8$'asn1'|U64'asn1_len'|*{cS8}$cS8$'name'|*{cS8}$cS8$'description']#'descriptor'|SYM##anon_enum$MBEDTLS_PK_NONE=0$MBEDTLS_PK_RSA=1$MBEDTLS_PK_ECKEY=2$MBEDTLS_PK_ECKEY_DH=3$MBEDTLS_PK_ECDSA=4$MBEDTLS_PK_RSA_ALT=5$MBEDTLS_PK_RSASSA_PSS=6#'pk_alg'|U32'$pad2']
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 418
struct anonymous$82;

// tag-#anon#ST[SYM#tag-#anon#ST[*{cSYM#tag-#anon#ST[SYM##anon_enum$MBEDTLS_CIPHER_NONE=0$MBEDTLS_CIPHER_NULL=1$MBEDTLS_CIPHER_AES_128_ECB=2$MBEDTLS_CIPHER_AES_192_ECB=3$MBEDTLS_CIPHER_AES_256_ECB=4$MBEDTLS_CIPHER_AES_128_CBC=5$MBEDTLS_CIPHER_AES_192_CBC=6$MBEDTLS_CIPHER_AES_256_CBC=7$MBEDTLS_CIPHER_AES_128_CFB128=8$MBEDTLS_CIPHER_AES_192_CFB128=9$MBEDTLS_CIPHER_AES_256_CFB128=10$MBEDTLS_CIPHER_AES_128_CTR=11$MBEDTLS_CIPHER_AES_192_CTR=12$MBEDTLS_CIPHER_AES_256_CTR=13$MBEDTLS_CIPHER_AES_128_GCM=14$MBEDTLS_CIPHER_AES_192_GCM=15$MBEDTLS_CIPHER_AES_256_GCM=16$MBEDTLS_CIPHER_CAMELLIA_128_ECB=17$MBEDTLS_CIPHER_CAMELLIA_192_ECB=18$MBEDTLS_CIPHER_CAMELLIA_256_ECB=19$MBEDTLS_CIPHER_CAMELLIA_128_CBC=20$MBEDTLS_CIPHER_CAMELLIA_192_CBC=21$MBEDTLS_CIPHER_CAMELLIA_256_CBC=22$MBEDTLS_CIPHER_CAMELLIA_128_CFB128=23$MBEDTLS_CIPHER_CAMELLIA_192_CFB128=24$MBEDTLS_CIPHER_CAMELLIA_256_CFB128=25$MBEDTLS_CIPHER_CAMELLIA_128_CTR=26$MBEDTLS_CIPHER_CAMELLIA_192_CTR=27$MBEDTLS_CIPHER_CAMELLIA_256_CTR=28$MBEDTLS_CIPHER_CAMELLIA_128_GCM=29$MBEDTLS_CIPHER_CAMELLIA_192_GCM=30$MBEDTLS_CIPHER_CAMELLIA_256_GCM=31$MBEDTLS_CIPHER_DES_ECB=32$MBEDTLS_CIPHER_DES_CBC=33$MBEDTLS_CIPHER_DES_EDE_ECB=34$MBEDTLS_CIPHER_DES_EDE_CBC=35$MBEDTLS_CIPHER_DES_EDE3_ECB=36$MBEDTLS_CIPHER_DES_EDE3_CBC=37$MBEDTLS_CIPHER_BLOWFISH_ECB=38$MBEDTLS_CIPHER_BLOWFISH_CBC=39$MBEDTLS_CIPHER_BLOWFISH_CFB64=40$MBEDTLS_CIPHER_BLOWFISH_CTR=41$MBEDTLS_CIPHER_ARC4_128=42$MBEDTLS_CIPHER_AES_128_CCM=43$MBEDTLS_CIPHER_AES_192_CCM=44$MBEDTLS_CIPHER_AES_256_CCM=45$MBEDTLS_CIPHER_CAMELLIA_128_CCM=46$MBEDTLS_CIPHER_CAMELLIA_192_CCM=47$MBEDTLS_CIPHER_CAMELLIA_256_CCM=48#'type'|SYM##anon_enum$MBEDTLS_MODE_NONE=0$MBEDTLS_MODE_ECB=1$MBEDTLS_MODE_CBC=2$MBEDTLS_MODE_CFB=3$MBEDTLS_MODE_OFB=4$MBEDTLS_MODE_CTR=5$MBEDTLS_MODE_GCM=6$MBEDTLS_MODE_STREAM=7$MBEDTLS_MODE_CCM=8#'mode'|U32'key_bitlen'|U32'$pad3'|*{cS8}$cS8$'name'|U32'iv_size'|S32'flags'|U32'block_size'|U32'$pad8'|*{cSYM#tag-mbedtls_cipher_base_t#}$cSYM#tag-mbedtls_cipher_base_t#$'base']#}$cSYM#tag-#anon#ST[SYM##anon_enum$MBEDTLS_CIPHER_NONE=0$MBEDTLS_CIPHER_NULL=1$MBEDTLS_CIPHER_AES_128_ECB=2$MBEDTLS_CIPHER_AES_192_ECB=3$MBEDTLS_CIPHER_AES_256_ECB=4$MBEDTLS_CIPHER_AES_128_CBC=5$MBEDTLS_CIPHER_AES_192_CBC=6$MBEDTLS_CIPHER_AES_256_CBC=7$MBEDTLS_CIPHER_AES_128_CFB128=8$MBEDTLS_CIPHER_AES_192_CFB128=9$MBEDTLS_CIPHER_AES_256_CFB128=10$MBEDTLS_CIPHER_AES_128_CTR=11$MBEDTLS_CIPHER_AES_192_CTR=12$MBEDTLS_CIPHER_AES_256_CTR=13$MBEDTLS_CIPHER_AES_128_GCM=14$MBEDTLS_CIPHER_AES_192_GCM=15$MBEDTLS_CIPHER_AES_256_GCM=16$MBEDTLS_CIPHER_CAMELLIA_128_ECB=17$MBEDTLS_CIPHER_CAMELLIA_192_ECB=18$MBEDTLS_CIPHER_CAMELLIA_256_ECB=19$MBEDTLS_CIPHER_CAMELLIA_128_CBC=20$MBEDTLS_CIPHER_CAMELLIA_192_CBC=21$MBEDTLS_CIPHER_CAMELLIA_256_CBC=22$MBEDTLS_CIPHER_CAMELLIA_128_CFB128=23$MBEDTLS_CIPHER_CAMELLIA_192_CFB128=24$MBEDTLS_CIPHER_CAMELLIA_256_CFB128=25$MBEDTLS_CIPHER_CAMELLIA_128_CTR=26$MBEDTLS_CIPHER_CAMELLIA_192_CTR=27$MBEDTLS_CIPHER_CAMELLIA_256_CTR=28$MBEDTLS_CIPHER_CAMELLIA_128_GCM=29$MBEDTLS_CIPHER_CAMELLIA_192_GCM=30$MBEDTLS_CIPHER_CAMELLIA_256_GCM=31$MBEDTLS_CIPHER_DES_ECB=32$MBEDTLS_CIPHER_DES_CBC=33$MBEDTLS_CIPHER_DES_EDE_ECB=34$MBEDTLS_CIPHER_DES_EDE_CBC=35$MBEDTLS_CIPHER_DES_EDE3_ECB=36$MBEDTLS_CIPHER_DES_EDE3_CBC=37$MBEDTLS_CIPHER_BLOWFISH_ECB=38$MBEDTLS_CIPHER_BLOWFISH_CBC=39$MBEDTLS_CIPHER_BLOWFISH_CFB64=40$MBEDTLS_CIPHER_BLOWFISH_CTR=41$MBEDTLS_CIPHER_ARC4_128=42$MBEDTLS_CIPHER_AES_128_CCM=43$MBEDTLS_CIPHER_AES_192_CCM=44$MBEDTLS_CIPHER_AES_256_CCM=45$MBEDTLS_CIPHER_CAMELLIA_128_CCM=46$MBEDTLS_CIPHER_CAMELLIA_192_CCM=47$MBEDTLS_CIPHER_CAMELLIA_256_CCM=48#'type'|SYM##anon_enum$MBEDTLS_MODE_NONE=0$MBEDTLS_MODE_ECB=1$MBEDTLS_MODE_CBC=2$MBEDTLS_MODE_CFB=3$MBEDTLS_MODE_OFB=4$MBEDTLS_MODE_CTR=5$MBEDTLS_MODE_GCM=6$MBEDTLS_MODE_STREAM=7$MBEDTLS_MODE_CCM=8#'mode'|U32'key_bitlen'|U32'$pad3'|*{cS8}$cS8$'name'|U32'iv_size'|S32'flags'|U32'block_size'|U32'$pad8'|*{cSYM#tag-mbedtls_cipher_base_t#}$cSYM#tag-mbedtls_cipher_base_t#$'base']#$'cipher_info'|S32'key_bitlen'|SYM##anon_enum$MBEDTLS_OPERATION_NONE=-1$MBEDTLS_DECRYPT=0$MBEDTLS_ENCRYPT=1#'operation'|*{V(*{U8}$U8$|U64|U64)->V}$V(*{U8}$U8$|U64|U64)->V$'add_padding'|*{S32(*{U8}$U8$|U64|*{U64}$U64$)->S32}$S32(*{U8}$U8$|U64|*{U64}$U64$)->S32$'get_padding'|ARR16{U8}$U8$'unprocessed_data'|U64'unprocessed_len'|ARR16{U8}$U8$'iv'|U64'iv_size'|*{V}$V$'cipher_ctx']#'cipher_ctx'|ARR16{U64}$U64$'HL'|ARR16{U64}$U64$'HH'|U64'len'|U64'add_len'|ARR16{U8}$U8$'base_ectr'|ARR16{U8}$U8$'y'|ARR16{U8}$U8$'buf'|S32'mode'|U32'$pad9']
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/gcm.h line 54
struct anonymous$8;

// tag-#anon#ST[SYM#tag-#anon#ST[*{cSYM#tag-mbedtls_md_info_t#}$cSYM#tag-mbedtls_md_info_t#$'md_info'|*{V}$V$'md_ctx'|*{V}$V$'hmac_ctx']#'md_ctx'|ARR32{U8}$U8$'V'|S32'reseed_counter'|U32'$pad3'|U64'entropy_len'|S32'prediction_resistance'|S32'reseed_interval'|*{S32(*{V}$V$|*{U8}$U8$|U64)->S32}$S32(*{V}$V$|*{U8}$U8$|U64)->S32$'f_entropy'|*{V}$V$'p_entropy']
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/hmac_drbg.h line 77
struct anonymous$4;

// tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\ecp.h line 109
struct anonymous$16;

// tag-#anon#ST[SYM#tag-#anon#ST[SYM##anon_enum$MBEDTLS_ECP_DP_NONE=0$MBEDTLS_ECP_DP_SECP192R1=1$MBEDTLS_ECP_DP_SECP224R1=2$MBEDTLS_ECP_DP_SECP256R1=3$MBEDTLS_ECP_DP_SECP384R1=4$MBEDTLS_ECP_DP_SECP521R1=5$MBEDTLS_ECP_DP_BP256R1=6$MBEDTLS_ECP_DP_BP384R1=7$MBEDTLS_ECP_DP_BP512R1=8$MBEDTLS_ECP_DP_CURVE25519=9$MBEDTLS_ECP_DP_CURVE448=10$MBEDTLS_ECP_DP_SECP192K1=11$MBEDTLS_ECP_DP_SECP224K1=12$MBEDTLS_ECP_DP_SECP256K1=13#'id'|U32'$pad1'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'P'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'A'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'B'|SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#'G'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'N'|U64'pbits'|U64'nbits'|U32'h'|U32'$pad10'|*{S32(*{SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#}$SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#$)->S32}$S32(*{SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#}$SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#$)->S32$'modp'|*{S32(*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#}$SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#$|*{V}$V$)->S32}$S32(*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#}$SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#$|*{V}$V$)->S32$'t_pre'|*{S32(*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#}$SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#$|*{V}$V$)->S32}$S32(*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#}$SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#$|*{V}$V$)->S32$'t_post'|*{V}$V$'t_data'|*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#}$SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#$'T'|U64'T_size']#'grp'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'d'|SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#'Q']
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\ecp.h line 168
struct anonymous$19;

// tag-#anon#ST[SYM#tag-#anon#ST[SYM##anon_enum$MBEDTLS_ECP_DP_NONE=0$MBEDTLS_ECP_DP_SECP192R1=1$MBEDTLS_ECP_DP_SECP224R1=2$MBEDTLS_ECP_DP_SECP256R1=3$MBEDTLS_ECP_DP_SECP384R1=4$MBEDTLS_ECP_DP_SECP521R1=5$MBEDTLS_ECP_DP_BP256R1=6$MBEDTLS_ECP_DP_BP384R1=7$MBEDTLS_ECP_DP_BP512R1=8$MBEDTLS_ECP_DP_CURVE25519=9$MBEDTLS_ECP_DP_CURVE448=10$MBEDTLS_ECP_DP_SECP192K1=11$MBEDTLS_ECP_DP_SECP224K1=12$MBEDTLS_ECP_DP_SECP256K1=13#'id'|U32'$pad1'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'P'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'A'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'B'|SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#'G'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'N'|U64'pbits'|U64'nbits'|U32'h'|U32'$pad10'|*{S32(*{SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#}$SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#$)->S32}$S32(*{SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#}$SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#$)->S32$'modp'|*{S32(*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#}$SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#$|*{V}$V$)->S32}$S32(*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#}$SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#$|*{V}$V$)->S32$'t_pre'|*{S32(*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#}$SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#$|*{V}$V$)->S32}$S32(*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#}$SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#$|*{V}$V$)->S32$'t_post'|*{V}$V$'t_data'|*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#}$SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#$'T'|U64'T_size']#'grp'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'d'|SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#'Q'|SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#'Qp'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'z'|S32'point_format'|U32'$pad6'|SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#'Vi'|SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'X'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Y'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'Z']#'Vf'|SYM#tag-#anon#ST[S32's'|U32'$pad1'|U64'n'|*{U64}$U64$'p']#'_d']
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/ecdh.h line 56
struct anonymous$5;

// tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U16'usBuild'|U8'ucMinor'|U8'ucMajor']#'x'|U32'ulVersion32']#'u']
// file ..\..\..\..\demos\common\include\aws_application_version.h line 35
struct anonymous$21;

// tag-#anon#ST[U16's_w1'|U16's_w2']
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\inaddr.h line 25
struct anonymous$107;

// tag-#anon#ST[U16'usBuild'|U8'ucMinor'|U8'ucMajor']
// file ..\..\..\..\demos\common\include\aws_application_version.h line 38
struct anonymous$74;

// tag-#anon#ST[U16'wProcessorArchitecture'|U16'wReserved']
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\sysinfoapi.h line 78
struct anonymous$80;

// tag-#anon#ST[U32'LowPart'|S32'HighPart']
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\winnt.h line 758
struct anonymous$129;

// tag-#anon#ST[U32'NumberOfObjectClasses'|U32'ObjectPropertyTableSizeInBytes'|ARR8{U8}$U8$'NumberOfObjectsPerClass'|ARR8{U8}$U8$'NameLengthPerClass'|ARR8{U8}$U8$'TotalPropertyBytesPerClass'|ARR8{U16}$U16$'StartIndexOfClass'|ARR14412{U8}$U8$'objbytes']
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\Include\trcRecorder.h line 893
struct anonymous$113;

// tag-#anon#ST[U32'Offset'|U32'OffsetHigh']
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\minwinbase.h line 55
struct anonymous$79;

// tag-#anon#ST[U32'allowed_mds'|U32'allowed_pks'|U32'allowed_curves'|U32'rsa_min_bitlen']
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\x509_crt.h line 108
struct anonymous$73;

// tag-#anon#ST[U32'pos'|U32'toknext'|S32'toksuper']
// file ..\..\..\..\lib\third_party\jsmn\jsmn.h line 79
struct anonymous$50;

// tag-#anon#ST[U32'symTableSize'|U32'nextFreeSymbolIndex'|ARR5000{U8}$U8$'symbytes'|ARR64{U16}$U16$'latestEntryOfChecksum']
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\Include\trcRecorder.h line 921
struct anonymous$111;

// tag-#anon#ST[U32'ulFirstSequenceNumber'|U32'ulCurrentSequenceNumber'|U32'ulFINSequenceNumber'|U32'ulHighestSequenceNumber']
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_TCP_WIN.h line 106
struct anonymous$103;

// tag-#anon#ST[U64'ullAlignmentWord']
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP_Private.h line 472
struct anonymous$97;

// tag-#anon#ST[U8's_b1'|U8's_b2'|U8's_b3'|U8's_b4']
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\inaddr.h line 24
struct anonymous$106;

// tag-#anon#ST[U8'type'|U8'addr_high'|U16'addr_low']
// file d:\tuttle\freertos\lib\third_party\tracealyzer_recorder\include\trcRecorder.h line 1035
struct anonymous$116;

// tag-#anon#ST[U8'type'|U8'arg1'|U8'arg2'|U8'arg3']
// file d:\tuttle\freertos\lib\third_party\tracealyzer_recorder\include\trcRecorder.h line 986
struct anonymous$122;

// tag-#anon#ST[U8'type'|U8'dts'|U16'param']
// file d:\tuttle\freertos\lib\third_party\tracealyzer_recorder\include\trcRecorder.h line 972
struct anonymous$121;

// tag-#anon#ST[U8'type'|U8'dts'|U16'payload']
// file d:\tuttle\freertos\lib\third_party\tracealyzer_recorder\include\trcRecorder.h line 1002
struct anonymous$123;

// tag-#anon#ST[U8'type'|U8'dts'|U16'size']
// file d:\tuttle\freertos\lib\third_party\tracealyzer_recorder\include\trcRecorder.h line 1029
struct anonymous$118;

// tag-#anon#ST[U8'type'|U8'dummy'|U16'dts']
// file d:\tuttle\freertos\lib\third_party\tracealyzer_recorder\include\trcRecorder.h line 950
struct anonymous$119;

// tag-#anon#ST[U8'type'|U8'objHandle'|U16'dts']
// file d:\tuttle\freertos\lib\third_party\tracealyzer_recorder\include\trcRecorder.h line 943
struct anonymous$117;

// tag-#anon#ST[U8'type'|U8'objHandle'|U16'symbolIndex']
// file d:\tuttle\freertos\lib\third_party\tracealyzer_recorder\include\trcRecorder.h line 979
struct anonymous$125;

// tag-#anon#ST[U8'type'|U8'objHandle'|U8'param'|U8'dts']
// file d:\tuttle\freertos\lib\third_party\tracealyzer_recorder\include\trcRecorder.h line 964
struct anonymous$120;

// tag-#anon#ST[U8'type'|U8'unused1'|U8'unused2'|U8'dts']
// file d:\tuttle\freertos\lib\third_party\tracealyzer_recorder\include\trcRecorder.h line 994
struct anonymous$124;

// tag-#anon#ST[U8'type'|U8'xps_8'|U16'xps_16']
// file d:\tuttle\freertos\lib\third_party\tracealyzer_recorder\include\trcRecorder.h line 1021
struct anonymous$126;

// tag-#anon#ST[U8'type'|U8'xts_8'|U16'xts_16']
// file d:\tuttle\freertos\lib\third_party\tracealyzer_recorder\include\trcRecorder.h line 1009
struct anonymous$115;

// tag-#anon#ST[vU8'startmarker0'|vU8'startmarker1'|vU8'startmarker2'|vU8'startmarker3'|vU8'startmarker4'|vU8'startmarker5'|vU8'startmarker6'|vU8'startmarker7'|vU8'startmarker8'|vU8'startmarker9'|vU8'startmarker10'|vU8'startmarker11'|U16'version'|U8'minor_version'|U8'irq_priority_order'|U32'filesize'|U32'numEvents'|U32'maxEvents'|U32'nextFreeIndex'|U32'bufferIsFull'|U32'frequency'|U32'absTimeLastEvent'|U32'absTimeLastEventSecond'|U32'recorderActive'|U32'isrTailchainingThreshold'|ARR24{U8}$U8$'notused'|U32'heapMemUsage'|S32'debugMarker0'|U32'isUsing16bitHandles'|SYM#tag-#anon#ST[U32'NumberOfObjectClasses'|U32'ObjectPropertyTableSizeInBytes'|ARR8{U8}$U8$'NumberOfObjectsPerClass'|ARR8{U8}$U8$'NameLengthPerClass'|ARR8{U8}$U8$'TotalPropertyBytesPerClass'|ARR8{U16}$U16$'StartIndexOfClass'|ARR14412{U8}$U8$'objbytes']#'ObjectPropertyTable'|S32'debugMarker1'|SYM#tag-#anon#ST[U32'symTableSize'|U32'nextFreeSymbolIndex'|ARR5000{U8}$U8$'symbytes'|ARR64{U16}$U16$'latestEntryOfChecksum']#'SymbolTable'|U32'exampleFloatEncoding'|U32'internalErrorOccured'|S32'debugMarker2'|ARR80{S8}$S8$'systemInfo'|S32'debugMarker3'|ARR60000{U8}$U8$'eventData'|U32'endOfSecondaryBlocks'|U8'endmarker0'|U8'endmarker1'|U8'endmarker2'|U8'endmarker3'|U8'endmarker4'|U8'endmarker5'|U8'endmarker6'|U8'endmarker7'|U8'endmarker8'|U8'endmarker9'|U8'endmarker10'|U8'endmarker11']
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\Include\trcRecorder.h line 1074
struct anonymous$114;

// tag-#anon#UN[*{S8}$S8$'pcReadFrom'|U32'uxRecursiveCallCount']
// file ..\..\..\..\lib\FreeRTOS\queue.c line 94
union anonymous$58;

// tag-#anon#UN[*{U8}$U8$'ptr'|S64'bytes_needed']
// file ..\..\..\..\lib\third_party\tinycbor\cbor.h line 165
union anonymous$30;

// tag-#anon#UN[*{V}$V$'pvDummy2'|U32'uxDummy2']
// file d:\tuttle\freertos\lib\include\FreeRTOS.h line 1055
union anonymous$57;

// tag-#anon#UN[*{cSYM#tag-MQTTAgentConnectParams#}$cSYM#tag-MQTTAgentConnectParams#$'pxConnectParams'|*{cSYM#tag-MQTTAgentSubscribeParams#}$cSYM#tag-MQTTAgentSubscribeParams#$'pxSubscribeParams'|*{cSYM#tag-MQTTAgentUnsubscribeParams#}$cSYM#tag-MQTTAgentUnsubscribeParams#$'pxUnsubscribeParams'|*{cSYM#tag-MQTTAgentPublishParams#}$cSYM#tag-MQTTAgentPublishParams#$'pxPublishParams']
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 195
union anonymous$31;

// tag-#anon#UN[S32'iFileHandle'|*{SYM#tag-_iobuf#}$SYM#tag-_iobuf#$'pstFile'|*{U8}$U8$'pucFile']
// file ..\..\..\..\lib\include\aws_ota_agent.h line 137
union anonymous$22;

// tag-#anon#UN[SYM#tag-#anon#ST[BF1{U32}$U32$'bHasInit'|BF1{U32}$U32$'bSendFullSize'|BF1{U32}$U32$'bTimeStamps'|BF29{U29}$U29$'$bit_field_pad3']#'bits'|U32'ulFlags']
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_TCP_WIN.h line 94
union anonymous$101;

// tag-#anon#UN[SYM#tag-#anon#ST[BF8{U32}$U32$'ucTransmitCount'|BF8{U32}$U32$'ucDupAckCount'|BF1{U32}$U32$'bOutstanding'|BF1{U32}$U32$'bAcked'|BF1{U32}$U32$'bIsForRx'|BF13{U13}$U13$'$bit_field_pad5']#'bits'|U32'ulFlags']
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_TCP_WIN.h line 52
union anonymous$96;

// tag-#anon#UN[SYM#tag-#anon#ST[U16'usBuild'|U8'ucMinor'|U8'ucMajor']#'x'|U32'ulVersion32']
// file ..\..\..\..\demos\common\include\aws_application_version.h line 36
union anonymous$66;

// tag-#anon#UN[SYM#tag-#anon#ST[U32'Offset'|U32'OffsetHigh']#'$anon0'|*{V}$V$'Pointer']
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\minwinbase.h line 54
union anonymous$108;

// tag-#anon#UN[SYM#tag-#anon#ST[U64'ullAlignmentWord']#'a'|SYM#tag-#anon#ST[ARR2{U8}$U8$'ucFillPacket'|ARR70{U8}$U8$'ucLastPacket']#'u']
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP_Private.h line 470
union anonymous$99;

// tag-#anon#UN[SYM#tag-#anon#ST[U8's_b1'|U8's_b2'|U8's_b3'|U8's_b4']#'S_un_b'|SYM#tag-#anon#ST[U16's_w1'|U16's_w2']#'S_un_w'|U32'S_addr']
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\inaddr.h line 23
union anonymous$87;

// tag-#anon#UN[SYM#tag-MQTTConnACKData#'xMQTTConnACKData'|SYM#tag-MQTTSubACKData#'xMQTTSubACKData'|SYM#tag-MQTTUnSubACKData#'xMQTTUnSubACKData'|SYM#tag-MQTTPubACKData#'xMQTTPubACKData'|SYM#tag-MQTTPublishData#'xPublishData'|SYM#tag-MQTTTimeoutData#'xTimeoutData'|SYM#tag-MQTTDisconnectData#'xDisconnectData']
// file d:\tuttle\freertos\lib\include\aws_mqtt_lib.h line 289
union anonymous$32;

// tag-#anon#UN[SYM#tag-MQTTPublishData#'xPublishData']
// file ..\..\..\..\lib\include\aws_mqtt_agent.h line 94
union anonymous$42;

// tag-#anon#UN[SYM#tag-UDPSOCKET#'xUDP'|SYM#tag-TCPSOCKET#'xTCP'|U64'ullTCPAlignment']
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP_Private.h line 641
union anonymous$105;

// tag-#anon#UN[SYM#tag-tmrTimerParameters#'xTimerParameters'|SYM#tag-tmrCallbackParameters#'xCallbackParameters']
// file ..\..\..\..\lib\FreeRTOS\timers.c line 113
union anonymous$54;

// tag-#anon#UN[U32'dwOemId'|SYM#tag-#anon#ST[U16'wProcessorArchitecture'|U16'wReserved']#'$anon0']
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\sysinfoapi.h line 76
union anonymous$81;

// tag-A_BLOCK_LINK
// file ..\..\..\..\lib\FreeRTOS\portable\MemMang\heap_4.c line 69
struct A_BLOCK_LINK;

// tag-BufferMetadata
// file ..\..\..\..\lib\bufferpool\aws_bufferpool_static_thread_safe.c line 98
struct BufferMetadata;

// tag-CK_ATTRIBUTE
// file d:\tuttle\freertos\lib\third_party\pkcs11\pkcs11t.h line 561
struct CK_ATTRIBUTE;

// tag-CK_FUNCTION_LIST
// file d:\tuttle\freertos\lib\third_party\pkcs11\pkcs11t.h line 1182
struct CK_FUNCTION_LIST;

// tag-CK_INFO
// file d:\tuttle\freertos\lib\third_party\pkcs11\pkcs11t.h line 81
struct CK_INFO;

// tag-CK_MECHANISM
// file d:\tuttle\freertos\lib\third_party\pkcs11\pkcs11t.h line 987
struct CK_MECHANISM;

// tag-CK_MECHANISM_INFO
// file d:\tuttle\freertos\lib\third_party\pkcs11\pkcs11t.h line 998
struct CK_MECHANISM_INFO;

// tag-CK_SESSION_INFO
// file d:\tuttle\freertos\lib\third_party\pkcs11\pkcs11t.h line 274
struct CK_SESSION_INFO;

// tag-CK_SLOT_INFO
// file d:\tuttle\freertos\lib\third_party\pkcs11\pkcs11t.h line 108
struct CK_SLOT_INFO;

// tag-CK_TOKEN_INFO
// file d:\tuttle\freertos\lib\third_party\pkcs11\pkcs11t.h line 130
struct CK_TOKEN_INFO;

// tag-CK_VERSION
// file d:\tuttle\freertos\lib\third_party\pkcs11\pkcs11t.h line 73
struct CK_VERSION;

// tag-CallbackCatalogEntry
// file ..\..\..\..\lib\shadow\aws_shadow.c line 153
struct CallbackCatalogEntry;

// tag-CborEncoder
// file ..\..\..\..\lib\third_party\tinycbor\cbor.h line 163
struct CborEncoder;

// tag-CborError
// file ..\..\..\..\lib\third_party\tinycbor\cbor.h line 117
enum CborError { CborNoError=0, CborUnknownError=1, CborErrorUnknownLength=2, CborErrorAdvancePastEOF=3, CborErrorIO=4, CborErrorGarbageAtEnd=256, CborErrorUnexpectedEOF=257, CborErrorUnexpectedBreak=258, CborErrorUnknownType=259, CborErrorIllegalType=260, CborErrorIllegalNumber=261, CborErrorIllegalSimpleType=262, CborErrorUnknownSimpleType=512, CborErrorUnknownTag=513, CborErrorInappropriateTagForType=514, CborErrorDuplicateObjectKeys=515, CborErrorInvalidUtf8TextString=516, CborErrorTooManyItems=768, CborErrorTooFewItems=769, CborErrorDataTooLarge=1024, CborErrorNestingTooDeep=1025, CborErrorUnsupportedType=1026, CborErrorJsonObjectKeyIsAggregate=1027, CborErrorJsonObjectKeyNotString=1028, CborErrorJsonNotImplemented=1029, CborErrorOutOfMemory=-2147483648, CborErrorInternalError=-1 };

// tag-CborParser
// file ..\..\..\..\lib\third_party\tinycbor\cbor.h line 228
struct CborParser;

// tag-CborType
// file ..\..\..\..\lib\third_party\tinycbor\cbor.h line 78
enum CborType { CborIntegerType=0, CborByteStringType=64, CborTextStringType=96, CborArrayType=128, CborMapType=160, CborTagType=192, CborSimpleType=224, CborBooleanType=245, CborNullType=246, CborUndefinedType=247, CborHalfFloatType=249, CborFloatType=250, CborDoubleType=251, CborInvalidType=255 };

// tag-CborValue
// file ..\..\..\..\lib\third_party\tinycbor\cbor.h line 235
struct CborValue;

// tag-HINSTANCE__
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\minwindef.h line 242
struct HINSTANCE__;

// tag-IP_TASK_COMMANDS
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP_Private.h line 259
struct IP_TASK_COMMANDS;

// tag-Link
// file d:\tuttle\freertos\lib\include\private\aws_doubly_linked_list.h line 93
struct Link;

// tag-MQTTAgentCallbackParams
// file ..\..\..\..\lib\include\aws_mqtt_agent.h line 90
struct MQTTAgentCallbackParams;

// tag-MQTTAgentConnectParams
// file ..\..\..\..\lib\include\aws_mqtt_agent.h line 135
struct MQTTAgentConnectParams;

// tag-MQTTAgentPublishParams
// file ..\..\..\..\lib\include\aws_mqtt_agent.h line 180
struct MQTTAgentPublishParams;

// tag-MQTTAgentSubscribeParams
// file ..\..\..\..\lib\include\aws_mqtt_agent.h line 154
struct MQTTAgentSubscribeParams;

// tag-MQTTAgentUnsubscribeParams
// file ..\..\..\..\lib\include\aws_mqtt_agent.h line 171
struct MQTTAgentUnsubscribeParams;

// tag-MQTTBrokerConnection
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 211
struct MQTTBrokerConnection;

// tag-MQTTBufferMetadata
// file ..\..\..\..\lib\include\private\aws_mqtt_buffer.h line 78
struct MQTTBufferMetadata;

// tag-MQTTBufferPoolInterface
// file d:\tuttle\freertos\lib\include\aws_mqtt_lib.h line 450
struct MQTTBufferPoolInterface;

// tag-MQTTBufferState
// file ..\..\..\..\lib\include\private\aws_mqtt_buffer.h line 61
struct MQTTBufferState;

// tag-MQTTCallbackParams
// file d:\tuttle\freertos\lib\include\aws_mqtt_lib.h line 283
struct MQTTCallbackParams;

// tag-MQTTConnACKData
// file d:\tuttle\freertos\lib\include\aws_mqtt_lib.h line 214
struct MQTTConnACKData;

// tag-MQTTConnectParams
// file d:\tuttle\freertos\lib\include\aws_mqtt_lib.h line 517
struct MQTTConnectParams;

// tag-MQTTContext
// file d:\tuttle\freertos\lib\include\aws_mqtt_lib.h line 473
struct MQTTContext;

// tag-MQTTDisconnectData
// file d:\tuttle\freertos\lib\include\aws_mqtt_lib.h line 275
struct MQTTDisconnectData;

// tag-MQTTEventData
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 187
struct MQTTEventData;

// tag-MQTTInitParams
// file d:\tuttle\freertos\lib\include\aws_mqtt_lib.h line 502
struct MQTTInitParams;

// tag-MQTTNotificationData
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 174
struct MQTTNotificationData;

// tag-MQTTPubACKData
// file d:\tuttle\freertos\lib\include\aws_mqtt_lib.h line 243
struct MQTTPubACKData;

// tag-MQTTPublishData
// file d:\tuttle\freertos\lib\include\aws_mqtt_lib.h line 252
struct MQTTPublishData;

// tag-MQTTPublishParams
// file d:\tuttle\freertos\lib\include\aws_mqtt_lib.h line 569
struct MQTTPublishParams;

// tag-MQTTRxMessageState
// file d:\tuttle\freertos\lib\include\aws_mqtt_lib.h line 459
struct MQTTRxMessageState;

// tag-MQTTSubACKData
// file d:\tuttle\freertos\lib\include\aws_mqtt_lib.h line 224
struct MQTTSubACKData;

// tag-MQTTSubscribeParams
// file d:\tuttle\freertos\lib\include\aws_mqtt_lib.h line 535
struct MQTTSubscribeParams;

// tag-MQTTSubscription
// file d:\tuttle\freertos\lib\include\aws_mqtt_lib.h line 418
struct MQTTSubscription;

// tag-MQTTSubscriptionManager
// file d:\tuttle\freertos\lib\include\aws_mqtt_lib.h line 436
struct MQTTSubscriptionManager;

// tag-MQTTTimeoutData
// file d:\tuttle\freertos\lib\include\aws_mqtt_lib.h line 266
struct MQTTTimeoutData;

// tag-MQTTUnSubACKData
// file d:\tuttle\freertos\lib\include\aws_mqtt_lib.h line 234
struct MQTTUnSubACKData;

// tag-MQTTUnsubscribeParams
// file d:\tuttle\freertos\lib\include\aws_mqtt_lib.h line 556
struct MQTTUnsubscribeParams;

// tag-P11Key
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 70
struct P11Key;

// tag-P11Session
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 82
struct P11Session;

// tag-ProvisioningParams_t
// file ..\..\..\..\demos\common\include\aws_dev_mode_key_provisioning.h line 30
struct ProvisioningParams_t;

// tag-QueueDefinition
// file ..\..\..\..\lib\FreeRTOS\queue.c line 88
struct QueueDefinition;

// tag-SSOCKETContext
// file ..\..\..\..\lib\secure_sockets\portable\freertos_plus_tcp\aws_secure_sockets.c line 39
struct SSOCKETContext;

// tag-ShadowCallbackParams
// file ..\..\..\..\lib\include\aws_shadow.h line 273
struct ShadowCallbackParams;

// tag-ShadowClient
// file ..\..\..\..\lib\shadow\aws_shadow.c line 163
struct ShadowClient;

// tag-ShadowCreateParams
// file ..\..\..\..\lib\include\aws_shadow.h line 119
struct ShadowCreateParams;

// tag-ShadowMQTTClientType
// file ..\..\..\..\lib\include\aws_shadow.h line 107
enum ShadowMQTTClientType { eSharedMQTTClient=0, eDedicatedMQTTClient=1 };

// tag-ShadowOperationCallParams
// file ..\..\..\..\lib\shadow\aws_shadow.c line 127
struct ShadowOperationCallParams;

// tag-ShadowOperationData
// file ..\..\..\..\lib\shadow\aws_shadow.c line 107
struct ShadowOperationData;

// tag-ShadowOperationName
// file ..\..\..\..\lib\shadow\aws_shadow.c line 92
enum ShadowOperationName { eShadowOperationUpdate=0, eShadowOperationGet=1, eShadowOperationDelete=2, eShadowOperationUpdateDocuments=3, eShadowOperationUpdateDelta=4, eShadowOperationDeletedByAnother=5, eShadowOperationOther=6 };

// tag-ShadowOperationParams
// file ..\..\..\..\lib\include\aws_shadow.h line 144
struct ShadowOperationParams;

// tag-SignatureVerificationState
// file ..\..\..\..\lib\crypto\aws_crypto.c line 46
struct SignatureVerificationState;

// tag-SocketsSockaddr
// file d:\tuttle\freertos\lib\include\aws_secure_sockets.h line 183
struct SocketsSockaddr;

// tag-SubpubUserData
// file ..\..\..\common\mqtt\aws_subscribe_publish_loop.c line 87
struct SubpubUserData;

// tag-TCPSOCKET
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP_Private.h line 492
struct TCPSOCKET;

// tag-TLSContext
// file ..\..\..\..\lib\tls\aws_tls.c line 72
struct TLSContext;

// tag-TimeOutData
// file ..\..\..\..\lib\shadow\aws_shadow.c line 117
struct TimeOutData;

// tag-UDPSOCKET
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP_Private.h line 579
struct UDPSOCKET;

// tag-XPROT_PACKET
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP_Private.h line 222
union XPROT_PACKET;

// tag-XSOCKET
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP_Private.h line 449
struct XSOCKET;

// tag-_CONTEXT
// file C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.14.26428\include\excpt.h line 33
struct _CONTEXT;

// tag-_FLOATING_SAVE_AREA
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\winnt.h line 5908
struct _FLOATING_SAVE_AREA;

// tag-_LARGE_INTEGER
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\winnt.h line 757
union _LARGE_INTEGER;

// tag-_OVERLAPPED
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\minwinbase.h line 51
struct _OVERLAPPED;

// tag-_SECURITY_ATTRIBUTES
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\minwinbase.h line 45
struct _SECURITY_ATTRIBUTES;

// tag-_SYSTEM_INFO
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\sysinfoapi.h line 75
struct _SYSTEM_INFO;

// tag-_TEB
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\winnt.h line 19759
struct _TEB;

// tag-__crt_locale_data
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt.h line 463
struct __crt_locale_data;

// tag-__crt_locale_data_public
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt.h line 454
struct __crt_locale_data_public;

// tag-__crt_locale_pointers
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt.h line 461
struct __crt_locale_pointers;

// tag-__crt_multibyte_data
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt.h line 464
struct __crt_multibyte_data;

// tag-_iobuf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 25
struct _iobuf;

// tag-_xUnion32
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 155
union _xUnion32;

// tag-_xUnionPtr
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 163
union _xUnionPtr;

// tag-addrinfo
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\ws2def.h line 868
struct addrinfo;

// tag-bpf_insn
// file ..\common\win_pcap\pcap/bpf.h line 90
struct bpf_insn;

// tag-bpf_program
// file ..\common\win_pcap\pcap/bpf.h line 88
struct bpf_program;

// tag-eNETWORK_EVENTS
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP.h line 116
enum eNETWORK_EVENTS { eNetworkUp=0, eNetworkDown=1 };

// tag-eTCP_STATE
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_TCP_IP.h line 35
enum eTCP_STATE { eCLOSED=0, eTCP_LISTEN=1, eCONNECT_SYN=2, eSYN_FIRST=3, eSYN_RECEIVED=4, eESTABLISHED=5, eFIN_WAIT_1=6, eFIN_WAIT_2=7, eCLOSE_WAIT=8, eCLOSING=9, eLAST_ACK=10, eTIME_WAIT=11 };

// tag-freertos_sockaddr
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_Sockets.h line 163
struct freertos_sockaddr;

// tag-hostent
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\winsock2.h line 225
struct hostent;

// tag-in_addr
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\inaddr.h line 22
struct in_addr;

// tag-ip_msfilter
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\ws2ipdef.h line 733
struct ip_msfilter;

// tag-mbedtls_asn1_bitstring
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/asn1.h line 145
struct mbedtls_asn1_bitstring;

// tag-mbedtls_asn1_buf
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\asn1.h line 134
struct mbedtls_asn1_buf;

// tag-mbedtls_asn1_named_data
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\asn1.h line 166
struct mbedtls_asn1_named_data;

// tag-mbedtls_asn1_sequence
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\asn1.h line 156
struct mbedtls_asn1_sequence;

// tag-mbedtls_cipher_base_t
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/cipher.h line 196
struct mbedtls_cipher_base_t;

// tag-mbedtls_md_info_t
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/md.h line 78
struct mbedtls_md_info_t;

// tag-mbedtls_pk_info_t
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/pk.h line 123
struct mbedtls_pk_info_t;

// tag-mbedtls_ssl_ciphersuite_t
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/ssl_ciphersuites.h line 326
struct mbedtls_ssl_ciphersuite_t;

// tag-mbedtls_ssl_config
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\ssl.h line 543
struct mbedtls_ssl_config;

// tag-mbedtls_ssl_context
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\ssl.h line 542
struct mbedtls_ssl_context;

// tag-mbedtls_ssl_handshake_params
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\ssl.h line 547
struct mbedtls_ssl_handshake_params;

// tag-mbedtls_ssl_key_cert
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\ssl.h line 550
struct mbedtls_ssl_key_cert;

// tag-mbedtls_ssl_premaster_secret
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\ssl.h line 364
union mbedtls_ssl_premaster_secret;

// tag-mbedtls_ssl_session
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\ssl.h line 541
struct mbedtls_ssl_session;

// tag-mbedtls_ssl_sig_hash_set_t
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\ssl.h line 548
struct mbedtls_ssl_sig_hash_set_t;

// tag-mbedtls_ssl_transform
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\ssl.h line 546
struct mbedtls_ssl_transform;

// tag-mbedtls_x509_crl
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\x509_crl.h line 70
struct mbedtls_x509_crl;

// tag-mbedtls_x509_crl_entry
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\x509_crl.h line 52
struct mbedtls_x509_crl_entry;

// tag-mbedtls_x509_crt
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/x509_crt.h line 53
struct mbedtls_x509_crt;

// tag-mbedtls_x509_time
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\x509.h line 208
struct mbedtls_x509_time;

// tag-pcap
// file ..\common\win_pcap\pcap/pcap.h line 87
struct pcap;

// tag-pcap_addr
// file ..\common\win_pcap\pcap/pcap.h line 90
struct pcap_addr;

// tag-pcap_if
// file ..\common\win_pcap\pcap/pcap.h line 89
struct pcap_if;

// tag-pcap_pkthdr
// file ..\common\win_pcap\pcap/pcap.h line 167
struct pcap_pkthdr;

// tag-pcap_rmtauth
// file ..\common\win_pcap\remote-ext.h line 338
struct pcap_rmtauth;

// tag-servent
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\winsock2.h line 245
struct servent;

// tag-sockaddr_in
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\ws2def.h line 608
struct sockaddr_in;

// tag-timecaps_tag
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\timeapi.h line 57
struct timecaps_tag;

// tag-tmrCallbackParameters
// file ..\..\..\..\lib\FreeRTOS\timers.c line 101
struct tmrCallbackParameters;

// tag-tmrTimerControl
// file ..\..\..\..\lib\FreeRTOS\timers.c line 68
struct tmrTimerControl;

// tag-tmrTimerParameters
// file ..\..\..\..\lib\FreeRTOS\timers.c line 94
struct tmrTimerParameters;

// tag-tmrTimerQueueMessage
// file ..\..\..\..\lib\FreeRTOS\timers.c line 110
struct tmrTimerQueueMessage;

// tag-tskTaskControlBlock
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 269
struct tskTaskControlBlock;

// tag-x509_crt_verify_string
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 1514
struct x509_crt_verify_string;

// tag-xARP_CACHE_TABLE_ROW
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_ARP.h line 42
struct xARP_CACHE_TABLE_ROW;

// tag-xARP_HEADER
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP_Private.h line 72
struct xARP_HEADER;

// tag-xARP_PACKET
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP_Private.h line 175
struct xARP_PACKET;

// tag-xDHCPMessage
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DHCP.c line 130
struct xDHCPMessage;

// tag-xDHCP_DATA
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DHCP.c line 166
struct xDHCP_DATA;

// tag-xDNSAnswerRecord
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DNS.c line 190
struct xDNSAnswerRecord;

// tag-xDNSMessage
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DNS.c line 163
struct xDNSMessage;

// tag-xDNSTail
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DNS.c line 180
struct xDNSTail;

// tag-xDNS_CACHE_TABLE_ROW
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DNS.c line 145
struct xDNS_CACHE_TABLE_ROW;

// tag-xETH_HEADER
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP_Private.h line 62
struct xETH_HEADER;

// tag-xEventGroupDefinition
// file ..\..\..\..\lib\FreeRTOS\event_groups.c line 63
struct xEventGroupDefinition;

// tag-xICMP_HEADER
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP_Private.h line 116
struct xICMP_HEADER;

// tag-xICMP_PACKET
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP_Private.h line 193
struct xICMP_PACKET;

// tag-xIP_HEADER
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP_Private.h line 88
struct xIP_HEADER;

// tag-xIP_PACKET
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP_Private.h line 184
struct xIP_PACKET;

// tag-xIP_TIMER
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 144
struct xIP_TIMER;

// tag-xLIST
// file ..\..\..\..\lib\include\private\list.h line 163
struct xLIST;

// tag-xLIST_ITEM
// file ..\..\..\..\lib\include\private\list.h line 139
struct xLIST_ITEM;

// tag-xMAC_ADDRESS
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP.h line 108
struct xMAC_ADDRESS;

// tag-xMEMORY_REGION
// file ..\..\..\..\lib\include\task.h line 102
struct xMEMORY_REGION;

// tag-xMINI_LIST_ITEM
// file ..\..\..\..\lib\include\private\list.h line 151
struct xMINI_LIST_ITEM;

// tag-xNETWORK_BUFFER
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP.h line 89
struct xNETWORK_BUFFER;

// tag-xNetworkAddressingParameters
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP_Private.h line 46
struct xNetworkAddressingParameters;

// tag-xSTATIC_EVENT_GROUP
// file d:\tuttle\freertos\lib\include\FreeRTOS.h line 1095
struct xSTATIC_EVENT_GROUP;

// tag-xSTATIC_LIST
// file d:\tuttle\freertos\lib\include\FreeRTOS.h line 968
struct xSTATIC_LIST;

// tag-xSTATIC_LIST_ITEM
// file d:\tuttle\freertos\lib\include\FreeRTOS.h line 952
struct xSTATIC_LIST_ITEM;

// tag-xSTATIC_MINI_LIST_ITEM
// file d:\tuttle\freertos\lib\include\FreeRTOS.h line 960
struct xSTATIC_MINI_LIST_ITEM;

// tag-xSTATIC_QUEUE
// file d:\tuttle\freertos\lib\include\FreeRTOS.h line 1051
struct xSTATIC_QUEUE;

// tag-xSTATIC_STREAM_BUFFER
// file d:\tuttle\freertos\lib\include\FreeRTOS.h line 1155
struct xSTATIC_STREAM_BUFFER;

// tag-xSTATIC_TCB
// file d:\tuttle\freertos\lib\include\FreeRTOS.h line 988
struct xSTATIC_TCB;

// tag-xSTATIC_TIMER
// file d:\tuttle\freertos\lib\include\FreeRTOS.h line 1124
struct xSTATIC_TIMER;

// tag-xSTREAM_BUFFER
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_Sockets.h line 348
struct xSTREAM_BUFFER$0;

// tag-xTASK_STATUS
// file ..\..\..\..\lib\include\task.h line 128
struct xTASK_STATUS;

// tag-xTCPTimer
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_TCP_WIN.h line 40
struct xTCPTimer;

// tag-xTCP_HEADER
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP_Private.h line 139
struct xTCP_HEADER;

// tag-xTCP_PACKET
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP_Private.h line 213
struct xTCP_PACKET;

// tag-xTCP_SEGMENT
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_TCP_WIN.h line 45
struct xTCP_SEGMENT;

// tag-xTCP_WINDOW
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_TCP_WIN.h line 92
struct xTCP_WINDOW;

// tag-xTCP_WINSIZE
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_TCP_WIN.h line 71
struct xTCP_WINSIZE;

// tag-xTIME_OUT
// file ..\..\..\..\lib\include\task.h line 93
struct xTIME_OUT;

// tag-xTLS_PARAMS
// file ..\..\..\..\lib\include\aws_tls.h line 69
struct xTLS_PARAMS;

// tag-xUDPPacketHeader
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP_Private.h line 328
union xUDPPacketHeader;

// tag-xUDP_HEADER
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP_Private.h line 128
struct xUDP_HEADER;

// tag-xUDP_PACKET
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP_Private.h line 203
struct xUDP_PACKET;

// tag-xWIN_PROPS
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_Sockets.h line 148
struct xWIN_PROPS;


typedef struct xARP_PACKET ARPPacket_t;
typedef signed int BOOL;
typedef unsigned char BOOLEAN;
typedef unsigned char BYTE;
typedef signed long int BaseType_t;
typedef struct A_BLOCK_LINK BlockLink_t;
typedef char CHAR;
typedef struct CK_ATTRIBUTE CK_ATTRIBUTE;
typedef CK_ATTRIBUTE *CK_ATTRIBUTE_PTR;
typedef unsigned long int CK_ATTRIBUTE_TYPE;
typedef unsigned char CK_BBOOL;
typedef unsigned char CK_BYTE;
typedef CK_BYTE *CK_BYTE_PTR;
typedef unsigned char CK_CHAR;
typedef unsigned long int CK_FLAGS;
typedef struct CK_FUNCTION_LIST CK_FUNCTION_LIST;
typedef CK_FUNCTION_LIST *CK_FUNCTION_LIST_PTR;
typedef CK_FUNCTION_LIST_PTR *CK_FUNCTION_LIST_PTR_PTR;
typedef struct CK_INFO CK_INFO;
typedef CK_INFO *CK_INFO_PTR;
typedef unsigned long int CK_KEY_TYPE;
typedef struct CK_MECHANISM CK_MECHANISM;
typedef struct CK_MECHANISM_INFO CK_MECHANISM_INFO;
typedef CK_MECHANISM_INFO *CK_MECHANISM_INFO_PTR;
typedef CK_MECHANISM *CK_MECHANISM_PTR;
typedef unsigned long int CK_MECHANISM_TYPE;
typedef CK_MECHANISM_TYPE *CK_MECHANISM_TYPE_PTR;
typedef unsigned long int CK_NOTIFICATION;
typedef unsigned long int CK_OBJECT_CLASS;
typedef unsigned long int CK_OBJECT_HANDLE;
typedef CK_OBJECT_HANDLE *CK_OBJECT_HANDLE_PTR;
typedef unsigned long int CK_RV;
typedef CK_RV (*CK_C_GetFunctionList)(CK_FUNCTION_LIST_PTR_PTR);
typedef CK_RV (*CK_C_GetInfo)(CK_INFO_PTR);
typedef unsigned long int CK_SESSION_HANDLE;
typedef CK_RV (*CK_C_CancelFunction)(CK_SESSION_HANDLE);
typedef CK_RV (*CK_C_CloseSession)(CK_SESSION_HANDLE);
typedef CK_RV (*CK_C_DecryptInit)(CK_SESSION_HANDLE, CK_MECHANISM_PTR, CK_OBJECT_HANDLE);
typedef CK_RV (*CK_C_DestroyObject)(CK_SESSION_HANDLE, CK_OBJECT_HANDLE);
typedef CK_RV (*CK_C_DigestInit)(CK_SESSION_HANDLE, CK_MECHANISM_PTR);
typedef CK_RV (*CK_C_DigestKey)(CK_SESSION_HANDLE, CK_OBJECT_HANDLE);
typedef CK_RV (*CK_C_EncryptInit)(CK_SESSION_HANDLE, CK_MECHANISM_PTR, CK_OBJECT_HANDLE);
typedef CK_RV (*CK_C_FindObjectsFinal)(CK_SESSION_HANDLE);
typedef CK_RV (*CK_C_GetFunctionStatus)(CK_SESSION_HANDLE);
typedef CK_RV (*CK_C_Logout)(CK_SESSION_HANDLE);
typedef CK_RV (*CK_C_SignInit)(CK_SESSION_HANDLE, CK_MECHANISM_PTR, CK_OBJECT_HANDLE);
typedef CK_RV (*CK_C_SignRecoverInit)(CK_SESSION_HANDLE, CK_MECHANISM_PTR, CK_OBJECT_HANDLE);
typedef CK_RV (*CK_C_VerifyInit)(CK_SESSION_HANDLE, CK_MECHANISM_PTR, CK_OBJECT_HANDLE);
typedef CK_RV (*CK_C_VerifyRecoverInit)(CK_SESSION_HANDLE, CK_MECHANISM_PTR, CK_OBJECT_HANDLE);
typedef CK_SESSION_HANDLE *CK_SESSION_HANDLE_PTR;
typedef struct CK_SESSION_INFO CK_SESSION_INFO;
typedef CK_SESSION_INFO *CK_SESSION_INFO_PTR;
typedef CK_RV (*CK_C_GetSessionInfo)(CK_SESSION_HANDLE, CK_SESSION_INFO_PTR);
typedef unsigned long int CK_SLOT_ID;
typedef CK_RV (*CK_C_CloseAllSessions)(CK_SLOT_ID);
typedef CK_RV (*CK_C_GetMechanismInfo)(CK_SLOT_ID, CK_MECHANISM_TYPE, CK_MECHANISM_INFO_PTR);
typedef CK_SLOT_ID *CK_SLOT_ID_PTR;
typedef struct CK_SLOT_INFO CK_SLOT_INFO;
typedef CK_SLOT_INFO *CK_SLOT_INFO_PTR;
typedef CK_RV (*CK_C_GetSlotInfo)(CK_SLOT_ID, CK_SLOT_INFO_PTR);
typedef unsigned long int CK_STATE;
typedef struct CK_TOKEN_INFO CK_TOKEN_INFO;
typedef CK_TOKEN_INFO *CK_TOKEN_INFO_PTR;
typedef CK_RV (*CK_C_GetTokenInfo)(CK_SLOT_ID, CK_TOKEN_INFO_PTR);
typedef unsigned long int CK_ULONG;
typedef CK_RV (*CK_C_CopyObject)(CK_SESSION_HANDLE, CK_OBJECT_HANDLE, CK_ATTRIBUTE_PTR, CK_ULONG, CK_OBJECT_HANDLE_PTR);
typedef CK_RV (*CK_C_CreateObject)(CK_SESSION_HANDLE, CK_ATTRIBUTE_PTR, CK_ULONG, CK_OBJECT_HANDLE_PTR);
typedef CK_RV (*CK_C_DeriveKey)(CK_SESSION_HANDLE, CK_MECHANISM_PTR, CK_OBJECT_HANDLE, CK_ATTRIBUTE_PTR, CK_ULONG, CK_OBJECT_HANDLE_PTR);
typedef CK_RV (*CK_C_DigestUpdate)(CK_SESSION_HANDLE, CK_BYTE_PTR, CK_ULONG);
typedef CK_RV (*CK_C_FindObjectsInit)(CK_SESSION_HANDLE, CK_ATTRIBUTE_PTR, CK_ULONG);
typedef CK_RV (*CK_C_GenerateKey)(CK_SESSION_HANDLE, CK_MECHANISM_PTR, CK_ATTRIBUTE_PTR, CK_ULONG, CK_OBJECT_HANDLE_PTR);
typedef CK_RV (*CK_C_GenerateKeyPair)(CK_SESSION_HANDLE, CK_MECHANISM_PTR, CK_ATTRIBUTE_PTR, CK_ULONG, CK_ATTRIBUTE_PTR, CK_ULONG, CK_OBJECT_HANDLE_PTR, CK_OBJECT_HANDLE_PTR);
typedef CK_RV (*CK_C_GenerateRandom)(CK_SESSION_HANDLE, CK_BYTE_PTR, CK_ULONG);
typedef CK_RV (*CK_C_GetAttributeValue)(CK_SESSION_HANDLE, CK_OBJECT_HANDLE, CK_ATTRIBUTE_PTR, CK_ULONG);
typedef CK_RV (*CK_C_SeedRandom)(CK_SESSION_HANDLE, CK_BYTE_PTR, CK_ULONG);
typedef CK_RV (*CK_C_SetAttributeValue)(CK_SESSION_HANDLE, CK_OBJECT_HANDLE, CK_ATTRIBUTE_PTR, CK_ULONG);
typedef CK_RV (*CK_C_SetOperationState)(CK_SESSION_HANDLE, CK_BYTE_PTR, CK_ULONG, CK_OBJECT_HANDLE, CK_OBJECT_HANDLE);
typedef CK_RV (*CK_C_SignUpdate)(CK_SESSION_HANDLE, CK_BYTE_PTR, CK_ULONG);
typedef CK_RV (*CK_C_UnwrapKey)(CK_SESSION_HANDLE, CK_MECHANISM_PTR, CK_OBJECT_HANDLE, CK_BYTE_PTR, CK_ULONG, CK_ATTRIBUTE_PTR, CK_ULONG, CK_OBJECT_HANDLE_PTR);
typedef CK_RV (*CK_C_Verify)(CK_SESSION_HANDLE, CK_BYTE_PTR, CK_ULONG, CK_BYTE_PTR, CK_ULONG);
typedef CK_RV (*CK_C_VerifyFinal)(CK_SESSION_HANDLE, CK_BYTE_PTR, CK_ULONG);
typedef CK_RV (*CK_C_VerifyUpdate)(CK_SESSION_HANDLE, CK_BYTE_PTR, CK_ULONG);
typedef CK_ULONG *CK_ULONG_PTR;
typedef CK_RV (*CK_C_Decrypt)(CK_SESSION_HANDLE, CK_BYTE_PTR, CK_ULONG, CK_BYTE_PTR, CK_ULONG_PTR);
typedef CK_RV (*CK_C_DecryptDigestUpdate)(CK_SESSION_HANDLE, CK_BYTE_PTR, CK_ULONG, CK_BYTE_PTR, CK_ULONG_PTR);
typedef CK_RV (*CK_C_DecryptFinal)(CK_SESSION_HANDLE, CK_BYTE_PTR, CK_ULONG_PTR);
typedef CK_RV (*CK_C_DecryptUpdate)(CK_SESSION_HANDLE, CK_BYTE_PTR, CK_ULONG, CK_BYTE_PTR, CK_ULONG_PTR);
typedef CK_RV (*CK_C_DecryptVerifyUpdate)(CK_SESSION_HANDLE, CK_BYTE_PTR, CK_ULONG, CK_BYTE_PTR, CK_ULONG_PTR);
typedef CK_RV (*CK_C_Digest)(CK_SESSION_HANDLE, CK_BYTE_PTR, CK_ULONG, CK_BYTE_PTR, CK_ULONG_PTR);
typedef CK_RV (*CK_C_DigestEncryptUpdate)(CK_SESSION_HANDLE, CK_BYTE_PTR, CK_ULONG, CK_BYTE_PTR, CK_ULONG_PTR);
typedef CK_RV (*CK_C_DigestFinal)(CK_SESSION_HANDLE, CK_BYTE_PTR, CK_ULONG_PTR);
typedef CK_RV (*CK_C_Encrypt)(CK_SESSION_HANDLE, CK_BYTE_PTR, CK_ULONG, CK_BYTE_PTR, CK_ULONG_PTR);
typedef CK_RV (*CK_C_EncryptFinal)(CK_SESSION_HANDLE, CK_BYTE_PTR, CK_ULONG_PTR);
typedef CK_RV (*CK_C_EncryptUpdate)(CK_SESSION_HANDLE, CK_BYTE_PTR, CK_ULONG, CK_BYTE_PTR, CK_ULONG_PTR);
typedef CK_RV (*CK_C_FindObjects)(CK_SESSION_HANDLE, CK_OBJECT_HANDLE_PTR, CK_ULONG, CK_ULONG_PTR);
typedef CK_RV (*CK_C_GetMechanismList)(CK_SLOT_ID, CK_MECHANISM_TYPE_PTR, CK_ULONG_PTR);
typedef CK_RV (*CK_C_GetObjectSize)(CK_SESSION_HANDLE, CK_OBJECT_HANDLE, CK_ULONG_PTR);
typedef CK_RV (*CK_C_GetOperationState)(CK_SESSION_HANDLE, CK_BYTE_PTR, CK_ULONG_PTR);
typedef CK_RV (*CK_C_GetSlotList)(CK_BBOOL, CK_SLOT_ID_PTR, CK_ULONG_PTR);
typedef CK_RV (*CK_C_Sign)(CK_SESSION_HANDLE, CK_BYTE_PTR, CK_ULONG, CK_BYTE_PTR, CK_ULONG_PTR);
typedef CK_RV (*CK_C_SignEncryptUpdate)(CK_SESSION_HANDLE, CK_BYTE_PTR, CK_ULONG, CK_BYTE_PTR, CK_ULONG_PTR);
typedef CK_RV (*CK_C_SignFinal)(CK_SESSION_HANDLE, CK_BYTE_PTR, CK_ULONG_PTR);
typedef CK_RV (*CK_C_SignRecover)(CK_SESSION_HANDLE, CK_BYTE_PTR, CK_ULONG, CK_BYTE_PTR, CK_ULONG_PTR);
typedef CK_RV (*CK_C_VerifyRecover)(CK_SESSION_HANDLE, CK_BYTE_PTR, CK_ULONG, CK_BYTE_PTR, CK_ULONG_PTR);
typedef CK_RV (*CK_C_WrapKey)(CK_SESSION_HANDLE, CK_MECHANISM_PTR, CK_OBJECT_HANDLE, CK_OBJECT_HANDLE, CK_BYTE_PTR, CK_ULONG_PTR);
typedef unsigned long int CK_USER_TYPE;
typedef unsigned char CK_UTF8CHAR;
typedef CK_UTF8CHAR *CK_UTF8CHAR_PTR;
typedef CK_RV (*CK_C_InitPIN)(CK_SESSION_HANDLE, CK_UTF8CHAR_PTR, CK_ULONG);
typedef CK_RV (*CK_C_InitToken)(CK_SLOT_ID, CK_UTF8CHAR_PTR, CK_ULONG, CK_UTF8CHAR_PTR);
typedef CK_RV (*CK_C_Login)(CK_SESSION_HANDLE, CK_USER_TYPE, CK_UTF8CHAR_PTR, CK_ULONG);
typedef CK_RV (*CK_C_SetPIN)(CK_SESSION_HANDLE, CK_UTF8CHAR_PTR, CK_ULONG, CK_UTF8CHAR_PTR, CK_ULONG);
typedef void *CK_VOID_PTR;
typedef CK_RV (*CK_C_Finalize)(CK_VOID_PTR);
typedef CK_RV (*CK_C_Initialize)(CK_VOID_PTR);
typedef CK_RV (*CK_C_WaitForSlotEvent)(CK_FLAGS, CK_SLOT_ID_PTR, CK_VOID_PTR);
typedef CK_RV (*CK_NOTIFY)(CK_SESSION_HANDLE, CK_NOTIFICATION, CK_VOID_PTR);
typedef CK_RV (*CK_C_OpenSession)(CK_SLOT_ID, CK_FLAGS, CK_VOID_PTR, CK_NOTIFY, CK_SESSION_HANDLE_PTR);
typedef struct _CONTEXT CONTEXT;
typedef struct CallbackCatalogEntry CallbackCatalogEntry_t;
typedef struct CborEncoder CborEncoder;
typedef enum CborError CborError;
typedef struct CborParser CborParser;
typedef unsigned long long int CborTag;
typedef enum CborType CborType;
typedef struct CborValue CborValue;
typedef unsigned long int DWORD;
typedef unsigned long long int DWORD_PTR;
typedef unsigned int EventBits_t;
typedef void *EventGroupHandle_t;
typedef struct XSOCKET FreeRTOS_Socket_t;
typedef struct anonymous$53 GGD_HostAddressData_t;
typedef void *HANDLE;
typedef unsigned long long int HCRYPTPROV;
typedef struct HINSTANCE__ *HMODULE;
typedef struct anonymous$49 HostParameters_t;
typedef struct xICMP_PACKET ICMPPacket_t;
typedef signed long long int INT_PTR;
typedef INT_PTR (*FARPROC)();
typedef struct in_addr IN_ADDR;
typedef struct xIP_PACKET IPPacket_t;
typedef struct IP_TASK_COMMANDS IPStackEvent_t;
typedef struct xIP_TIMER IPTimer_t;
typedef enum anonymous$24 IngestResult_t;
typedef enum anonymous$25 JobParamType_t;
typedef struct anonymous$117 KernelCall;
typedef union _LARGE_INTEGER LARGE_INTEGER;
typedef signed long int LONG;
typedef signed long long int LONGLONG;
typedef signed long long int LONG_PTR;
typedef CONTEXT *LPCONTEXT;
typedef const CHAR *LPCSTR;
typedef const void *LPCVOID;
typedef DWORD *LPDWORD;
typedef struct _OVERLAPPED *LPOVERLAPPED;
typedef struct _SECURITY_ATTRIBUTES *LPSECURITY_ATTRIBUTES;
typedef CHAR *LPSTR;
typedef struct _SYSTEM_INFO *LPSYSTEM_INFO;
typedef struct timecaps_tag *LPTIMECAPS;
typedef void *LPVOID;
typedef DWORD (*LPTHREAD_START_ROUTINE)(LPVOID);
typedef struct _OVERLAPPED *LPWSAOVERLAPPED;
typedef void (*LPWSAOVERLAPPED_COMPLETION_ROUTINE)(DWORD, DWORD, LPWSAOVERLAPPED, DWORD);
typedef struct xLIST_ITEM ListItem_t;
typedef struct xLIST List_t;
typedef struct xMAC_ADDRESS MACAddress_t;
typedef unsigned int MMRESULT;
typedef enum anonymous$39 MQTTAction_t;
typedef struct MQTTAgentCallbackParams MQTTAgentCallbackParams_t;
typedef BaseType_t (*MQTTAgentCallback_t)(void *, const MQTTAgentCallbackParams_t *);
typedef struct MQTTAgentConnectParams MQTTAgentConnectParams_t;
typedef enum anonymous$43 MQTTAgentEvent_t;
typedef void *MQTTAgentHandle_t;
typedef struct MQTTAgentPublishParams MQTTAgentPublishParams_t;
typedef enum anonymous$41 MQTTAgentReturnCode_t;
typedef struct MQTTAgentSubscribeParams MQTTAgentSubscribeParams_t;
typedef struct MQTTAgentUnsubscribeParams MQTTAgentUnsubscribeParams_t;
typedef enum anonymous$46 MQTTBool_t;
typedef struct MQTTBrokerConnection MQTTBrokerConnection_t;
typedef void *MQTTBufferHandle_t;
typedef enum anonymous$37 MQTTConnACKReturnCode_t;
typedef struct MQTTConnectParams MQTTConnectParams_t;
typedef enum anonymous$33 MQTTConnectionState_t;
typedef struct MQTTContext MQTTContext_t;
typedef enum anonymous$36 MQTTDisconnectReason_t;
typedef struct MQTTCallbackParams MQTTEventCallbackParams_t;
typedef MQTTBool_t (*MQTTEventCallback_t)(void *, const MQTTEventCallbackParams_t *);
typedef struct MQTTEventData MQTTEventData_t;
typedef enum anonymous$34 MQTTEventType_t;
typedef struct MQTTInitParams MQTTInitParams_t;
typedef struct MQTTNotificationData MQTTNotificationData_t;
typedef enum anonymous$35 MQTTNotifyCodes_t;
typedef struct MQTTPublishData MQTTPublishData_t;
typedef MQTTBool_t (*MQTTPublishCallback_t)(void *, const MQTTPublishData_t *);
typedef struct MQTTPublishParams MQTTPublishParams_t;
typedef enum anonymous$47 MQTTQoS_t;
typedef enum anonymous$44 MQTTReturnCode_t;
typedef enum anonymous$40 MQTTRxMessageAction_t;
typedef enum anonymous$38 MQTTRxNextByte_t;
typedef enum anonymous$48 MQTTSubACKReturnCode_t;
typedef struct MQTTSubscribeParams MQTTSubscribeParams_t;
typedef enum anonymous$45 MQTTTopicFilterType_t;
typedef struct MQTTUnsubscribeParams MQTTUnsubscribeParams_t;
typedef enum anonymous$77 MULTICAST_MODE_TYPE;
typedef struct xMEMORY_REGION MemoryRegion_t;
typedef void *MessageBufferHandle_t;
typedef struct xMINI_LIST_ITEM MiniListItem_t;
typedef struct xNETWORK_BUFFER NetworkBufferDescriptor_t;
typedef unsigned int OTA_Err_t;
typedef struct anonymous$29 OTA_FileContext_t;
typedef enum anonymous$28 OTA_ImageState_t;
typedef enum anonymous$23 OTA_JobParseErr_t;
typedef enum anonymous$26 OTA_JobStatus_t;
typedef enum anonymous$27 OTA_State_t;
typedef struct P11Key *P11KeyPtr_t;
typedef struct P11Session *P11SessionPtr_t;
typedef DWORD *PDWORD;
typedef BOOL (*PHANDLER_ROUTINE)(DWORD);
typedef struct ip_msfilter *PIP_MSFILTER;
typedef void *PVOID;
typedef struct ProvisioningParams_t ProvisioningParams_t;
typedef void *QueueHandle_t;
typedef struct QueueDefinition Queue_t;
typedef unsigned long long int SIZE_T;
typedef unsigned long long int SOCKET;
typedef struct SSOCKETContext *SSOCKETContextPtr_t;
typedef void *SemaphoreHandle_t;
typedef struct ShadowCallbackParams ShadowCallbackParams_t;
typedef void *ShadowClientHandle_t;
typedef struct ShadowClient ShadowClient_t;
typedef struct ShadowCreateParams ShadowCreateParams_t;
typedef void (*ShadowDeletedCallback_t)(void *, const char *);
typedef enum ShadowMQTTClientType ShadowMQTTClientType_t;
typedef struct ShadowOperationCallParams ShadowOperationCallParams_t;
typedef struct ShadowOperationData ShadowOperationData_t;
typedef enum ShadowOperationName ShadowOperationName_t;
typedef struct ShadowOperationParams ShadowOperationParams_t;
typedef struct anonymous$127 ShadowQueueData_t;
typedef signed short int ShadowReturnCode_t;
typedef struct SignatureVerificationState *SignatureVerificationStatePtr_t;
typedef void (*SocketWakeupCallback_t)(struct XSOCKET *);
typedef void *Socket_t;
typedef struct SocketsSockaddr SocketsSockaddr_t;
typedef unsigned long long int StackType_t;
typedef struct xSTATIC_EVENT_GROUP StaticEventGroup_t;
typedef struct xSTATIC_QUEUE StaticQueue_t;
typedef struct xSTATIC_STREAM_BUFFER StaticStreamBuffer_t;
typedef struct xSTATIC_TCB StaticTask_t;
typedef struct xSTATIC_TIMER StaticTimer_t;
typedef void *StreamBufferHandle_t;
typedef struct SubpubUserData SubpubUserData_t;
typedef struct tskTaskControlBlock TCB_t;
typedef struct xTCP_PACKET TCPPacket_t;
typedef struct xTCP_SEGMENT TCPSegment_t;
typedef struct xTCPTimer TCPTimer_t;
typedef struct xTCP_WINDOW TCPWindow_t;
typedef struct TLSContext TLSContext_t;
typedef struct xTLS_PARAMS TLSParams_t;
typedef void (*TRACE_STOP_HOOK)(void);
typedef struct anonymous$117 TREvent;
typedef void (*TaskFunction_t)(void *);
typedef void *TaskHandle_t;
typedef struct xTASK_STATUS TaskStatus_t;
typedef unsigned int TickType_t;
typedef struct TimeOutData TimeOutData_t;
typedef struct xTIME_OUT TimeOut_t;
typedef void *TimerHandle_t;
typedef void (*TimerCallbackFunction_t)(TimerHandle_t);
typedef struct tmrTimerControl Timer_t;
typedef unsigned long int UBaseType_t;
typedef unsigned char UCHAR;
typedef unsigned int UINT;
typedef unsigned long long int UINT_PTR;
typedef unsigned long int ULONG;
typedef unsigned long long int ULONG_PTR;
typedef unsigned short int USHORT;
typedef unsigned short int WCHAR;
typedef WCHAR *LPWSTR;
typedef unsigned short int WORD;
typedef void (*WSPIAPI_PFREEADDRINFO)(struct addrinfo *);
typedef signed int (*WSPIAPI_PGETADDRINFO)(const char *, const char *, const struct addrinfo *, struct addrinfo **);
typedef struct __crt_locale_data_public __crt_locale_data_public;
typedef struct __crt_locale_pointers __crt_locale_pointers;
typedef __crt_locale_pointers *_locale_t;
typedef unsigned int bpf_u_int32;
typedef enum anonymous$85 eARPLookupResult_t;
typedef enum anonymous$102 eDHCPState_t;
typedef enum anonymous$60 eFrameProcessingResult_t;
typedef enum eNETWORK_EVENTS eIPCallbackEvent_t;
typedef enum anonymous$61 eIPEvent_t;
typedef enum anonymous$56 eNotifyAction;
typedef enum anonymous$55 eTaskState;
typedef enum anonymous$86 ecp_curve_type;
typedef signed int errno_t;
typedef struct anonymous$50 jsmn_parser;
typedef struct anonymous$51 jsmntok_t;
typedef enum anonymous$52 jsmntype_t;
typedef struct anonymous$18 mbedtls_aes_context;
typedef struct mbedtls_asn1_bitstring mbedtls_asn1_bitstring;
typedef struct mbedtls_asn1_buf mbedtls_asn1_buf;
typedef struct mbedtls_asn1_named_data mbedtls_asn1_named_data;
typedef struct mbedtls_asn1_sequence mbedtls_asn1_sequence;
typedef struct mbedtls_cipher_base_t mbedtls_cipher_base_t;
typedef struct anonymous$14 mbedtls_cipher_context_t;
typedef enum anonymous$9 mbedtls_cipher_id_t;
typedef struct anonymous$10 mbedtls_cipher_info_t;
typedef enum anonymous$11 mbedtls_cipher_mode_t;
typedef enum anonymous$12 mbedtls_cipher_padding_t;
typedef enum anonymous$15 mbedtls_cipher_type_t;
typedef struct anonymous$63 mbedtls_ctr_drbg_context;
typedef struct anonymous$5 mbedtls_ecdh_context;
typedef enum anonymous$6 mbedtls_ecdh_side;
typedef struct anonymous$19 mbedtls_ecdsa_context;
typedef struct anonymous$2 mbedtls_ecp_curve_info;
typedef struct anonymous$78 mbedtls_ecp_group;
typedef enum anonymous$64 mbedtls_ecp_group_id;
typedef struct anonymous$19 mbedtls_ecp_keypair;
typedef struct anonymous$16 mbedtls_ecp_point;
typedef struct anonymous$83 mbedtls_entropy_context;
typedef struct anonymous$8 mbedtls_gcm_context;
typedef struct anonymous$4 mbedtls_hmac_drbg_context;
typedef enum anonymous$62 mbedtls_key_exchange_type_t;
typedef struct anonymous$3 mbedtls_md_context_t;
typedef struct mbedtls_md_info_t mbedtls_md_info_t;
typedef enum anonymous$69 mbedtls_md_type_t;
typedef struct anonymous$17 mbedtls_mpi;
typedef signed long long int mbedtls_mpi_sint;
typedef unsigned long long int mbedtls_mpi_uint;
typedef struct anonymous$0 mbedtls_oid_descriptor_t;
typedef enum anonymous$13 mbedtls_operation_t;
typedef struct anonymous$93 mbedtls_pem_context;
typedef struct anonymous$70 mbedtls_pk_context;
typedef struct anonymous$92 mbedtls_pk_debug_item;
typedef enum anonymous$65 mbedtls_pk_debug_type;
typedef struct mbedtls_pk_info_t mbedtls_pk_info_t;
typedef enum anonymous$67 mbedtls_pk_type_t;
typedef struct anonymous$75 mbedtls_platform_context;
typedef struct anonymous$1 mbedtls_rsa_context;
typedef struct anonymous$68 mbedtls_sha1_context;
typedef struct anonymous$72 mbedtls_sha256_context;
typedef struct mbedtls_ssl_ciphersuite_t mbedtls_ssl_ciphersuite_t;
typedef struct mbedtls_ssl_config mbedtls_ssl_config;
typedef struct mbedtls_ssl_context mbedtls_ssl_context;
typedef signed int mbedtls_ssl_get_timer_t(void *);
typedef struct mbedtls_ssl_handshake_params mbedtls_ssl_handshake_params;
typedef struct mbedtls_ssl_key_cert mbedtls_ssl_key_cert;
typedef struct mbedtls_ssl_session mbedtls_ssl_session;
typedef struct mbedtls_ssl_sig_hash_set_t mbedtls_ssl_sig_hash_set_t;
typedef struct mbedtls_ssl_transform mbedtls_ssl_transform;
typedef struct mbedtls_asn1_buf mbedtls_x509_buf;
typedef struct mbedtls_x509_crl mbedtls_x509_crl;
typedef struct mbedtls_x509_crt mbedtls_x509_crt;
typedef struct anonymous$73 mbedtls_x509_crt_profile;
typedef struct mbedtls_asn1_named_data mbedtls_x509_name;
typedef struct mbedtls_asn1_sequence mbedtls_x509_sequence;
typedef struct mbedtls_x509_time mbedtls_x509_time;
typedef struct anonymous$59 oid_cipher_alg_t;
typedef struct anonymous$91 oid_ecp_grp_t;
typedef struct anonymous$84 oid_md_alg_t;
typedef struct anonymous$88 oid_md_hmac_t;
typedef struct anonymous$82 oid_pk_alg_t;
typedef struct anonymous oid_sig_alg_t;
typedef struct anonymous$90 oid_x509_ext_t;
typedef struct anonymous$89 oid_x520_attr_t;
typedef struct pcap_if pcap_if_t;
typedef struct pcap pcap_t;
typedef signed long long int ptrdiff_t;
typedef void (*pxOTACompleteCallback_t)(OTA_ImageState_t);
typedef size_t rsize_t;
typedef BaseType_t (*NetworkRecv_t)(void *, unsigned char *, size_t);
typedef BaseType_t (*NetworkSend_t)(void *, const unsigned char *, size_t);
typedef signed int (*mbedtls_entropy_f_source_ptr)(void *, unsigned char *, size_t, size_t *);
typedef signed int (*mbedtls_pk_rsa_alt_decrypt_func)(void *, signed int, size_t *, const unsigned char *, unsigned char *, size_t);
typedef size_t (*mbedtls_pk_rsa_alt_key_len_func)(void *);
typedef signed int (*mbedtls_pk_rsa_alt_sign_func)(void *, signed int (*)(void *, unsigned char *, size_t), void *, signed int, mbedtls_md_type_t, unsigned int, const unsigned char *, unsigned char *);
typedef signed int mbedtls_ssl_recv_t(void *, unsigned char *, size_t);
typedef signed int mbedtls_ssl_send_t(void *, const unsigned char *, size_t);
typedef signed int (*pfnMbedTlsSign)(void *, mbedtls_md_type_t, const unsigned char *, size_t, unsigned char *, size_t *, signed int (*)(void *, unsigned char *, size_t), void *);
typedef signed int (*WSPIAPI_PGETNAMEINFO)(const struct sockaddr *, socklen_t, char *, size_t, char *, size_t, signed int);
typedef unsigned char traceHandle;
typedef unsigned char traceObjectClass;
typedef unsigned short int traceString;
typedef unsigned char u_char;
typedef void (*pcap_handler)(u_char *, const struct pcap_pkthdr *, const u_char *);
typedef unsigned int u_int;
typedef unsigned long int u_long;
typedef unsigned short int u_short;
typedef unsigned short int uint16_t;
typedef unsigned int uint32_t;
typedef void (*PendedFunction_t)(void *, uint32_t);
typedef BaseType_t (*ShadowDeltaCallback_t)(void *, const char *, const char *, uint32_t, MQTTBufferHandle_t);
typedef BaseType_t (*ShadowUpdatedCallback_t)(void *, const char *, const char *, uint32_t, MQTTBufferHandle_t);
typedef signed int mbedtls_ssl_recv_timeout_t(void *, unsigned char *, size_t, uint32_t);
typedef void mbedtls_ssl_set_timer_t(void *, uint32_t, uint32_t);
/*typedef unsigned long long int uint64_t;*/
typedef void (*MQTTGetTicks_t)(uint64_t *);
typedef unsigned char uint8_t;
typedef uint8_t * (*MQTTGetFreeBuffer_t)(uint32_t *);
typedef void (*MQTTReturnBuffer_t)(uint8_t *);
typedef uint32_t (*MQTTSend_t)(void *, const uint8_t *, uint32_t);
/*typedef unsigned long long int uintptr_t;*/
typedef uintptr_t (*IterateFunction)(char *, const uint8_t *, size_t);
typedef struct anonymous$110 x509_crt_verify_chain_item;

typedef struct xSTREAM_BUFFER$0
{
  // uxTail
  volatile size_t uxTail;
  // uxMid
  volatile size_t uxMid;
  // uxHead
  volatile size_t uxHead;
  // uxFront
  volatile size_t uxFront;
  // LENGTH
  size_t LENGTH;
  // ucArray
  uint8_t ucArray[(signed long long int)sizeof(size_t)];
} StreamBuffer_t;

typedef struct xSTREAM_BUFFER
{
  // xTail
  volatile size_t xTail;
  // xHead
  volatile size_t xHead;
  // xLength
  size_t xLength;
  // xTriggerLevelBytes
  size_t xTriggerLevelBytes;
  // xTaskWaitingToReceive
  volatile TaskHandle_t xTaskWaitingToReceive;
  // xTaskWaitingToSend
  volatile TaskHandle_t xTaskWaitingToSend;
  // pucBuffer
  uint8_t *pucBuffer;
  // ucFlags
  uint8_t ucFlags;
  // uxStreamBufferNumber
  UBaseType_t uxStreamBufferNumber;
} StreamBuffer_t1;

// App_OTACompleteCallback
// file ..\..\..\common\ota\aws_ota_update_demo.c line 143
static void App_OTACompleteCallback(OTA_ImageState_t eState);
// BUFFERPOOL_GetFreeBuffer
// file ..\..\..\..\lib\bufferpool\aws_bufferpool_static_thread_safe.c line 133
uint8_t * BUFFERPOOL_GetFreeBuffer(uint32_t *pulBufferLength);
// BUFFERPOOL_Init
// file ..\..\..\..\lib\bufferpool\aws_bufferpool_static_thread_safe.c line 117
extern BaseType_t BUFFERPOOL_Init(void);
// BUFFERPOOL_ReturnBuffer
// file ..\..\..\..\lib\bufferpool\aws_bufferpool_static_thread_safe.c line 181
void BUFFERPOOL_ReturnBuffer(uint8_t * const pucBuffer);
// CRYPTO_ConfigureHeap
// file ..\..\..\..\lib\crypto\aws_crypto.c line 144
void CRYPTO_ConfigureHeap(void);
// CRYPTO_SignatureVerificationFinal
// file ..\..\..\..\lib\crypto\aws_crypto.c line 225
BaseType_t CRYPTO_SignatureVerificationFinal(void *pvContext, char *pcSignerCertificate, size_t xSignerCertificateLength, uint8_t *pucSignature, size_t xSignatureLength);
// CRYPTO_SignatureVerificationStart
// file ..\..\..\..\lib\crypto\aws_crypto.c line 155
BaseType_t CRYPTO_SignatureVerificationStart(void **ppvContext, BaseType_t xAsymmetricAlgorithm, BaseType_t xHashAlgorithm);
// CRYPTO_SignatureVerificationUpdate
// file ..\..\..\..\lib\crypto\aws_crypto.c line 203
void CRYPTO_SignatureVerificationUpdate(void *pvContext, uint8_t *pucData, size_t xDataLength);
// C_CloseSession
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 656
extern CK_RV C_CloseSession(CK_SESSION_HANDLE xSession);
// C_CreateObject
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 693
extern CK_RV C_CreateObject(CK_SESSION_HANDLE xSession, CK_ATTRIBUTE_PTR pxTemplate, CK_ULONG ulCount, CK_OBJECT_HANDLE_PTR pxObject);
// C_DestroyObject
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 901
extern CK_RV C_DestroyObject(CK_SESSION_HANDLE xSession, CK_OBJECT_HANDLE xObject);
// C_DigestFinal
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 1285
extern CK_RV C_DigestFinal(CK_SESSION_HANDLE xSession, CK_BYTE_PTR pDigest, CK_ULONG_PTR pulDigestLen);
// C_DigestInit
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 1221
extern CK_RV C_DigestInit(CK_SESSION_HANDLE xSession, CK_MECHANISM_PTR pMechanism);
// C_DigestUpdate
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 1257
extern CK_RV C_DigestUpdate(CK_SESSION_HANDLE xSession, CK_BYTE_PTR pPart, CK_ULONG ulPartLen);
// C_Finalize
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 491
extern CK_RV C_Finalize(CK_VOID_PTR pvReserved);
// C_FindObjects
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 1105
extern CK_RV C_FindObjects(CK_SESSION_HANDLE xSession, CK_OBJECT_HANDLE_PTR pxObject, CK_ULONG ulMaxObjectCount, CK_ULONG_PTR pulObjectCount);
// C_FindObjectsFinal
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 1194
extern CK_RV C_FindObjectsFinal(CK_SESSION_HANDLE xSession);
// C_FindObjectsInit
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 1070
extern CK_RV C_FindObjectsInit(CK_SESSION_HANDLE xSession, CK_ATTRIBUTE_PTR pxTemplate, CK_ULONG ulCount);
// C_GenerateKeyPair
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 1493
extern CK_RV C_GenerateKeyPair(CK_SESSION_HANDLE xSession, CK_MECHANISM_PTR pxMechanism, CK_ATTRIBUTE_PTR pxPublicKeyTemplate, CK_ULONG ulPublicKeyAttributeCount, CK_ATTRIBUTE_PTR pxPrivateKeyTemplate, CK_ULONG ulPrivateKeyAttributeCount, CK_OBJECT_HANDLE_PTR pxPublicKey, CK_OBJECT_HANDLE_PTR pxPrivateKey);
// C_GenerateRandom
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 1588
extern CK_RV C_GenerateRandom(CK_SESSION_HANDLE xSession, CK_BYTE_PTR pucRandomData, CK_ULONG ulRandomLen);
// C_GetAttributeValue
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 929
extern CK_RV C_GetAttributeValue(CK_SESSION_HANDLE xSession, CK_OBJECT_HANDLE xObject, CK_ATTRIBUTE_PTR pxTemplate, CK_ULONG ulCount);
// C_GetFunctionList
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 506
extern CK_RV C_GetFunctionList(CK_FUNCTION_LIST_PTR_PTR ppxFunctionList);
// C_GetSlotList
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 525
extern CK_RV C_GetSlotList(CK_BBOOL xTokenPresent, CK_SLOT_ID_PTR pxSlotList, CK_ULONG_PTR pulCount);
// C_Initialize
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 477
extern CK_RV C_Initialize(CK_VOID_PTR pvInitArgs);
// C_OpenSession
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 560
extern CK_RV C_OpenSession(CK_SLOT_ID xSlotID, CK_FLAGS xFlags, CK_VOID_PTR pvApplication, CK_NOTIFY xNotify, CK_SESSION_HANDLE_PTR pxSession);
// C_Sign
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 1354
extern CK_RV C_Sign(CK_SESSION_HANDLE xSession, CK_BYTE_PTR pucData, CK_ULONG ulDataLen, CK_BYTE_PTR pucSignature, CK_ULONG_PTR pulSignatureLen);
// C_SignInit
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 1333
extern CK_RV C_SignInit(CK_SESSION_HANDLE xSession, CK_MECHANISM_PTR pxMechanism, CK_OBJECT_HANDLE xKey);
// C_Verify
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 1437
extern CK_RV C_Verify(CK_SESSION_HANDLE xSession, CK_BYTE_PTR pucData, CK_ULONG ulDataLen, CK_BYTE_PTR pucSignature, CK_ULONG ulSignatureLen);
// C_VerifyInit
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 1415
extern CK_RV C_VerifyInit(CK_SESSION_HANDLE xSession, CK_MECHANISM_PTR pxMechanism, CK_OBJECT_HANDLE xKey);
// CloseHandle
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\handleapi.h line 50
BOOL CloseHandle(HANDLE);
// CreateEventA
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\synchapi.h line 590
HANDLE CreateEventA(LPSECURITY_ATTRIBUTES, BOOL, BOOL, LPCSTR);
// CreateFileA
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\fileapi.h line 122
HANDLE CreateFileA(LPCSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE);
// CreateMutexA
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\synchapi.h line 535
HANDLE CreateMutexA(LPSECURITY_ATTRIBUTES, BOOL, LPCSTR);
// CreateThread
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\processthreadsapi.h line 209
HANDLE CreateThread(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD);
// CryptAcquireContextA
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\wincrypt.h line 1086
BOOL CryptAcquireContextA(HCRYPTPROV *, LPCSTR, LPCSTR, DWORD, DWORD);
// CryptGenRandom
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\wincrypt.h line 1270
BOOL CryptGenRandom(HCRYPTPROV, DWORD, BYTE *);
// CryptReleaseContext
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\wincrypt.h line 1128
BOOL CryptReleaseContext(HCRYPTPROV, ULONG_PTR);
// DEMO_RUNNER_RunDemos
// file ..\..\..\common\demo_runner\aws_demo_runner.c line 53
void DEMO_RUNNER_RunDemos(void);
// ExitThread
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\processthreadsapi.h line 335
void ExitThread(DWORD);
// FormatMessageA
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\winbase.h line 2329
DWORD FormatMessageA(DWORD, LPCVOID, DWORD, DWORD, LPSTR, DWORD, va_list *);
// FormatMessageW
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\winbase.h line 2342
DWORD FormatMessageW(DWORD, LPCVOID, DWORD, DWORD, LPWSTR, DWORD, va_list *);
// FreeLibrary
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\libloaderapi.h line 213
BOOL FreeLibrary(HMODULE);
// FreeRTOS_ClearARP
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_ARP.c line 618
void FreeRTOS_ClearARP(void);
// FreeRTOS_GetAddressConfiguration
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 1024
void FreeRTOS_GetAddressConfiguration(uint32_t *pulIPAddress, uint32_t *pulNetMask, uint32_t *pulGatewayAddress, uint32_t *pulDNSServerAddress);
// FreeRTOS_GetDNSServerAddress
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 2215
uint32_t FreeRTOS_GetDNSServerAddress(void);
// FreeRTOS_GetGatewayAddress
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 2209
uint32_t FreeRTOS_GetGatewayAddress(void);
// FreeRTOS_GetIPAddress
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 2195
uint32_t FreeRTOS_GetIPAddress(void);
// FreeRTOS_GetLocalAddress
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 1825
size_t FreeRTOS_GetLocalAddress(Socket_t xSocket, struct freertos_sockaddr *pxAddress);
// FreeRTOS_GetMACAddress
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 2234
const uint8_t * FreeRTOS_GetMACAddress(void);
// FreeRTOS_GetNetmask
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 2221
uint32_t FreeRTOS_GetNetmask(void);
// FreeRTOS_GetRemoteAddress
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 3081
BaseType_t FreeRTOS_GetRemoteAddress(Socket_t xSocket, struct freertos_sockaddr *pxAddress);
// FreeRTOS_GetTCPStateName
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 3264
const char * FreeRTOS_GetTCPStateName(UBaseType_t ulState);
// FreeRTOS_GetUDPPayloadBuffer
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 788
void * FreeRTOS_GetUDPPayloadBuffer(size_t xRequestedSizeBytes, TickType_t xBlockTimeTicks);
// FreeRTOS_IPInit
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 935
BaseType_t FreeRTOS_IPInit(const uint8_t *FreeRTOS_IPInit$$ucIPAddress, const uint8_t *FreeRTOS_IPInit$$ucNetMask, const uint8_t *FreeRTOS_IPInit$$ucGatewayAddress, const uint8_t *FreeRTOS_IPInit$$ucDNSServerAddress, const uint8_t *FreeRTOS_IPInit$$ucMACAddress);
// FreeRTOS_IsNetworkUp
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 2304
BaseType_t FreeRTOS_IsNetworkUp(void);
// FreeRTOS_NetworkDown
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 746
void FreeRTOS_NetworkDown(void);
// FreeRTOS_NetworkDownFromISR
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 767
BaseType_t FreeRTOS_NetworkDownFromISR(void);
// FreeRTOS_OutputARPRequest
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_ARP.c line 556
void FreeRTOS_OutputARPRequest(uint32_t ulIPAddress);
// FreeRTOS_PrintARPCache
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_ARP.c line 626
void FreeRTOS_PrintARPCache(void);
// FreeRTOS_ReleaseUDPPayloadBuffer
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 925
void FreeRTOS_ReleaseUDPPayloadBuffer(void *pvBuffer);
// FreeRTOS_SetAddressConfiguration
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 1050
void FreeRTOS_SetAddressConfiguration(const uint32_t *pulIPAddress, const uint32_t *pulNetMask, const uint32_t *pulGatewayAddress, const uint32_t *pulDNSServerAddress);
// FreeRTOS_SetGatewayAddress
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 2246
void FreeRTOS_SetGatewayAddress(uint32_t ulGatewayAddress);
// FreeRTOS_SetIPAddress
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 2202
void FreeRTOS_SetIPAddress(uint32_t ulIPAddress);
// FreeRTOS_SetNetmask
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 2240
void FreeRTOS_SetNetmask(uint32_t ulNetmask);
// FreeRTOS_UpdateMACAddress
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 2227
void FreeRTOS_UpdateMACAddress(const uint8_t *FreeRTOS_UpdateMACAddress$$ucMACAddress);
// FreeRTOS_accept
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 2078
Socket_t FreeRTOS_accept(Socket_t xServerSocket, struct freertos_sockaddr *pxAddress, uint32_t *pxAddressLength);
// FreeRTOS_bind
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 904
BaseType_t FreeRTOS_bind(Socket_t xSocket, struct freertos_sockaddr *pxAddress, uint32_t xAddressLength);
// FreeRTOS_closesocket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 1087
BaseType_t FreeRTOS_closesocket(Socket_t xSocket);
// FreeRTOS_connect
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 2001
BaseType_t FreeRTOS_connect(Socket_t xClientSocket, struct freertos_sockaddr *pxAddress, uint32_t xAddressLength);
// FreeRTOS_connstatus
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 3268
BaseType_t FreeRTOS_connstatus(Socket_t xSocket);
// FreeRTOS_dnslookup
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DNS.c line 256
uint32_t FreeRTOS_dnslookup(const char *pcHostName);
// FreeRTOS_get_rx_buf
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 2867
const struct xSTREAM_BUFFER$0 * FreeRTOS_get_rx_buf(Socket_t xSocket);
// FreeRTOS_get_tx_head
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 2417
uint8_t * FreeRTOS_get_tx_head(Socket_t xSocket, BaseType_t *pxLength);
// FreeRTOS_gethostbyname
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DNS.c line 410
uint32_t FreeRTOS_gethostbyname(const char *pcHostName);
// FreeRTOS_inet_addr
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 1736
uint32_t FreeRTOS_inet_addr(const char *pcIPAddress);
// FreeRTOS_issocketconnected
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 3213
BaseType_t FreeRTOS_issocketconnected(Socket_t xSocket);
// FreeRTOS_listen
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 2631
BaseType_t FreeRTOS_listen(Socket_t xSocket, BaseType_t xBacklog);
// FreeRTOS_max_int32
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP.h line 182
static inline int32_t FreeRTOS_max_int32(int32_t a, int32_t b);
// FreeRTOS_max_uint32
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP.h line 183
static inline uint32_t FreeRTOS_max_uint32(uint32_t a, uint32_t b);
// FreeRTOS_maywrite
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 3117
BaseType_t FreeRTOS_maywrite(Socket_t xSocket);
// FreeRTOS_min_BaseType
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP.h line 191
static inline BaseType_t FreeRTOS_min_BaseType(BaseType_t a, BaseType_t b);
// FreeRTOS_min_int32
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP.h line 184
static inline int32_t FreeRTOS_min_int32(int32_t a, int32_t b);
// FreeRTOS_min_int32$link1
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP.h line 184
static inline int32_t FreeRTOS_min_int32$link1(int32_t a$link1, int32_t b$link1);
// FreeRTOS_min_int32$link2
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP.h line 184
static inline int32_t FreeRTOS_min_int32$link2(int32_t a$link2, int32_t b$link2);
// FreeRTOS_min_uint32
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP.h line 185
static inline uint32_t FreeRTOS_min_uint32(uint32_t a, uint32_t b);
// FreeRTOS_min_uint32$link1
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP.h line 185
static inline uint32_t FreeRTOS_min_uint32$link1(uint32_t a$link1, uint32_t b$link1);
// FreeRTOS_min_uint32$link2
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP.h line 185
static inline uint32_t FreeRTOS_min_uint32$link2(uint32_t a$link2, uint32_t b$link2);
// FreeRTOS_min_uint32$link3
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP.h line 185
static inline uint32_t FreeRTOS_min_uint32$link3(uint32_t a$link3, uint32_t b$link3);
// FreeRTOS_mss
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 3242
BaseType_t FreeRTOS_mss(Socket_t xSocket);
// FreeRTOS_netstat
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 3320
void FreeRTOS_netstat(void);
// FreeRTOS_recv
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 2206
BaseType_t FreeRTOS_recv(Socket_t xSocket, void *pvBuffer, size_t xBufferLength, BaseType_t xFlags);
// FreeRTOS_recvfrom
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 594
int32_t FreeRTOS_recvfrom(Socket_t xSocket, void *pvBuffer, size_t xBufferLength, BaseType_t xFlags, struct freertos_sockaddr *pxSourceAddress, uint32_t *pxSourceAddressLength);
// FreeRTOS_round_up
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP.h line 186
static inline uint32_t FreeRTOS_round_up(uint32_t a, uint32_t d);
// FreeRTOS_rx_size
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 3294
BaseType_t FreeRTOS_rx_size(Socket_t xSocket);
// FreeRTOS_send
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 2448
BaseType_t FreeRTOS_send(Socket_t xSocket, const void *pvBuffer, size_t uxDataLength, BaseType_t xFlags);
// FreeRTOS_sendto
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 759
int32_t FreeRTOS_sendto(Socket_t xSocket, const void *pvBuffer, size_t xTotalDataLength, BaseType_t xFlags, const struct freertos_sockaddr *pxDestinationAddress, uint32_t xDestinationAddressLength);
// FreeRTOS_setsockopt
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 1275
BaseType_t FreeRTOS_setsockopt(Socket_t xSocket, int32_t lLevel, int32_t lOptionName, const void *pvOptionValue, size_t xOptionLength);
// FreeRTOS_shutdown
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 2690
BaseType_t FreeRTOS_shutdown(Socket_t xSocket, BaseType_t xHow);
// FreeRTOS_socket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 267
Socket_t FreeRTOS_socket(BaseType_t xDomain, BaseType_t xType, BaseType_t xProtocol);
// FreeRTOS_tx_size
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 3183
BaseType_t FreeRTOS_tx_size(Socket_t xSocket);
// FreeRTOS_tx_space
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 3154
BaseType_t FreeRTOS_tx_space(Socket_t xSocket);
// GGD_GetGGCIPandCertificate
// file ..\..\..\..\lib\greengrass\aws_greengrass_discovery.c line 159
BaseType_t GGD_GetGGCIPandCertificate(char *pcBuffer, const uint32_t ulBufferSize, GGD_HostAddressData_t *pxHostAddressData);
// GGD_GetIPandCertificateFromJSON
// file ..\..\..\..\lib\greengrass\aws_greengrass_discovery.c line 445
BaseType_t GGD_GetIPandCertificateFromJSON(char *GGD_GetIPandCertificateFromJSON$$pcJSONFile, const uint32_t ulJSONFileSize, const HostParameters_t *pxHostParameters, GGD_HostAddressData_t *pxHostAddressData, const BaseType_t xAutoSelectFlag);
// GGD_JSONRequestAbort
// file ..\..\..\..\lib\greengrass\aws_greengrass_discovery.c line 433
void GGD_JSONRequestAbort(Socket_t *pxSocket);
// GGD_JSONRequestGetFile
// file ..\..\..\..\lib\greengrass\aws_greengrass_discovery.c line 364
BaseType_t GGD_JSONRequestGetFile(Socket_t *pxSocket, char *pcBuffer, const uint32_t ulBufferSize, uint32_t *pulByteRead, BaseType_t *pxJSONFileRetrieveCompleted, const uint32_t pulJSONFileSize);
// GGD_JSONRequestGetSize
// file ..\..\..\..\lib\greengrass\aws_greengrass_discovery.c line 268
BaseType_t GGD_JSONRequestGetSize(Socket_t *pxSocket, uint32_t *pulJSONFileSize);
// GGD_JSONRequestStart
// file ..\..\..\..\lib\greengrass\aws_greengrass_discovery.c line 227
BaseType_t GGD_JSONRequestStart(Socket_t *pxSocket);
// GGD_SecureConnect_Connect
// file ..\..\..\..\lib\greengrass\aws_helper_secure_connect.c line 58
BaseType_t GGD_SecureConnect_Connect(const GGD_HostAddressData_t *pxHostAddressData, Socket_t *pxSocket, uint32_t ulReceiveTimeOut, uint32_t ulSendTimeOut);
// GGD_SecureConnect_Disconnect
// file ..\..\..\..\lib\greengrass\aws_helper_secure_connect.c line 182
void GGD_SecureConnect_Disconnect(Socket_t *pxSocket);
// GGD_SecureConnect_Read
// file ..\..\..\..\lib\greengrass\aws_helper_secure_connect.c line 285
BaseType_t GGD_SecureConnect_Read(char *pcBuffer, const uint32_t ulBufferSize, const Socket_t xSocket, uint32_t *pulDataRecvSize);
// GGD_SecureConnect_Send
// file ..\..\..\..\lib\greengrass\aws_helper_secure_connect.c line 230
BaseType_t GGD_SecureConnect_Send(const char *pcPayload, const uint32_t ulPayloadSize, const Socket_t xSocket);
// GetCurrentProcess
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\processthreadsapi.h line 145
HANDLE GetCurrentProcess(void);
// GetCurrentThread
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\processthreadsapi.h line 249
HANDLE GetCurrentThread(void);
// GetFileSize
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\fileapi.h line 636
DWORD GetFileSize(HANDLE, LPDWORD);
// GetLastError
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\errhandlingapi.h line 118
DWORD GetLastError(void);
// GetProcAddress
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\libloaderapi.h line 360
FARPROC GetProcAddress(HMODULE, LPCSTR);
// GetProcessHeap
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\heapapi.h line 189
HANDLE GetProcessHeap(void);
// GetSystemDirectoryA
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\sysinfoapi.h line 250
UINT GetSystemDirectoryA(LPSTR, UINT);
// GetSystemInfo
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\sysinfoapi.h line 184
void GetSystemInfo(LPSYSTEM_INFO);
// GetThreadContext
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\processthreadsapi.h line 859
BOOL GetThreadContext(HANDLE, LPCONTEXT);
// GetThreadPriority
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\processthreadsapi.h line 326
signed int GetThreadPriority(HANDLE);
// Handle32ToHandle
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 304
inline void * Handle32ToHandle(const void * h);
// HandleToLong
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 167
inline signed long int HandleToLong(const void *h);
// HandleToULong
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 158
inline unsigned long int HandleToULong(const void *h);
// HeapAlloc
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\heapapi.h line 97
LPVOID HeapAlloc(HANDLE, DWORD, SIZE_T);
// HeapFree
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\heapapi.h line 122
BOOL HeapFree(HANDLE, DWORD, LPVOID);
// IntToPtr
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 250
inline void * IntToPtr(const signed int i);
// JSON_IsCStringEqual
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1147
uint8_t JSON_IsCStringEqual(const char *pcJSONString, uint32_t lLen, const char *pcCString);
// LoadLibraryA
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\winbase.h line 3179
HMODULE LoadLibraryA(LPCSTR);
// LongToHandle
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 186
inline void * LongToHandle(const signed long int h);
// LongToPtr
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 270
inline void * LongToPtr(const signed long int l);
// MQTT_AGENT_Connect
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1931
MQTTAgentReturnCode_t MQTT_AGENT_Connect(MQTTAgentHandle_t MQTT_AGENT_Connect$$xMQTTHandle, const MQTTAgentConnectParams_t * const pxConnectParams, TickType_t xTimeoutTicks);
// MQTT_AGENT_Create
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1889
MQTTAgentReturnCode_t MQTT_AGENT_Create(MQTTAgentHandle_t * const pxMQTTHandle);
// MQTT_AGENT_Delete
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1920
MQTTAgentReturnCode_t MQTT_AGENT_Delete(MQTTAgentHandle_t MQTT_AGENT_Delete$$xMQTTHandle);
// MQTT_AGENT_Disconnect
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1954
MQTTAgentReturnCode_t MQTT_AGENT_Disconnect(MQTTAgentHandle_t MQTT_AGENT_Disconnect$$xMQTTHandle, TickType_t xTimeoutTicks);
// MQTT_AGENT_Init
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1809
extern BaseType_t MQTT_AGENT_Init(void);
// MQTT_AGENT_Publish
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 2018
MQTTAgentReturnCode_t MQTT_AGENT_Publish(MQTTAgentHandle_t MQTT_AGENT_Publish$$xMQTTHandle, const MQTTAgentPublishParams_t * const pxPublishParams, TickType_t xTimeoutTicks);
// MQTT_AGENT_ReturnBuffer
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 2040
MQTTAgentReturnCode_t MQTT_AGENT_ReturnBuffer(MQTTAgentHandle_t MQTT_AGENT_ReturnBuffer$$xMQTTHandle, MQTTBufferHandle_t xBufferHandle);
// MQTT_AGENT_Subscribe
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1974
MQTTAgentReturnCode_t MQTT_AGENT_Subscribe(MQTTAgentHandle_t MQTT_AGENT_Subscribe$$xMQTTHandle, const MQTTAgentSubscribeParams_t * const pxSubscribeParams, TickType_t xTimeoutTicks);
// MQTT_AGENT_Unsubscribe
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1996
MQTTAgentReturnCode_t MQTT_AGENT_Unsubscribe(MQTTAgentHandle_t MQTT_AGENT_Unsubscribe$$xMQTTHandle, const MQTTAgentUnsubscribeParams_t * const pxUnsubscribeParams, TickType_t xTimeoutTicks);
// MQTT_Connect
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 2477
MQTTReturnCode_t MQTT_Connect(MQTTContext_t *pxMQTTContext, const MQTTConnectParams_t * const pxConnectParams);
// MQTT_Disconnect
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 2638
MQTTReturnCode_t MQTT_Disconnect(MQTTContext_t *pxMQTTContext);
// MQTT_Init
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 2422
MQTTReturnCode_t MQTT_Init(MQTTContext_t *pxMQTTContext, const MQTTInitParams_t * const pxInitParams);
// MQTT_ParseReceivedData
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 3096
MQTTReturnCode_t MQTT_ParseReceivedData(MQTTContext_t *pxMQTTContext, const uint8_t *pucReceivedData, size_t xReceivedDataLength);
// MQTT_Periodic
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 3303
uint32_t MQTT_Periodic(MQTTContext_t *pxMQTTContext, uint64_t xCurrentTickCount);
// MQTT_Publish
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 2962
MQTTReturnCode_t MQTT_Publish(MQTTContext_t *pxMQTTContext, const MQTTPublishParams_t * const pxPublishParams);
// MQTT_ReturnBuffer
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 3285
MQTTReturnCode_t MQTT_ReturnBuffer(MQTTContext_t *pxMQTTContext, MQTTBufferHandle_t xBufferHandle);
// MQTT_Subscribe
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 2681
MQTTReturnCode_t MQTT_Subscribe(MQTTContext_t *pxMQTTContext, const MQTTSubscribeParams_t * const pxSubscribeParams);
// MQTT_Unsubscribe
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 2840
MQTTReturnCode_t MQTT_Unsubscribe(MQTTContext_t *pxMQTTContext, const MQTTUnsubscribeParams_t * const pxUnsubscribeParams);
// NtCurrentTeb
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\winnt.h line 19832
inline struct _TEB * NtCurrentTeb(void);
// OTA_ActivateNewImage
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 540
OTA_Err_t OTA_ActivateNewImage(void);
// OTA_AgentInit
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 384
OTA_State_t OTA_AgentInit(void *pvClient, pxOTACompleteCallback_t func, TickType_t xTicksToWait);
// OTA_AgentShutdown
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 440
OTA_State_t OTA_AgentShutdown(TickType_t xTicksToWait);
// OTA_CBOR_Decode_GetStreamResponseMessage
// file ..\..\..\..\lib\ota\aws_ota_cbor.c line 57
BaseType_t OTA_CBOR_Decode_GetStreamResponseMessage(uint8_t *pucMessageBuffer, size_t xMessageSize, signed int *plFileId, signed int *plBlockId, signed int *plBlockSize, uint8_t **ppucPayload, size_t *pxPayloadSize);
// OTA_CBOR_Encode_GetStreamRequestMessage
// file ..\..\..\..\lib\ota\aws_ota_cbor.c line 216
BaseType_t OTA_CBOR_Encode_GetStreamRequestMessage(uint8_t *pucMessageBuffer, size_t xMessageBufferSize, size_t *pxEncodedMessageSize, char *pcClientToken, signed int lFileId, signed int lBlockSize, signed int lBlockOffset, uint8_t *pucBlockBitmap, size_t xBlockBitmapSize);
// OTA_CheckForUpdate
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 483
OTA_Err_t OTA_CheckForUpdate(void);
// OTA_GetAgentState
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 459
OTA_State_t OTA_GetAgentState(void);
// OTA_GetImageState
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 558
OTA_ImageState_t OTA_GetImageState(void);
// OTA_GetPacketsDropped
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 464
uint32_t OTA_GetPacketsDropped(void);
// OTA_GetPacketsProcessed
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 474
uint32_t OTA_GetPacketsProcessed(void);
// OTA_GetPacketsQueued
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 469
uint32_t OTA_GetPacketsQueued(void);
// OTA_SetImageState
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 566
OTA_Err_t OTA_SetImageState(OTA_ImageState_t eState);
// PKCS11_PAL_ReadFile
// file ..\..\..\..\lib\pkcs11\portable\pc\windows\aws_pkcs11_pal.c line 118
BaseType_t PKCS11_PAL_ReadFile(char *pcFileName, uint8_t **ppucData, uint32_t *pulDataSize);
// PKCS11_PAL_ReleaseFileData
// file ..\..\..\..\lib\pkcs11\portable\pc\windows\aws_pkcs11_pal.c line 191
void PKCS11_PAL_ReleaseFileData(uint8_t *pucBuffer, uint32_t ulBufferSize);
// PKCS11_PAL_SaveFile
// file ..\..\..\..\lib\pkcs11\portable\pc\windows\aws_pkcs11_pal.c line 62
BaseType_t PKCS11_PAL_SaveFile(char *pcFileName, uint8_t *pucData, uint32_t ulDataSize);
// Ptr32ToPtr
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 295
inline void * Ptr32ToPtr(const void * p);
// PtrToInt
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 232
inline signed int PtrToInt(const void *p);
// PtrToLong
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 223
inline signed long int PtrToLong(const void *p);
// PtrToPtr32
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 313
inline void * PtrToPtr32(const void *p);
// PtrToShort
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 241
inline signed short int PtrToShort(const void *p);
// PtrToUint
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 205
inline unsigned int PtrToUint(const void *p);
// PtrToUlong
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 196
inline unsigned long int PtrToUlong(const void *p);
// PtrToUshort
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 214
inline unsigned short int PtrToUshort(const void *p);
// QueryPerformanceCounter
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\profileapi.h line 42
BOOL QueryPerformanceCounter(LARGE_INTEGER *);
// QueryPerformanceFrequency
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\profileapi.h line 50
BOOL QueryPerformanceFrequency(LARGE_INTEGER *);
// ReadFile
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\fileapi.h line 932
BOOL ReadFile(HANDLE, LPVOID, DWORD, LPDWORD, LPOVERLAPPED);
// ReleaseMutex
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\synchapi.h line 458
BOOL ReleaseMutex(HANDLE);
// ResumeThread
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\processthreadsapi.h line 381
DWORD ResumeThread(HANDLE);
// SHADOW_ClientConnect
// file ..\..\..\..\lib\shadow\aws_shadow.c line 1405
ShadowReturnCode_t SHADOW_ClientConnect(ShadowClientHandle_t xShadowClientHandle, MQTTAgentConnectParams_t * const pxConnectParams, TickType_t xTimeoutTicks);
// SHADOW_ClientCreate
// file ..\..\..\..\lib\shadow\aws_shadow.c line 1351
ShadowReturnCode_t SHADOW_ClientCreate(ShadowClientHandle_t *pxShadowClientHandle, const ShadowCreateParams_t * const pxShadowCreateParams);
// SHADOW_ClientDelete
// file ..\..\..\..\lib\shadow\aws_shadow.c line 1464
ShadowReturnCode_t SHADOW_ClientDelete(ShadowClientHandle_t xShadowClientHandle);
// SHADOW_ClientDisconnect
// file ..\..\..\..\lib\shadow\aws_shadow.c line 1437
ShadowReturnCode_t SHADOW_ClientDisconnect(ShadowClientHandle_t xShadowClientHandle);
// SHADOW_Delete
// file ..\..\..\..\lib\shadow\aws_shadow.c line 1561
ShadowReturnCode_t SHADOW_Delete(ShadowClientHandle_t xShadowClientHandle, ShadowOperationParams_t * const pxDeleteParams, TickType_t xTimeoutTicks);
// SHADOW_Get
// file ..\..\..\..\lib\shadow\aws_shadow.c line 1528
ShadowReturnCode_t SHADOW_Get(ShadowClientHandle_t xShadowClientHandle, ShadowOperationParams_t * const pxGetParams, TickType_t xTimeoutTicks);
// SHADOW_JSONDocClientTokenMatch
// file ..\..\..\..\lib\shadow\aws_shadow_json.c line 72
BaseType_t SHADOW_JSONDocClientTokenMatch(const char * const pcDoc1, uint32_t ulDoc1Length, const char * const pcDoc2, uint32_t ulDoc2Length);
// SHADOW_JSONGetErrorCodeAndMessage
// file ..\..\..\..\lib\shadow\aws_shadow_json.c line 128
int16_t SHADOW_JSONGetErrorCodeAndMessage(const char * const pcErrorJSON, uint32_t ulErrorJSONLength, char **ppcErrorMessage, uint16_t *pusErrorMessageLength);
// SHADOW_RegisterCallbacks
// file ..\..\..\..\lib\shadow\aws_shadow.c line 1597
ShadowReturnCode_t SHADOW_RegisterCallbacks(ShadowClientHandle_t xShadowClientHandle, ShadowCallbackParams_t * const pxCallbackParams, TickType_t xTimeoutTicks);
// SHADOW_ReturnMQTTBuffer
// file ..\..\..\..\lib\shadow\aws_shadow.c line 1671
ShadowReturnCode_t SHADOW_ReturnMQTTBuffer(ShadowClientHandle_t xShadowClientHandle, MQTTBufferHandle_t xBufferHandle);
// SHADOW_Update
// file ..\..\..\..\lib\shadow\aws_shadow.c line 1494
ShadowReturnCode_t SHADOW_Update(ShadowClientHandle_t xShadowClientHandle, ShadowOperationParams_t * const pxUpdateParams, TickType_t xTimeoutTicks);
// SOCKETS_Close
// file ..\..\..\..\lib\secure_sockets\portable\freertos_plus_tcp\aws_secure_sockets.c line 88
int32_t SOCKETS_Close(Socket_t xSocket);
// SOCKETS_Connect
// file ..\..\..\..\lib\secure_sockets\portable\freertos_plus_tcp\aws_secure_sockets.c line 146
int32_t SOCKETS_Connect(Socket_t xSocket, SocketsSockaddr_t *pxAddress, uint32_t xAddressLength);
// SOCKETS_GetHostByName
// file ..\..\..\..\lib\secure_sockets\portable\freertos_plus_tcp\aws_secure_sockets.c line 197
uint32_t SOCKETS_GetHostByName(const char *pcHostName);
// SOCKETS_Init
// file ..\..\..\..\lib\secure_sockets\portable\freertos_plus_tcp\aws_secure_sockets.c line 518
extern BaseType_t SOCKETS_Init(void);
// SOCKETS_Recv
// file ..\..\..\..\lib\secure_sockets\portable\freertos_plus_tcp\aws_secure_sockets.c line 203
int32_t SOCKETS_Recv(Socket_t xSocket, void *pvBuffer, size_t xBufferLength, uint32_t ulFlags);
// SOCKETS_Send
// file ..\..\..\..\lib\secure_sockets\portable\freertos_plus_tcp\aws_secure_sockets.c line 236
int32_t SOCKETS_Send(Socket_t xSocket, const void *pvBuffer, size_t xDataLength, uint32_t ulFlags);
// SOCKETS_SetSockOpt
// file ..\..\..\..\lib\secure_sockets\portable\freertos_plus_tcp\aws_secure_sockets.c line 269
int32_t SOCKETS_SetSockOpt(Socket_t xSocket, int32_t lLevel, int32_t lOptionName, const void *pvOptionValue, size_t xOptionLength);
// SOCKETS_Shutdown
// file ..\..\..\..\lib\secure_sockets\portable\freertos_plus_tcp\aws_secure_sockets.c line 460
int32_t SOCKETS_Shutdown(Socket_t xSocket, uint32_t ulHow);
// SOCKETS_Socket
// file ..\..\..\..\lib\secure_sockets\portable\freertos_plus_tcp\aws_secure_sockets.c line 479
Socket_t SOCKETS_Socket(int32_t lDomain, int32_t lType, int32_t lProtocol);
// SYSTEM_Init
// file ..\..\..\..\lib\utils\aws_system_init.c line 38
BaseType_t SYSTEM_Init();
// SetConsoleCtrlHandler
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\consoleapi.h line 159
BOOL SetConsoleCtrlHandler(PHANDLER_ROUTINE, BOOL);
// SetEvent
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\synchapi.h line 432
BOOL SetEvent(HANDLE);
// SetPriorityClass
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\processthreadsapi.h line 652
BOOL SetPriorityClass(HANDLE, DWORD);
// SetThreadAffinityMask
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\winbase.h line 1572
DWORD_PTR SetThreadAffinityMask(HANDLE, DWORD_PTR);
// SetThreadPriority
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\processthreadsapi.h line 288
BOOL SetThreadPriority(HANDLE, signed int);
// SetThreadPriorityBoost
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\processthreadsapi.h line 303
BOOL SetThreadPriorityBoost(HANDLE, BOOL);
// Sleep
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\synchapi.h line 908
void Sleep(DWORD);
// SuspendThread
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\processthreadsapi.h line 373
DWORD SuspendThread(HANDLE);
// TLS_Cleanup
// file ..\..\..\..\lib\tls\aws_tls.c line 710
void TLS_Cleanup(void *pvContext);
// TLS_Connect
// file ..\..\..\..\lib\tls\aws_tls.c line 485
BaseType_t TLS_Connect(void *pvContext);
// TLS_Init
// file ..\..\..\..\lib\tls\aws_tls.c line 432
BaseType_t TLS_Init(void **ppvContext, TLSParams_t *pxParams);
// TLS_Recv
// file ..\..\..\..\lib\tls\aws_tls.c line 616
BaseType_t TLS_Recv(void *pvContext, unsigned char *pucReadBuffer, size_t xReadLength);
// TLS_Send
// file ..\..\..\..\lib\tls\aws_tls.c line 663
BaseType_t TLS_Send(void *pvContext, const unsigned char *pucMsg, size_t xMsgLength);
// TerminateProcess
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\processthreadsapi.h line 177
BOOL TerminateProcess(HANDLE, UINT);
// TerminateThread
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\processthreadsapi.h line 348
BOOL TerminateThread(HANDLE, DWORD);
// UIntToPtr
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 260
inline void * UIntToPtr(const unsigned int ui);
// ULongToHandle
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 176
inline void * ULongToHandle(const unsigned long int h);
// ULongToPtr
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 280
inline void * ULongToPtr(const unsigned long int ul);
// WSAGetLastError
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\winsock2.h line 2351
signed int WSAGetLastError(void);
// WSAIoctl
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\winsock2.h line 2995
signed int WSAIoctl(SOCKET, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
// WSASetLastError
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\winsock2.h line 2334
void WSASetLastError(signed int);
// WaitForMultipleObjects
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\winbase.h line 1892
DWORD WaitForMultipleObjects(DWORD, const HANDLE *, BOOL, DWORD);
// WaitForSingleObject
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\synchapi.h line 473
DWORD WaitForSingleObject(HANDLE, DWORD);
// WriteFile
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\fileapi.h line 1149
BOOL WriteFile(HANDLE, LPCVOID, DWORD, LPDWORD, LPOVERLAPPED);
// WspiapiClone
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\wspiapi.h line 405
inline signed int WspiapiClone(WORD wPort, struct addrinfo *ptResult);
// WspiapiFreeAddrInfo
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\wspiapi.h line 1054
inline void WspiapiFreeAddrInfo(struct addrinfo *ai);
// WspiapiGetAddrInfo
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\wspiapi.h line 1007
inline signed int WspiapiGetAddrInfo(const char *nodename, const char *servname, const struct addrinfo *hints, struct addrinfo **res);
// WspiapiGetNameInfo
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\wspiapi.h line 1029
inline signed int WspiapiGetNameInfo(const struct sockaddr *sa, socklen_t salen, char *host, size_t hostlen, char *serv, size_t servlen, signed int flags);
// WspiapiLegacyFreeAddrInfo
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\wspiapi.h line 455
inline void WspiapiLegacyFreeAddrInfo(struct addrinfo *ptHead);
// WspiapiLegacyGetAddrInfo
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\wspiapi.h line 488
inline signed int WspiapiLegacyGetAddrInfo(const char *pszNodeName, const char *pszServiceName, const struct addrinfo *ptHints, struct addrinfo **pptResult);
// WspiapiLegacyGetNameInfo
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\wspiapi.h line 707
inline signed int WspiapiLegacyGetNameInfo(const struct sockaddr *ptSocketAddress, socklen_t tSocketLength, char *pszNodeName, size_t tNodeLength, char *pszServiceName, size_t tServiceLength, signed int iFlags);
// WspiapiLoad
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\wspiapi.h line 881
inline FARPROC WspiapiLoad(WORD wFunction);
// WspiapiLookupNode
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\wspiapi.h line 321
inline signed int WspiapiLookupNode(const char *pszNodeName, signed int iSocketType, signed int iProtocol, WORD wPort, BOOL bAI_CANONNAME, struct addrinfo **pptResult);
// WspiapiNewAddrInfo
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\wspiapi.h line 185
inline struct addrinfo * WspiapiNewAddrInfo(signed int iSocketType, signed int iProtocol, WORD wPort, DWORD dwAddress);
// WspiapiParseV4Address
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\wspiapi.h line 140
inline BOOL WspiapiParseV4Address(const char *pszAddress, PDWORD pdwAddress);
// WspiapiQueryDNS
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\wspiapi.h line 242
inline signed int WspiapiQueryDNS(const char *pszNodeName, signed int iSocketType, signed int iProtocol, WORD wPort, char *pszAlias, struct addrinfo **pptResult);
// WspiapiStrdup
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\wspiapi.h line 103
inline char * WspiapiStrdup(const char *pszString);
// _BitScanReverse
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\winnt.h line 5073
BOOLEAN _BitScanReverse(DWORD *, DWORD);
// _MallocaComputeSize
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\malloc.h line 100
inline size_t _MallocaComputeSize(size_t _Size);
// _MarkAllocaS
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\malloc.h line 90
inline void * _MarkAllocaS(void *_Ptr, unsigned int _Marker);
// __acrt_get_locale_data_prefix
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\ctype.h line 144
inline __crt_locale_data_public * __acrt_get_locale_data_prefix(const volatile void * const _LocalePointers);
// __acrt_iob_func
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 31
FILE * __acrt_iob_func(unsigned int);
// __conio_common_vcprintf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 46
signed int __conio_common_vcprintf(unsigned long long int, const char *, _locale_t, va_list);
// __conio_common_vcprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 62
signed int __conio_common_vcprintf_p(unsigned long long int, const char *, _locale_t, va_list);
// __conio_common_vcprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 54
signed int __conio_common_vcprintf_s(unsigned long long int, const char *, _locale_t, va_list);
// __conio_common_vcscanf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 268
signed int __conio_common_vcscanf(unsigned long long int, const char *, _locale_t, va_list);
// __conio_common_vcwprintf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 62
signed int __conio_common_vcwprintf(unsigned long long int, const wchar_t *, _locale_t, va_list);
// __conio_common_vcwprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 78
signed int __conio_common_vcwprintf_p(unsigned long long int, const wchar_t *, _locale_t, va_list);
// __conio_common_vcwprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 70
signed int __conio_common_vcwprintf_s(unsigned long long int, const wchar_t *, _locale_t, va_list);
// __conio_common_vcwscanf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 279
signed int __conio_common_vcwscanf(unsigned long long int, const wchar_t *, _locale_t, va_list);
// __local_stdio_printf_options
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_stdio_config.h line 72
inline unsigned long long int * __local_stdio_printf_options(void);
// __local_stdio_scanf_options
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_stdio_config.h line 81
inline unsigned long long int * __local_stdio_scanf_options(void);
// __readfsdword
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\winnt.h line 5700
DWORD __readfsdword(DWORD);
// __stdio_common_vfprintf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 603
signed int __stdio_common_vfprintf(unsigned long long int, FILE *, const char *, _locale_t, va_list);
// __stdio_common_vfprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 620
signed int __stdio_common_vfprintf_p(unsigned long long int, FILE *, const char *, _locale_t, va_list);
// __stdio_common_vfprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 611
signed int __stdio_common_vfprintf_s(unsigned long long int, FILE *, const char *, _locale_t, va_list);
// __stdio_common_vfscanf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1040
signed int __stdio_common_vfscanf(unsigned long long int, FILE *, const char *, _locale_t, va_list);
// __stdio_common_vfwprintf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 267
signed int __stdio_common_vfwprintf(unsigned long long int, FILE *, const wchar_t *, _locale_t, va_list);
// __stdio_common_vfwprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 285
signed int __stdio_common_vfwprintf_p(unsigned long long int, FILE *, const wchar_t *, _locale_t, va_list);
// __stdio_common_vfwprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 276
signed int __stdio_common_vfwprintf_s(unsigned long long int, FILE *, const wchar_t *, _locale_t, va_list);
// __stdio_common_vfwscanf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 700
signed int __stdio_common_vfwscanf(unsigned long long int, FILE *, const wchar_t *, _locale_t, va_list);
// __stdio_common_vsnprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1353
signed int __stdio_common_vsnprintf_s(unsigned long long int, char *, size_t, size_t, const char *, _locale_t, va_list);
// __stdio_common_vsnwprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1023
signed int __stdio_common_vsnwprintf_s(unsigned long long int, wchar_t *, size_t, size_t, const wchar_t *, _locale_t, va_list);
// __stdio_common_vsprintf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1333
signed int __stdio_common_vsprintf(unsigned long long int, char *, size_t, const char *, _locale_t, va_list);
// __stdio_common_vsprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1364
signed int __stdio_common_vsprintf_p(unsigned long long int, char *, size_t, const char *, _locale_t, va_list);
// __stdio_common_vsprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1343
signed int __stdio_common_vsprintf_s(unsigned long long int, char *, size_t, const char *, _locale_t, va_list);
// __stdio_common_vsscanf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 2147
signed int __stdio_common_vsscanf(unsigned long long int, const char *, size_t, const char *, _locale_t, va_list);
// __stdio_common_vswprintf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1001
signed int __stdio_common_vswprintf(unsigned long long int, wchar_t *, size_t, const wchar_t *, _locale_t, va_list);
// __stdio_common_vswprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1035
signed int __stdio_common_vswprintf_p(unsigned long long int, wchar_t *, size_t, const wchar_t *, _locale_t, va_list);
// __stdio_common_vswprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1012
signed int __stdio_common_vswprintf_s(unsigned long long int, wchar_t *, size_t, const wchar_t *, _locale_t, va_list);
// __stdio_common_vswscanf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1890
signed int __stdio_common_vswscanf(unsigned long long int, const wchar_t *, size_t, const wchar_t *, _locale_t, va_list);
// __swprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1403
inline signed int __swprintf_l(wchar_t * const _Buffer, const wchar_t * const _Format, const _locale_t _Locale, ...);
// __vswprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1205
inline signed int __vswprintf_l(wchar_t * const _Buffer, const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList);
// _access
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_io.h line 106
signed int _access(const char *, signed int);
// _byteswap_uint64
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdlib.h line 291
unsigned long long int _byteswap_uint64(unsigned long long int);
// _byteswap_ulong
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdlib.h line 290
unsigned long int _byteswap_ulong(unsigned long int);
// _byteswap_ushort
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdlib.h line 289
unsigned short int _byteswap_ushort(unsigned short int);
// _cbor_value_copy_string
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 1064
CborError _cbor_value_copy_string(const CborValue *value, void *buffer, size_t *buflen, CborValue *next);
// _cbor_value_decode_int64_internal
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 300
uint64_t _cbor_value_decode_int64_internal(const CborValue *value);
// _cbor_value_dup_string
// file ..\..\..\..\lib\third_party\tinycbor\cborparser_dup_string.c line 92
CborError _cbor_value_dup_string(const CborValue *value, void **buffer, size_t *buflen, CborValue *next);
// _cbor_value_extract_int64_helper
// file ..\..\..\..\lib\third_party\tinycbor\cbor.h line 260
static inline uint64_t _cbor_value_extract_int64_helper(const CborValue *value);
// _cbor_value_extract_int64_helper$link1
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 260
static inline uint64_t _cbor_value_extract_int64_helper$link1(const CborValue *value$link1);
// _cbor_value_extract_int64_helper$link2
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 260
static inline uint64_t _cbor_value_extract_int64_helper$link2(const CborValue *value$link2);
// _chgsign
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\float.h line 308
double _chgsign(double);
// _chgsignl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 794
inline double _chgsignl(double _X);
// _chvalidator_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\ctype.h line 151
signed int _chvalidator_l(_locale_t, signed int, signed int);
// _chvalidchk_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\ctype.h line 154
inline signed int _chvalidchk_l(const signed int _C, const signed int _Mask, const _locale_t _Locale);
// _copysign
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\float.h line 307
double _copysign(double, double);
// _copysignl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 801
inline double _copysignl(double _Number, double _Sign);
// _cprintf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 175
inline signed int _cprintf(const char * const _Format, ...);
// _cprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 157
inline signed int _cprintf_l(const char * const _Format, const _locale_t _Locale, ...);
// _cprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 245
inline signed int _cprintf_p(const char * const _Format, ...);
// _cprintf_p_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 227
inline signed int _cprintf_p_l(const char * const _Format, const _locale_t _Locale, ...);
// _cprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 210
inline signed int _cprintf_s(const char * const _Format, ...);
// _cprintf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 192
inline signed int _cprintf_s_l(const char * const _Format, const _locale_t _Locale, ...);
// _cscanf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 360
inline signed int _cscanf(const char * const _Format, ...);
// _cscanf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 337
inline signed int _cscanf_l(const char * const _Format, const _locale_t _Locale, ...);
// _cscanf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 400
inline signed int _cscanf_s(const char * const _Format, ...);
// _cscanf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 382
inline signed int _cscanf_s_l(const char * const _Format, const _locale_t _Locale, ...);
// _cwprintf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 185
inline signed int _cwprintf(const wchar_t * const _Format, ...);
// _cwprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 167
inline signed int _cwprintf_l(const wchar_t * const _Format, const _locale_t _Locale, ...);
// _cwprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 255
inline signed int _cwprintf_p(const wchar_t * const _Format, ...);
// _cwprintf_p_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 237
inline signed int _cwprintf_p_l(const wchar_t * const _Format, const _locale_t _Locale, ...);
// _cwprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 220
inline signed int _cwprintf_s(const wchar_t * const _Format, ...);
// _cwprintf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 202
inline signed int _cwprintf_s_l(const wchar_t * const _Format, const _locale_t _Locale, ...);
// _cwscanf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 371
inline signed int _cwscanf(const wchar_t * const _Format, ...);
// _cwscanf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 348
inline signed int _cwscanf_l(const wchar_t * const _Format, const _locale_t _Locale, ...);
// _cwscanf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 411
inline signed int _cwscanf_s(const wchar_t * const _Format, ...);
// _cwscanf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 393
inline signed int _cwscanf_s_l(const wchar_t * const _Format, const _locale_t _Locale, ...);
// _dclass
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 161
signed short int _dclass(double);
// _fdclass
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 163
signed short int _fdclass(float);
// _fprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 805
inline signed int _fprintf_l(FILE * const _Stream, const char * const _Format, const _locale_t _Locale, ...);
// _fprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 908
inline signed int _fprintf_p(FILE * const _Stream, const char * const _Format, ...);
// _fprintf_p_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 889
inline signed int _fprintf_p_l(FILE * const _Stream, const char * const _Format, const _locale_t _Locale, ...);
// _fprintf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 848
inline signed int _fprintf_s_l(FILE * const _Stream, const char * const _Format, const _locale_t _Locale, ...);
// _freea
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\malloc.h line 146
inline void _freea(void *_Memory);
// _fscanf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1174
inline signed int _fscanf_l(FILE * const _Stream, const char * const _Format, const _locale_t _Locale, ...);
// _fscanf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1211
inline signed int _fscanf_s_l(FILE * const _Stream, const char * const _Format, const _locale_t _Locale, ...);
// _fwprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 470
inline signed int _fwprintf_l(FILE * const _Stream, const wchar_t * const _Format, const _locale_t _Locale, ...);
// _fwprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 567
inline signed int _fwprintf_p(FILE * const _Stream, const wchar_t * const _Format, ...);
// _fwprintf_p_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 548
inline signed int _fwprintf_p_l(FILE * const _Stream, const wchar_t * const _Format, const _locale_t _Locale, ...);
// _fwprintf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 507
inline signed int _fwprintf_s_l(FILE * const _Stream, const wchar_t * const _Format, const _locale_t _Locale, ...);
// _fwscanf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 832
inline signed int _fwscanf_l(FILE * const _Stream, const wchar_t * const _Format, const _locale_t _Locale, ...);
// _fwscanf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 869
inline signed int _fwscanf_s_l(FILE * const _Stream, const wchar_t * const _Format, const _locale_t _Locale, ...);
// _hypot
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 499
double _hypot(double, double);
// _hypotf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 548
float _hypotf(float, float);
// _hypotl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 855
inline double _hypotl(double _X, double _Y);
// _ischartype_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\ctype.h line 175
inline signed int _ischartype_l(const signed int _C, const signed int _Mask, const _locale_t _Locale);
// _isctype_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\ctype.h line 25
signed int _isctype_l(signed int, signed int, _locale_t);
// _kbhit
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 417
signed int _kbhit(void);
// _ldclass
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 162
signed short int _ldclass(double);
// _printf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 926
inline signed int _printf_l(const char * const _Format, const _locale_t _Locale, ...);
// _printf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1018
inline signed int _printf_p(const char * const _Format, ...);
// _printf_p_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1000
inline signed int _printf_p_l(const char * const _Format, const _locale_t _Locale, ...);
// _printf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 961
inline signed int _printf_s_l(const char * const _Format, const _locale_t _Locale, ...);
// _scanf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1252
inline signed int _scanf_l(const char * const _Format, const _locale_t _Locale, ...);
// _scanf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1287
inline signed int _scanf_s_l(const char * const _Format, const _locale_t _Locale, ...);
// _scprintf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 2091
inline signed int _scprintf(const char * const _Format, ...);
// _scprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 2073
inline signed int _scprintf_l(const char * const _Format, const _locale_t _Locale, ...);
// _scprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 2126
inline signed int _scprintf_p(const char * const _Format, ...);
// _scprintf_p_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 2108
inline signed int _scprintf_p_l(const char * const _Format, const _locale_t _Locale, ...);
// _scwprintf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1759
inline signed int _scwprintf(const wchar_t * const _Format, ...);
// _scwprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1740
inline signed int _scwprintf_l(const wchar_t * const _Format, const _locale_t _Locale, ...);
// _scwprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1796
inline signed int _scwprintf_p(const wchar_t * const _Format, ...);
// _scwprintf_p_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1777
inline signed int _scwprintf_p_l(const wchar_t * const _Format, const _locale_t _Locale, ...);
// _snprintf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1952
inline signed int _snprintf(char * const _Buffer, const size_t _BufferCount, const char * const _Format, ...);
// _snprintf_c
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 2003
inline signed int _snprintf_c(char * const _Buffer, const size_t _BufferCount, const char * const _Format, ...);
// _snprintf_c_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1982
inline signed int _snprintf_c_l(char * const _Buffer, const size_t _BufferCount, const char * const _Format, const _locale_t _Locale, ...);
// _snprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1895
inline signed int _snprintf_l(char * const _Buffer, const size_t _BufferCount, const char * const _Format, const _locale_t _Locale, ...);
// _snprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 2045
inline signed int _snprintf_s(char * const _Buffer, const size_t _BufferCount, const size_t _MaxCount, const char * const _Format, ...);
// _snprintf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 2023
inline signed int _snprintf_s_l(char * const _Buffer, const size_t _BufferCount, const size_t _MaxCount, const char * const _Format, const _locale_t _Locale, ...);
// _snscanf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 2345
inline signed int _snscanf(const char * const _Buffer, const size_t _BufferCount, const char * const _Format, ...);
// _snscanf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 2321
inline signed int _snscanf_l(const char * const _Buffer, const size_t _BufferCount, const char * const _Format, const _locale_t _Locale, ...);
// _snscanf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 2393
inline signed int _snscanf_s(const char * const _Buffer, const size_t _BufferCount, const char * const _Format, ...);
// _snscanf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 2369
inline signed int _snscanf_s_l(const char * const _Buffer, const size_t _BufferCount, const char * const _Format, const _locale_t _Locale, ...);
// _snwprintf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1665
inline signed int _snwprintf(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, ...);
// _snwprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1639
inline signed int _snwprintf_l(wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, const _locale_t _Locale, ...);
// _snwprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1712
inline signed int _snwprintf_s(wchar_t * const _Buffer, const size_t _BufferCount, const size_t _MaxCount, const wchar_t * const _Format, ...);
// _snwprintf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1690
inline signed int _snwprintf_s_l(wchar_t * const _Buffer, const size_t _BufferCount, const size_t _MaxCount, const wchar_t * const _Format, const _locale_t _Locale, ...);
// _snwscanf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 2125
inline signed int _snwscanf(const wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, ...);
// _snwscanf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 2099
inline signed int _snwscanf_l(const wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, const _locale_t _Locale, ...);
// _snwscanf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 2171
inline signed int _snwscanf_s(const wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, ...);
// _snwscanf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 2150
inline signed int _snwscanf_s_l(const wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, const _locale_t _Locale, ...);
// _sprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1744
inline signed int _sprintf_l(char * const _Buffer, const char * const _Format, const _locale_t _Locale, ...);
// _sprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1875
inline signed int _sprintf_p(char * const _Buffer, const size_t _BufferCount, const char * const _Format, ...);
// _sprintf_p_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1854
inline signed int _sprintf_p_l(char * const _Buffer, const size_t _BufferCount, const char * const _Format, const _locale_t _Locale, ...);
// _sprintf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1803
inline signed int _sprintf_s_l(char * const _Buffer, const size_t _BufferCount, const char * const _Format, const _locale_t _Locale, ...);
// _sscanf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 2235
inline signed int _sscanf_l(const char * const _Buffer, const char * const _Format, const _locale_t _Locale, ...);
// _sscanf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 2272
inline signed int _sscanf_s_l(const char * const _Buffer, const char * const _Format, const _locale_t _Locale, ...);
// _swprintf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1444
inline signed int _swprintf(wchar_t * const _Buffer, const wchar_t * const _Format, ...);
// _swprintf_c
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1619
inline signed int _swprintf_c(wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, ...);
// _swprintf_c_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1598
inline signed int _swprintf_c_l(wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, const _locale_t _Locale, ...);
// _swprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1423
inline signed int _swprintf_l(wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, const _locale_t _Locale, ...);
// _swprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1578
inline signed int _swprintf_p(wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, ...);
// _swprintf_p_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1557
inline signed int _swprintf_p_l(wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, const _locale_t _Locale, ...);
// _swprintf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1506
inline signed int _swprintf_s_l(wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, const _locale_t _Locale, ...);
// _swscanf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 2017
inline signed int _swscanf_l(const wchar_t * const _Buffer, const wchar_t * const _Format, _locale_t _Locale, ...);
// _swscanf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 2056
inline signed int _swscanf_s_l(const wchar_t * const _Buffer, const wchar_t * const _Format, const _locale_t _Locale, ...);
// _vcprintf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 86
inline signed int _vcprintf(const char * const _Format, va_list _ArgList);
// _vcprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 70
inline signed int _vcprintf_l(const char * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vcprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 144
inline signed int _vcprintf_p(const char * const _Format, va_list _ArgList);
// _vcprintf_p_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 128
inline signed int _vcprintf_p_l(const char * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vcprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 115
inline signed int _vcprintf_s(const char * const _Format, va_list _ArgList);
// _vcprintf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 99
inline signed int _vcprintf_s_l(const char * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vcscanf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 292
inline signed int _vcscanf(const char * const _Format, va_list _ArgList);
// _vcscanf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 276
inline signed int _vcscanf_l(const char * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vcscanf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 324
inline signed int _vcscanf_s(const char * const _Format, va_list _ArgList);
// _vcscanf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 308
inline signed int _vcscanf_s_l(const char * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vcwprintf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 100
inline signed int _vcwprintf(const wchar_t * const _Format, va_list _ArgList);
// _vcwprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 86
inline signed int _vcwprintf_l(const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vcwprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 154
inline signed int _vcwprintf_p(const wchar_t * const _Format, va_list _ArgList);
// _vcwprintf_p_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 140
inline signed int _vcwprintf_p_l(const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vcwprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 127
inline signed int _vcwprintf_s(const wchar_t * const _Format, va_list _ArgList);
// _vcwprintf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 113
inline signed int _vcwprintf_s_l(const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vcwscanf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 303
inline signed int _vcwscanf(const wchar_t * const _Format, va_list _ArgList);
// _vcwscanf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 287
inline signed int _vcwscanf_l(const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vcwscanf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 335
inline signed int _vcwscanf_s(const wchar_t * const _Format, va_list _ArgList);
// _vcwscanf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 319
inline signed int _vcwscanf_s_l(const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vfprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 629
inline signed int _vfprintf_l(FILE * const _Stream, const char * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vfprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 706
inline signed int _vfprintf_p(FILE * const _Stream, const char * const _Format, va_list _ArgList);
// _vfprintf_p_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 691
inline signed int _vfprintf_p_l(FILE * const _Stream, const char * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vfprintf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 658
inline signed int _vfprintf_s_l(FILE * const _Stream, const char * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vfscanf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1049
inline signed int _vfscanf_l(FILE * const _Stream, const char * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vfscanf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1080
inline signed int _vfscanf_s_l(FILE * const _Stream, const char * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vfwprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 294
inline signed int _vfwprintf_l(FILE * const _Stream, const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vfwprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 371
inline signed int _vfwprintf_p(FILE * const _Stream, const wchar_t * const _Format, va_list _ArgList);
// _vfwprintf_p_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 356
inline signed int _vfwprintf_p_l(FILE * const _Stream, const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vfwprintf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 323
inline signed int _vfwprintf_s_l(FILE * const _Stream, const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vfwscanf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 709
inline signed int _vfwscanf_l(FILE * const _Stream, const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vfwscanf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 740
inline signed int _vfwscanf_s_l(FILE * const _Stream, const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 720
inline signed int _vprintf_l(const char * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 792
inline signed int _vprintf_p(const char * const _Format, va_list _ArgList);
// _vprintf_p_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 778
inline signed int _vprintf_p_l(const char * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vprintf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 747
inline signed int _vprintf_s_l(const char * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vscanf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1116
inline signed int _vscanf_l(const char * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vscanf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1143
inline signed int _vscanf_s_l(const char * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vscprintf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1664
inline signed int _vscprintf(const char * const _Format, va_list _ArgList);
// _vscprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1646
inline signed int _vscprintf_l(const char * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vscprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1695
inline signed int _vscprintf_p(const char * const _Format, va_list _ArgList);
// _vscprintf_p_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1677
inline signed int _vscprintf_p_l(const char * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vscwprintf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1356
inline signed int _vscwprintf(const wchar_t * const _Format, va_list _ArgList);
// _vscwprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1337
inline signed int _vscwprintf_l(const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vscwprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1389
inline signed int _vscwprintf_p(const wchar_t * const _Format, va_list _ArgList);
// _vscwprintf_p_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1370
inline signed int _vscwprintf_p_l(const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vsnprintf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1396
inline signed int _vsnprintf(char * const _Buffer, const size_t _BufferCount, const char * const _Format, va_list _ArgList);
// _vsnprintf_c
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1729
inline signed int _vsnprintf_c(char * const _Buffer, const size_t _BufferCount, const char * const _Format, va_list _ArgList);
// _vsnprintf_c_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1708
inline signed int _vsnprintf_c_l(char * const _Buffer, const size_t _BufferCount, const char * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vsnprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1375
inline signed int _vsnprintf_l(char * const _Buffer, const size_t _BufferCount, const char * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vsnprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1591
inline signed int _vsnprintf_s(char * const _Buffer, const size_t _BufferCount, const size_t _MaxCount, const char * const _Format, va_list _ArgList);
// _vsnprintf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1569
inline signed int _vsnprintf_s_l(char * const _Buffer, const size_t _BufferCount, const size_t _MaxCount, const char * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vsnwprintf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1120
inline signed int _vsnwprintf(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, va_list _ArgList);
// _vsnwprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1046
inline signed int _vsnwprintf_l(wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vsnwprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1092
inline signed int _vsnwprintf_s(wchar_t * const _Buffer, const size_t _BufferCount, const size_t _MaxCount, const wchar_t * const _Format, va_list _ArgList);
// _vsnwprintf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1070
inline signed int _vsnwprintf_s_l(wchar_t * const _Buffer, const size_t _BufferCount, const size_t _MaxCount, const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vsnwscanf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1979
inline signed int _vsnwscanf_l(const wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vsnwscanf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1998
inline signed int _vsnwscanf_s_l(const wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vsprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1446
inline signed int _vsprintf_l(char * const _Buffer, const char * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vsprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1553
inline signed int _vsprintf_p(char * const _Buffer, const size_t _BufferCount, const char * const _Format, va_list _ArgList);
// _vsprintf_p_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1532
inline signed int _vsprintf_p_l(char * const _Buffer, const size_t _BufferCount, const char * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vsprintf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1483
inline signed int _vsprintf_s_l(char * const _Buffer, const size_t _BufferCount, const char * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vsscanf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 2157
inline signed int _vsscanf_l(const char * const _Buffer, const char * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vsscanf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 2188
inline signed int _vsscanf_s_l(const char * const _Buffer, const char * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vswprintf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1221
inline signed int _vswprintf(wchar_t * const _Buffer, const wchar_t * const _Format, va_list _ArgList);
// _vswprintf_c
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1169
inline signed int _vswprintf_c(wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, va_list _ArgList);
// _vswprintf_c_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1148
inline signed int _vswprintf_c_l(wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vswprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1185
inline signed int _vswprintf_l(wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vswprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1321
inline signed int _vswprintf_p(wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, va_list _ArgList);
// _vswprintf_p_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1300
inline signed int _vswprintf_p_l(wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vswprintf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1252
inline signed int _vswprintf_s_l(wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vswscanf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1901
inline signed int _vswscanf_l(const wchar_t * const _Buffer, const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vswscanf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1934
inline signed int _vswscanf_s_l(const wchar_t * const _Buffer, const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vwprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 385
inline signed int _vwprintf_l(const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vwprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 457
inline signed int _vwprintf_p(const wchar_t * const _Format, va_list _ArgList);
// _vwprintf_p_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 443
inline signed int _vwprintf_p_l(const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vwprintf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 412
inline signed int _vwprintf_s_l(const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vwscanf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 774
inline signed int _vwscanf_l(const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList);
// _vwscanf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 801
inline signed int _vwscanf_s_l(const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList);
// _wprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 585
inline signed int _wprintf_l(const wchar_t * const _Format, const _locale_t _Locale, ...);
// _wprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 677
inline signed int _wprintf_p(const wchar_t * const _Format, ...);
// _wprintf_p_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 659
inline signed int _wprintf_p_l(const wchar_t * const _Format, const _locale_t _Locale, ...);
// _wprintf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 620
inline signed int _wprintf_s_l(const wchar_t * const _Format, const _locale_t _Locale, ...);
// _wscanf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 910
inline signed int _wscanf_l(const wchar_t * const _Format, const _locale_t _Locale, ...);
// _wscanf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 945
inline signed int _wscanf_s_l(const wchar_t * const _Format, const _locale_t _Locale, ...);
// acosl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 763
// add32
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp_curves.c line 965
static inline void add32(uint32_t *dst, uint32_t src, signed char *carry);
// add_check_overflow
// file d:\tuttle\freertos\lib\third_party\tinycbor\compilersupport_p.h line 190
static inline _Bool add_check_overflow(size_t v1, size_t v2, size_t *r);
// add_one_and_zeros_padding
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 509
static void add_one_and_zeros_padding(unsigned char *output, size_t output_len, size_t data_len);
// add_pkcs_padding
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 469
static void add_pkcs_padding(unsigned char *output, size_t output_len, size_t data_len);
// add_zeros_and_len_padding
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 548
static void add_zeros_and_len_padding(unsigned char *output, size_t output_len, size_t data_len);
// add_zeros_padding
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 588
static void add_zeros_padding(unsigned char *output, size_t output_len, size_t data_len);
// advance_internal
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 275
static CborError advance_internal(CborValue *it);
// advance_ptr
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 247
static inline void advance_ptr(CborEncoder *encoder, size_t n);
// advance_recursive
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 403
static CborError advance_recursive(CborValue *it, signed int nestingLevel);
// aes_crypt_cbc_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 123
static signed int aes_crypt_cbc_wrap(void *ctx, mbedtls_operation_t operation, size_t length, unsigned char *aes_crypt_cbc_wrap$$iv, const unsigned char *input, unsigned char *output);
// aes_crypt_cfb128_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 132
static signed int aes_crypt_cfb128_wrap(void *ctx, mbedtls_operation_t operation, size_t length, size_t *iv_off, unsigned char *aes_crypt_cfb128_wrap$$iv, const unsigned char *input, unsigned char *output);
// aes_crypt_ctr_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 142
static signed int aes_crypt_ctr_wrap(void *ctx, size_t length, size_t *nc_off, unsigned char *nonce_counter, unsigned char *stream_block, const unsigned char *input, unsigned char *output);
// aes_crypt_ecb_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 116
static signed int aes_crypt_ecb_wrap(void *ctx, mbedtls_operation_t operation, const unsigned char *input, unsigned char *output);
// aes_ctx_alloc
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 163
static void * aes_ctx_alloc(void);
// aes_ctx_free
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 175
static void aes_ctx_free(void *ctx);
// aes_setkey_dec_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 151
static signed int aes_setkey_dec_wrap(void *ctx, const unsigned char *aes_setkey_dec_wrap$$key, unsigned int key_bitlen);
// aes_setkey_enc_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 157
static signed int aes_setkey_enc_wrap(void *ctx, const unsigned char *aes_setkey_enc_wrap$$key, unsigned int key_bitlen);
// append_byte_to_buffer
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 273
static inline CborError append_byte_to_buffer(CborEncoder *encoder, uint8_t byte);
// append_to_buffer
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 255
static inline CborError append_to_buffer(CborEncoder *encoder, const void *data, size_t len);
// asinl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 770
// atan2l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 775
// atanl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 782
// bMayConnect
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 1919
static BaseType_t bMayConnect(FreeRTOS_Socket_t *pxSocket);
// block_cipher_df
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 146
static signed int block_cipher_df(unsigned char *output, const unsigned char *data, size_t data_len);
// cbor_encode_byte_string
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 432
CborError cbor_encode_byte_string(CborEncoder *encoder, const uint8_t *string, size_t length);
// cbor_encode_floating_point
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 378
CborError cbor_encode_floating_point(CborEncoder *encoder, CborType fpType, const void *value);
// cbor_encode_int
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 341
CborError cbor_encode_int(CborEncoder *encoder, int64_t value);
// cbor_encode_negative_int
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 330
CborError cbor_encode_negative_int(CborEncoder *encoder, uint64_t absolute_value);
// cbor_encode_simple_value
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 357
CborError cbor_encode_simple_value(CborEncoder *encoder, uint8_t value);
// cbor_encode_tag
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 400
CborError cbor_encode_tag(CborEncoder *encoder, CborTag cbor_encode_tag$$tag);
// cbor_encode_text_string
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 443
CborError cbor_encode_text_string(CborEncoder *encoder, const char *string, size_t length);
// cbor_encode_text_stringz
// file ..\..\..\..\lib\third_party\tinycbor\cbor.h line 184
static inline CborError cbor_encode_text_stringz(CborEncoder *encoder, const char *string);
// cbor_encode_uint
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 319
CborError cbor_encode_uint(CborEncoder *encoder, uint64_t value);
// cbor_encoder_close_container
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 528
CborError cbor_encoder_close_container(CborEncoder *encoder, const CborEncoder *containerEncoder);
// cbor_encoder_close_container_checked
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder_close_container_checked.c line 60
CborError cbor_encoder_close_container_checked(CborEncoder *encoder, const CborEncoder *containerEncoder);
// cbor_encoder_create_array
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 486
CborError cbor_encoder_create_array(CborEncoder *encoder, CborEncoder *arrayEncoder, size_t length);
// cbor_encoder_create_map
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 509
CborError cbor_encoder_create_map(CborEncoder *encoder, CborEncoder *mapEncoder, size_t length);
// cbor_encoder_get_buffer_size
// file ..\..\..\..\lib\third_party\tinycbor\cbor.h line 208
static inline size_t cbor_encoder_get_buffer_size(const CborEncoder *encoder, const uint8_t *buffer);
// cbor_encoder_init
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 202
void cbor_encoder_init(CborEncoder *encoder, uint8_t *buffer, size_t size, signed int flags);
// cbor_error_string
// file ..\..\..\..\lib\third_party\tinycbor\cborerrorstrings.c line 80
const char * cbor_error_string(CborError error);
// cbor_parser_init
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 325
CborError cbor_parser_init(const uint8_t *buffer, size_t size, signed int flags, CborParser *parser, CborValue *it);
// cbor_value_advance
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 442
CborError cbor_value_advance(CborValue *it);
// cbor_value_advance_fixed
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 394
CborError cbor_value_advance_fixed(CborValue *it);
// cbor_value_at_end
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 248
static inline _Bool cbor_value_at_end(const CborValue *it);
// cbor_value_at_end$link1
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 248
static inline _Bool cbor_value_at_end$link1(const CborValue *it$link1);
// cbor_value_calculate_string_length
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 893
CborError cbor_value_calculate_string_length(const CborValue *value, size_t *len);
// cbor_value_copy_byte_string
// file ..\..\..\..\lib\third_party\tinycbor\cbor.h line 385
static inline CborError cbor_value_copy_byte_string(const CborValue *value, uint8_t *buffer, size_t *buflen, CborValue *next);
// cbor_value_dup_byte_string
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 398
static inline CborError cbor_value_dup_byte_string(const CborValue *value, uint8_t **buffer, size_t *buflen, CborValue *next);
// cbor_value_dup_text_string
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 392
static inline CborError cbor_value_dup_text_string(const CborValue *value, char **buffer, size_t *buflen, CborValue *next);
// cbor_value_enter_container
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 505
CborError cbor_value_enter_container(const CborValue *it, CborValue *recursed);
// cbor_value_get_boolean
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 280
static inline CborError cbor_value_get_boolean(const CborValue *value, _Bool *result);
// cbor_value_get_double
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 459
static inline CborError cbor_value_get_double(const CborValue *value, double *result);
// cbor_value_get_float
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 448
static inline CborError cbor_value_get_float(const CborValue *value, float *result);
// cbor_value_get_half_float
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 1290
CborError cbor_value_get_half_float(const CborValue *value, void *result);
// cbor_value_get_int
// file ..\..\..\..\lib\third_party\tinycbor\cbor.h line 328
static inline CborError cbor_value_get_int(const CborValue *value, signed int *result);
// cbor_value_get_int64_checked
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 744
CborError cbor_value_get_int64_checked(const CborValue *value, int64_t *result);
// cbor_value_get_int_checked
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 783
CborError cbor_value_get_int_checked(const CborValue *value, signed int *result);
// cbor_value_get_raw_integer
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 305
static inline CborError cbor_value_get_raw_integer(const CborValue *value, uint64_t *result);
// cbor_value_get_simple_type
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 290
static inline CborError cbor_value_get_simple_type(const CborValue *value, uint8_t *result);
// cbor_value_get_tag
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 346
static inline CborError cbor_value_get_tag(const CborValue *value, CborTag *result);
// cbor_value_get_type
// file ..\..\..\..\lib\third_party\tinycbor\cbor.h line 268
static inline CborType cbor_value_get_type(const CborValue *value);
// cbor_value_get_type$link1
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 268
static inline CborType cbor_value_get_type$link1(const CborValue *value$link1);
// cbor_value_is_boolean
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 278
static inline _Bool cbor_value_is_boolean(const CborValue *value);
// cbor_value_is_byte_string
// file ..\..\..\..\lib\third_party\tinycbor\cbor.h line 355
static inline _Bool cbor_value_is_byte_string(const CborValue *value);
// cbor_value_is_byte_string$link1
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 355
static inline _Bool cbor_value_is_byte_string$link1(const CborValue *value$link1);
// cbor_value_is_byte_string$link2
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 355
static inline _Bool cbor_value_is_byte_string$link2(const CborValue *value$link2);
// cbor_value_is_container
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 254
static inline _Bool cbor_value_is_container(const CborValue *it);
// cbor_value_is_double
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 457
static inline _Bool cbor_value_is_double(const CborValue *value);
// cbor_value_is_float
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 446
static inline _Bool cbor_value_is_float(const CborValue *value);
// cbor_value_is_half_float
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 442
static inline _Bool cbor_value_is_half_float(const CborValue *value);
// cbor_value_is_integer
// file ..\..\..\..\lib\third_party\tinycbor\cbor.h line 298
static inline _Bool cbor_value_is_integer(const CborValue *value);
// cbor_value_is_integer$link1
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 298
static inline _Bool cbor_value_is_integer$link1(const CborValue *value$link1);
// cbor_value_is_integer$link2
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 298
static inline _Bool cbor_value_is_integer$link2(const CborValue *value$link2);
// cbor_value_is_length_known
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 340
static inline _Bool cbor_value_is_length_known(const CborValue *value);
// cbor_value_is_length_known$link1
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 340
static inline _Bool cbor_value_is_length_known$link1(const CborValue *value$link1);
// cbor_value_is_map
// file ..\..\..\..\lib\third_party\tinycbor\cbor.h line 412
static inline _Bool cbor_value_is_map(const CborValue *value);
// cbor_value_is_map$link1
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 412
static inline _Bool cbor_value_is_map$link1(const CborValue *value$link1);
// cbor_value_is_simple_type
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 288
static inline _Bool cbor_value_is_simple_type(const CborValue *value);
// cbor_value_is_tag
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 344
static inline _Bool cbor_value_is_tag(const CborValue *value);
// cbor_value_is_tag$link1
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 344
static inline _Bool cbor_value_is_tag$link1(const CborValue *value$link1);
// cbor_value_is_text_string
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 357
static inline _Bool cbor_value_is_text_string(const CborValue *value);
// cbor_value_is_text_string$link1
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 357
static inline _Bool cbor_value_is_text_string$link1(const CborValue *value$link1);
// cbor_value_is_unsigned_integer
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 300
static inline _Bool cbor_value_is_unsigned_integer(const CborValue *value);
// cbor_value_leave_container
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 562
CborError cbor_value_leave_container(CborValue *it, const CborValue *recursed);
// cbor_value_map_find_value
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 1179
CborError cbor_value_map_find_value(const CborValue *map, const char *string, CborValue *element);
// cbor_value_skip_tag
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 478
CborError cbor_value_skip_tag(CborValue *it);
// cbor_value_text_string_equals
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 1092
CborError cbor_value_text_string_equals(const CborValue *value, const char *string, _Bool *result);
// cbor_value_to_pretty_advance
// file ..\..\..\..\lib\third_party\tinycbor\cborpretty.c line 466
CborError cbor_value_to_pretty_advance(FILE *out, CborValue *value);
// ceill
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 789
// container_to_pretty
// file ..\..\..\..\lib\third_party\tinycbor\cborpretty.c line 242
static CborError container_to_pretty(FILE *out, CborValue *it, CborType containerType);
// coshl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 806
// cosl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 811
// cprintf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 471
inline signed int cprintf(const char * const _Format, ...);
// create_container
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 451
static CborError create_container(CborEncoder *encoder, CborEncoder *container, size_t length, uint8_t shiftedMajorType);
// cscanf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 488
inline signed int cscanf(const char * const _Format, ...);
// ctr_drbg_self_test_entropy
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 581
static signed int ctr_drbg_self_test_entropy(void *data, unsigned char *buf, size_t len);
// ctr_drbg_update_internal
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 263
static signed int ctr_drbg_update_internal(mbedtls_ctr_drbg_context *ctx, const unsigned char *data);
// decode_half
// file d:\tuttle\freertos\lib\third_party\tinycbor\math_support_p.h line 31
static inline double decode_half(unsigned short int half);
// derive_mpi
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdsa.c line 49
static signed int derive_mpi(const mbedtls_ecp_group *grp, mbedtls_mpi *x, const unsigned char *buf, size_t blen);
// eARPGetCacheEntry
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_ARP.c line 371
eARPLookupResult_t eARPGetCacheEntry(uint32_t *pulIPAddress, MACAddress_t * const pxMACAddress);
// eARPProcessPacket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_ARP.c line 108
eFrameProcessingResult_t eARPProcessPacket(ARPPacket_t * const pxARPFrame);
// eConsiderFrameForProcessing
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 1217
eFrameProcessingResult_t eConsiderFrameForProcessing(const uint8_t * const pucEthernetBuffer);
// eTaskGetState
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 1344
eTaskState eTaskGetState(TaskHandle_t xTask);
// ecdsa_alloc_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 375
static void * ecdsa_alloc_wrap(void);
// ecdsa_can_do
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 345
static signed int ecdsa_can_do(mbedtls_pk_type_t type);
// ecdsa_free_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 385
static void ecdsa_free_wrap(void *ctx);
// ecdsa_sign_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 366
static signed int ecdsa_sign_wrap(void *ctx, mbedtls_md_type_t md_alg, const unsigned char *hash, size_t hash_len, unsigned char *sig, size_t *sig_len, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
// ecdsa_signature_to_asn1
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdsa.c line 292
static signed int ecdsa_signature_to_asn1(const mbedtls_mpi *r, const mbedtls_mpi *s, unsigned char *sig, size_t *slen);
// ecdsa_verify_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 350
static signed int ecdsa_verify_wrap(void *ctx, mbedtls_md_type_t md_alg, const unsigned char *hash, size_t hash_len, const unsigned char *sig, size_t sig_len);
// eckey_alloc_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 276
static void * eckey_alloc_wrap(void);
// eckey_can_do
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 209
static signed int eckey_can_do(mbedtls_pk_type_t type);
// eckey_check_pair
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 270
static signed int eckey_check_pair(const void *pub, const void *prv);
// eckey_debug
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 292
static void eckey_debug(const void *ctx, mbedtls_pk_debug_item *items);
// eckey_free_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 286
static void eckey_free_wrap(void *ctx);
// eckey_get_bitlen
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 216
static size_t eckey_get_bitlen(const void *ctx);
// eckey_sign_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 249
static signed int eckey_sign_wrap(void *ctx, mbedtls_md_type_t md_alg, const unsigned char *hash, size_t hash_len, unsigned char *sig, size_t *sig_len, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
// eckey_verify_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 232
static signed int eckey_verify_wrap(void *ctx, mbedtls_md_type_t md_alg, const unsigned char *hash, size_t hash_len, const unsigned char *sig, size_t sig_len);
// eckeydh_can_do
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 322
static signed int eckeydh_can_do(mbedtls_pk_type_t type);
// ecp_add_mixed
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 1023
static signed int ecp_add_mixed(const mbedtls_ecp_group *grp, mbedtls_ecp_point *R, const mbedtls_ecp_point *P, const mbedtls_ecp_point *Q);
// ecp_check_pubkey_sw
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 1728
static signed int ecp_check_pubkey_sw(const mbedtls_ecp_group *grp, const mbedtls_ecp_point *ecp_check_pubkey_sw$$pt);
// ecp_comb_fixed
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 1193
static void ecp_comb_fixed(unsigned char *x, size_t d, unsigned char w, const mbedtls_mpi *m);
// ecp_double_jac
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 925
static signed int ecp_double_jac(const mbedtls_ecp_group *grp, mbedtls_ecp_point *R, const mbedtls_ecp_point *P);
// ecp_get_type
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 264
static inline ecp_curve_type ecp_get_type(const mbedtls_ecp_group *grp);
// ecp_group_load
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp_curves.c line 577
static signed int ecp_group_load(mbedtls_ecp_group *grp, const mbedtls_mpi_uint *p, size_t plen, const mbedtls_mpi_uint *a, size_t alen, const mbedtls_mpi_uint *b, size_t blen, const mbedtls_mpi_uint *gx, size_t gxlen, const mbedtls_mpi_uint *gy, size_t gylen, const mbedtls_mpi_uint *n, size_t nlen);
// ecp_mod_p256
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp_curves.c line 1066
static signed int ecp_mod_p256(mbedtls_mpi *N);
// ecp_modp
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 670
static signed int ecp_modp(mbedtls_mpi *N, const mbedtls_ecp_group *grp);
// ecp_mpi_load
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp_curves.c line 556
static inline void ecp_mpi_load(mbedtls_mpi *X, const mbedtls_mpi_uint *p, size_t len);
// ecp_mpi_set1
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp_curves.c line 566
static inline void ecp_mpi_set1(mbedtls_mpi *X);
// ecp_mul_comb
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 1353
static signed int ecp_mul_comb(mbedtls_ecp_group *grp, mbedtls_ecp_point *R, const mbedtls_mpi *m, const mbedtls_ecp_point *P, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
// ecp_mul_comb_core
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 1316
static signed int ecp_mul_comb_core(const mbedtls_ecp_group *grp, mbedtls_ecp_point *R, const mbedtls_ecp_point *T, unsigned char t_len, const unsigned char *x, size_t d, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
// ecp_normalize_jac
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 750
static signed int ecp_normalize_jac(const mbedtls_ecp_group *grp, mbedtls_ecp_point *ecp_normalize_jac$$pt);
// ecp_normalize_jac_many
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 802
static signed int ecp_normalize_jac_many(const mbedtls_ecp_group *grp, mbedtls_ecp_point **T, size_t t_len);
// ecp_precompute_comb
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 1233
static signed int ecp_precompute_comb(const mbedtls_ecp_group *grp, mbedtls_ecp_point *T, const mbedtls_ecp_point *P, unsigned char w, size_t d);
// ecp_randomize_jac
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 1112
static signed int ecp_randomize_jac(const mbedtls_ecp_group *grp, mbedtls_ecp_point *ecp_randomize_jac$$pt, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
// ecp_safe_invert_jac
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 890
static signed int ecp_safe_invert_jac(const mbedtls_ecp_group *grp, mbedtls_ecp_point *Q, unsigned char inv);
// ecp_select_comb
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 1286
static signed int ecp_select_comb(const mbedtls_ecp_group *grp, mbedtls_ecp_point *R, const mbedtls_ecp_point *T, unsigned char t_len, unsigned char i);
// encode_number
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 307
static inline CborError encode_number(CborEncoder *encoder, uint64_t ui, uint8_t shiftedMajorType);
// encode_number_no_update
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 278
static inline CborError encode_number_no_update(CborEncoder *encoder, uint64_t ui, uint8_t shiftedMajorType);
// encode_string
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 406
static CborError encode_string(CborEncoder *encoder, size_t length, uint8_t shiftedMajorType, const void *string);
// entropy_dummy_source
// file ..\..\..\..\lib\third_party\mbedtls\library\entropy.c line 533
static signed int entropy_dummy_source(void *data, unsigned char *output, size_t len, size_t *olen);
// entropy_gather_internal
// file ..\..\..\..\lib\third_party\mbedtls\library\entropy.c line 263
static signed int entropy_gather_internal(mbedtls_entropy_context *ctx);
// entropy_update
// file ..\..\..\..\lib\third_party\mbedtls\library\entropy.c line 184
static signed int entropy_update(mbedtls_entropy_context *ctx, unsigned char source_id, const unsigned char *data, size_t len);
// expl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 819
// extract_length
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 149
static CborError extract_length(const CborParser *parser, const uint8_t **ptr, size_t *len);
// extract_number
// file d:\tuttle\freertos\lib\third_party\tinycbor\extract_number_p.h line 53
static CborError extract_number(const uint8_t **ptr, const uint8_t *end, uint64_t *len);
// extract_number$link1
// file d:\tuttle\freertos\lib\third_party\tinycbor\extract_number_p.h line 53
static CborError extract_number$link1(const uint8_t **ptr$link1, const uint8_t *end$link1, uint64_t *len$link1);
// fabsf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 656
// fabsl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 827
// fix_negative
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp_curves.c line 1018
static inline signed int fix_negative(mbedtls_mpi *N, signed char c, mbedtls_mpi *C, size_t bits);
// floorl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 834
// fmodl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 843
// fopen_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 94
errno_t fopen_s(FILE **, const char *, const char *);
// fprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 869
inline signed int fprintf_s(FILE * const _Stream, const char * const _Format, ...);
// frexpf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 682
inline float frexpf(float _X, signed int *_Y);
// frexpl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 848
// fscanf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1232
inline signed int fscanf_s(FILE * const _Stream, const char * const _Format, ...);
// fwprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 528
inline signed int fwprintf_s(FILE * const _Stream, const wchar_t * const _Format, ...);
// fwscanf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 851
inline signed int fwscanf(FILE * const _Stream, const wchar_t * const _Format, ...);
// fwscanf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 890
inline signed int fwscanf_s(FILE * const _Stream, const wchar_t * const _Format, ...);
// gai_strerrorA
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\ws2tcpip.h line 634
inline char * gai_strerrorA(signed int ecode);
// gai_strerrorW
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\ws2tcpip.h line 655
inline WCHAR * gai_strerrorW(signed int ecode);
// gcm_aes_setkey_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 341
static signed int gcm_aes_setkey_wrap(void *ctx, const unsigned char *gcm_aes_setkey_wrap$$key, unsigned int key_bitlen);
// gcm_ctx_alloc
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 78
static void * gcm_ctx_alloc(void);
// gcm_ctx_free
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 88
static void gcm_ctx_free(void *ctx);
// gcm_gen_table
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 104
static signed int gcm_gen_table(mbedtls_gcm_context *ctx);
// gcm_mult
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 213
static void gcm_mult(mbedtls_gcm_context *ctx, const unsigned char *x, unsigned char *output);
// get16
// file d:\tuttle\freertos\lib\third_party\tinycbor\extract_number_p.h line 32
static inline uint16_t get16(const uint8_t *ptr);
// get16$link1
// file d:\tuttle\freertos\lib\third_party\tinycbor\extract_number_p.h line 32
static inline uint16_t get16$link1(const uint8_t *ptr$link1);
// get32
// file d:\tuttle\freertos\lib\third_party\tinycbor\extract_number_p.h line 39
static inline uint32_t get32(const uint8_t *ptr);
// get32$link1
// file d:\tuttle\freertos\lib\third_party\tinycbor\extract_number_p.h line 39
static inline uint32_t get32$link1(const uint8_t *ptr$link1);
// get64
// file d:\tuttle\freertos\lib\third_party\tinycbor\extract_number_p.h line 46
static inline uint64_t get64(const uint8_t *ptr);
// get64$link1
// file d:\tuttle\freertos\lib\third_party\tinycbor\extract_number_p.h line 46
static inline uint64_t get64$link1(const uint8_t *ptr$link1);
// getUserCmd
// file ..\common\application_code\main.c line 475
void getUserCmd(char *pucUserCmd);
// get_no_padding
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 624
static signed int get_no_padding(unsigned char *input, size_t input_len, size_t *data_len);
// get_one_and_zeros_padding
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 520
static signed int get_one_and_zeros_padding(unsigned char *input, size_t input_len, size_t *data_len);
// get_pkcs_padding
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 479
static signed int get_pkcs_padding(unsigned char *input, size_t input_len, size_t *data_len);
// get_zeros_and_len_padding
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 559
static signed int get_zeros_and_len_padding(unsigned char *input, size_t input_len, size_t *data_len);
// get_zeros_padding
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 597
static signed int get_zeros_padding(unsigned char *input, size_t input_len, size_t *data_len);
// gethostbyaddr
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\winsock2.h line 2144
struct hostent * gethostbyaddr(const char *, signed int, signed int);
// gethostbyname
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\winsock2.h line 2165
struct hostent * gethostbyname(const char *);
// getipv4sourcefilter
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\ws2tcpip.h line 727
inline signed int getipv4sourcefilter(SOCKET Socket, IN_ADDR Interface, IN_ADDR Group, MULTICAST_MODE_TYPE *FilterMode, ULONG *SourceCount, IN_ADDR *SourceList);
// getservbyname
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\winsock2.h line 2241
struct servent * getservbyname(const char *, const char *);
// getservbyport
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\winsock2.h line 2222
struct servent * getservbyport(signed int, const char *);
// hexDump
// file ..\..\..\..\lib\third_party\tinycbor\cborpretty.c line 113
static signed int hexDump(FILE *out, const uint8_t *buffer, size_t n);
// hmac_drbg_self_test_entropy
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 455
static signed int hmac_drbg_self_test_entropy(void *data, unsigned char *buf, size_t len);
// htonl
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\winsock2.h line 1746
u_long htonl(u_long);
// htons
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\winsock2.h line 1763
u_short htons(u_short);
// hypotf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 687
/*inline float hypotf(float _X, float _Y);*/
// hypotl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 860
// inet_addr
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\winsock2.h line 1780
unsigned long int inet_addr(const char *);
// inet_ntoa
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\winsock2.h line 1797
char * inet_ntoa(struct in_addr);
// isOomError
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 221
static inline _Bool isOomError(CborError err);
// is_fixed_type
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 164
static _Bool is_fixed_type(uint8_t type);
// iterate_memcmp
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 913
static uintptr_t iterate_memcmp(char *s1, const uint8_t *s2, size_t len);
// iterate_memcpy
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 918
static uintptr_t iterate_memcpy(char *dest, const uint8_t *src, size_t len);
// iterate_noop
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 905
static uintptr_t iterate_noop(char *dest, const uint8_t *src, size_t len);
// iterate_string_chunks
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 923
static CborError iterate_string_chunks(const CborValue *value, char *buffer, size_t *buflen, _Bool *result, CborValue *next, IterateFunction func);
// jsmn_alloc_token
// file ..\..\..\..\lib\third_party\jsmn\jsmn.c line 6
static jsmntok_t * jsmn_alloc_token(jsmn_parser *parser, jsmntok_t *tokens, size_t num_tokens);
// jsmn_fill_token
// file ..\..\..\..\lib\third_party\jsmn\jsmn.c line 24
static void jsmn_fill_token(jsmntok_t *token, jsmntype_t type, signed int start, signed int end);
// jsmn_init
// file ..\..\..\..\lib\third_party\jsmn\jsmn.c line 309
void jsmn_init(jsmn_parser *parser);
// jsmn_parse
// file ..\..\..\..\lib\third_party\jsmn\jsmn.c line 151
signed int jsmn_parse(jsmn_parser *parser, const char *js, size_t len, jsmntok_t *tokens, unsigned int num_tokens);
// jsmn_parse_primitive
// file ..\..\..\..\lib\third_party\jsmn\jsmn.c line 35
static signed int jsmn_parse_primitive(jsmn_parser *parser, const char *js, size_t len, jsmntok_t *tokens, size_t num_tokens);
// jsmn_parse_string
// file ..\..\..\..\lib\third_party\jsmn\jsmn.c line 84
static signed int jsmn_parse_string(jsmn_parser *parser, const char *js, size_t len, jsmntok_t *tokens, size_t num_tokens);
// lTCPAddRxdata
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 2955
int32_t lTCPAddRxdata(FreeRTOS_Socket_t *pxSocket, size_t uxOffset, const uint8_t *pcData, uint32_t ulByteCount);
// lTCPIncrementTxPosition
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 974
static int32_t lTCPIncrementTxPosition(int32_t lPosition, int32_t lMax, int32_t lCount);
// lTCPWindowRxCheck
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 751
int32_t lTCPWindowRxCheck(TCPWindow_t *pxWindow, uint32_t ulSequenceNumber, uint32_t ulLength, uint32_t ulSpace);
// lTCPWindowTxAdd
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 992
int32_t lTCPWindowTxAdd(TCPWindow_t *pxWindow, uint32_t ulLength, int32_t lPosition, int32_t lMax);
// ldexpf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 692
/*inline float ldexpf(float _X, signed int _Y);*/
// ldexpl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 865
// log10l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 879
// logl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 874
// mbedtls_aes_crypt_cbc
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 928
signed int mbedtls_aes_crypt_cbc(mbedtls_aes_context *ctx, signed int mode, size_t length, unsigned char *mbedtls_aes_crypt_cbc$$iv, const unsigned char *input, unsigned char *output);
// mbedtls_aes_crypt_cfb128
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 994
signed int mbedtls_aes_crypt_cfb128(mbedtls_aes_context *ctx, signed int mode, size_t length, size_t *iv_off, unsigned char *mbedtls_aes_crypt_cfb128$$iv, const unsigned char *input, unsigned char *output);
// mbedtls_aes_crypt_cfb8
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 1040
signed int mbedtls_aes_crypt_cfb8(mbedtls_aes_context *ctx, signed int mode, size_t length, unsigned char *mbedtls_aes_crypt_cfb8$$iv, const unsigned char *input, unsigned char *output);
// mbedtls_aes_crypt_ctr
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 1074
signed int mbedtls_aes_crypt_ctr(mbedtls_aes_context *ctx, size_t length, size_t *nc_off, unsigned char *nonce_counter, unsigned char *stream_block, const unsigned char *input, unsigned char *output);
// mbedtls_aes_crypt_ecb
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 896
signed int mbedtls_aes_crypt_ecb(mbedtls_aes_context *ctx, signed int mode, const unsigned char *input, unsigned char *output);
// mbedtls_aes_free
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 520
void mbedtls_aes_free(mbedtls_aes_context *ctx);
// mbedtls_aes_init
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 515
void mbedtls_aes_init(mbedtls_aes_context *ctx);
// mbedtls_aes_self_test
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 1288
signed int mbedtls_aes_self_test(signed int verbose);
// mbedtls_aes_setkey_dec
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 646
signed int mbedtls_aes_setkey_dec(mbedtls_aes_context *ctx, const unsigned char *mbedtls_aes_setkey_dec$$key, unsigned int keybits);
// mbedtls_aes_setkey_enc
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 532
signed int mbedtls_aes_setkey_enc(mbedtls_aes_context *ctx, const unsigned char *mbedtls_aes_setkey_enc$$key, unsigned int keybits);
// mbedtls_asn1_find_named_data
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1parse.c line 376
mbedtls_asn1_named_data * mbedtls_asn1_find_named_data(mbedtls_asn1_named_data *list, const char *oid, size_t len);
// mbedtls_asn1_free_named_data
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1parse.c line 353
void mbedtls_asn1_free_named_data(mbedtls_asn1_named_data *cur);
// mbedtls_asn1_free_named_data_list
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1parse.c line 364
void mbedtls_asn1_free_named_data_list(mbedtls_asn1_named_data **head);
// mbedtls_asn1_get_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1parse.c line 291
signed int mbedtls_asn1_get_alg(unsigned char **p, const unsigned char *end, mbedtls_asn1_buf *alg, mbedtls_asn1_buf *params);
// mbedtls_asn1_get_alg_null
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1parse.c line 335
signed int mbedtls_asn1_get_alg_null(unsigned char **p, const unsigned char *end, mbedtls_asn1_buf *alg);
// mbedtls_asn1_get_bitstring
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1parse.c line 189
signed int mbedtls_asn1_get_bitstring(unsigned char **p, const unsigned char *end, mbedtls_asn1_bitstring *bs);
// mbedtls_asn1_get_bitstring_null
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1parse.c line 222
signed int mbedtls_asn1_get_bitstring_null(unsigned char **p, const unsigned char *end, size_t *len);
// mbedtls_asn1_get_bool
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1parse.c line 127
signed int mbedtls_asn1_get_bool(unsigned char **p, const unsigned char *end, signed int *val);
// mbedtls_asn1_get_int
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1parse.c line 146
signed int mbedtls_asn1_get_int(unsigned char **p, const unsigned char *end, signed int *val);
// mbedtls_asn1_get_len
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1parse.c line 54
signed int mbedtls_asn1_get_len(unsigned char **p, const unsigned char *end, size_t *len);
// mbedtls_asn1_get_mpi
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1parse.c line 171
signed int mbedtls_asn1_get_mpi(unsigned char **p, const unsigned char *end, mbedtls_mpi *X);
// mbedtls_asn1_get_sequence_of
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1parse.c line 241
signed int mbedtls_asn1_get_sequence_of(unsigned char **p, const unsigned char *end, mbedtls_asn1_sequence *cur, signed int mbedtls_asn1_get_sequence_of$$tag);
// mbedtls_asn1_get_tag
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1parse.c line 112
signed int mbedtls_asn1_get_tag(unsigned char **p, const unsigned char *end, size_t *len, signed int mbedtls_asn1_get_tag$$tag);
// mbedtls_asn1_store_named_data
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1write.c line 331
mbedtls_asn1_named_data * mbedtls_asn1_store_named_data(mbedtls_asn1_named_data **head, const char *oid, size_t oid_len, const unsigned char *val, size_t val_len);
// mbedtls_asn1_write_algorithm_identifier
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1write.c line 192
signed int mbedtls_asn1_write_algorithm_identifier(unsigned char **p, unsigned char *start, const char *oid, size_t oid_len, size_t par_len);
// mbedtls_asn1_write_bitstring
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1write.c line 290
signed int mbedtls_asn1_write_bitstring(unsigned char **p, unsigned char *start, const unsigned char *buf, size_t bits);
// mbedtls_asn1_write_bool
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1write.c line 213
signed int mbedtls_asn1_write_bool(unsigned char **p, unsigned char *start, signed int boolean);
// mbedtls_asn1_write_ia5_string
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1write.c line 275
signed int mbedtls_asn1_write_ia5_string(unsigned char **p, unsigned char *start, const char *text, size_t text_len);
// mbedtls_asn1_write_int
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1write.c line 230
signed int mbedtls_asn1_write_int(unsigned char **p, unsigned char *start, signed int val);
// mbedtls_asn1_write_len
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1write.c line 42
signed int mbedtls_asn1_write_len(unsigned char **p, unsigned char *start, size_t len);
// mbedtls_asn1_write_mpi
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1write.c line 128
signed int mbedtls_asn1_write_mpi(unsigned char **p, unsigned char *start, const mbedtls_mpi *X);
// mbedtls_asn1_write_null
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1write.c line 165
signed int mbedtls_asn1_write_null(unsigned char **p, unsigned char *start);
// mbedtls_asn1_write_octet_string
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1write.c line 317
signed int mbedtls_asn1_write_octet_string(unsigned char **p, unsigned char *start, const unsigned char *buf, size_t size);
// mbedtls_asn1_write_oid
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1write.c line 178
signed int mbedtls_asn1_write_oid(unsigned char **p, unsigned char *start, const char *oid, size_t oid_len);
// mbedtls_asn1_write_printable_string
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1write.c line 260
signed int mbedtls_asn1_write_printable_string(unsigned char **p, unsigned char *start, const char *text, size_t text_len);
// mbedtls_asn1_write_raw_buffer
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1write.c line 112
signed int mbedtls_asn1_write_raw_buffer(unsigned char **p, unsigned char *start, const unsigned char *buf, size_t size);
// mbedtls_asn1_write_tag
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1write.c line 102
signed int mbedtls_asn1_write_tag(unsigned char **p, unsigned char *start, unsigned char mbedtls_asn1_write_tag$$tag);
// mbedtls_base64_decode
// file ..\..\..\..\lib\third_party\mbedtls\library\base64.c line 144
signed int mbedtls_base64_decode(unsigned char *dst, size_t dlen, size_t *olen, const unsigned char *src, size_t slen);
// mbedtls_base64_encode
// file ..\..\..\..\lib\third_party\mbedtls\library\base64.c line 77
signed int mbedtls_base64_encode(unsigned char *dst, size_t dlen, size_t *olen, const unsigned char *src, size_t slen);
// mbedtls_base64_self_test
// file ..\..\..\..\lib\third_party\mbedtls\library\base64.c line 251
signed int mbedtls_base64_self_test(signed int verbose);
// mbedtls_cipher_auth_decrypt
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 883
signed int mbedtls_cipher_auth_decrypt(mbedtls_cipher_context_t *ctx, const unsigned char *mbedtls_cipher_auth_decrypt$$iv, size_t mbedtls_cipher_auth_decrypt$$iv_len, const unsigned char *ad, size_t ad_len, const unsigned char *input, size_t ilen, unsigned char *output, size_t *olen, const unsigned char *mbedtls_cipher_auth_decrypt$$tag, size_t tag_len);
// mbedtls_cipher_auth_encrypt
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 851
signed int mbedtls_cipher_auth_encrypt(mbedtls_cipher_context_t *ctx, const unsigned char *mbedtls_cipher_auth_encrypt$$iv, size_t mbedtls_cipher_auth_encrypt$$iv_len, const unsigned char *ad, size_t ad_len, const unsigned char *input, size_t ilen, unsigned char *output, size_t *olen, unsigned char *mbedtls_cipher_auth_encrypt$$tag, size_t tag_len);
// mbedtls_cipher_check_tag
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 779
signed int mbedtls_cipher_check_tag(mbedtls_cipher_context_t *ctx, const unsigned char *mbedtls_cipher_check_tag$$tag, size_t tag_len);
// mbedtls_cipher_crypt
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 822
signed int mbedtls_cipher_crypt(mbedtls_cipher_context_t *ctx, const unsigned char *mbedtls_cipher_crypt$$iv, size_t mbedtls_cipher_crypt$$iv_len, const unsigned char *input, size_t ilen, unsigned char *output, size_t *olen);
// mbedtls_cipher_finish
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 636
signed int mbedtls_cipher_finish(mbedtls_cipher_context_t *ctx, unsigned char *output, size_t *olen);
// mbedtls_cipher_free
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 136
void mbedtls_cipher_free(mbedtls_cipher_context_t *ctx);
// mbedtls_cipher_get_block_size
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/cipher.h line 374
static inline unsigned int mbedtls_cipher_get_block_size(const mbedtls_cipher_context_t *ctx);
// mbedtls_cipher_get_block_size$link1
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\cipher.h line 374
static inline unsigned int mbedtls_cipher_get_block_size$link1(const mbedtls_cipher_context_t *ctx$link1);
// mbedtls_cipher_get_cipher_mode
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\cipher.h line 391
static inline mbedtls_cipher_mode_t mbedtls_cipher_get_cipher_mode(const mbedtls_cipher_context_t *ctx);
// mbedtls_cipher_get_iv_size
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/cipher.h line 409
static inline signed int mbedtls_cipher_get_iv_size(const mbedtls_cipher_context_t *ctx);
// mbedtls_cipher_info_from_string
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 102
const mbedtls_cipher_info_t * mbedtls_cipher_info_from_string(const char *cipher_name);
// mbedtls_cipher_info_from_type
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 91
const mbedtls_cipher_info_t * mbedtls_cipher_info_from_type(const mbedtls_cipher_type_t cipher_type);
// mbedtls_cipher_info_from_values
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 116
const mbedtls_cipher_info_t * mbedtls_cipher_info_from_values(const mbedtls_cipher_id_t cipher_id, signed int key_bitlen, const mbedtls_cipher_mode_t mode);
// mbedtls_cipher_init
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 131
void mbedtls_cipher_init(mbedtls_cipher_context_t *ctx);
// mbedtls_cipher_list
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 70
const signed int * mbedtls_cipher_list(void);
// mbedtls_cipher_reset
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 243
signed int mbedtls_cipher_reset(mbedtls_cipher_context_t *ctx);
// mbedtls_cipher_set_iv
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 214
signed int mbedtls_cipher_set_iv(mbedtls_cipher_context_t *ctx, const unsigned char *mbedtls_cipher_set_iv$$iv, size_t mbedtls_cipher_set_iv$$iv_len);
// mbedtls_cipher_set_padding_mode
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 716
signed int mbedtls_cipher_set_padding_mode(mbedtls_cipher_context_t *ctx, mbedtls_cipher_padding_t mode);
// mbedtls_cipher_setkey
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 181
signed int mbedtls_cipher_setkey(mbedtls_cipher_context_t *ctx, const unsigned char *mbedtls_cipher_setkey$$key, signed int key_bitlen, const mbedtls_operation_t operation);
// mbedtls_cipher_setup
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 155
signed int mbedtls_cipher_setup(mbedtls_cipher_context_t *ctx, const mbedtls_cipher_info_t *cipher_info);
// mbedtls_cipher_update
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 270
signed int mbedtls_cipher_update(mbedtls_cipher_context_t *ctx, const unsigned char *input, size_t ilen, unsigned char *output, size_t *olen);
// mbedtls_cipher_update_ad
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 254
signed int mbedtls_cipher_update_ad(mbedtls_cipher_context_t *ctx, const unsigned char *ad, size_t ad_len);
// mbedtls_cipher_write_tag
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 764
signed int mbedtls_cipher_write_tag(mbedtls_cipher_context_t *ctx, unsigned char *mbedtls_cipher_write_tag$$tag, size_t tag_len);
// mbedtls_clz
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 373
static size_t mbedtls_clz(const mbedtls_mpi_uint x);
// mbedtls_ctr_drbg_free
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 119
void mbedtls_ctr_drbg_free(mbedtls_ctr_drbg_context *ctx);
// mbedtls_ctr_drbg_init
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 60
void mbedtls_ctr_drbg_init(mbedtls_ctr_drbg_context *ctx);
// mbedtls_ctr_drbg_random
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 457
signed int mbedtls_ctr_drbg_random(void *p_rng, unsigned char *output, size_t output_len);
// mbedtls_ctr_drbg_random_with_add
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 378
signed int mbedtls_ctr_drbg_random_with_add(void *p_rng, unsigned char *output, size_t output_len, const unsigned char *mbedtls_ctr_drbg_random_with_add$$additional, size_t mbedtls_ctr_drbg_random_with_add$$add_len);
// mbedtls_ctr_drbg_reseed
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 325
signed int mbedtls_ctr_drbg_reseed(mbedtls_ctr_drbg_context *ctx, const unsigned char *mbedtls_ctr_drbg_reseed$$additional, size_t len);
// mbedtls_ctr_drbg_seed
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 109
signed int mbedtls_ctr_drbg_seed(mbedtls_ctr_drbg_context *ctx, signed int (*f_entropy)(void *, unsigned char *, size_t), void *p_entropy, const unsigned char *custom, size_t len);
// mbedtls_ctr_drbg_seed_entropy_len
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 73
signed int mbedtls_ctr_drbg_seed_entropy_len(mbedtls_ctr_drbg_context *ctx, signed int (*f_entropy)(void *, unsigned char *, size_t), void *p_entropy, const unsigned char *custom, size_t len, size_t entropy_len);
// mbedtls_ctr_drbg_self_test
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 600
signed int mbedtls_ctr_drbg_self_test(signed int verbose);
// mbedtls_ctr_drbg_set_entropy_len
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 136
void mbedtls_ctr_drbg_set_entropy_len(mbedtls_ctr_drbg_context *ctx, size_t len);
// mbedtls_ctr_drbg_set_prediction_resistance
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 131
void mbedtls_ctr_drbg_set_prediction_resistance(mbedtls_ctr_drbg_context *ctx, signed int resistance);
// mbedtls_ctr_drbg_set_reseed_interval
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 141
void mbedtls_ctr_drbg_set_reseed_interval(mbedtls_ctr_drbg_context *ctx, signed int interval);
// mbedtls_ctr_drbg_update
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 308
void mbedtls_ctr_drbg_update(mbedtls_ctr_drbg_context *ctx, const unsigned char *mbedtls_ctr_drbg_update$$additional, size_t mbedtls_ctr_drbg_update$$add_len);
// mbedtls_ecdh_calc_secret
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdh.c line 245
signed int mbedtls_ecdh_calc_secret(mbedtls_ecdh_context *ctx, size_t *olen, unsigned char *buf, size_t blen, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
// mbedtls_ecdh_compute_shared
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdh.c line 57
signed int mbedtls_ecdh_compute_shared(mbedtls_ecp_group *grp, mbedtls_mpi *z, const mbedtls_ecp_point *Q, const mbedtls_mpi *d, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
// mbedtls_ecdh_free
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdh.c line 100
void mbedtls_ecdh_free(mbedtls_ecdh_context *ctx);
// mbedtls_ecdh_gen_public
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdh.c line 45
signed int mbedtls_ecdh_gen_public(mbedtls_ecp_group *grp, mbedtls_mpi *d, mbedtls_ecp_point *Q, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
// mbedtls_ecdh_get_params
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdh.c line 177
signed int mbedtls_ecdh_get_params(mbedtls_ecdh_context *ctx, const mbedtls_ecp_keypair *mbedtls_ecdh_get_params$$key, mbedtls_ecdh_side side);
// mbedtls_ecdh_init
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdh.c line 92
void mbedtls_ecdh_init(mbedtls_ecdh_context *ctx);
// mbedtls_ecdh_make_params
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdh.c line 122
signed int mbedtls_ecdh_make_params(mbedtls_ecdh_context *ctx, size_t *olen, unsigned char *buf, size_t blen, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
// mbedtls_ecdh_make_public
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdh.c line 203
signed int mbedtls_ecdh_make_public(mbedtls_ecdh_context *ctx, size_t *olen, unsigned char *buf, size_t blen, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
// mbedtls_ecdh_read_params
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdh.c line 159
signed int mbedtls_ecdh_read_params(mbedtls_ecdh_context *ctx, const unsigned char **buf, const unsigned char *end);
// mbedtls_ecdh_read_public
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdh.c line 224
signed int mbedtls_ecdh_read_public(mbedtls_ecdh_context *ctx, const unsigned char *buf, size_t blen);
// mbedtls_ecdsa_free
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdsa.c line 456
void mbedtls_ecdsa_free(mbedtls_ecdsa_context *ctx);
// mbedtls_ecdsa_from_keypair
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdsa.c line 431
signed int mbedtls_ecdsa_from_keypair(mbedtls_ecdsa_context *ctx, const mbedtls_ecp_keypair *mbedtls_ecdsa_from_keypair$$key);
// mbedtls_ecdsa_genkey
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdsa.c line 420
signed int mbedtls_ecdsa_genkey(mbedtls_ecdsa_context *ctx, mbedtls_ecp_group_id gid, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
// mbedtls_ecdsa_init
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdsa.c line 448
void mbedtls_ecdsa_init(mbedtls_ecdsa_context *ctx);
// mbedtls_ecdsa_read_signature
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdsa.c line 365
signed int mbedtls_ecdsa_read_signature(mbedtls_ecdsa_context *ctx, const unsigned char *hash, size_t hlen, const unsigned char *sig, size_t slen);
// mbedtls_ecdsa_sign
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdsa.c line 73
signed int mbedtls_ecdsa_sign(mbedtls_ecp_group *grp, mbedtls_mpi *r, mbedtls_mpi *s, const mbedtls_mpi *d, const unsigned char *buf, size_t blen, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
// mbedtls_ecdsa_sign_det
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdsa.c line 167
signed int mbedtls_ecdsa_sign_det(mbedtls_ecp_group *grp, mbedtls_mpi *r, mbedtls_mpi *s, const mbedtls_mpi *d, const unsigned char *buf, size_t blen, mbedtls_md_type_t md_alg);
// mbedtls_ecdsa_verify
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdsa.c line 206
signed int mbedtls_ecdsa_verify(mbedtls_ecp_group *grp, const unsigned char *buf, size_t blen, const mbedtls_ecp_point *Q, const mbedtls_mpi *r, const mbedtls_mpi *s);
// mbedtls_ecdsa_write_signature
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdsa.c line 316
signed int mbedtls_ecdsa_write_signature(mbedtls_ecdsa_context *ctx, mbedtls_md_type_t md_alg, const unsigned char *hash, size_t hlen, unsigned char *sig, size_t *slen, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
// mbedtls_ecp_check_privkey
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 1889
signed int mbedtls_ecp_check_privkey(const mbedtls_ecp_group *grp, const mbedtls_mpi *d);
// mbedtls_ecp_check_pub_priv
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 2035
signed int mbedtls_ecp_check_pub_priv(const mbedtls_ecp_keypair *pub, const mbedtls_ecp_keypair *prv);
// mbedtls_ecp_check_pubkey
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 1869
signed int mbedtls_ecp_check_pubkey(const mbedtls_ecp_group *grp, const mbedtls_ecp_point *mbedtls_ecp_check_pubkey$$pt);
// mbedtls_ecp_copy
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 370
signed int mbedtls_ecp_copy(mbedtls_ecp_point *P, const mbedtls_ecp_point *Q);
// mbedtls_ecp_curve_info_from_grp_id
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 210
const mbedtls_ecp_curve_info * mbedtls_ecp_curve_info_from_grp_id(mbedtls_ecp_group_id grp_id);
// mbedtls_ecp_curve_info_from_name
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 246
const mbedtls_ecp_curve_info * mbedtls_ecp_curve_info_from_name(const char *name);
// mbedtls_ecp_curve_info_from_tls_id
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 228
const mbedtls_ecp_curve_info * mbedtls_ecp_curve_info_from_tls_id(uint16_t tls_id);
// mbedtls_ecp_curve_list
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 176
const mbedtls_ecp_curve_info * mbedtls_ecp_curve_list(void);
// mbedtls_ecp_gen_key
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 2021
signed int mbedtls_ecp_gen_key(mbedtls_ecp_group_id grp_id, mbedtls_ecp_keypair *mbedtls_ecp_gen_key$$key, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
// mbedtls_ecp_gen_keypair
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 2010
signed int mbedtls_ecp_gen_keypair(mbedtls_ecp_group *grp, mbedtls_mpi *d, mbedtls_ecp_point *Q, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
// mbedtls_ecp_gen_keypair_base
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 1926
signed int mbedtls_ecp_gen_keypair_base(mbedtls_ecp_group *grp, const mbedtls_ecp_point *G, mbedtls_mpi *d, mbedtls_ecp_point *Q, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
// mbedtls_ecp_group_copy
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 385
signed int mbedtls_ecp_group_copy(mbedtls_ecp_group *dst, const mbedtls_ecp_group *src);
// mbedtls_ecp_group_free
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 328
void mbedtls_ecp_group_free(mbedtls_ecp_group *grp);
// mbedtls_ecp_group_init
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 291
void mbedtls_ecp_group_init(mbedtls_ecp_group *grp);
// mbedtls_ecp_group_load
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp_curves.c line 747
signed int mbedtls_ecp_group_load(mbedtls_ecp_group *grp, mbedtls_ecp_group_id id);
// mbedtls_ecp_grp_id_list
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 184
const mbedtls_ecp_group_id * mbedtls_ecp_grp_id_list(void);
// mbedtls_ecp_is_zero
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 408
signed int mbedtls_ecp_is_zero(mbedtls_ecp_point *mbedtls_ecp_is_zero$$pt);
// mbedtls_ecp_keypair_free
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 357
void mbedtls_ecp_keypair_free(mbedtls_ecp_keypair *mbedtls_ecp_keypair_free$$key);
// mbedtls_ecp_keypair_init
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 302
void mbedtls_ecp_keypair_init(mbedtls_ecp_keypair *mbedtls_ecp_keypair_init$$key);
// mbedtls_ecp_mul
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 1677
signed int mbedtls_ecp_mul(mbedtls_ecp_group *grp, mbedtls_ecp_point *R, const mbedtls_mpi *m, const mbedtls_ecp_point *P, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
// mbedtls_ecp_mul_shortcuts
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 1777
static signed int mbedtls_ecp_mul_shortcuts(mbedtls_ecp_group *grp, mbedtls_ecp_point *R, const mbedtls_mpi *m, const mbedtls_ecp_point *P);
// mbedtls_ecp_muladd
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 1807
signed int mbedtls_ecp_muladd(mbedtls_ecp_group *grp, mbedtls_ecp_point *R, const mbedtls_mpi *m, const mbedtls_ecp_point *P, const mbedtls_mpi *n, const mbedtls_ecp_point *Q);
// mbedtls_ecp_point_cmp
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 416
signed int mbedtls_ecp_point_cmp(const mbedtls_ecp_point *P, const mbedtls_ecp_point *Q);
// mbedtls_ecp_point_free
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 315
void mbedtls_ecp_point_free(mbedtls_ecp_point *mbedtls_ecp_point_free$$pt);
// mbedtls_ecp_point_init
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 278
void mbedtls_ecp_point_init(mbedtls_ecp_point *mbedtls_ecp_point_init$$pt);
// mbedtls_ecp_point_read_binary
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 504
signed int mbedtls_ecp_point_read_binary(const mbedtls_ecp_group *grp, mbedtls_ecp_point *mbedtls_ecp_point_read_binary$$pt, const unsigned char *buf, size_t ilen);
// mbedtls_ecp_point_read_string
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 432
signed int mbedtls_ecp_point_read_string(mbedtls_ecp_point *P, signed int radix, const char *x, const char *y);
// mbedtls_ecp_point_write_binary
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 448
signed int mbedtls_ecp_point_write_binary(const mbedtls_ecp_group *grp, const mbedtls_ecp_point *P, signed int format, size_t *olen, unsigned char *buf, size_t buflen);
// mbedtls_ecp_self_test
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 2079
signed int mbedtls_ecp_self_test(signed int verbose);
// mbedtls_ecp_set_zero
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 393
signed int mbedtls_ecp_set_zero(mbedtls_ecp_point *mbedtls_ecp_set_zero$$pt);
// mbedtls_ecp_tls_read_group
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 602
signed int mbedtls_ecp_tls_read_group(mbedtls_ecp_group *grp, const unsigned char **buf, size_t len);
// mbedtls_ecp_tls_read_point
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 543
signed int mbedtls_ecp_tls_read_point(const mbedtls_ecp_group *grp, mbedtls_ecp_point *mbedtls_ecp_tls_read_point$$pt, const unsigned char **buf, size_t buf_len);
// mbedtls_ecp_tls_write_group
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 635
signed int mbedtls_ecp_tls_write_group(const mbedtls_ecp_group *grp, size_t *olen, unsigned char *buf, size_t blen);
// mbedtls_ecp_tls_write_point
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 574
signed int mbedtls_ecp_tls_write_point(const mbedtls_ecp_group *grp, const mbedtls_ecp_point *mbedtls_ecp_tls_write_point$$pt, signed int format, size_t *olen, unsigned char *buf, size_t blen);
// mbedtls_entropy_add_source
// file ..\..\..\..\lib\third_party\mbedtls\library\entropy.c line 147
signed int mbedtls_entropy_add_source(mbedtls_entropy_context *ctx, mbedtls_entropy_f_source_ptr f_source, void *p_source, size_t threshold, signed int strong);
// mbedtls_entropy_free
// file ..\..\..\..\lib\third_party\mbedtls\library\entropy.c line 126
void mbedtls_entropy_free(mbedtls_entropy_context *ctx);
// mbedtls_entropy_func
// file ..\..\..\..\lib\third_party\mbedtls\library\entropy.c line 330
signed int mbedtls_entropy_func(void *data, unsigned char *output, size_t len);
// mbedtls_entropy_gather
// file ..\..\..\..\lib\third_party\mbedtls\library\entropy.c line 311
signed int mbedtls_entropy_gather(mbedtls_entropy_context *ctx);
// mbedtls_entropy_init
// file ..\..\..\..\lib\third_party\mbedtls\library\entropy.c line 69
void mbedtls_entropy_init(mbedtls_entropy_context *ctx);
// mbedtls_entropy_self_test
// file ..\..\..\..\lib\third_party\mbedtls\library\entropy.c line 648
signed int mbedtls_entropy_self_test(signed int verbose);
// mbedtls_entropy_source_self_test
// file ..\..\..\..\lib\third_party\mbedtls\library\entropy.c line 600
signed int mbedtls_entropy_source_self_test(signed int verbose);
// mbedtls_entropy_source_self_test_check_bits
// file ..\..\..\..\lib\third_party\mbedtls\library\entropy.c line 573
static signed int mbedtls_entropy_source_self_test_check_bits(const unsigned char *buf, size_t buf_len);
// mbedtls_entropy_source_self_test_gather
// file ..\..\..\..\lib\third_party\mbedtls\library\entropy.c line 547
static signed int mbedtls_entropy_source_self_test_gather(unsigned char *buf, size_t buf_len);
// mbedtls_entropy_update_manual
// file ..\..\..\..\lib\third_party\mbedtls\library\entropy.c line 240
signed int mbedtls_entropy_update_manual(mbedtls_entropy_context *ctx, const unsigned char *data, size_t len);
// mbedtls_gcm_auth_decrypt
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 472
signed int mbedtls_gcm_auth_decrypt(mbedtls_gcm_context *ctx, size_t length, const unsigned char *mbedtls_gcm_auth_decrypt$$iv, size_t mbedtls_gcm_auth_decrypt$$iv_len, const unsigned char *add, size_t mbedtls_gcm_auth_decrypt$$add_len, const unsigned char *mbedtls_gcm_auth_decrypt$$tag, size_t tag_len, const unsigned char *input, unsigned char *output);
// mbedtls_gcm_crypt_and_tag
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 446
signed int mbedtls_gcm_crypt_and_tag(mbedtls_gcm_context *ctx, signed int mode, size_t length, const unsigned char *mbedtls_gcm_crypt_and_tag$$iv, size_t mbedtls_gcm_crypt_and_tag$$iv_len, const unsigned char *add, size_t mbedtls_gcm_crypt_and_tag$$add_len, const unsigned char *input, unsigned char *output, size_t tag_len, unsigned char *mbedtls_gcm_crypt_and_tag$$tag);
// mbedtls_gcm_finish
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 411
signed int mbedtls_gcm_finish(mbedtls_gcm_context *ctx, unsigned char *mbedtls_gcm_finish$$tag, size_t tag_len);
// mbedtls_gcm_free
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 508
void mbedtls_gcm_free(mbedtls_gcm_context *ctx);
// mbedtls_gcm_init
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 91
void mbedtls_gcm_init(mbedtls_gcm_context *ctx);
// mbedtls_gcm_self_test
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 744
signed int mbedtls_gcm_self_test(signed int verbose);
// mbedtls_gcm_setkey
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 164
signed int mbedtls_gcm_setkey(mbedtls_gcm_context *ctx, mbedtls_cipher_id_t cipher, const unsigned char *mbedtls_gcm_setkey$$key, unsigned int keybits);
// mbedtls_gcm_starts
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 269
signed int mbedtls_gcm_starts(mbedtls_gcm_context *ctx, signed int mode, const unsigned char *mbedtls_gcm_starts$$iv, size_t mbedtls_gcm_starts$$iv_len, const unsigned char *add, size_t mbedtls_gcm_starts$$add_len);
// mbedtls_gcm_update
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 352
signed int mbedtls_gcm_update(mbedtls_gcm_context *ctx, size_t length, const unsigned char *input, unsigned char *output);
// mbedtls_hardware_poll
// file ..\common\application_code\aws_entropy_hardware_poll.c line 33
signed int mbedtls_hardware_poll(void *data, unsigned char *output, size_t len, size_t *olen);
// mbedtls_hmac_drbg_free
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 332
void mbedtls_hmac_drbg_free(mbedtls_hmac_drbg_context *ctx);
// mbedtls_hmac_drbg_init
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 61
void mbedtls_hmac_drbg_init(mbedtls_hmac_drbg_context *ctx);
// mbedtls_hmac_drbg_random
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 309
signed int mbedtls_hmac_drbg_random(void *p_rng, unsigned char *output, size_t out_len);
// mbedtls_hmac_drbg_random_with_add
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 249
signed int mbedtls_hmac_drbg_random_with_add(void *p_rng, unsigned char *output, size_t out_len, const unsigned char *mbedtls_hmac_drbg_random_with_add$$additional, size_t mbedtls_hmac_drbg_random_with_add$$add_len);
// mbedtls_hmac_drbg_reseed
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 126
signed int mbedtls_hmac_drbg_reseed(mbedtls_hmac_drbg_context *ctx, const unsigned char *mbedtls_hmac_drbg_reseed$$additional, size_t len);
// mbedtls_hmac_drbg_seed
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 167
signed int mbedtls_hmac_drbg_seed(mbedtls_hmac_drbg_context *ctx, const mbedtls_md_info_t *md_info, signed int (*f_entropy)(void *, unsigned char *, size_t), void *p_entropy, const unsigned char *custom, size_t len);
// mbedtls_hmac_drbg_seed_buf
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 101
signed int mbedtls_hmac_drbg_seed_buf(mbedtls_hmac_drbg_context *ctx, const mbedtls_md_info_t *md_info, const unsigned char *data, size_t data_len);
// mbedtls_hmac_drbg_self_test
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 474
signed int mbedtls_hmac_drbg_self_test(signed int verbose);
// mbedtls_hmac_drbg_set_entropy_len
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 232
void mbedtls_hmac_drbg_set_entropy_len(mbedtls_hmac_drbg_context *ctx, size_t len);
// mbedtls_hmac_drbg_set_prediction_resistance
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 223
void mbedtls_hmac_drbg_set_prediction_resistance(mbedtls_hmac_drbg_context *ctx, signed int resistance);
// mbedtls_hmac_drbg_set_reseed_interval
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 240
void mbedtls_hmac_drbg_set_reseed_interval(mbedtls_hmac_drbg_context *ctx, signed int interval);
// mbedtls_hmac_drbg_update
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 73
void mbedtls_hmac_drbg_update(mbedtls_hmac_drbg_context *ctx, const unsigned char *mbedtls_hmac_drbg_update$$additional, size_t mbedtls_hmac_drbg_update$$add_len);
// mbedtls_int_div_int
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1242
static mbedtls_mpi_uint mbedtls_int_div_int(mbedtls_mpi_uint u1, mbedtls_mpi_uint u0, mbedtls_mpi_uint d, mbedtls_mpi_uint *r);
// mbedtls_internal_aes_decrypt
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 829
signed int mbedtls_internal_aes_decrypt(mbedtls_aes_context *ctx, const unsigned char *input, unsigned char *output);
// mbedtls_internal_aes_encrypt
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 761
signed int mbedtls_internal_aes_encrypt(mbedtls_aes_context *ctx, const unsigned char *input, unsigned char *output);
// mbedtls_internal_sha1_process
// file ..\..\..\..\lib\third_party\mbedtls\library\sha1.c line 122
signed int mbedtls_internal_sha1_process(mbedtls_sha1_context *ctx, const unsigned char *data);
// mbedtls_internal_sha256_process
// file ..\..\..\..\lib\third_party\mbedtls\library\sha256.c line 192
signed int mbedtls_internal_sha256_process(mbedtls_sha256_context *ctx, const unsigned char *data);
// mbedtls_md
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 272
signed int mbedtls_md(const mbedtls_md_info_t *md_info, const unsigned char *input, size_t ilen, unsigned char *output);
// mbedtls_md_clone
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 203
signed int mbedtls_md_clone(mbedtls_md_context_t *dst, const mbedtls_md_context_t *src);
// mbedtls_md_finish
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 264
signed int mbedtls_md_finish(mbedtls_md_context_t *ctx, unsigned char *output);
// mbedtls_md_free
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 186
void mbedtls_md_free(mbedtls_md_context_t *ctx);
// mbedtls_md_get_name
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 470
const char * mbedtls_md_get_name(const mbedtls_md_info_t *md_info);
// mbedtls_md_get_size
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 454
unsigned char mbedtls_md_get_size(const mbedtls_md_info_t *md_info);
// mbedtls_md_get_type
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 462
mbedtls_md_type_t mbedtls_md_get_type(const mbedtls_md_info_t *md_info);
// mbedtls_md_hmac
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 417
signed int mbedtls_md_hmac(const mbedtls_md_info_t *md_info, const unsigned char *mbedtls_md_hmac$$key, size_t keylen, const unsigned char *input, size_t ilen, unsigned char *output);
// mbedtls_md_hmac_finish
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 377
signed int mbedtls_md_hmac_finish(mbedtls_md_context_t *ctx, unsigned char *output);
// mbedtls_md_hmac_reset
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 401
signed int mbedtls_md_hmac_reset(mbedtls_md_context_t *ctx);
// mbedtls_md_hmac_starts
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 322
signed int mbedtls_md_hmac_starts(mbedtls_md_context_t *ctx, const unsigned char *mbedtls_md_hmac_starts$$key, size_t keylen);
// mbedtls_md_hmac_update
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 369
signed int mbedtls_md_hmac_update(mbedtls_md_context_t *ctx, const unsigned char *input, size_t ilen);
// mbedtls_md_info_from_string
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 99
const mbedtls_md_info_t * mbedtls_md_info_from_string(const char *md_name);
// mbedtls_md_info_from_type
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 140
const mbedtls_md_info_t * mbedtls_md_info_from_type(mbedtls_md_type_t md_type);
// mbedtls_md_init
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 181
void mbedtls_md_init(mbedtls_md_context_t *ctx);
// mbedtls_md_list
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 94
const signed int * mbedtls_md_list(void);
// mbedtls_md_process
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 446
signed int mbedtls_md_process(mbedtls_md_context_t *ctx, const unsigned char *data);
// mbedtls_md_setup
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 225
signed int mbedtls_md_setup(mbedtls_md_context_t *ctx, const mbedtls_md_info_t *md_info, signed int hmac);
// mbedtls_md_starts
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 248
signed int mbedtls_md_starts(mbedtls_md_context_t *ctx);
// mbedtls_md_update
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 256
signed int mbedtls_md_update(mbedtls_md_context_t *ctx, const unsigned char *input, size_t ilen);
// mbedtls_mpi_add_abs
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 902
signed int mbedtls_mpi_add_abs(mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B);
// mbedtls_mpi_add_int
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1084
signed int mbedtls_mpi_add_int(mbedtls_mpi *X, const mbedtls_mpi *A, mbedtls_mpi_sint b);
// mbedtls_mpi_add_mpi
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1022
signed int mbedtls_mpi_add_mpi(mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B);
// mbedtls_mpi_bitlen
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 391
size_t mbedtls_mpi_bitlen(const mbedtls_mpi *X);
// mbedtls_mpi_cmp_abs
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 823
signed int mbedtls_mpi_cmp_abs(const mbedtls_mpi *X, const mbedtls_mpi *Y);
// mbedtls_mpi_cmp_int
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 886
signed int mbedtls_mpi_cmp_int(const mbedtls_mpi *X, mbedtls_mpi_sint z);
// mbedtls_mpi_cmp_mpi
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 853
signed int mbedtls_mpi_cmp_mpi(const mbedtls_mpi *X, const mbedtls_mpi *Y);
// mbedtls_mpi_copy
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 185
signed int mbedtls_mpi_copy(mbedtls_mpi *X, const mbedtls_mpi *Y);
// mbedtls_mpi_div_int
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1452
signed int mbedtls_mpi_div_int(mbedtls_mpi *Q, mbedtls_mpi *R, const mbedtls_mpi *A, mbedtls_mpi_sint b);
// mbedtls_mpi_div_mpi
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1337
signed int mbedtls_mpi_div_mpi(mbedtls_mpi *Q, mbedtls_mpi *R, const mbedtls_mpi *A, const mbedtls_mpi *B);
// mbedtls_mpi_exp_mod
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1622
signed int mbedtls_mpi_exp_mod(mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *E, const mbedtls_mpi *N, mbedtls_mpi *_RR);
// mbedtls_mpi_fill_random
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1886
signed int mbedtls_mpi_fill_random(mbedtls_mpi *X, size_t size, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
// mbedtls_mpi_free
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 100
void mbedtls_mpi_free(mbedtls_mpi *X);
// mbedtls_mpi_gcd
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1830
signed int mbedtls_mpi_gcd(mbedtls_mpi *G, const mbedtls_mpi *A, const mbedtls_mpi *B);
// mbedtls_mpi_gen_prime
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 2198
signed int mbedtls_mpi_gen_prime(mbedtls_mpi *X, size_t nbits, signed int dh_flag, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
// mbedtls_mpi_get_bit
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 319
signed int mbedtls_mpi_get_bit(const mbedtls_mpi *X, size_t pos);
// mbedtls_mpi_grow
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 119
signed int mbedtls_mpi_grow(mbedtls_mpi *X, size_t nblimbs);
// mbedtls_mpi_init
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 87
void mbedtls_mpi_init(mbedtls_mpi *X);
// mbedtls_mpi_inv_mod
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1907
signed int mbedtls_mpi_inv_mod(mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *N);
// mbedtls_mpi_is_prime
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 2166
signed int mbedtls_mpi_is_prime(const mbedtls_mpi *X, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
// mbedtls_mpi_lsb
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 358
size_t mbedtls_mpi_lsb(const mbedtls_mpi *X);
// mbedtls_mpi_lset
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 301
signed int mbedtls_mpi_lset(mbedtls_mpi *X, mbedtls_mpi_sint z);
// mbedtls_mpi_mod_int
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1491
signed int mbedtls_mpi_mod_int(mbedtls_mpi_uint *r, const mbedtls_mpi *A, mbedtls_mpi_sint b);
// mbedtls_mpi_mod_mpi
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1468
signed int mbedtls_mpi_mod_mpi(mbedtls_mpi *R, const mbedtls_mpi *A, const mbedtls_mpi *B);
// mbedtls_mpi_mul_int
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1225
signed int mbedtls_mpi_mul_int(mbedtls_mpi *X, const mbedtls_mpi *A, mbedtls_mpi_uint b);
// mbedtls_mpi_mul_mpi
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1188
signed int mbedtls_mpi_mul_mpi(mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B);
// mbedtls_mpi_read_binary
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 683
signed int mbedtls_mpi_read_binary(mbedtls_mpi *X, const unsigned char *buf, size_t buflen);
// mbedtls_mpi_read_string
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 435
signed int mbedtls_mpi_read_string(mbedtls_mpi *X, signed int radix, const char *s);
// mbedtls_mpi_safe_cond_assign
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 239
signed int mbedtls_mpi_safe_cond_assign(mbedtls_mpi *X, const mbedtls_mpi *Y, unsigned char assign);
// mbedtls_mpi_safe_cond_swap
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 267
signed int mbedtls_mpi_safe_cond_swap(mbedtls_mpi *X, mbedtls_mpi *Y, unsigned char swap);
// mbedtls_mpi_self_test
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 2303
signed int mbedtls_mpi_self_test(signed int verbose);
// mbedtls_mpi_set_bit
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 330
signed int mbedtls_mpi_set_bit(mbedtls_mpi *X, size_t pos, unsigned char val);
// mbedtls_mpi_shift_l
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 730
signed int mbedtls_mpi_shift_l(mbedtls_mpi *X, size_t count);
// mbedtls_mpi_shift_r
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 780
signed int mbedtls_mpi_shift_r(mbedtls_mpi *X, size_t count);
// mbedtls_mpi_shrink
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 149
signed int mbedtls_mpi_shrink(mbedtls_mpi *X, size_t nblimbs);
// mbedtls_mpi_size
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 410
size_t mbedtls_mpi_size(const mbedtls_mpi *X);
// mbedtls_mpi_sub_abs
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 979
signed int mbedtls_mpi_sub_abs(mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B);
// mbedtls_mpi_sub_int
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1100
signed int mbedtls_mpi_sub_int(mbedtls_mpi *X, const mbedtls_mpi *A, mbedtls_mpi_sint b);
// mbedtls_mpi_sub_mpi
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1053
signed int mbedtls_mpi_sub_mpi(mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B);
// mbedtls_mpi_swap
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 225
void mbedtls_mpi_swap(mbedtls_mpi *X, mbedtls_mpi *Y);
// mbedtls_mpi_write_binary
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 710
signed int mbedtls_mpi_write_binary(const mbedtls_mpi *X, unsigned char *buf, size_t buflen);
// mbedtls_mpi_write_string
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 534
signed int mbedtls_mpi_write_string(const mbedtls_mpi *X, signed int radix, char *buf, size_t buflen, size_t *olen);
// mbedtls_mpi_zeroize
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 62
static void mbedtls_mpi_zeroize(mbedtls_mpi_uint *v, size_t n);
// mbedtls_oid_get_attr_short_name
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 249
signed int mbedtls_oid_get_attr_short_name(const mbedtls_asn1_buf *oid, const char **short_name);
// mbedtls_oid_get_cipher_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 561
signed int mbedtls_oid_get_cipher_alg(const mbedtls_asn1_buf *oid, mbedtls_cipher_type_t *cipher_alg);
// mbedtls_oid_get_ec_grp
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 531
signed int mbedtls_oid_get_ec_grp(const mbedtls_asn1_buf *oid, mbedtls_ecp_group_id *grp_id);
// mbedtls_oid_get_extended_key_usage
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 302
signed int mbedtls_oid_get_extended_key_usage(const mbedtls_asn1_buf *oid, const char **description);
// mbedtls_oid_get_md_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 626
signed int mbedtls_oid_get_md_alg(const mbedtls_asn1_buf *oid, mbedtls_md_type_t *md_alg);
// mbedtls_oid_get_md_hmac
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 672
signed int mbedtls_oid_get_md_hmac(const mbedtls_asn1_buf *oid, mbedtls_md_type_t *md_hmac);
// mbedtls_oid_get_numeric_string
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 715
signed int mbedtls_oid_get_numeric_string(char *buf, size_t size, const mbedtls_asn1_buf *oid);
// mbedtls_oid_get_oid_by_ec_grp
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 532
signed int mbedtls_oid_get_oid_by_ec_grp(mbedtls_ecp_group_id grp_id, const char **oid, size_t *olen);
// mbedtls_oid_get_oid_by_md
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 627
signed int mbedtls_oid_get_oid_by_md(mbedtls_md_type_t md_alg, const char **oid, size_t *olen);
// mbedtls_oid_get_oid_by_pk_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 445
signed int mbedtls_oid_get_oid_by_pk_alg(mbedtls_pk_type_t pk_alg, const char **oid, size_t *olen);
// mbedtls_oid_get_oid_by_sig_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 412
signed int mbedtls_oid_get_oid_by_sig_alg(mbedtls_pk_type_t pk_alg, mbedtls_md_type_t md_alg, const char **oid, size_t *olen);
// mbedtls_oid_get_pk_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 444
signed int mbedtls_oid_get_pk_alg(const mbedtls_asn1_buf *oid, mbedtls_pk_type_t *pk_alg);
// mbedtls_oid_get_sig_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 411
signed int mbedtls_oid_get_sig_alg(const mbedtls_asn1_buf *oid, mbedtls_md_type_t *md_alg, mbedtls_pk_type_t *pk_alg);
// mbedtls_oid_get_sig_alg_desc
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 410
signed int mbedtls_oid_get_sig_alg_desc(const mbedtls_asn1_buf *oid, const char **description);
// mbedtls_oid_get_x509_ext_type
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 288
signed int mbedtls_oid_get_x509_ext_type(const mbedtls_asn1_buf *oid, signed int *ext_type);
// mbedtls_pem_free
// file ..\..\..\..\lib\third_party\mbedtls\library\pem.c line 428
void mbedtls_pem_free(mbedtls_pem_context *ctx);
// mbedtls_pem_init
// file ..\..\..\..\lib\third_party\mbedtls\library\pem.c line 53
void mbedtls_pem_init(mbedtls_pem_context *ctx);
// mbedtls_pem_read_buffer
// file ..\..\..\..\lib\third_party\mbedtls\library\pem.c line 234
signed int mbedtls_pem_read_buffer(mbedtls_pem_context *ctx, const char *header, const char *footer, const unsigned char *data, const unsigned char *pwd, size_t pwdlen, size_t *use_len);
// mbedtls_pk_can_do
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 151
signed int mbedtls_pk_can_do(const mbedtls_pk_context *ctx, mbedtls_pk_type_t type);
// mbedtls_pk_check_pair
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 311
signed int mbedtls_pk_check_pair(const mbedtls_pk_context *pub, const mbedtls_pk_context *prv);
// mbedtls_pk_debug
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 348
signed int mbedtls_pk_debug(const mbedtls_pk_context *ctx, mbedtls_pk_debug_item *items);
// mbedtls_pk_decrypt
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 275
signed int mbedtls_pk_decrypt(mbedtls_pk_context *ctx, const unsigned char *input, size_t ilen, unsigned char *output, size_t *olen, size_t osize, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
// mbedtls_pk_ec
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/pk.h line 154
static inline mbedtls_ecp_keypair * mbedtls_pk_ec(const mbedtls_pk_context pk);
// mbedtls_pk_ec$link1
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\pk.h line 154
static inline mbedtls_ecp_keypair * mbedtls_pk_ec$link1(const mbedtls_pk_context pk$link1);
// mbedtls_pk_ec$link2
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\pk.h line 154
static inline mbedtls_ecp_keypair * mbedtls_pk_ec$link2(const mbedtls_pk_context pk$link2);
// mbedtls_pk_encrypt
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 293
signed int mbedtls_pk_encrypt(mbedtls_pk_context *ctx, const unsigned char *input, size_t ilen, unsigned char *output, size_t *olen, size_t osize, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
// mbedtls_pk_free
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 65
void mbedtls_pk_free(mbedtls_pk_context *ctx);
// mbedtls_pk_get_bitlen
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 337
size_t mbedtls_pk_get_bitlen(const mbedtls_pk_context *ctx);
// mbedtls_pk_get_name
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 363
const char * mbedtls_pk_get_name(const mbedtls_pk_context *ctx);
// mbedtls_pk_get_type
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 374
mbedtls_pk_type_t mbedtls_pk_get_type(const mbedtls_pk_context *ctx);
// mbedtls_pk_info_from_type
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 78
const mbedtls_pk_info_t * mbedtls_pk_info_from_type(mbedtls_pk_type_t pk_type);
// mbedtls_pk_init
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 53
void mbedtls_pk_init(mbedtls_pk_context *ctx);
// mbedtls_pk_parse_key
// file ..\..\..\..\lib\third_party\mbedtls\library\pkparse.c line 1149
signed int mbedtls_pk_parse_key(mbedtls_pk_context *pk, const unsigned char *mbedtls_pk_parse_key$$key, size_t keylen, const unsigned char *pwd, size_t pwdlen);
// mbedtls_pk_parse_public_key
// file ..\..\..\..\lib\third_party\mbedtls\library\pkparse.c line 1356
signed int mbedtls_pk_parse_public_key(mbedtls_pk_context *ctx, const unsigned char *mbedtls_pk_parse_public_key$$key, size_t keylen);
// mbedtls_pk_parse_subpubkey
// file ..\..\..\..\lib\third_party\mbedtls\library\pkparse.c line 606
signed int mbedtls_pk_parse_subpubkey(unsigned char **p, const unsigned char *end, mbedtls_pk_context *pk);
// mbedtls_pk_rsa
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/pk.h line 141
static inline mbedtls_rsa_context * mbedtls_pk_rsa(const mbedtls_pk_context pk);
// mbedtls_pk_setup
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 104
signed int mbedtls_pk_setup(mbedtls_pk_context *ctx, const mbedtls_pk_info_t *info);
// mbedtls_pk_setup_rsa_alt
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 121
signed int mbedtls_pk_setup_rsa_alt(mbedtls_pk_context *ctx, void *mbedtls_pk_setup_rsa_alt$$key, mbedtls_pk_rsa_alt_decrypt_func decrypt_func, mbedtls_pk_rsa_alt_sign_func sign_func, mbedtls_pk_rsa_alt_key_len_func key_len_func);
// mbedtls_pk_sign
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 256
signed int mbedtls_pk_sign(mbedtls_pk_context *ctx, mbedtls_md_type_t md_alg, const unsigned char *hash, size_t hash_len, unsigned char *sig, size_t *sig_len, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
// mbedtls_pk_verify
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 180
signed int mbedtls_pk_verify(mbedtls_pk_context *ctx, mbedtls_md_type_t md_alg, const unsigned char *hash, size_t hash_len, const unsigned char *sig, size_t sig_len);
// mbedtls_pk_verify_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 198
signed int mbedtls_pk_verify_ext(mbedtls_pk_type_t type, const void *options, mbedtls_pk_context *ctx, mbedtls_md_type_t md_alg, const unsigned char *hash, size_t hash_len, const unsigned char *sig, size_t sig_len);
// mbedtls_platform_set_calloc_free
// file ..\..\..\..\lib\third_party\mbedtls\library\platform.c line 64
signed int mbedtls_platform_set_calloc_free(void * (*calloc_func)(size_t, size_t), void (*free_func)(void *));
// mbedtls_platform_set_snprintf
// file ..\..\..\..\lib\third_party\mbedtls\library\platform.c line 122
signed int mbedtls_platform_set_snprintf(signed int (*snprintf_func)(char *, size_t, const char *, ...));
// mbedtls_platform_setup
// file ..\..\..\..\lib\third_party\mbedtls\library\platform.c line 320
signed int mbedtls_platform_setup(mbedtls_platform_context *ctx);
// mbedtls_platform_teardown
// file ..\..\..\..\lib\third_party\mbedtls\library\platform.c line 330
void mbedtls_platform_teardown(mbedtls_platform_context *ctx);
// mbedtls_platform_win32_snprintf
// file ..\..\..\..\lib\third_party\mbedtls\library\platform.c line 75
signed int mbedtls_platform_win32_snprintf(char *s, size_t n, const char *fmt, ...);
// mbedtls_rsa_check_privkey
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 613
signed int mbedtls_rsa_check_privkey(const mbedtls_rsa_context *ctx);
// mbedtls_rsa_check_pub_priv
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 641
signed int mbedtls_rsa_check_pub_priv(const mbedtls_rsa_context *pub, const mbedtls_rsa_context *prv);
// mbedtls_rsa_check_pubkey
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 590
signed int mbedtls_rsa_check_pubkey(const mbedtls_rsa_context *ctx);
// mbedtls_rsa_complete
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 244
signed int mbedtls_rsa_complete(mbedtls_rsa_context *ctx);
// mbedtls_rsa_copy
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 2115
signed int mbedtls_rsa_copy(mbedtls_rsa_context *dst, const mbedtls_rsa_context *src);
// mbedtls_rsa_deduce_crt
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa_internal.c line 453
signed int mbedtls_rsa_deduce_crt(const mbedtls_mpi *P, const mbedtls_mpi *Q, const mbedtls_mpi *D, mbedtls_mpi *DP, mbedtls_mpi *DQ, mbedtls_mpi *QP);
// mbedtls_rsa_deduce_primes
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa_internal.c line 68
signed int mbedtls_rsa_deduce_primes(const mbedtls_mpi *N, const mbedtls_mpi *E, const mbedtls_mpi *D, mbedtls_mpi *P, mbedtls_mpi *Q);
// mbedtls_rsa_deduce_private_exponent
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa_internal.c line 203
signed int mbedtls_rsa_deduce_private_exponent(const mbedtls_mpi *P, const mbedtls_mpi *Q, const mbedtls_mpi *E, mbedtls_mpi *D);
// mbedtls_rsa_export
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 381
signed int mbedtls_rsa_export(const mbedtls_rsa_context *ctx, mbedtls_mpi *N, mbedtls_mpi *P, mbedtls_mpi *Q, mbedtls_mpi *D, mbedtls_mpi *E);
// mbedtls_rsa_export_crt
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 424
signed int mbedtls_rsa_export_crt(const mbedtls_rsa_context *ctx, mbedtls_mpi *DP, mbedtls_mpi *DQ, mbedtls_mpi *QP);
// mbedtls_rsa_export_raw
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 335
signed int mbedtls_rsa_export_raw(const mbedtls_rsa_context *ctx, unsigned char *N, size_t N_len, unsigned char *P, size_t P_len, unsigned char *Q, size_t Q_len, unsigned char *D, size_t D_len, unsigned char *E, size_t E_len);
// mbedtls_rsa_free
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 2155
void mbedtls_rsa_free(mbedtls_rsa_context *ctx);
// mbedtls_rsa_gen_key
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 499
signed int mbedtls_rsa_gen_key(mbedtls_rsa_context *ctx, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, unsigned int nbits, signed int exponent);
// mbedtls_rsa_get_len
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 488
size_t mbedtls_rsa_get_len(const mbedtls_rsa_context *ctx);
// mbedtls_rsa_import
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 94
signed int mbedtls_rsa_import(mbedtls_rsa_context *ctx, const mbedtls_mpi *N, const mbedtls_mpi *P, const mbedtls_mpi *Q, const mbedtls_mpi *D, const mbedtls_mpi *E);
// mbedtls_rsa_import_raw
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 116
signed int mbedtls_rsa_import_raw(mbedtls_rsa_context *ctx, const unsigned char *N, size_t N_len, const unsigned char *P, size_t P_len, const unsigned char *Q, size_t Q_len, const unsigned char *D, size_t D_len, const unsigned char *E, size_t E_len);
// mbedtls_rsa_init
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 462
void mbedtls_rsa_init(mbedtls_rsa_context *ctx, signed int padding, signed int hash_id);
// mbedtls_rsa_pkcs1_decrypt
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 1466
signed int mbedtls_rsa_pkcs1_decrypt(mbedtls_rsa_context *ctx, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, signed int mode, size_t *olen, const unsigned char *input, unsigned char *output, size_t output_max_len);
// mbedtls_rsa_pkcs1_encrypt
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 1202
signed int mbedtls_rsa_pkcs1_encrypt(mbedtls_rsa_context *ctx, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, signed int mode, size_t ilen, const unsigned char *input, unsigned char *output);
// mbedtls_rsa_pkcs1_sign
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 1812
signed int mbedtls_rsa_pkcs1_sign(mbedtls_rsa_context *ctx, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, signed int mode, mbedtls_md_type_t md_alg, unsigned int hashlen, const unsigned char *hash, unsigned char *sig);
// mbedtls_rsa_pkcs1_verify
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 2084
signed int mbedtls_rsa_pkcs1_verify(mbedtls_rsa_context *ctx, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, signed int mode, mbedtls_md_type_t md_alg, unsigned int hashlen, const unsigned char *hash, const unsigned char *sig);
// mbedtls_rsa_private
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 770
signed int mbedtls_rsa_private(mbedtls_rsa_context *ctx, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, const unsigned char *input, unsigned char *output);
// mbedtls_rsa_public
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 662
signed int mbedtls_rsa_public(mbedtls_rsa_context *ctx, const unsigned char *input, unsigned char *output);
// mbedtls_rsa_rsaes_pkcs1_v15_decrypt
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 1370
signed int mbedtls_rsa_rsaes_pkcs1_v15_decrypt(mbedtls_rsa_context *ctx, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, signed int mode, size_t *olen, const unsigned char *input, unsigned char *output, size_t output_max_len);
// mbedtls_rsa_rsaes_pkcs1_v15_encrypt
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 1136
signed int mbedtls_rsa_rsaes_pkcs1_v15_encrypt(mbedtls_rsa_context *ctx, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, signed int mode, size_t ilen, const unsigned char *input, unsigned char *output);
// mbedtls_rsa_rsassa_pkcs1_v15_sign
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 1740
signed int mbedtls_rsa_rsassa_pkcs1_v15_sign(mbedtls_rsa_context *ctx, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, signed int mode, mbedtls_md_type_t md_alg, unsigned int hashlen, const unsigned char *hash, unsigned char *sig);
// mbedtls_rsa_rsassa_pkcs1_v15_verify
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 2011
signed int mbedtls_rsa_rsassa_pkcs1_v15_verify(mbedtls_rsa_context *ctx, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, signed int mode, mbedtls_md_type_t md_alg, unsigned int hashlen, const unsigned char *hash, const unsigned char *sig);
// mbedtls_rsa_self_test
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 2243
signed int mbedtls_rsa_self_test(signed int verbose);
// mbedtls_rsa_set_padding
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 478
void mbedtls_rsa_set_padding(mbedtls_rsa_context *ctx, signed int padding, signed int hash_id);
// mbedtls_rsa_validate_crt
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa_internal.c line 249
signed int mbedtls_rsa_validate_crt(const mbedtls_mpi *P, const mbedtls_mpi *Q, const mbedtls_mpi *D, const mbedtls_mpi *DP, const mbedtls_mpi *DQ, const mbedtls_mpi *QP);
// mbedtls_rsa_validate_params
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa_internal.c line 337
signed int mbedtls_rsa_validate_params(const mbedtls_mpi *N, const mbedtls_mpi *P, const mbedtls_mpi *Q, const mbedtls_mpi *D, const mbedtls_mpi *E, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
// mbedtls_safer_memcmp
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 80
static inline signed int mbedtls_safer_memcmp(const void *a, const void *b, size_t n);
// mbedtls_sha1_clone
// file ..\..\..\..\lib\third_party\mbedtls\library\sha1.c line 91
void mbedtls_sha1_clone(mbedtls_sha1_context *dst, const mbedtls_sha1_context *src);
// mbedtls_sha1_finish_ret
// file ..\..\..\..\lib\third_party\mbedtls\library\sha1.c line 360
signed int mbedtls_sha1_finish_ret(mbedtls_sha1_context *ctx, unsigned char *output);
// mbedtls_sha1_free
// file ..\..\..\..\lib\third_party\mbedtls\library\sha1.c line 83
void mbedtls_sha1_free(mbedtls_sha1_context *ctx);
// mbedtls_sha1_init
// file ..\..\..\..\lib\third_party\mbedtls\library\sha1.c line 78
void mbedtls_sha1_init(mbedtls_sha1_context *ctx);
// mbedtls_sha1_ret
// file ..\..\..\..\lib\third_party\mbedtls\library\sha1.c line 405
signed int mbedtls_sha1_ret(const unsigned char *input, size_t ilen, unsigned char *output);
// mbedtls_sha1_self_test
// file ..\..\..\..\lib\third_party\mbedtls\library\sha1.c line 467
signed int mbedtls_sha1_self_test(signed int verbose);
// mbedtls_sha1_starts_ret
// file ..\..\..\..\lib\third_party\mbedtls\library\sha1.c line 100
signed int mbedtls_sha1_starts_ret(mbedtls_sha1_context *ctx);
// mbedtls_sha1_update_ret
// file ..\..\..\..\lib\third_party\mbedtls\library\sha1.c line 293
signed int mbedtls_sha1_update_ret(mbedtls_sha1_context *ctx, const unsigned char *input, size_t ilen);
// mbedtls_sha256_clone
// file ..\..\..\..\lib\third_party\mbedtls\library\sha256.c line 94
void mbedtls_sha256_clone(mbedtls_sha256_context *dst, const mbedtls_sha256_context *src);
// mbedtls_sha256_finish_ret
// file ..\..\..\..\lib\third_party\mbedtls\library\sha256.c line 329
signed int mbedtls_sha256_finish_ret(mbedtls_sha256_context *ctx, unsigned char *output);
// mbedtls_sha256_free
// file ..\..\..\..\lib\third_party\mbedtls\library\sha256.c line 86
void mbedtls_sha256_free(mbedtls_sha256_context *ctx);
// mbedtls_sha256_init
// file ..\..\..\..\lib\third_party\mbedtls\library\sha256.c line 81
void mbedtls_sha256_init(mbedtls_sha256_context *ctx);
// mbedtls_sha256_ret
// file ..\..\..\..\lib\third_party\mbedtls\library\sha256.c line 380
signed int mbedtls_sha256_ret(const unsigned char *input, size_t ilen, unsigned char *output, signed int is224);
// mbedtls_sha256_self_test
// file ..\..\..\..\lib\third_party\mbedtls\library\sha256.c line 469
signed int mbedtls_sha256_self_test(signed int verbose);
// mbedtls_sha256_starts_ret
// file ..\..\..\..\lib\third_party\mbedtls\library\sha256.c line 103
signed int mbedtls_sha256_starts_ret(mbedtls_sha256_context *ctx, signed int is224);
// mbedtls_sha256_update_ret
// file ..\..\..\..\lib\third_party\mbedtls\library\sha256.c line 262
signed int mbedtls_sha256_update_ret(mbedtls_sha256_context *ctx, const unsigned char *input, size_t ilen);
// mbedtls_ssl_check_cert_usage
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 8039
signed int mbedtls_ssl_check_cert_usage(const mbedtls_x509_crt *cert, const mbedtls_ssl_ciphersuite_t *ciphersuite, signed int cert_endpoint, uint32_t *flags);
// mbedtls_ssl_check_curve
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 8002
signed int mbedtls_ssl_check_curve(const mbedtls_ssl_context *ssl, mbedtls_ecp_group_id grp_id);
// mbedtls_ssl_check_pending
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6489
signed int mbedtls_ssl_check_pending(const mbedtls_ssl_context *ssl);
// mbedtls_ssl_check_sig_hash
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 8022
signed int mbedtls_ssl_check_sig_hash(const mbedtls_ssl_context *ssl, mbedtls_md_type_t md);
// mbedtls_ssl_ciphersuite_cert_req_allowed
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\ssl_ciphersuites.h line 418
static inline signed int mbedtls_ssl_ciphersuite_cert_req_allowed(const mbedtls_ssl_ciphersuite_t *info);
// mbedtls_ssl_ciphersuite_from_id
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_ciphersuites.c line 1759
const mbedtls_ssl_ciphersuite_t * mbedtls_ssl_ciphersuite_from_id(signed int ciphersuite);
// mbedtls_ssl_ciphersuite_from_string
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_ciphersuites.c line 1740
const mbedtls_ssl_ciphersuite_t * mbedtls_ssl_ciphersuite_from_string(const char *ciphersuite_name);
// mbedtls_ssl_ciphersuite_uses_ec
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_ciphersuites.c line 1841
signed int mbedtls_ssl_ciphersuite_uses_ec(const mbedtls_ssl_ciphersuite_t *info);
// mbedtls_ssl_ciphersuite_uses_server_signature
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\ssl_ciphersuites.h line 467
static inline signed int mbedtls_ssl_ciphersuite_uses_server_signature(const mbedtls_ssl_ciphersuite_t *info);
// mbedtls_ssl_close_notify
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7351
signed int mbedtls_ssl_close_notify(mbedtls_ssl_context *ssl);
// mbedtls_ssl_conf_alpn_protocols
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6319
signed int mbedtls_ssl_conf_alpn_protocols(mbedtls_ssl_config *conf, const char **protos);
// mbedtls_ssl_conf_authmode
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5868
void mbedtls_ssl_conf_authmode(mbedtls_ssl_config *conf, signed int authmode);
// mbedtls_ssl_conf_ca_chain
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6030
void mbedtls_ssl_conf_ca_chain(mbedtls_ssl_config *conf, mbedtls_x509_crt *ca_chain, mbedtls_x509_crl *ca_crl);
// mbedtls_ssl_conf_cert_profile
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5986
void mbedtls_ssl_conf_cert_profile(mbedtls_ssl_config *conf, const mbedtls_x509_crt_profile *profile);
// mbedtls_ssl_conf_ciphersuites
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5963
void mbedtls_ssl_conf_ciphersuites(mbedtls_ssl_config *conf, const signed int *ciphersuites);
// mbedtls_ssl_conf_ciphersuites_for_version
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5972
void mbedtls_ssl_conf_ciphersuites_for_version(mbedtls_ssl_config *conf, const signed int *ciphersuites, signed int major, signed int minor);
// mbedtls_ssl_conf_curves
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6254
void mbedtls_ssl_conf_curves(mbedtls_ssl_config *conf, const mbedtls_ecp_group_id *curve_list);
// mbedtls_ssl_conf_dbg
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5891
void mbedtls_ssl_conf_dbg(mbedtls_ssl_config *conf, void (*f_dbg)(void *, signed int, const char *, signed int, const char *), void *p_dbg);
// mbedtls_ssl_conf_encrypt_then_mac
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6378
void mbedtls_ssl_conf_encrypt_then_mac(mbedtls_ssl_config *conf, char etm);
// mbedtls_ssl_conf_endpoint
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5836
void mbedtls_ssl_conf_endpoint(mbedtls_ssl_config *conf, signed int endpoint);
// mbedtls_ssl_conf_extended_master_secret
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6385
void mbedtls_ssl_conf_extended_master_secret(mbedtls_ssl_config *conf, char ems);
// mbedtls_ssl_conf_legacy_renegotiation
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6427
void mbedtls_ssl_conf_legacy_renegotiation(mbedtls_ssl_config *conf, signed int allow_legacy);
// mbedtls_ssl_conf_max_frag_len
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6399
signed int mbedtls_ssl_conf_max_frag_len(mbedtls_ssl_config *conf, unsigned char mfl_code);
// mbedtls_ssl_conf_max_version
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6350
void mbedtls_ssl_conf_max_version(mbedtls_ssl_config *conf, signed int major, signed int minor);
// mbedtls_ssl_conf_min_version
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6356
void mbedtls_ssl_conf_min_version(mbedtls_ssl_config *conf, signed int major, signed int minor);
// mbedtls_ssl_conf_own_cert
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6023
signed int mbedtls_ssl_conf_own_cert(mbedtls_ssl_config *conf, mbedtls_x509_crt *own_cert, mbedtls_pk_context *pk_key);
// mbedtls_ssl_conf_read_timeout
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5911
void mbedtls_ssl_conf_read_timeout(mbedtls_ssl_config *conf, uint32_t timeout);
// mbedtls_ssl_conf_rng
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5883
void mbedtls_ssl_conf_rng(mbedtls_ssl_config *conf, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
// mbedtls_ssl_conf_sig_hashes
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6243
void mbedtls_ssl_conf_sig_hashes(mbedtls_ssl_config *conf, const signed int *hashes);
// mbedtls_ssl_conf_sni
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6308
void mbedtls_ssl_conf_sni(mbedtls_ssl_config *conf, signed int (*f_sni)(void *, mbedtls_ssl_context *, const unsigned char *, size_t), void *p_sni);
// mbedtls_ssl_conf_transport
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5841
void mbedtls_ssl_conf_transport(mbedtls_ssl_config *conf, signed int transport);
// mbedtls_ssl_conf_verify
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5874
void mbedtls_ssl_conf_verify(mbedtls_ssl_config *conf, signed int (*f_vrfy)(void *, mbedtls_x509_crt *, signed int, uint32_t *), void *p_vrfy);
// mbedtls_ssl_config_defaults
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7637
signed int mbedtls_ssl_config_defaults(mbedtls_ssl_config *conf, signed int endpoint, signed int transport, signed int preset);
// mbedtls_ssl_config_free
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7801
void mbedtls_ssl_config_free(mbedtls_ssl_config *conf);
// mbedtls_ssl_config_init
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7590
void mbedtls_ssl_config_init(mbedtls_ssl_config *conf);
// mbedtls_ssl_derive_keys
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 495
signed int mbedtls_ssl_derive_keys(mbedtls_ssl_context *ssl);
// mbedtls_ssl_fetch_input
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 2246
signed int mbedtls_ssl_fetch_input(mbedtls_ssl_context *ssl, size_t nb_want);
// mbedtls_ssl_flush_output
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 2465
signed int mbedtls_ssl_flush_output(mbedtls_ssl_context *ssl);
// mbedtls_ssl_free
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7511
void mbedtls_ssl_free(mbedtls_ssl_context *ssl);
// mbedtls_ssl_get_alpn_protocol
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6344
const char * mbedtls_ssl_get_alpn_protocol(const mbedtls_ssl_context *ssl);
// mbedtls_ssl_get_bytes_avail
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6484
size_t mbedtls_ssl_get_bytes_avail(const mbedtls_ssl_context *ssl);
// mbedtls_ssl_get_ciphersuite
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6555
const char * mbedtls_ssl_get_ciphersuite(const mbedtls_ssl_context *ssl);
// mbedtls_ssl_get_ciphersuite_id
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_ciphersuites.c line 1786
signed int mbedtls_ssl_get_ciphersuite_id(const char *ciphersuite_name);
// mbedtls_ssl_get_ciphersuite_name
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_ciphersuites.c line 1774
const char * mbedtls_ssl_get_ciphersuite_name(const signed int ciphersuite_id);
// mbedtls_ssl_get_ciphersuite_sig_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_ciphersuites.c line 1821
mbedtls_pk_type_t mbedtls_ssl_get_ciphersuite_sig_alg(const mbedtls_ssl_ciphersuite_t *info);
// mbedtls_ssl_get_ciphersuite_sig_pk_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_ciphersuites.c line 1799
mbedtls_pk_type_t mbedtls_ssl_get_ciphersuite_sig_pk_alg(const mbedtls_ssl_ciphersuite_t *info);
// mbedtls_ssl_get_key_exchange_md_tls1_2
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 8311
signed int mbedtls_ssl_get_key_exchange_md_tls1_2(mbedtls_ssl_context *ssl, unsigned char *output, unsigned char *data, size_t data_len, mbedtls_md_type_t md_alg);
// mbedtls_ssl_get_max_frag_len
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6636
size_t mbedtls_ssl_get_max_frag_len(const mbedtls_ssl_context *ssl);
// mbedtls_ssl_get_peer_cert
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6659
const mbedtls_x509_crt * mbedtls_ssl_get_peer_cert(const mbedtls_ssl_context *ssl);
// mbedtls_ssl_get_record_expansion
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6601
signed int mbedtls_ssl_get_record_expansion(const mbedtls_ssl_context *ssl);
// mbedtls_ssl_get_session
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6669
signed int mbedtls_ssl_get_session(const mbedtls_ssl_context *ssl, mbedtls_ssl_session *dst);
// mbedtls_ssl_get_verify_result
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6544
uint32_t mbedtls_ssl_get_verify_result(const mbedtls_ssl_context *ssl);
// mbedtls_ssl_get_version
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6563
const char * mbedtls_ssl_get_version(const mbedtls_ssl_context *ssl);
// mbedtls_ssl_handle_message_type
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 4081
signed int mbedtls_ssl_handle_message_type(mbedtls_ssl_context *ssl);
// mbedtls_ssl_handshake
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6708
signed int mbedtls_ssl_handshake(mbedtls_ssl_context *ssl);
// mbedtls_ssl_handshake_client_step
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 3329
signed int mbedtls_ssl_handshake_client_step(mbedtls_ssl_context *ssl);
// mbedtls_ssl_handshake_free
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7412
void mbedtls_ssl_handshake_free(mbedtls_ssl_handshake_params *handshake);
// mbedtls_ssl_handshake_step
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6686
signed int mbedtls_ssl_handshake_step(mbedtls_ssl_context *ssl);
// mbedtls_ssl_handshake_wrapup
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5222
void mbedtls_ssl_handshake_wrapup(mbedtls_ssl_context *ssl);
// mbedtls_ssl_hash_from_md_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7968
unsigned char mbedtls_ssl_hash_from_md_alg(signed int md);
// mbedtls_ssl_hdr_len
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/ssl_internal.h line 590
static inline size_t mbedtls_ssl_hdr_len(const mbedtls_ssl_context *ssl);
// mbedtls_ssl_hs_hdr_len
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/ssl_internal.h line 601
static inline size_t mbedtls_ssl_hs_hdr_len(const mbedtls_ssl_context *ssl);
// mbedtls_ssl_hs_hdr_len$link1
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/ssl_internal.h line 601
static inline size_t mbedtls_ssl_hs_hdr_len$link1(const mbedtls_ssl_context *ssl$link1);
// mbedtls_ssl_init
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5652
void mbedtls_ssl_init(mbedtls_ssl_context *ssl);
// mbedtls_ssl_list_ciphersuites
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_ciphersuites.c line 1707
const signed int * mbedtls_ssl_list_ciphersuites(void);
// mbedtls_ssl_md_alg_from_hash
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7936
mbedtls_md_type_t mbedtls_ssl_md_alg_from_hash(unsigned char hash);
// mbedtls_ssl_optimize_checksum
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 4861
void mbedtls_ssl_optimize_checksum(mbedtls_ssl_context *ssl, const mbedtls_ssl_ciphersuite_t *ciphersuite_info);
// mbedtls_ssl_own_cert
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/ssl_internal.h line 558
static inline mbedtls_x509_crt * mbedtls_ssl_own_cert(mbedtls_ssl_context *ssl);
// mbedtls_ssl_own_cert$link1
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/ssl_internal.h line 558
static inline mbedtls_x509_crt * mbedtls_ssl_own_cert$link1(mbedtls_ssl_context *ssl$link1);
// mbedtls_ssl_own_key
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/ssl_internal.h line 546
static inline mbedtls_pk_context * mbedtls_ssl_own_key(mbedtls_ssl_context *ssl);
// mbedtls_ssl_parse_certificate
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 4367
signed int mbedtls_ssl_parse_certificate(mbedtls_ssl_context *ssl);
// mbedtls_ssl_parse_change_cipher_spec
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 4774
signed int mbedtls_ssl_parse_change_cipher_spec(mbedtls_ssl_context *ssl);
// mbedtls_ssl_parse_finished
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5408
signed int mbedtls_ssl_parse_finished(mbedtls_ssl_context *ssl);
// mbedtls_ssl_pk_alg_from_sig
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7864
mbedtls_pk_type_t mbedtls_ssl_pk_alg_from_sig(unsigned char sig);
// mbedtls_ssl_prepare_handshake_record
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 3144
signed int mbedtls_ssl_prepare_handshake_record(mbedtls_ssl_context *ssl);
// mbedtls_ssl_read
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6893
signed int mbedtls_ssl_read(mbedtls_ssl_context *ssl, unsigned char *buf, size_t len);
// mbedtls_ssl_read_record
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 3804
signed int mbedtls_ssl_read_record(mbedtls_ssl_context *ssl);
// mbedtls_ssl_read_record_layer
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 3850
signed int mbedtls_ssl_read_record_layer(mbedtls_ssl_context *ssl);
// mbedtls_ssl_read_version
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 8160
void mbedtls_ssl_read_version(signed int *major, signed int *minor, signed int transport, const unsigned char *ver);
// mbedtls_ssl_reset_checksum
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 4890
void mbedtls_ssl_reset_checksum(mbedtls_ssl_context *ssl);
// mbedtls_ssl_safer_memcmp
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/ssl_internal.h line 625
static inline signed int mbedtls_ssl_safer_memcmp(const void *a, const void *b, size_t n);
// mbedtls_ssl_send_alert_message
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 4170
signed int mbedtls_ssl_send_alert_message(mbedtls_ssl_context *ssl, unsigned char level, unsigned char message);
// mbedtls_ssl_send_fatal_handshake_failure
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 4156
signed int mbedtls_ssl_send_fatal_handshake_failure(mbedtls_ssl_context *ssl);
// mbedtls_ssl_session_free
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7488
void mbedtls_ssl_session_free(mbedtls_ssl_session *session);
// mbedtls_ssl_session_init
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5546
void mbedtls_ssl_session_init(mbedtls_ssl_session *session);
// mbedtls_ssl_session_reset
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5828
signed int mbedtls_ssl_session_reset(mbedtls_ssl_context *ssl);
// mbedtls_ssl_set_bio
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5899
void mbedtls_ssl_set_bio(mbedtls_ssl_context *ssl, void *p_bio, mbedtls_ssl_send_t (*f_send), mbedtls_ssl_recv_t (*f_recv), mbedtls_ssl_recv_timeout_t (*f_recv_timeout));
// mbedtls_ssl_set_calc_verify_md
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 8182
signed int mbedtls_ssl_set_calc_verify_md(mbedtls_ssl_context *ssl, signed int md);
// mbedtls_ssl_set_hostname
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6262
signed int mbedtls_ssl_set_hostname(mbedtls_ssl_context *ssl, const char *hostname);
// mbedtls_ssl_set_hs_authmode
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6056
void mbedtls_ssl_set_hs_authmode(mbedtls_ssl_context *ssl, signed int authmode);
// mbedtls_ssl_set_hs_ca_chain
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6048
void mbedtls_ssl_set_hs_ca_chain(mbedtls_ssl_context *ssl, mbedtls_x509_crt *ca_chain, mbedtls_x509_crl *ca_crl);
// mbedtls_ssl_set_hs_own_cert
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6040
signed int mbedtls_ssl_set_hs_own_cert(mbedtls_ssl_context *ssl, mbedtls_x509_crt *own_cert, mbedtls_pk_context *pk_key);
// mbedtls_ssl_set_session
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5942
signed int mbedtls_ssl_set_session(mbedtls_ssl_context *ssl, const mbedtls_ssl_session *session);
// mbedtls_ssl_set_timer_cb
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5916
void mbedtls_ssl_set_timer_cb(mbedtls_ssl_context *ssl, void *p_timer, mbedtls_ssl_set_timer_t (*f_set_timer), mbedtls_ssl_get_timer_t (*f_get_timer));
// mbedtls_ssl_setup
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5660
signed int mbedtls_ssl_setup(mbedtls_ssl_context *ssl, const mbedtls_ssl_config *conf);
// mbedtls_ssl_sig_from_pk
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7837
unsigned char mbedtls_ssl_sig_from_pk(mbedtls_pk_context *pk);
// mbedtls_ssl_sig_from_pk_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7851
unsigned char mbedtls_ssl_sig_from_pk_alg(mbedtls_pk_type_t type);
// mbedtls_ssl_sig_hash_set_add
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7900
void mbedtls_ssl_sig_hash_set_add(mbedtls_ssl_sig_hash_set_t *set, mbedtls_pk_type_t sig_alg, mbedtls_md_type_t md_alg);
// mbedtls_ssl_sig_hash_set_const_hash
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7922
void mbedtls_ssl_sig_hash_set_const_hash(mbedtls_ssl_sig_hash_set_t *set, mbedtls_md_type_t md_alg);
// mbedtls_ssl_sig_hash_set_find
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7885
mbedtls_md_type_t mbedtls_ssl_sig_hash_set_find(mbedtls_ssl_sig_hash_set_t *set, mbedtls_pk_type_t sig_alg);
// mbedtls_ssl_sig_hash_set_init
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/ssl_internal.h line 392
static inline void mbedtls_ssl_sig_hash_set_init(mbedtls_ssl_sig_hash_set_t *set);
// mbedtls_ssl_transform_free
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7379
void mbedtls_ssl_transform_free(mbedtls_ssl_transform *transform);
// mbedtls_ssl_update_handshake_status
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 3231
void mbedtls_ssl_update_handshake_status(mbedtls_ssl_context *ssl);
// mbedtls_ssl_write
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7311
signed int mbedtls_ssl_write(mbedtls_ssl_context *ssl, const unsigned char *buf, size_t len);
// mbedtls_ssl_write_certificate
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 4251
signed int mbedtls_ssl_write_certificate(mbedtls_ssl_context *ssl);
// mbedtls_ssl_write_change_cipher_spec
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 4751
signed int mbedtls_ssl_write_change_cipher_spec(mbedtls_ssl_context *ssl);
// mbedtls_ssl_write_finished
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5284
signed int mbedtls_ssl_write_finished(mbedtls_ssl_context *ssl);
// mbedtls_ssl_write_record
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 2758
signed int mbedtls_ssl_write_record(mbedtls_ssl_context *ssl);
// mbedtls_ssl_write_version
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 8138
void mbedtls_ssl_write_version(signed int major, signed int minor, signed int transport, unsigned char *ver);
// mbedtls_version_check_feature
// file ..\..\..\..\lib\third_party\mbedtls\library\version_features.c line 706
signed int mbedtls_version_check_feature(const char *feature);
// mbedtls_version_get_number
// file ..\..\..\..\lib\third_party\mbedtls\library\version.c line 33
unsigned int mbedtls_version_get_number(void);
// mbedtls_version_get_string
// file ..\..\..\..\lib\third_party\mbedtls\library\version.c line 38
void mbedtls_version_get_string(char *string);
// mbedtls_version_get_string_full
// file ..\..\..\..\lib\third_party\mbedtls\library\version.c line 44
void mbedtls_version_get_string_full(char *string);
// mbedtls_x509_crt_check_extended_key_usage
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 1597
signed int mbedtls_x509_crt_check_extended_key_usage(const mbedtls_x509_crt *crt, const char *usage_oid, size_t usage_len);
// mbedtls_x509_crt_check_key_usage
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 1572
signed int mbedtls_x509_crt_check_key_usage(const mbedtls_x509_crt *crt, unsigned int usage);
// mbedtls_x509_crt_free
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 2404
void mbedtls_x509_crt_free(mbedtls_x509_crt *crt);
// mbedtls_x509_crt_info
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 1382
signed int mbedtls_x509_crt_info(char *buf, size_t size, const char *prefix, const mbedtls_x509_crt *crt);
// mbedtls_x509_crt_init
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 2396
void mbedtls_x509_crt_init(mbedtls_x509_crt *crt);
// mbedtls_x509_crt_parse
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 992
signed int mbedtls_x509_crt_parse(mbedtls_x509_crt *chain, const unsigned char *buf, size_t buflen);
// mbedtls_x509_crt_parse_der
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 941
signed int mbedtls_x509_crt_parse_der(mbedtls_x509_crt *chain, const unsigned char *buf, size_t buflen);
// mbedtls_x509_crt_verify
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 2306
signed int mbedtls_x509_crt_verify(mbedtls_x509_crt *crt, mbedtls_x509_crt *trust_ca, mbedtls_x509_crl *ca_crl, const char *cn, uint32_t *flags, signed int (*f_vrfy)(void *, mbedtls_x509_crt *, signed int, uint32_t *), void *p_vrfy);
// mbedtls_x509_crt_verify_info
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 1543
signed int mbedtls_x509_crt_verify_info(char *buf, size_t size, const char *prefix, uint32_t flags);
// mbedtls_x509_crt_verify_with_profile
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 2327
signed int mbedtls_x509_crt_verify_with_profile(mbedtls_x509_crt *crt, mbedtls_x509_crt *trust_ca, mbedtls_x509_crl *ca_crl, const mbedtls_x509_crt_profile *profile, const char *cn, uint32_t *flags, signed int (*f_vrfy)(void *, mbedtls_x509_crt *, signed int, uint32_t *), void *p_vrfy);
// mbedtls_x509_dn_gets
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 748
signed int mbedtls_x509_dn_gets(char *buf, size_t size, const mbedtls_x509_name *dn);
// mbedtls_x509_get_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 133
signed int mbedtls_x509_get_alg(unsigned char **p, const unsigned char *end, mbedtls_x509_buf *alg, mbedtls_x509_buf *params);
// mbedtls_x509_get_alg_null
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 119
signed int mbedtls_x509_get_alg_null(unsigned char **p, const unsigned char *end, mbedtls_x509_buf *alg);
// mbedtls_x509_get_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 707
signed int mbedtls_x509_get_ext(unsigned char **p, const unsigned char *end, mbedtls_x509_buf *ext, signed int mbedtls_x509_get_ext$$tag);
// mbedtls_x509_get_name
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 430
signed int mbedtls_x509_get_name(unsigned char **p, const unsigned char *end, mbedtls_x509_name *cur);
// mbedtls_x509_get_serial
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 88
signed int mbedtls_x509_get_serial(unsigned char **p, const unsigned char *end, mbedtls_x509_buf *serial);
// mbedtls_x509_get_sig
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 631
signed int mbedtls_x509_get_sig(unsigned char **p, const unsigned char *end, mbedtls_x509_buf *sig);
// mbedtls_x509_get_sig_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 658
signed int mbedtls_x509_get_sig_alg(const mbedtls_x509_buf *sig_oid, const mbedtls_x509_buf *sig_params, mbedtls_md_type_t *md_alg, mbedtls_pk_type_t *pk_alg, void **sig_opts);
// mbedtls_x509_get_time
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 601
signed int mbedtls_x509_get_time(unsigned char **p, const unsigned char *end, mbedtls_x509_time *tm);
// mbedtls_x509_key_size_helper
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 889
signed int mbedtls_x509_key_size_helper(char *buf, size_t buf_size, const char *name);
// mbedtls_x509_self_test
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 1042
signed int mbedtls_x509_self_test(signed int verbose);
// mbedtls_x509_serial_gets
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 810
signed int mbedtls_x509_serial_gets(char *buf, size_t size, const mbedtls_x509_buf *serial);
// mbedtls_x509_sig_alg_gets
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 844
signed int mbedtls_x509_sig_alg_gets(char *buf, size_t size, const mbedtls_x509_buf *sig_oid, mbedtls_pk_type_t pk_alg, mbedtls_md_type_t md_alg, const void *sig_opts);
// mbedtls_x509_time_is_future
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 1027
signed int mbedtls_x509_time_is_future(const mbedtls_x509_time *from);
// mbedtls_x509_time_is_past
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 1021
signed int mbedtls_x509_time_is_past(const mbedtls_x509_time *to);
// mbedtls_zeroize
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 58
static void mbedtls_zeroize(void *v, size_t n);
// mbedtls_zeroize$link1
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1parse.c line 47
static void mbedtls_zeroize$link1(void *v$link1, size_t n$link1);
// mbedtls_zeroize$link10
// file ..\..\..\..\lib\third_party\mbedtls\library\pem.c line 49
static void mbedtls_zeroize$link10(void *v$link10, size_t n$link10);
// mbedtls_zeroize$link11
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 46
static void mbedtls_zeroize$link11(void *v$link11, size_t n$link11);
// mbedtls_zeroize$link12
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 57
static void mbedtls_zeroize$link12(void *v$link12, size_t n$link12);
// mbedtls_zeroize$link13
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 74
static void mbedtls_zeroize$link13(void *v$link13, size_t n$link13);
// mbedtls_zeroize$link14
// file ..\..\..\..\lib\third_party\mbedtls\library\sha1.c line 51
static void mbedtls_zeroize$link14(void *v$link14, size_t n$link14);
// mbedtls_zeroize$link15
// file ..\..\..\..\lib\third_party\mbedtls\library\sha256.c line 54
static void mbedtls_zeroize$link15(void *v$link15, size_t n$link15);
// mbedtls_zeroize$link16
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 57
static void mbedtls_zeroize$link16(void *v$link16, size_t n$link16);
// mbedtls_zeroize$link17
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 94
static void mbedtls_zeroize$link17(void *v$link17, size_t n$link17);
// mbedtls_zeroize$link2
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 67
static void mbedtls_zeroize$link2(void *v$link2, size_t n$link2);
// mbedtls_zeroize$link3
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 64
static void mbedtls_zeroize$link3(void *v$link3, size_t n$link3);
// mbedtls_zeroize$link4
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 53
static void mbedtls_zeroize$link4(void *v$link4, size_t n$link4);
// mbedtls_zeroize$link5
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 77
static void mbedtls_zeroize$link5(void *v$link5, size_t n$link5);
// mbedtls_zeroize$link6
// file ..\..\..\..\lib\third_party\mbedtls\library\entropy.c line 63
static void mbedtls_zeroize$link6(void *v$link6, size_t n$link6);
// mbedtls_zeroize$link7
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 84
static void mbedtls_zeroize$link7(void *v$link7, size_t n$link7);
// mbedtls_zeroize$link8
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 54
static void mbedtls_zeroize$link8(void *v$link8, size_t n$link8);
// mbedtls_zeroize$link9
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 52
static void mbedtls_zeroize$link9(void *v$link9, size_t n$link9);
// memcmp
// file C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.14.26428\include\vcruntime_string.h line 26
signed int memcmp(const void *, const void *, size_t);
// memcpy
// file C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.14.26428\include\vcruntime_string.h line 40
void * memcpy(void *, const void *, size_t);
// memmove
// file C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.14.26428\include\vcruntime_string.h line 47
void * memmove(void *, const void *, size_t);
// modfl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 890
// mpi_check_small_factors
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 2035
static signed int mpi_check_small_factors(const mbedtls_mpi *X);
// mpi_get_digit
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 418
static signed int mpi_get_digit(mbedtls_mpi_uint *d, signed int radix, char c);
// mpi_miller_rabin
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 2062
static signed int mpi_miller_rabin(const mbedtls_mpi *X, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
// mpi_montg_init
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1548
static void mpi_montg_init(mbedtls_mpi_uint *mm, const mbedtls_mpi *N);
// mpi_montmul
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1565
static signed int mpi_montmul(mbedtls_mpi *A, const mbedtls_mpi *B, const mbedtls_mpi *N, mbedtls_mpi_uint mm, const mbedtls_mpi *T);
// mpi_montred
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1608
static signed int mpi_montred(mbedtls_mpi *A, const mbedtls_mpi *N, mbedtls_mpi_uint mm, const mbedtls_mpi *T);
// mpi_mul_hlp
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1124
static void mpi_mul_hlp(size_t i, mbedtls_mpi_uint *s, mbedtls_mpi_uint *d, mbedtls_mpi_uint b);
// mpi_sub_hlp
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 958
static void mpi_sub_hlp(size_t n, mbedtls_mpi_uint *s, mbedtls_mpi_uint *d);
// mpi_write_hlp
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 507
static signed int mpi_write_hlp(mbedtls_mpi *X, signed int radix, char **p);
// myrand
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 2219
static signed int myrand(void *rng_state, unsigned char *output, size_t len);
// ntohs
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\winsock2.h line 1933
u_short ntohs(u_short);
// oid_cipher_alg_from_asn1
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 560
static const oid_cipher_alg_t * oid_cipher_alg_from_asn1(const mbedtls_asn1_buf *oid);
// oid_ext_key_usage_from_asn1
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 301
static const mbedtls_oid_descriptor_t * oid_ext_key_usage_from_asn1(const mbedtls_asn1_buf *oid);
// oid_grp_id_from_asn1
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 530
static const oid_ecp_grp_t * oid_grp_id_from_asn1(const mbedtls_asn1_buf *oid);
// oid_md_alg_from_asn1
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 625
static const oid_md_alg_t * oid_md_alg_from_asn1(const mbedtls_asn1_buf *oid);
// oid_md_hmac_from_asn1
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 671
static const oid_md_hmac_t * oid_md_hmac_from_asn1(const mbedtls_asn1_buf *oid);
// oid_pk_alg_from_asn1
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 443
static const oid_pk_alg_t * oid_pk_alg_from_asn1(const mbedtls_asn1_buf *oid);
// oid_sig_alg_from_asn1
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 409
static const oid_sig_alg_t * oid_sig_alg_from_asn1(const mbedtls_asn1_buf *oid);
// oid_x509_ext_from_asn1
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 287
static const oid_x509_ext_t * oid_x509_ext_from_asn1(const mbedtls_asn1_buf *oid);
// oid_x520_attr_from_asn1
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 248
static const oid_x520_attr_t * oid_x520_attr_from_asn1(const mbedtls_asn1_buf *oid);
// pcApplicationHostnameHook
// file ..\common\application_code\main.c line 290
const char * pcApplicationHostnameHook(void);
// pcTaskGetName
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 2326
char * pcTaskGetName(TaskHandle_t xTaskToQuery);
// pcTimerGetName
// file ..\..\..\..\lib\FreeRTOS\timers.c line 453
const char * pcTimerGetName(TimerHandle_t xTimer);
// pcap_callback
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 436
void pcap_callback(u_char *user, const struct pcap_pkthdr *pkt_header, const u_char *pkt_data);
// pcap_compile
// file ..\common\win_pcap\pcap/pcap.h line 316
signed int pcap_compile(pcap_t *, struct bpf_program *, const char *, signed int, bpf_u_int32);
// pcap_dispatch
// file ..\common\win_pcap\pcap/pcap.h line 300
signed int pcap_dispatch(pcap_t *, signed int, pcap_handler, u_char *);
// pcap_findalldevs_ex
// file ..\common\win_pcap\remote-ext.h line 420
signed int pcap_findalldevs_ex(char *, struct pcap_rmtauth *, pcap_if_t **, char *);
// pcap_freealldevs
// file ..\common\win_pcap\pcap/pcap.h line 349
void pcap_freealldevs(pcap_if_t *);
// pcap_open
// file ..\common\win_pcap\remote-ext.h line 417
pcap_t * pcap_open(const char *, signed int, signed int, signed int, struct pcap_rmtauth *, char *);
// pcap_sendpacket
// file ..\common\win_pcap\pcap/pcap.h line 311
signed int pcap_sendpacket(pcap_t *, const u_char *, signed int);
// pcap_setfilter
// file ..\common\win_pcap\pcap/pcap.h line 306
signed int pcap_setfilter(pcap_t *, struct bpf_program *);
// pk_get_ecparams
// file ..\..\..\..\lib\third_party\mbedtls\library\pkparse.c line 179
static signed int pk_get_ecparams(unsigned char **p, const unsigned char *end, mbedtls_asn1_buf *params);
// pk_get_ecpubkey
// file ..\..\..\..\lib\third_party\mbedtls\library\pkparse.c line 491
static signed int pk_get_ecpubkey(unsigned char **p, const unsigned char *end, mbedtls_ecp_keypair *pk_get_ecpubkey$$key);
// pk_get_pk_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\pkparse.c line 573
static signed int pk_get_pk_alg(unsigned char **p, const unsigned char *end, mbedtls_pk_type_t *pk_alg, mbedtls_asn1_buf *params);
// pk_get_rsapubkey
// file ..\..\..\..\lib\third_party\mbedtls\library\pkparse.c line 518
static signed int pk_get_rsapubkey(unsigned char **p, const unsigned char *end, mbedtls_rsa_context *rsa);
// pk_hashlen_helper
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 163
static inline signed int pk_hashlen_helper(mbedtls_md_type_t md_alg, size_t *hash_len);
// pk_parse_key_pkcs1_der
// file ..\..\..\..\lib\third_party\mbedtls\library\pkparse.c line 669
static signed int pk_parse_key_pkcs1_der(mbedtls_rsa_context *rsa, const unsigned char *pk_parse_key_pkcs1_der$$key, size_t keylen);
// pk_parse_key_pkcs8_unencrypted_der
// file ..\..\..\..\lib\third_party\mbedtls\library\pkparse.c line 934
static signed int pk_parse_key_pkcs8_unencrypted_der(mbedtls_pk_context *pk, const unsigned char *pk_parse_key_pkcs8_unencrypted_der$$key, size_t keylen);
// pk_parse_key_sec1_der
// file ..\..\..\..\lib\third_party\mbedtls\library\pkparse.c line 796
static signed int pk_parse_key_sec1_der(mbedtls_ecp_keypair *eck, const unsigned char *pk_parse_key_sec1_der$$key, size_t keylen);
// pk_use_ecparams
// file ..\..\..\..\lib\third_party\mbedtls\library\pkparse.c line 452
static signed int pk_use_ecparams(const mbedtls_asn1_buf *params, mbedtls_ecp_group *grp);
// powl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 903
// preparse_next_value
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 256
static CborError preparse_next_value(CborValue *it);
// preparse_value
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 170
static CborError preparse_value(CborValue *it);
// printf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 981
inline signed int printf_s(const char * const _Format, ...);
// prvAbort
// file ..\..\..\..\lib\ota\portable\pc\windows\aws_ota_pal.c line 38
static OTA_Err_t prvAbort(OTA_FileContext_t * const C);
// prvActivateNewImage
// file ..\..\..\..\lib\ota\portable\pc\windows\aws_ota_pal.c line 104
static OTA_Err_t prvActivateNewImage(void);
// prvAddCurrentTaskToDelayedList
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 4983
static void prvAddCurrentTaskToDelayedList(TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely);
// prvAddNewTaskToReadyList
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 1038
static void prvAddNewTaskToReadyList(TCB_t *pxNewTCB);
// prvAgentShutdown
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 515
void prvAgentShutdown(void);
// prvAllowIPPacket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 1422
static eFrameProcessingResult_t prvAllowIPPacket(const IPPacket_t * const pxIPPacket, NetworkBufferDescriptor_t * const pxNetworkBuffer, UBaseType_t uxHeaderLength);
// prvBuildDataRequestTopicName
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1759
static uint32_t prvBuildDataRequestTopicName(char *pcNameBuffer, uint32_t ulBufSize, OTA_FileContext_t *C);
// prvBuildDataStreamTopicName
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1783
static uint32_t prvBuildDataStreamTopicName(char *pcNameBuffer, uint32_t ulBufSize, OTA_FileContext_t *C);
// prvBuildJobStatusTopicName
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1730
static uint32_t prvBuildJobStatusTopicName(char *pcNameBuffer, uint32_t ulBufSize, const char *pacJobName);
// prvBytesInBuffer
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 1121
static size_t prvBytesInBuffer(const StreamBuffer_t1 * const pxStreamBuffer);
// prvCacheLookup
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_ARP.c line 461
static eARPLookupResult_t prvCacheLookup(uint32_t ulAddressToLookup, MACAddress_t * const pxMACAddress);
// prvCalculateSleepTime
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 571
static TickType_t prvCalculateSleepTime(void);
// prvCalloc
// file ..\..\..\..\lib\crypto\aws_crypto.c line 61
static void * prvCalloc(size_t xNmemb, size_t xSize);
// prvChangeDesiredTask
// file ..\..\..\common\shadow\aws_shadow_lightbulb_on_off.c line 372
static void prvChangeDesiredTask(void *pvParameters);
// prvCheckCertificate
// file ..\..\..\..\lib\tls\aws_tls.c line 194
static signed int prvCheckCertificate(void *pvCtx, mbedtls_x509_crt *pxCertificate, signed int lPathCount, uint32_t *pulFlags);
// prvCheckDataToBeOverwrittenForMultiEntryEvents
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2570
static void prvCheckDataToBeOverwrittenForMultiEntryEvents(uint8_t nofEntriesToCheck);
// prvCheckFileSignature
// file ..\..\..\..\lib\ota\portable\pc\windows\aws_ota_pal.c line 124
static OTA_Err_t prvCheckFileSignature(OTA_FileContext_t * const C);
// prvCheckForContentLengthString
// file ..\..\..\..\lib\greengrass\aws_greengrass_discovery.c line 863
static BaseType_t prvCheckForContentLengthString(uint8_t *pucIndex, const char cNewChar);
// prvCheckForValidListAndQueue
// file ..\..\..\..\lib\FreeRTOS\timers.c line 894
static void prvCheckForValidListAndQueue(void);
// prvCheckMatch
// file ..\..\..\..\lib\greengrass\aws_greengrass_discovery.c line 614
static void prvCheckMatch(const char *prvCheckMatch$$pcJSONFile, const jsmntok_t *pxTok, const uint32_t ulTokenIndex, BaseType_t *pxMatch, const char *pcMatchCategory, const char *pcMatchString, const BaseType_t xAutoSelectFlag);
// prvCheckNetworkTimers
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 624
static void prvCheckNetworkTimers(void);
// prvCheckOptions
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 1138
static void prvCheckOptions(FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxNetworkBuffer);
// prvCheckRxData
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 2062
static BaseType_t prvCheckRxData(NetworkBufferDescriptor_t *pxNetworkBuffer, uint8_t **ppucRecvData);
// prvCheckTasksWaitingTermination
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3539
static void prvCheckTasksWaitingTermination(void);
// prvCloseFile
// file ..\..\..\..\lib\ota\portable\pc\windows\aws_ota_pal.c line 74
static OTA_Err_t prvCloseFile(OTA_FileContext_t * const C);
// prvConfigureCaptureBehaviour
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 369
static void prvConfigureCaptureBehaviour(void);
// prvConnectionListeningTask
// file ..\..\..\common\tcp\aws_simple_tcp_echo_server.c line 113
static void prvConnectionListeningTask(void *pvParameters);
// prvConvertMQTTReturnCode
// file ..\..\..\..\lib\shadow\aws_shadow.c line 415
static ShadowReturnCode_t prvConvertMQTTReturnCode(MQTTAgentReturnCode_t xMQTTReturn, ShadowClientHandle_t xShadowClientHandle, const char * const pcDebugMessageSubject);
// prvCopyDataFromQueue
// file ..\..\..\..\lib\FreeRTOS\queue.c line 2120
static void prvCopyDataFromQueue(Queue_t * const pxQueue, void * const pvBuffer);
// prvCopyDataToQueue
// file ..\..\..\..\lib\FreeRTOS\queue.c line 2041
static BaseType_t prvCopyDataToQueue(Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition);
// prvCreateClientAndConnectToBroker
// file ..\..\..\common\mqtt\aws_hello_world.c line 183
static BaseType_t prvCreateClientAndConnectToBroker(void);
// prvCreateDHCPSocket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DHCP.c line 555
static void prvCreateDHCPSocket(void);
// prvCreateDNSMessage
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DNS.c line 601
static size_t prvCreateDNSMessage(uint8_t *pucUDPPayloadBuffer, const char *pcHostName, TickType_t xIdentifier);
// prvCreateDNSSocket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DNS.c line 1262
static Socket_t prvCreateDNSSocket(void);
// prvCreateFileForRx
// file ..\..\..\..\lib\ota\portable\pc\windows\aws_ota_pal.c line 54
static uint8_t prvCreateFileForRx(OTA_FileContext_t * const C);
// prvCreatePartDHCPMessage
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DHCP.c line 826
static uint8_t * prvCreatePartDHCPMessage(struct freertos_sockaddr *pxAddress, BaseType_t xOpcode, const uint8_t * const pucOptionsArray, size_t *pxOptionsArraySize);
// prvCreatePrintSocket
// file ..\common\application_code\aws_demo_logging.c line 240
static void prvCreatePrintSocket(void *pvParameter1, uint32_t ulParameter2);
// prvCreateSectors
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 303
static BaseType_t prvCreateSectors(void);
// prvCreateThreadSafeBuffers
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 167
static void prvCreateThreadSafeBuffers(void);
// prvCreateTopic
// file ..\..\..\..\lib\shadow\aws_shadow.c line 455
static uint16_t prvCreateTopic(char *pcTopicString, const uint16_t usBufferLength, const char *pcTopicFormat, const char *pcthingName);
// prvCreateTxData
// file ..\..\..\common\tcp\aws_tcp_echo_client_single_task.c line 359
static BaseType_t prvCreateTxData(char *cBuffer, uint32_t ulBufferLength);
// prvDecodeRemainingLength
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1927
static uint8_t prvDecodeRemainingLength(const uint8_t * const pucEncodedRemainingLength, uint32_t * const pulRemainingLength);
// prvDeleteTCB
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3747
static void prvDeleteTCB(TCB_t *pxTCB);
// prvDeltaCallback
// file ..\..\..\common\shadow\aws_shadow_lightbulb_on_off.c line 226
static BaseType_t prvDeltaCallback(void *pvUserData, const char * const pcThingName, const char * const pcDeltaDocument, uint32_t ulDocumentLength, MQTTBufferHandle_t xBuffer);
// prvDetermineSocketSize
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 205
static BaseType_t prvDetermineSocketSize(BaseType_t xDomain, BaseType_t xType, BaseType_t xProtocol, size_t *pxSocketSize);
// prvDiscoverGreenGrassCore
// file ..\..\..\common\greengrass_connectivity\aws_greengrass_discovery_demo.c line 181
static void prvDiscoverGreenGrassCore(void *pvParameters);
// prvDoesTopicMatchTopicFilter
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 2324
static MQTTBool_t prvDoesTopicMatchTopicFilter(const uint8_t * const pucTopic, uint16_t usTopicLength, const uint8_t * const pucTopicFilter, uint16_t usTopicFilterLength);
// prvEchoClientRxTask
// file ..\..\..\common\tcp\aws_tcp_echo_client_separate_tasks.c line 323
static void prvEchoClientRxTask(void *pvParameters);
// prvEchoClientTask
// file ..\..\..\common\tcp\aws_tcp_echo_client_single_task.c line 158
static void prvEchoClientTask(void *pvParameters);
// prvEchoClientTxTask
// file ..\..\..\common\tcp\aws_tcp_echo_client_separate_tasks.c line 140
static void prvEchoClientTxTask(void *pvParameters);
// prvEncodeRemainingLength
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1882
static uint8_t prvEncodeRemainingLength(uint32_t ulRemainingLength, uint8_t * const pucEncodedRemainingLength, const uint8_t * const pucLastByteInBuffer);
// prvEndProcess
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 193
static BOOL prvEndProcess(DWORD dwCtrlType);
// prvFileClose
// file ..\common\application_code\aws_demo_logging.c line 565
static void prvFileClose(void);
// prvFileLoggingInit
// file ..\common\application_code\aws_demo_logging.c line 548
static void prvFileLoggingInit(void);
// prvFreeContext
// file ..\..\..\..\lib\tls\aws_tls.c line 108
static void prvFreeContext(TLSContext_t *pCtx);
// prvFreeKey
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 379
static void prvFreeKey(P11KeyPtr_t pxKey);
// prvGGDGetCertificate
// file ..\..\..\..\lib\greengrass\aws_greengrass_discovery.c line 709
static BaseType_t prvGGDGetCertificate(char *prvGGDGetCertificate$$pcJSONFile, const HostParameters_t *pxHostParameters, const BaseType_t xAutoSelectFlag, const jsmntok_t *pxTok, const uint32_t ulNbTokens, GGD_HostAddressData_t *pxHostAddressData);
// prvGGDGetCore
// file ..\..\..\..\lib\greengrass\aws_greengrass_discovery.c line 650
static BaseType_t prvGGDGetCore(const char *prvGGDGetCore$$pcJSONFile, const HostParameters_t * const pxHostParameters, const BaseType_t xAutoSelectFlag, const jsmntok_t *pxTok, const uint32_t ulNbTokens, uint32_t *pulTokenIndex);
// prvGGDGetIPOnInterface
// file ..\..\..\..\lib\greengrass\aws_greengrass_discovery.c line 812
static BaseType_t prvGGDGetIPOnInterface(char *prvGGDGetIPOnInterface$$pcJSONFile, const uint8_t ucTargetInterface, const jsmntok_t *pxTok, const uint32_t ulNbTokens, GGD_HostAddressData_t *pxHostAddressData, uint32_t *pulTokenIndex, uint8_t *pucCurrentInterface);
// prvGGDJsoneq
// file ..\..\..\..\lib\greengrass\aws_greengrass_discovery.c line 589
static BaseType_t prvGGDJsoneq(const char *pcJson, const jsmntok_t * const pxTok, const char *pcString);
// prvGenerateDesiredJSON
// file ..\..\..\common\shadow\aws_shadow_lightbulb_on_off.c line 175
static uint32_t prvGenerateDesiredJSON(ShadowQueueData_t * const pxShadowQueueData, const char * const pcTaskName, uint8_t ucBulbState);
// prvGenerateRandomBytes
// file ..\..\..\..\lib\tls\aws_tls.c line 174
static signed int prvGenerateRandomBytes(void *pvCtx, unsigned char *pucRandom, size_t xRandomLength);
// prvGenerateReportedJSON
// file ..\..\..\common\shadow\aws_shadow_lightbulb_on_off.c line 191
static uint32_t prvGenerateReportedJSON(ShadowQueueData_t * const pxShadowQueueData, const char * const pcReportedData, uint32_t ulReportedDataLength);
// prvGetCallbackCatalogEntry
// file ..\..\..\..\lib\shadow\aws_shadow.c line 365
static BaseType_t prvGetCallbackCatalogEntry(CallbackCatalogEntry_t * const pxCallbackCatalog, const char * const pcThingName);
// prvGetCurrentTickCount
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1044
static uint64_t prvGetCurrentTickCount(MQTTContext_t *pxMQTTContext);
// prvGetDisinheritPriorityAfterTimeout
// file ..\..\..\..\lib\FreeRTOS\queue.c line 2016
static UBaseType_t prvGetDisinheritPriorityAfterTimeout(const Queue_t * const pxQueue);
// prvGetErrorCodeAndMessage
// file ..\..\..\..\lib\shadow\aws_shadow.c line 1092
static ShadowReturnCode_t prvGetErrorCodeAndMessage(const char * const pcData, uint32_t ulDataLength, BaseType_t xShadowClientID, const char * const pcOperationName);
// prvGetFreeBuffer
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 843
static MQTTBufferHandle_t prvGetFreeBuffer(MQTTContext_t *pxMQTTContext, uint32_t ulBufferLength);
// prvGetFreeConnection
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 752
static BaseType_t prvGetFreeConnection(void);
// prvGetFreeContext
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1106
static OTA_FileContext_t * prvGetFreeContext(void);
// prvGetFreeShadowClient
// file ..\..\..\..\lib\shadow\aws_shadow.c line 343
static BaseType_t prvGetFreeShadowClient(void);
// prvGetHostByName
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DNS.c line 483
static uint32_t prvGetHostByName(const char *pcHostName, TickType_t xIdentifier, TickType_t xReadTimeOut_ms);
// prvGetJSONValue
// file ..\..\..\..\lib\shadow\aws_shadow_json.c line 193
static uint16_t prvGetJSONValue(const char **ppcValue, const char * const pcKey, const char * const pcDoc, jsmntok_t *pxJSMNTokens, int16_t sTokensParsed);
// prvGetNextExpireTime
// file ..\..\..\..\lib\FreeRTOS\timers.c line 598
static TickType_t prvGetNextExpireTime(BaseType_t * const pxListWasEmpty);
// prvGetPrivatePortNumber
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 1612
static uint16_t prvGetPrivatePortNumber(BaseType_t xProtocol);
// prvGetSubscribedFlag
// file ..\..\..\..\lib\shadow\aws_shadow.c line 1322
static uint8_t prvGetSubscribedFlag(const ShadowClient_t * const pxShadowClient, ShadowOperationName_t xOperationName);
// prvGetTopicFilterType
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 2232
static MQTTTopicFilterType_t prvGetTopicFilterType(const uint8_t * const pucTopicFilter, uint16_t usTopicFilterLength);
// prvGracefulSocketClose
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 983
static void prvGracefulSocketClose(MQTTBrokerConnection_t * const pxConnection);
// prvHandleEstablished
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 2361
static BaseType_t prvHandleEstablished(FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkBuffer, uint32_t ulReceiveLength, UBaseType_t uxOptionsLength);
// prvHandleEthernetPacket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 534
static void prvHandleEthernetPacket(NetworkBufferDescriptor_t *pxBuffer);
// prvHandleListen
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 3083
static FreeRTOS_Socket_t * prvHandleListen(FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxNetworkBuffer);
// prvHandleSynReceived
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 2258
static BaseType_t prvHandleSynReceived(FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkBuffer, uint32_t ulReceiveLength, UBaseType_t uxOptionsLength);
// prvHeapInit
// file ..\..\..\..\lib\FreeRTOS\portable\MemMang\heap_4.c line 329
static void prvHeapInit(void);
// prvIPTask
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 314
static void prvIPTask(void *pvParameters);
// prvIPTimerCheck
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 717
static BaseType_t prvIPTimerCheck(IPTimer_t *pxTimer);
// prvIPTimerReload
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 710
static void prvIPTimerReload(IPTimer_t *pxTimer, TickType_t xTime);
// prvIPTimerStart
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 692
static void prvIPTimerStart(IPTimer_t *pxTimer, TickType_t xTime);
// prvIdleTask
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3295
static void prvIdleTask(void *pvParameters);
// prvIngestDataBlock
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1589
static IngestResult_t prvIngestDataBlock(OTA_FileContext_t *C, const char *pacRawMsg, uint32_t iMsgSize);
// prvInitialiseDHCP
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DHCP.c line 592
static void prvInitialiseDHCP(void);
// prvInitialiseMutex
// file ..\..\..\..\lib\FreeRTOS\queue.c line 452
static void prvInitialiseMutex(Queue_t *pxNewQueue);
// prvInitialiseNewQueue
// file ..\..\..\..\lib\FreeRTOS\queue.c line 408
static void prvInitialiseNewQueue(const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue);
// prvInitialiseNewStreamBuffer
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 1141
static void prvInitialiseNewStreamBuffer(StreamBuffer_t1 * const pxStreamBuffer, uint8_t * const pucBuffer, size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer);
// prvInitialiseNewTask
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 834
static void prvInitialiseNewTask(TaskFunction_t pxTaskCode, const char * const pcName, const uint32_t ulStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, TCB_t *pxNewTCB, const MemoryRegion_t * const xRegions);
// prvInitialiseNewTimer
// file ..\..\..\..\lib\FreeRTOS\timers.c line 352
static void prvInitialiseNewTimer(const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction, Timer_t *pxNewTimer);
// prvInitialiseTaskLists
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3507
static void prvInitialiseTaskLists(void);
// prvInitialize
// file ..\..\..\common\devmode_key_provisioning\aws_dev_mode_key_provisioning.c line 63
static CK_RV prvInitialize(CK_FUNCTION_LIST_PTR *ppxFunctionList, CK_SLOT_ID *pxSlotId, CK_SESSION_HANDLE *pxSession);
// prvInitializeClientCredential
// file ..\..\..\..\lib\tls\aws_tls.c line 257
static signed int prvInitializeClientCredential(TLSContext_t *pCtx);
// prvInitializeKey
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 237
static CK_RV prvInitializeKey(P11SessionPtr_t pxSessionObj, const char *pcEncodedKey, const uint32_t ulEncodedKeyLength, const char *pcEncodedCertificate, const uint32_t ulEncodedCertificateLength);
// prvInitiateMQTTConnect
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1345
static void prvInitiateMQTTConnect(MQTTEventData_t * const pxEventData);
// prvInitiateMQTTDisconnect
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1424
static void prvInitiateMQTTDisconnect(MQTTEventData_t * const pxEventData);
// prvInitiateMQTTPublish
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1551
static void prvInitiateMQTTPublish(MQTTEventData_t * const pxEventData);
// prvInitiateMQTTSubscribe
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1445
static void prvInitiateMQTTSubscribe(MQTTEventData_t * const pxEventData);
// prvInitiateMQTTUnSubscribe
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1500
static void prvInitiateMQTTUnSubscribe(MQTTEventData_t * const pxEventData);
// prvInsertBlockIntoFreeList
// file ..\..\..\..\lib\FreeRTOS\portable\MemMang\heap_4.c line 377
static void prvInsertBlockIntoFreeList(BlockLink_t *pxBlockToInsert);
// prvInsertTimerInActiveList
// file ..\..\..\..\lib\FreeRTOS\timers.c line 647
static BaseType_t prvInsertTimerInActiveList(Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime);
// prvInterruptSimulatorTask
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 500
static void prvInterruptSimulatorTask(void *pvParameters);
// prvInvokeCallback
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1775
static MQTTBool_t prvInvokeCallback(MQTTContext_t *pxMQTTContext, MQTTEventCallbackParams_t *pxEventCallbackParams);
// prvInvokeSubscriptionCallbacks
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 2133
static MQTTBool_t prvInvokeSubscriptionCallbacks(MQTTContext_t *pxMQTTContext, const MQTTPublishData_t *pxPublishData, MQTTBool_t *pxSubscriptionCallbackInvoked);
// prvIsIPaddress
// file ..\..\..\..\lib\greengrass\aws_helper_secure_connect.c line 340
static uint32_t prvIsIPaddress(const char *pcIPAddress);
// prvIsIPvalid
// file ..\..\..\..\lib\greengrass\aws_greengrass_discovery.c line 791
static BaseType_t prvIsIPvalid(const char *pcIP, uint32_t ulIPlength);
// prvIsMsgFromJobTopic
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 826
static uint8_t prvIsMsgFromJobTopic(MQTTPublishData_t xMsgMetaData);
// prvIsQueueEmpty
// file ..\..\..\..\lib\FreeRTOS\queue.c line 2258
static BaseType_t prvIsQueueEmpty(const Queue_t *pxQueue);
// prvIsQueueFull
// file ..\..\..\..\lib\FreeRTOS\queue.c line 2297
static BaseType_t prvIsQueueFull(const Queue_t *pxQueue);
// prvIsStringEqual
// file ..\..\..\common\shadow\aws_shadow_lightbulb_on_off.c line 205
static BaseType_t prvIsStringEqual(const char * const pcJson, const jsmntok_t * const pxTok, const char * const pcString);
// prvIsTimeElapsed
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1063
static MQTTBool_t prvIsTimeElapsed(uint64_t *pxRecordedTickCount, uint64_t xCurrentTickCount, uint32_t *pulRemainingTicks);
// prvListTasksWithinSingleList
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3666
static UBaseType_t prvListTasksWithinSingleList(TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState);
// prvLoadAndInitializeDefaultCertificateAndKey
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 309
static CK_RV prvLoadAndInitializeDefaultCertificateAndKey(P11SessionPtr_t pxSession);
// prvLogToFile
// file ..\common\application_code\aws_demo_logging.c line 575
static void prvLogToFile(const char *pcMessage, size_t xLength);
// prvLoggingFlushBuffer
// file ..\common\application_code\aws_demo_logging.c line 476
static void prvLoggingFlushBuffer(void);
// prvMQTTCallback
// file ..\..\..\common\mqtt\aws_hello_world.c line 380
static MQTTBool_t prvMQTTCallback(void *pvUserData, const MQTTPublishData_t * const pxPublishParameters);
// prvMQTTCallback$link1
// file ..\..\..\common\mqtt\aws_subscribe_publish_loop.c line 217
static BaseType_t prvMQTTCallback$link1(void *pvUserData$link1, const MQTTAgentCallbackParams_t * const pxCallbackParams);
// prvMQTTClientSocketWakeupCallback
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1026
static void prvMQTTClientSocketWakeupCallback(Socket_t pxSocket);
// prvMQTTConnect
// file ..\..\..\common\greengrass_connectivity\aws_greengrass_discovery_demo.c line 150
static BaseType_t prvMQTTConnect(GGD_HostAddressData_t *pxHostAddressData);
// prvMQTTConnectAndPublishTask
// file ..\..\..\common\mqtt\aws_hello_world.c line 436
static void prvMQTTConnectAndPublishTask(void *pvParameters);
// prvMQTTEventCallback
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 674
static MQTTBool_t prvMQTTEventCallback(void *pvCallbackContext, const MQTTEventCallbackParams_t * const pxParams);
// prvMQTTGetTicks
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 738
static void prvMQTTGetTicks(uint64_t *pxCurrentTickCount);
// prvMQTTSendCallback
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 616
static uint32_t prvMQTTSendCallback(void *pvSendContext, const uint8_t * const pucData, uint32_t ulDataLength);
// prvMQTTStringPublishCallback
// file ..\..\..\common\mqtt\aws_subscribe_publish_loop.c line 241
static MQTTBool_t prvMQTTStringPublishCallback(void *pvCallbackContext, const MQTTPublishData_t * const pxPublishData);
// prvMQTTTask
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1733
static void prvMQTTTask(void *pvParameters);
// prvMQTTUint32PublishCallback
// file ..\..\..\common\mqtt\aws_subscribe_publish_loop.c line 285
static MQTTBool_t prvMQTTUint32PublishCallback(void *pvCallbackContext, const MQTTPublishData_t * const pxPublishData);
// prvManageConnections
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1256
static TickType_t prvManageConnections(void);
// prvMarkObjectAsUsed
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2411
void prvMarkObjectAsUsed(traceObjectClass objectclass, traceHandle handle);
// prvMatchCallbackTopic
// file ..\..\..\..\lib\shadow\aws_shadow.c line 904
static const CallbackCatalogEntry_t * prvMatchCallbackTopic(const ShadowClient_t * const pxShadowClient, const uint8_t * const pucTopic, uint16_t usTopicLength, ShadowOperationName_t * const pxOperationName);
// prvMemPrint
// file ..\..\..\..\lib\ota\aws_rsprintf.c line 518
static char * prvMemPrint(uint8_t *ptr, uint32_t len, uint8_t bUseIsPrint, uint8_t bConsoleOut, char *acSmallBuf, char *dptr);
// prvMessageEchoingTask
// file ..\..\..\common\mqtt\aws_hello_world.c line 282
static void prvMessageEchoingTask(void *pvParameters);
// prvMiscInitialisation
// file ..\common\application_code\main.c line 265
static void prvMiscInitialisation(void);
// prvNetworkRecv
// file ..\..\..\..\lib\secure_sockets\portable\freertos_plus_tcp\aws_secure_sockets.c line 74
static BaseType_t prvNetworkRecv(void *pvContext, unsigned char *pucReceiveBuffer, size_t xReceiveLength);
// prvNetworkRecv$link1
// file ..\..\..\..\lib\tls\aws_tls.c line 156
static signed int prvNetworkRecv$link1(void *pvContext$link1, unsigned char *pucReceiveBuffer$link1, size_t xReceiveLength$link1);
// prvNetworkSend
// file ..\..\..\..\lib\secure_sockets\portable\freertos_plus_tcp\aws_secure_sockets.c line 61
static BaseType_t prvNetworkSend(void *pvContext, const unsigned char *pucData, size_t xDataLength);
// prvNetworkSend$link1
// file ..\..\..\..\lib\tls\aws_tls.c line 138
static signed int prvNetworkSend$link1(void *pvContext$link1, const unsigned char *pucData$link1, size_t xDataLength$link1);
// prvNotifyRequestingTask
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1232
static void prvNotifyRequestingTask(MQTTNotificationData_t * const pxNotificationData, MQTTNotifyCodes_t xNotificationCode, UBaseType_t uxStatus);
// prvOTAPublishCallback
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 788
static MQTTBool_t prvOTAPublishCallback(void *pvCallbackContext, const MQTTPublishData_t * const pxPublishData);
// prvOTAUpdateTask
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 849
static void prvOTAUpdateTask(MQTTAgentHandle_t xPubSubClientHandle);
// prvOTA_Close
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1057
static uint8_t prvOTA_Close(OTA_FileContext_t * const C);
// prvOpenInterface
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 302
static signed int prvOpenInterface(const char *pucName);
// prvOpenSelectedNetworkInterface
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 340
static void prvOpenSelectedNetworkInterface(pcap_if_t *pxAllNetworkInterfaces);
// prvPacketTypeFlagsGetTxBuffer
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 891
static MQTTBufferHandle_t prvPacketTypeFlagsGetTxBuffer(MQTTContext_t *pxMQTTContext, uint8_t ucPacketType, uint8_t ucFlags);
// prvPacketTypeFlagsIdentifierGetTxBuffer
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 924
static MQTTBufferHandle_t prvPacketTypeFlagsIdentifierGetTxBuffer(MQTTContext_t *pxMQTTContext, uint8_t ucPacketType, uint8_t ucFlags, uint16_t prvPacketTypeFlagsIdentifierGetTxBuffer$$usPacketIdentifier);
// prvPacketTypeIdentifierGetTxBuffer
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 959
static MQTTBufferHandle_t prvPacketTypeIdentifierGetTxBuffer(MQTTContext_t *pxMQTTContext, uint8_t ucPacketType, uint16_t prvPacketTypeIdentifierGetTxBuffer$$usPacketIdentifier);
// prvParseDNSReply
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DNS.c line 858
uint32_t prvParseDNSReply(uint8_t *pucUDPPayloadBuffer, size_t xBufferLength, TickType_t xIdentifier);
// prvParseJSON
// file ..\..\..\..\lib\shadow\aws_shadow_json.c line 175
static int16_t prvParseJSON(const char * const pcDoc, uint32_t ulDocLength, jsmntok_t *pxJSMNTokens);
// prvParseJobDocFromJSON
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1164
static OTA_FileContext_t * prvParseJobDocFromJSON(const char *pacRawMsg, uint32_t iMsgLen);
// prvParseShadowOperationStatus
// file ..\..\..\..\lib\shadow\aws_shadow.c line 869
static ShadowReturnCode_t prvParseShadowOperationStatus(const uint8_t * const pucTopic, uint16_t usTopicLength);
// prvPrintAvailableNetworkInterfaces
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 231
static pcap_if_t * prvPrintAvailableNetworkInterfaces(void);
// prvPrivateKeySigningCallback
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 168
static signed int prvPrivateKeySigningCallback(void *pvContext, mbedtls_md_type_t xMdAlg, const unsigned char *pucHash, unsigned int uiHashLen, unsigned char *pucSig, size_t *pxSigLen, signed int (*piRng)(void *, unsigned char *, size_t), void *pvRng);
// prvProcessDHCPReplies
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DHCP.c line 615
static BaseType_t prvProcessDHCPReplies(BaseType_t xExpectedMessageType);
// prvProcessDNSCache
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DNS.c line 1340
static void prvProcessDNSCache(const char *pcName, uint32_t *pulIP, uint32_t ulTTL, BaseType_t xLookUp);
// prvProcessEthernetPacket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 1345
static void prvProcessEthernetPacket(NetworkBufferDescriptor_t * const pxNetworkBuffer);
// prvProcessExpiredTimer
// file ..\..\..\..\lib\FreeRTOS\timers.c line 462
static void prvProcessExpiredTimer(const TickType_t xNextExpireTime, const TickType_t xTimeNow);
// prvProcessICMPEchoRequest
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 1713
static eFrameProcessingResult_t prvProcessICMPEchoRequest(ICMPPacket_t * const pxICMPPacket);
// prvProcessICMPPacket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 1761
static eFrameProcessingResult_t prvProcessICMPPacket(ICMPPacket_t * const pxICMPPacket);
// prvProcessIPPacket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 1509
static eFrameProcessingResult_t prvProcessIPPacket(IPPacket_t * const pxIPPacket, NetworkBufferDescriptor_t * const pxNetworkBuffer);
// prvProcessNetworkDownEvent
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 1271
static void prvProcessNetworkDownEvent(void);
// prvProcessOTAJobMsg
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1511
static OTA_FileContext_t * prvProcessOTAJobMsg(const char *pacRawMsg, uint32_t iMsgLen);
// prvProcessReceivedCONNACK
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1055
static void prvProcessReceivedCONNACK(MQTTBrokerConnection_t * const pxConnection, const MQTTEventCallbackParams_t * const pxParams);
// prvProcessReceivedCONNACK$link1
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1190
static void prvProcessReceivedCONNACK$link1(MQTTContext_t *pxMQTTContext);
// prvProcessReceivedCommands
// file ..\..\..\..\lib\FreeRTOS\timers.c line 688
static void prvProcessReceivedCommands(void);
// prvProcessReceivedDisconnect
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1189
static void prvProcessReceivedDisconnect(MQTTBrokerConnection_t * const pxConnection, const MQTTEventCallbackParams_t * const pxParams);
// prvProcessReceivedFixedHeaderOnlyMQTTPacket
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1124
static void prvProcessReceivedFixedHeaderOnlyMQTTPacket(MQTTContext_t *pxMQTTContext);
// prvProcessReceivedMQTTPacket
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1147
static void prvProcessReceivedMQTTPacket(MQTTContext_t *pxMQTTContext);
// prvProcessReceivedPINGRESP
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1618
static void prvProcessReceivedPINGRESP(MQTTContext_t *pxMQTTContext);
// prvProcessReceivedPUBACK
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1130
static void prvProcessReceivedPUBACK(MQTTBrokerConnection_t * const pxConnection, const MQTTEventCallbackParams_t * const pxParams);
// prvProcessReceivedPUBACK$link1
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1538
static void prvProcessReceivedPUBACK$link1(MQTTContext_t *pxMQTTContext);
// prvProcessReceivedPublish
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1148
static BaseType_t prvProcessReceivedPublish(MQTTBrokerConnection_t * const pxConnection, const MQTTEventCallbackParams_t * const pxParams);
// prvProcessReceivedPublish$link1
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1672
static void prvProcessReceivedPublish$link1(MQTTContext_t *pxMQTTContext);
// prvProcessReceivedSUBACK
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1087
static void prvProcessReceivedSUBACK(MQTTBrokerConnection_t * const pxConnection, const MQTTEventCallbackParams_t * const pxParams);
// prvProcessReceivedSUBACK$link1
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1346
static void prvProcessReceivedSUBACK$link1(MQTTContext_t *pxMQTTContext);
// prvProcessReceivedTimeout
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1171
static void prvProcessReceivedTimeout(MQTTBrokerConnection_t * const pxConnection, const MQTTEventCallbackParams_t * const pxParams);
// prvProcessReceivedUNSUBACK
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1112
static void prvProcessReceivedUNSUBACK(MQTTBrokerConnection_t * const pxConnection, const MQTTEventCallbackParams_t * const pxParams);
// prvProcessReceivedUNSUBACK$link1
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1450
static void prvProcessReceivedUNSUBACK$link1(MQTTContext_t *pxMQTTContext);
// prvProcessSimulatedInterrupts
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 350
static void prvProcessSimulatedInterrupts(void);
// prvProcessTickInterrupt
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 338
static uint32_t prvProcessTickInterrupt(void);
// prvProcessTimerOrBlockTask
// file ..\..\..\..\lib\FreeRTOS\timers.c line 538
static void prvProcessTimerOrBlockTask(const TickType_t xNextExpireTime, BaseType_t xListWasEmpty);
// prvProcessYieldInterrupt
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 332
static uint32_t prvProcessYieldInterrupt(void);
// prvPublishGetStreamMessage
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 714
static OTA_Err_t prvPublishGetStreamMessage(OTA_FileContext_t *C, char *pcOTA_DynamicTopic);
// prvPublishMessage
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1923
static MQTTAgentReturnCode_t prvPublishMessage(void * const pvClient, const char * const pacTopic, uint16_t usTopicLen, char *pacMsg, uint32_t ulMsgSize, MQTTQoS_t eQOS);
// prvPublishNextMessage
// file ..\..\..\common\mqtt\aws_hello_world.c line 240
static void prvPublishNextMessage(BaseType_t xMessageNumber);
// prvPublishSubscribeTask
// file ..\..\..\common\mqtt\aws_subscribe_publish_loop.c line 683
static void prvPublishSubscribeTask(void *pvParameters);
// prvReadAndAssumeCertificate
// file ..\..\..\..\lib\ota\portable\pc\windows\aws_ota_pal.c line 196
static uint8_t * prvReadAndAssumeCertificate(const uint8_t * const pucCertName, int32_t * const lSignerCertSize);
// prvReadBytesFromBuffer
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 1066
static size_t prvReadBytesFromBuffer(StreamBuffer_t1 *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable);
// prvReadMessageFromBuffer
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 852
static size_t prvReadMessageFromBuffer(StreamBuffer_t1 *pxStreamBuffer, void *pvRxData, size_t xBufferLengthBytes, size_t xBytesAvailable, size_t xBytesToStoreMessageLength);
// prvReadNameField
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DNS.c line 675
static uint8_t * prvReadNameField(uint8_t *pucByte, size_t xSourceLen, char *pcName, size_t xDestLen);
// prvRegisterCallback
// file ..\..\..\..\lib\shadow\aws_shadow.c line 511
static ShadowReturnCode_t prvRegisterCallback(BaseType_t xShadowClientID, const void ** const ppvOldCallback, const void ** const ppvNewCallback, const char * const pcThingName, const uint8_t * const pucTopicFormat, TickType_t xTimeoutTicks);
// prvRemoveSpaces
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 608
static const char * prvRemoveSpaces(char *pcBuffer, signed int aBuflen, const char *pcMessage);
// prvRemoveSubscription
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 2063
static void prvRemoveSubscription(MQTTContext_t *pxMQTTContext, const uint8_t * const pucTopic, uint16_t usTopicLength);
// prvRemoveSubscriptionForSubscribeOrUnsubscribeBuffer
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 2098
static void prvRemoveSubscriptionForSubscribeOrUnsubscribeBuffer(MQTTContext_t *pxMQTTContext, MQTTBufferHandle_t xBuffer);
// prvRequestTimer_Callback
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1003
static void prvRequestTimer_Callback(TimerHandle_t T);
// prvResetMQTTContext
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1004
static void prvResetMQTTContext(MQTTContext_t *pxMQTTContext);
// prvResetNextTaskUnblockTime
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3801
static void prvResetNextTaskUnblockTime(void);
// prvResetRxMessageState
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 992
static void prvResetRxMessageState(MQTTContext_t *pxMQTTContext);
// prvRetrieveNotificationData
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 823
static MQTTNotificationData_t * prvRetrieveNotificationData(MQTTBrokerConnection_t * const pxConnection, uint16_t prvRetrieveNotificationData$$usPacketIdentifier);
// prvReturnBuffer
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 874
static void prvReturnBuffer(MQTTContext_t *pxMQTTContext, MQTTBufferHandle_t xBuffer);
// prvReturnConnection
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 785
static void prvReturnConnection(UBaseType_t uxBrokerNumber);
// prvSampleTimeNow
// file ..\..\..\..\lib\FreeRTOS\timers.c line 624
static TickType_t prvSampleTimeNow(BaseType_t * const pxTimerListsWereSwitched);
// prvSaveTraceFile
// file ..\common\application_code\main.c line 456
static void prvSaveTraceFile(void);
// prvSendCommandToMQTTTask
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1616
static MQTTAgentReturnCode_t prvSendCommandToMQTTTask(MQTTEventData_t *pxEventData);
// prvSendDHCPDiscover
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DHCP.c line 938
static void prvSendDHCPDiscover(void);
// prvSendDHCPRequest
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DHCP.c line 899
static void prvSendDHCPRequest(void);
// prvSendData
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 2521
static BaseType_t prvSendData(FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkBuffer, uint32_t ulReceiveLength, BaseType_t xSendLength);
// prvSendData$link1
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1102
static MQTTReturnCode_t prvSendData$link1(MQTTContext_t *pxMQTTContext, const uint8_t * const pucData, uint32_t ulDataLength);
// prvSendMessageToGGC
// file ..\..\..\common\greengrass_connectivity\aws_greengrass_discovery_demo.c line 92
static void prvSendMessageToGGC(GGD_HostAddressData_t *pxHostAddressData);
// prvServerConnectionInstance
// file ..\..\..\common\tcp\aws_simple_tcp_echo_server.c line 160
static void prvServerConnectionInstance(void *pvParameters);
// prvSessionPointerFromHandle
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 149
P11SessionPtr_t prvSessionPointerFromHandle(CK_SESSION_HANDLE xSession);
// prvSetImageState
// file ..\..\..\..\lib\ota\portable\pc\windows\aws_ota_pal.c line 115
static OTA_Err_t prvSetImageState(OTA_ImageState_t eState);
// prvSetOptions
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 2204
static UBaseType_t prvSetOptions(FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxNetworkBuffer);
// prvSetSubscribedFlag
// file ..\..\..\..\lib\shadow\aws_shadow.c line 1296
static void prvSetSubscribedFlag(ShadowClient_t * const pxShadowClient, ShadowOperationName_t xOperationName, BaseType_t ucValue);
// prvSetSynAckOptions
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 1356
static UBaseType_t prvSetSynAckOptions(FreeRTOS_Socket_t *pxSocket, TCPPacket_t *pxTCPPacket);
// prvSetupConnection
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 847
static BaseType_t prvSetupConnection(const MQTTEventData_t * const pxEventData);
// prvSetupPkcs11SigningForMbedTls
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 213
static CK_RV prvSetupPkcs11SigningForMbedTls(P11SessionPtr_t pxSessionObj, P11KeyPtr_t pxKeyObj);
// prvShadowClientCreateConnect
// file ..\..\..\common\shadow\aws_shadow_lightbulb_on_off.c line 331
static ShadowReturnCode_t prvShadowClientCreateConnect(void);
// prvShadowDeleteCallback
// file ..\..\..\..\lib\shadow\aws_shadow.c line 1070
static void prvShadowDeleteCallback(BaseType_t xShadowClientID, ShadowReturnCode_t xResult, const char * const pcData, uint32_t ulDataLength);
// prvShadowGetCallback
// file ..\..\..\..\lib\shadow\aws_shadow.c line 1036
static void prvShadowGetCallback(BaseType_t xShadowClientID, ShadowReturnCode_t xResult, ShadowOperationParams_t * const pxParams, const char * const pcData, uint32_t ulDataLength, MQTTBufferHandle_t xBuffer);
// prvShadowInitTask
// file ..\..\..\common\shadow\aws_shadow_lightbulb_on_off.c line 428
static void prvShadowInitTask(void *pvParameters);
// prvShadowMQTTCallback
// file ..\..\..\..\lib\shadow\aws_shadow.c line 715
static BaseType_t prvShadowMQTTCallback(void *pvUserData, const MQTTAgentCallbackParams_t * const pxCallbackParams);
// prvShadowOperation
// file ..\..\..\..\lib\shadow\aws_shadow.c line 1137
static ShadowReturnCode_t prvShadowOperation(ShadowOperationCallParams_t *pxParams);
// prvShadowSubscribeToAcceptedRejected
// file ..\..\..\..\lib\shadow\aws_shadow.c line 578
static ShadowReturnCode_t prvShadowSubscribeToAcceptedRejected(BaseType_t xShadowClientID, const char * const pcThingName, const char * const pcAcceptedTopic, const char * const pcRejectedTopic, TimeOutData_t * const pxTimeOutData);
// prvShadowUnsubscribeFromAcceptedRejected
// file ..\..\..\..\lib\shadow\aws_shadow.c line 659
static ShadowReturnCode_t prvShadowUnsubscribeFromAcceptedRejected(BaseType_t xShadowClientID, const char * const pcThingName, const char * const pcAcceptedTopic, const char * const pcRejectedTopic, TimeOutData_t * const pxTimeOutData);
// prvShadowUpdateCallback
// file ..\..\..\..\lib\shadow\aws_shadow.c line 996
static void prvShadowUpdateCallback(BaseType_t xShadowClientID, ShadowReturnCode_t xResult, const ShadowOperationParams_t * const pxParams, const char * const pcData, uint32_t ulDataLength);
// prvSimulatedPeripheralTimer
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 126
static DWORD prvSimulatedPeripheralTimer(LPVOID lpParameter);
// prvSizeOfRemainingLength
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1848
static uint8_t prvSizeOfRemainingLength(uint32_t ulRemainingLength);
// prvSkipNameField
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DNS.c line 750
static uint8_t * prvSkipNameField(uint8_t *pucByte, size_t xSourceLen);
// prvSocketSetMSS
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 2869
static void prvSocketSetMSS(FreeRTOS_Socket_t *pxSocket);
// prvSocketsGetCryptoSession
// file ..\..\..\..\lib\secure_sockets\portable\freertos_plus_tcp\aws_secure_sockets.c line 525
static CK_RV prvSocketsGetCryptoSession(CK_SESSION_HANDLE *pxSession, CK_FUNCTION_LIST_PTR_PTR ppxFunctionList);
// prvStartRequestTimer
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1018
static void prvStartRequestTimer(OTA_FileContext_t *C);
// prvStopRequestTimer
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1045
static void prvStopRequestTimer(OTA_FileContext_t *C);
// prvStoreNotificationData
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 799
static MQTTNotificationData_t * prvStoreNotificationData(MQTTBrokerConnection_t * const pxConnection, const MQTTEventData_t * const pxEventData);
// prvStoreRxData
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 2127
static BaseType_t prvStoreRxData(FreeRTOS_Socket_t *pxSocket, uint8_t *pucRecvData, NetworkBufferDescriptor_t *pxNetworkBuffer, uint32_t ulReceiveLength);
// prvStoreSubscription
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1982
static MQTTBool_t prvStoreSubscription(MQTTContext_t *pxMQTTContext, const uint8_t * const pucTopic, uint16_t usTopicLength, void *pvPublishCallbackContext, MQTTPublishCallback_t pxPublishCallback);
// prvStringPublishSubscribe
// file ..\..\..\common\mqtt\aws_subscribe_publish_loop.c line 458
static BaseType_t prvStringPublishSubscribe(MQTTAgentConnectParams_t *pxConnectParams, MQTTQoS_t xQOS, MQTTAgentHandle_t prvStringPublishSubscribe$$xMQTTClientHandle, SubpubUserData_t *pxUserData);
// prvStrncpy
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2422
static void prvStrncpy(char *dst, const char *src, uint32_t maxLength);
// prvSubscribe
// file ..\..\..\common\mqtt\aws_hello_world.c line 347
static BaseType_t prvSubscribe(void);
// prvSubscribePublishDemo
// file ..\..\..\common\mqtt\aws_subscribe_publish_loop.c line 595
static void prvSubscribePublishDemo(MQTTAgentHandle_t prvSubscribePublishDemo$$xMQTTClientHandle, BaseType_t xSecureConnection);
// prvSubscribeToDataStream
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1835
static uint8_t prvSubscribeToDataStream(OTA_FileContext_t *C);
// prvSubscribeToJobNotificationTopic
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1805
static uint8_t prvSubscribeToJobNotificationTopic(void);
// prvSwitchTimerLists
// file ..\..\..\..\lib\FreeRTOS\timers.c line 835
static void prvSwitchTimerLists(void);
// prvTCPAddTxData
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 1926
static void prvTCPAddTxData(FreeRTOS_Socket_t *pxSocket);
// prvTCPBufferResize
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 1606
static NetworkBufferDescriptor_t * prvTCPBufferResize(FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxNetworkBuffer, int32_t lDataLen, UBaseType_t uxOptionsLength);
// prvTCPConnectStart
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 1935
static BaseType_t prvTCPConnectStart(FreeRTOS_Socket_t *pxSocket, struct freertos_sockaddr *pxAddress);
// prvTCPCreateStream
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 2879
static const StreamBuffer_t * prvTCPCreateStream(FreeRTOS_Socket_t *pxSocket, BaseType_t xIsInputStream);
// prvTCPCreateWindow
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 953
static void prvTCPCreateWindow(FreeRTOS_Socket_t *pxSocket);
// prvTCPHandleFin
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 1967
static BaseType_t prvTCPHandleFin(FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxNetworkBuffer);
// prvTCPHandleState
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 2674
static BaseType_t prvTCPHandleState(FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkBuffer);
// prvTCPNextTimeout
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 1863
static TickType_t prvTCPNextTimeout(FreeRTOS_Socket_t *pxSocket);
// prvTCPPrepareConnect
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 977
static BaseType_t prvTCPPrepareConnect(FreeRTOS_Socket_t *pxSocket);
// prvTCPPrepareSend
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 1678
static int32_t prvTCPPrepareSend(FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkBuffer, UBaseType_t uxOptionsLength);
// prvTCPReturnPacket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 677
static void prvTCPReturnPacket(FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxNetworkBuffer, uint32_t ulLen, BaseType_t xReleaseAfterSend);
// prvTCPSendCheck
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 2367
static int32_t prvTCPSendCheck(FreeRTOS_Socket_t *pxSocket, size_t xDataLength);
// prvTCPSendPacket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 562
static int32_t prvTCPSendPacket(FreeRTOS_Socket_t *pxSocket);
// prvTCPSendRepeated
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 637
static int32_t prvTCPSendRepeated(FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkBuffer);
// prvTCPSendReset
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 2847
static BaseType_t prvTCPSendReset(NetworkBufferDescriptor_t *pxNetworkBuffer);
// prvTCPSetSocketCount
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 1244
static void prvTCPSetSocketCount(FreeRTOS_Socket_t *pxSocketToDelete);
// prvTCPSocketCopy
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 3171
static BaseType_t prvTCPSocketCopy(FreeRTOS_Socket_t *pxNewSocket, FreeRTOS_Socket_t *pxSocket);
// prvTCPSocketIsActive
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 366
static BaseType_t prvTCPSocketIsActive(UBaseType_t uxStatus);
// prvTCPStatusAgeCheck
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 384
static BaseType_t prvTCPStatusAgeCheck(FreeRTOS_Socket_t *pxSocket);
// prvTCPTouchSocket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 1407
static void prvTCPTouchSocket(FreeRTOS_Socket_t *pxSocket);
// prvTCPWindowFastRetransmit
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 1578
static uint32_t prvTCPWindowFastRetransmit(TCPWindow_t *pxWindow, uint32_t ulFirst);
// prvTCPWindowTxCheckAck
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 1427
static uint32_t prvTCPWindowTxCheckAck(TCPWindow_t *pxWindow, uint32_t ulFirst, uint32_t ulLast);
// prvTCPWindowTxHasSpace
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 1124
static BaseType_t prvTCPWindowTxHasSpace(TCPWindow_t *pxWindow, uint32_t ulWindowSize);
// prvTaskCheckFreeStackSpace
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3699
static uint16_t prvTaskCheckFreeStackSpace(const uint8_t *pucStackByte);
// prvTaskIsTaskSuspended
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 1742
static BaseType_t prvTaskIsTaskSuspended(const TaskHandle_t xTask);
// prvTestWaitCondition
// file ..\..\..\..\lib\FreeRTOS\event_groups.c line 656
static BaseType_t prvTestWaitCondition(const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits);
// prvTimerTask
// file ..\..\..\..\lib\FreeRTOS\timers.c line 502
static void prvTimerTask(void *pvParameters);
// prvTraceCreateSymbolTableEntry
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2812
static uint16_t prvTraceCreateSymbolTableEntry(const char *name, uint8_t crc6, uint8_t len, traceString channel);
// prvTraceError
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2537
void prvTraceError(const char *msg);
// prvTraceFreeObjectHandle
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2380
void prvTraceFreeObjectHandle(traceObjectClass objectclass, traceHandle handle);
// prvTraceGetChecksum
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2873
static void prvTraceGetChecksum(const char *pname, uint8_t *pcrc, uint8_t *plength);
// prvTraceGetCurrentTaskHandle
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcKernelPort.c line 452
void * prvTraceGetCurrentTaskHandle(void);
// prvTraceGetDTS
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2651
static uint16_t prvTraceGetDTS(uint16_t param_maxDTS);
// prvTraceGetObjectHandle
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2334
traceHandle prvTraceGetObjectHandle(traceObjectClass objectclass);
// prvTraceGetObjectNumber
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcKernelPort.c line 463
traceHandle prvTraceGetObjectNumber(void *handle);
// prvTraceGetObjectState
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2121
static uint8_t prvTraceGetObjectState(uint8_t objectclass, traceHandle id);
// prvTraceGetObjectType
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcKernelPort.c line 469
uint8_t prvTraceGetObjectType(void *handle);
// prvTraceGetParam
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 1854
static uint32_t prvTraceGetParam(uint32_t param_max, uint32_t param);
// prvTraceGetPriorityProperty
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2101
uint8_t prvTraceGetPriorityProperty(uint8_t objectclass, traceHandle id);
// prvTraceGetTaskNumber
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcKernelPort.c line 474
traceHandle prvTraceGetTaskNumber(void *handle);
// prvTraceInitTraceData
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2186
static void prvTraceInitTraceData(void);
// prvTraceIsSchedulerSuspended
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcKernelPort.c line 593
unsigned char prvTraceIsSchedulerSuspended(void);
// prvTraceLookupSymbolTableEntry
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2769
static traceString prvTraceLookupSymbolTableEntry(const char *name, uint8_t crc6, uint8_t len, traceString chn);
// prvTraceNextFreeEventBufferSlot
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2299
static void * prvTraceNextFreeEventBufferSlot(void);
// prvTraceOpenSymbol
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2477
static traceString prvTraceOpenSymbol(const char *name, traceString userEventChannel);
// prvTracePortGetTimeStamp
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 3010
void prvTracePortGetTimeStamp(uint32_t *pTimestamp);
// prvTraceSetObjectName
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2439
void prvTraceSetObjectName(traceObjectClass objectclass, traceHandle handle, const char *name);
// prvTraceSetObjectState
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2111
void prvTraceSetObjectState(uint8_t objectclass, traceHandle id, uint8_t value);
// prvTraceSetPriorityProperty
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2091
void prvTraceSetPriorityProperty(uint8_t objectclass, traceHandle id, uint8_t value);
// prvTraceSetReadyEventsEnabled
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 1515
void prvTraceSetReadyEventsEnabled(signed int status);
// prvTraceSetTaskInstanceFinished
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2131
void prvTraceSetTaskInstanceFinished(traceHandle handle);
// prvTraceStoreKernelCall
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 1723
void prvTraceStoreKernelCall(uint32_t ecode, traceObjectClass objectClass, uint32_t objectNumber);
// prvTraceStoreKernelCallWithNumericParamOnly
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 1888
void prvTraceStoreKernelCallWithNumericParamOnly(uint32_t evtcode, uint32_t param);
// prvTraceStoreKernelCallWithParam
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 1789
void prvTraceStoreKernelCallWithParam(uint32_t evtcode, traceObjectClass objectClass, uint32_t objectNumber, uint32_t param);
// prvTraceStoreLowPower
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 1592
void prvTraceStoreLowPower(uint32_t flag);
// prvTraceStoreObjectNameOnCloseEvent
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2030
void prvTraceStoreObjectNameOnCloseEvent(traceHandle handle, traceObjectClass objectclass);
// prvTraceStoreObjectPropertiesOnCloseEvent
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2060
void prvTraceStoreObjectPropertiesOnCloseEvent(traceHandle handle, traceObjectClass objectclass);
// prvTraceStoreTaskReady
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 1525
void prvTraceStoreTaskReady(traceHandle handle);
// prvTraceStoreTaskswitch
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 1943
void prvTraceStoreTaskswitch(traceHandle task_handle);
// prvTraceTaskInstanceFinish
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 438
static void prvTraceTaskInstanceFinish(int8_t direct);
// prvTraceUpdateCounters
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2615
static void prvTraceUpdateCounters(void);
// prvTraceUserEventFormat
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 897
static uint8_t prvTraceUserEventFormat(const char *formatStr, va_list vl, uint8_t *buffer, uint8_t byteOffset);
// prvUint32PublishSubscribe
// file ..\..\..\common\mqtt\aws_subscribe_publish_loop.c line 328
static BaseType_t prvUint32PublishSubscribe(MQTTAgentConnectParams_t *pxConnectParams, MQTTQoS_t xQOS, MQTTAgentHandle_t prvUint32PublishSubscribe$$xMQTTClientHandle, SubpubUserData_t *pxUserData);
// prvUnSubscribeFromDataStream
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1866
static uint8_t prvUnSubscribeFromDataStream(OTA_FileContext_t *C);
// prvUnSubscribeFromJobNotificationTopic
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1899
static uint8_t prvUnSubscribeFromJobNotificationTopic(void);
// prvUnlockQueue
// file ..\..\..\..\lib\FreeRTOS\queue.c line 2138
static void prvUnlockQueue(Queue_t * const pxQueue);
// prvUpdateJobStatus
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 620
static void prvUpdateJobStatus(OTA_FileContext_t *C, char *pcOTA_DynamicTopic, OTA_JobStatus_t eStatus, int32_t lReason);
// prvUpdateQueueTask
// file ..\..\..\common\shadow\aws_shadow_lightbulb_on_off.c line 289
static void prvUpdateQueueTask(void *pvParameters);
// prvValidSocket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 168
static BaseType_t prvValidSocket(FreeRTOS_Socket_t *pxSocket, BaseType_t xProtocol, BaseType_t xIsBound);
// prvVerifySignature
// file ..\..\..\..\lib\crypto\aws_crypto.c line 78
static BaseType_t prvVerifySignature(char *pcSignerCertificate, size_t xSignerCertificateLength, BaseType_t xHashAlgorithm, uint8_t *pucHash, size_t xHashLength, uint8_t *pucSignature, size_t xSignatureLength);
// prvWin32LoggingThread
// file ..\common\application_code\aws_demo_logging.c line 520
static DWORD prvWin32LoggingThread(void *pvParameter);
// prvWinPcapRecvThread
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 453
DWORD prvWinPcapRecvThread(void *pvParam);
// prvWinPcapSendThread
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 467
DWORD prvWinPcapSendThread(void *pvParam);
// prvWinScaleFactor
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 1325
static uint8_t prvWinScaleFactor(FreeRTOS_Socket_t *pxSocket);
// prvWriteBlock
// file ..\..\..\..\lib\ota\portable\pc\windows\aws_ota_pal.c line 236
static int16_t prvWriteBlock(OTA_FileContext_t * const C, int32_t iOffset, uint8_t * const pacData, uint32_t iBlockSize);
// prvWriteBytesToBuffer
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 1020
static size_t prvWriteBytesToBuffer(StreamBuffer_t1 * const pxStreamBuffer, const uint8_t *pucData, size_t xCount);
// prvWriteMessageToBuffer
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 639
static size_t prvWriteMessageToBuffer(StreamBuffer_t1 * const pxStreamBuffer, const void *pvTxData, size_t xDataLengthBytes, size_t xSpace, size_t xRequiredSpace);
// prvWriteNameToBuffer
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 4204
static char * prvWriteNameToBuffer(char *pcBuffer, const char *pcTaskName);
// prvWriteString
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1815
static uint8_t * prvWriteString(uint8_t *pucDestination, const uint8_t * const pucLastByteInBuffer, const uint8_t * const pucString, uint16_t usStringLength);
// pszTraceGetErrorNotEnoughHandles
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcKernelPort.c line 535
const char * pszTraceGetErrorNotEnoughHandles(traceObjectClass objectclass);
// pucGetNetworkBuffer
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\BufferManagement\BufferAllocation_2.c line 157
uint8_t * pucGetNetworkBuffer(size_t *pxRequestedSizeBytes);
// put16
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 210
static inline void put16(void *where, uint16_t v);
// put32
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 227
static inline void put32(void *where, uint32_t v);
// put64
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 233
static inline void put64(void *where, uint64_t v);
// pvPortMalloc
// file ..\..\..\..\lib\FreeRTOS\portable\MemMang\heap_4.c line 113
void * pvPortMalloc(size_t xWantedSize);
// pvTaskGetThreadLocalStoragePointer
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3470
void * pvTaskGetThreadLocalStoragePointer(TaskHandle_t xTaskToQuery, BaseType_t xIndex);
// pvTaskIncrementMutexHeldCount
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 4469
void * pvTaskIncrementMutexHeldCount(void);
// pvTimerGetTimerID
// file ..\..\..\..\lib\FreeRTOS\timers.c line 966
void * pvTimerGetTimerID(const TimerHandle_t xTimer);
// pxDuplicateNetworkBufferWithDescriptor
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 822
NetworkBufferDescriptor_t * pxDuplicateNetworkBufferWithDescriptor(NetworkBufferDescriptor_t * const pxNetworkBuffer, BaseType_t xNewLength);
// pxGetNetworkBufferWithDescriptor
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\BufferManagement\BufferAllocation_2.c line 208
NetworkBufferDescriptor_t * pxGetNetworkBufferWithDescriptor(size_t xRequestedSizeBytes, TickType_t xBlockTimeTicks);
// pxListFindListItemWithValue
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 1686
static const ListItem_t * pxListFindListItemWithValue(const List_t *pxList, TickType_t xWantedItemValue);
// pxPortInitialiseStack
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 210
StackType_t * pxPortInitialiseStack(StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters);
// pxResizeNetworkBufferWithDescriptor
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\BufferManagement\BufferAllocation_2.c line 360
NetworkBufferDescriptor_t * pxResizeNetworkBufferWithDescriptor(NetworkBufferDescriptor_t *pxNetworkBuffer, size_t xNewSizeBytes);
// pxTCPSocketLookup
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 2820
FreeRTOS_Socket_t * pxTCPSocketLookup(uint32_t ulLocalIP, UBaseType_t uxLocalPort, uint32_t ulRemoteIP, UBaseType_t uxRemotePort);
// pxUDPPayloadBuffer_to_NetworkBuffer
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 887
NetworkBufferDescriptor_t * pxUDPPayloadBuffer_to_NetworkBuffer(void *pvBuffer);
// pxUDPSocketLookup
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 1712
FreeRTOS_Socket_t * pxUDPSocketLookup(UBaseType_t uxLocalPort);
// rename
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 368
signed int rename(const char *, const char *);
// rsa_alloc_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 160
static void * rsa_alloc_wrap(void);
// rsa_alt_alloc_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 489
static void * rsa_alt_alloc_wrap(void);
// rsa_alt_can_do
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 412
static signed int rsa_alt_can_do(mbedtls_pk_type_t type);
// rsa_alt_check_pair
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 460
static signed int rsa_alt_check_pair(const void *pub, const void *prv);
// rsa_alt_decrypt_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 442
static signed int rsa_alt_decrypt_wrap(void *ctx, const unsigned char *input, size_t ilen, unsigned char *output, size_t *olen, size_t osize, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
// rsa_alt_free_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 499
static void rsa_alt_free_wrap(void *ctx);
// rsa_alt_get_bitlen
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 417
static size_t rsa_alt_get_bitlen(const void *ctx);
// rsa_alt_sign_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 424
static signed int rsa_alt_sign_wrap(void *ctx, mbedtls_md_type_t md_alg, const unsigned char *hash, size_t hash_len, unsigned char *sig, size_t *sig_len, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
// rsa_can_do
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 63
static signed int rsa_can_do(mbedtls_pk_type_t type);
// rsa_check_context
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 156
static signed int rsa_check_context(const mbedtls_rsa_context *ctx, signed int is_priv, signed int blinding_needed);
// rsa_check_pair_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 154
static signed int rsa_check_pair_wrap(const void *pub, const void *prv);
// rsa_debug
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 176
static void rsa_debug(const void *ctx, mbedtls_pk_debug_item *items);
// rsa_decrypt_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 125
static signed int rsa_decrypt_wrap(void *ctx, const unsigned char *input, size_t ilen, unsigned char *output, size_t *olen, size_t osize, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
// rsa_encrypt_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 139
static signed int rsa_encrypt_wrap(void *ctx, const unsigned char *input, size_t ilen, unsigned char *output, size_t *olen, size_t osize, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
// rsa_free_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 170
static void rsa_free_wrap(void *ctx);
// rsa_get_bitlen
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 69
static size_t rsa_get_bitlen(const void *ctx);
// rsa_prepare_blinding
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 712
static signed int rsa_prepare_blinding(mbedtls_rsa_context *ctx, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
// rsa_rsassa_pkcs1_v15_encode
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 1625
static signed int rsa_rsassa_pkcs1_v15_encode(mbedtls_md_type_t md_alg, unsigned int hashlen, const unsigned char *hash, size_t dst_len, unsigned char *dst);
// rsa_sign_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 107
static signed int rsa_sign_wrap(void *ctx, mbedtls_md_type_t md_alg, const unsigned char *hash, size_t hash_len, unsigned char *sig, size_t *sig_len, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
// rsa_verify_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 75
static signed int rsa_verify_wrap(void *ctx, mbedtls_md_type_t md_alg, const unsigned char *hash, size_t hash_len, const unsigned char *sig, size_t sig_len);
// rsprintf
// file ..\..\..\..\lib\ota\aws_rsprintf.c line 303
uint32_t rsprintf(char *dest, const char *fmt, ...);
// rvsprintf
// file ..\..\..\..\lib\ota\aws_rsprintf.c line 313
uint32_t rvsprintf(char *dest, const char *fmt, va_list va);
// scanf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1307
inline signed int scanf_s(const char * const _Format, ...);
// setipv4sourcefilter
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\ws2tcpip.h line 681
inline signed int setipv4sourcefilter(SOCKET Socket, IN_ADDR Interface, IN_ADDR Group, MULTICAST_MODE_TYPE FilterMode, ULONG SourceCount, const IN_ADDR *SourceList);
// sha1_clone_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 354
static void sha1_clone_wrap(void *dst, const void *src);
// sha1_ctx_alloc
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 344
static void * sha1_ctx_alloc(void);
// sha1_ctx_free
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 360
static void sha1_ctx_free(void *ctx);
// sha1_finish_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 339
static signed int sha1_finish_wrap(void *ctx, unsigned char *output);
// sha1_process_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 366
static signed int sha1_process_wrap(void *ctx, const unsigned char *data);
// sha1_starts_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 327
static signed int sha1_starts_wrap(void *ctx);
// sha1_update_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 332
static signed int sha1_update_wrap(void *ctx, const unsigned char *input, size_t ilen);
// sha224_clone_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 434
static void sha224_clone_wrap(void *dst, const void *src);
// sha224_ctx_alloc
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 418
static void * sha224_ctx_alloc(void);
// sha224_ctx_free
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 428
static void sha224_ctx_free(void *ctx);
// sha224_finish_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 406
static signed int sha224_finish_wrap(void *ctx, unsigned char *output);
// sha224_process_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 440
static signed int sha224_process_wrap(void *ctx, const unsigned char *data);
// sha224_starts_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 394
static signed int sha224_starts_wrap(void *ctx);
// sha224_update_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 399
static signed int sha224_update_wrap(void *ctx, const unsigned char *input, size_t ilen);
// sha224_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 412
static signed int sha224_wrap(const unsigned char *input, size_t ilen, unsigned char *output);
// sha256_starts_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 461
static signed int sha256_starts_wrap(void *ctx);
// sha256_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 466
static signed int sha256_wrap(const unsigned char *input, size_t ilen, unsigned char *output);
// sinhl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 915
// sinl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 920
// sprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1826
inline signed int sprintf_s(char * const _Buffer, const size_t _BufferCount, const char * const _Format, ...);
// sqrtl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 925
// sscanf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 2293
inline signed int sscanf_s(const char * const _Buffer, const char * const _Format, ...);
// ssl_append_key_cert
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5993
static signed int ssl_append_key_cert(mbedtls_ssl_key_cert **head, mbedtls_x509_crt *cert, mbedtls_pk_context *ssl_append_key_cert$$key);
// ssl_calc_finished_tls_sha256
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5099
static void ssl_calc_finished_tls_sha256(mbedtls_ssl_context *ssl, unsigned char *buf, signed int from);
// ssl_calc_verify_tls_sha256
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 1068
static void ssl_calc_verify_tls_sha256(mbedtls_ssl_context *ssl, unsigned char *hash);
// ssl_check_server_ecdh_params
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 1976
static signed int ssl_check_server_ecdh_params(const mbedtls_ssl_context *ssl);
// ssl_check_timer
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 89
static signed int ssl_check_timer(mbedtls_ssl_context *ssl);
// ssl_decrypt_buf
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 1612
static signed int ssl_decrypt_buf(mbedtls_ssl_context *ssl);
// ssl_encrypt_buf
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 1284
static signed int ssl_encrypt_buf(mbedtls_ssl_context *ssl);
// ssl_ep_len
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 62
static inline size_t ssl_ep_len(const mbedtls_ssl_context *ssl);
// ssl_generate_random
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 680
static signed int ssl_generate_random(mbedtls_ssl_context *ssl);
// ssl_handshake_init
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5551
static signed int ssl_handshake_init(mbedtls_ssl_context *ssl);
// ssl_handshake_params_init
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5487
static void ssl_handshake_params_init(mbedtls_ssl_handshake_params *handshake);
// ssl_handshake_wrapup_free_hs_transform
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5197
static void ssl_handshake_wrapup_free_hs_transform(mbedtls_ssl_context *ssl);
// ssl_key_cert_free
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7399
static void ssl_key_cert_free(mbedtls_ssl_key_cert *key_cert);
// ssl_parse_alpn_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 1300
static signed int ssl_parse_alpn_ext(mbedtls_ssl_context *ssl, const unsigned char *buf, size_t len);
// ssl_parse_certificate_request
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 2604
static signed int ssl_parse_certificate_request(mbedtls_ssl_context *ssl);
// ssl_parse_encrypt_then_mac_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 1154
static signed int ssl_parse_encrypt_then_mac_ext(mbedtls_ssl_context *ssl, const unsigned char *buf, size_t len);
// ssl_parse_extended_ms_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 1177
static signed int ssl_parse_extended_ms_ext(mbedtls_ssl_context *ssl, const unsigned char *buf, size_t len);
// ssl_parse_max_fragment_length_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 1109
static signed int ssl_parse_max_fragment_length_ext(mbedtls_ssl_context *ssl, const unsigned char *buf, size_t len);
// ssl_parse_record_header
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 3547
static signed int ssl_parse_record_header(mbedtls_ssl_context *ssl);
// ssl_parse_renegotiation_info
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 1070
static signed int ssl_parse_renegotiation_info(mbedtls_ssl_context *ssl, const unsigned char *buf, size_t len);
// ssl_parse_server_ecdh_params
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 2012
static signed int ssl_parse_server_ecdh_params(mbedtls_ssl_context *ssl, unsigned char **p, unsigned char *end);
// ssl_parse_server_hello
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 1442
static signed int ssl_parse_server_hello(mbedtls_ssl_context *ssl);
// ssl_parse_server_hello_done
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 2736
static signed int ssl_parse_server_hello_done(mbedtls_ssl_context *ssl);
// ssl_parse_server_key_exchange
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 2271
static signed int ssl_parse_server_key_exchange(mbedtls_ssl_context *ssl);
// ssl_parse_signature_algorithm
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 2169
static signed int ssl_parse_signature_algorithm(mbedtls_ssl_context *ssl, unsigned char **p, unsigned char *end, mbedtls_md_type_t *md_alg, mbedtls_pk_type_t *pk_alg);
// ssl_parse_supported_point_formats_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 1222
static signed int ssl_parse_supported_point_formats_ext(mbedtls_ssl_context *ssl, const unsigned char *buf, size_t len);
// ssl_prepare_record_content
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 3732
static signed int ssl_prepare_record_content(mbedtls_ssl_context *ssl);
// ssl_session_copy
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 159
static signed int ssl_session_copy(mbedtls_ssl_session *dst, const mbedtls_ssl_session *src);
// ssl_session_reset_int
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5724
static signed int ssl_session_reset_int(mbedtls_ssl_context *ssl, signed int partial);
// ssl_set_timer
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 77
static void ssl_set_timer(mbedtls_ssl_context *ssl, uint32_t millisecs);
// ssl_transform_init
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5535
static void ssl_transform_init(mbedtls_ssl_transform *transform);
// ssl_update_checksum_sha256
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 4937
static void ssl_update_checksum_sha256(mbedtls_ssl_context *ssl, const unsigned char *buf, size_t len);
// ssl_update_checksum_start
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 4907
static void ssl_update_checksum_start(mbedtls_ssl_context *ssl, const unsigned char *buf, size_t len);
// ssl_write_alpn_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 618
static void ssl_write_alpn_ext(mbedtls_ssl_context *ssl, unsigned char *buf, size_t *olen);
// ssl_write_certificate_verify
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 3064
static signed int ssl_write_certificate_verify(mbedtls_ssl_context *ssl);
// ssl_write_client_hello
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 720
static signed int ssl_write_client_hello(mbedtls_ssl_context *ssl);
// ssl_write_client_key_exchange
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 2775
static signed int ssl_write_client_key_exchange(mbedtls_ssl_context *ssl);
// ssl_write_encrypt_then_mac_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 506
static void ssl_write_encrypt_then_mac_ext(mbedtls_ssl_context *ssl, unsigned char *buf, size_t *olen);
// ssl_write_extended_ms_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 540
static void ssl_write_extended_ms_ext(mbedtls_ssl_context *ssl, unsigned char *buf, size_t *olen);
// ssl_write_hostname_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 58
static void ssl_write_hostname_ext(mbedtls_ssl_context *ssl, unsigned char *buf, size_t *olen);
// ssl_write_max_fragment_length_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 440
static void ssl_write_max_fragment_length_ext(mbedtls_ssl_context *ssl, unsigned char *buf, size_t *olen);
// ssl_write_real
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7222
static signed int ssl_write_real(mbedtls_ssl_context *ssl, const unsigned char *buf, size_t len);
// ssl_write_signature_algorithms_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 171
static void ssl_write_signature_algorithms_ext(mbedtls_ssl_context *ssl, unsigned char *buf, size_t *olen);
// ssl_write_supported_elliptic_curves_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 256
static void ssl_write_supported_elliptic_curves_ext(mbedtls_ssl_context *ssl, unsigned char *buf, size_t *olen);
// ssl_write_supported_point_formats_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 330
static void ssl_write_supported_point_formats_ext(mbedtls_ssl_context *ssl, unsigned char *buf, size_t *olen);
// stpcpy
// file ..\..\..\..\lib\ota\aws_rsprintf.c line 86
char * stpcpy(char *dest, const char *src);
// strcat_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\string.h line 34
errno_t strcat_s(char *, rsize_t, const char *);
// strcpy_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\string.h line 27
errno_t strcpy_s(char *, rsize_t, const char *);
// strncpy_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\string.h line 55
errno_t strncpy_s(char *, rsize_t, const char *, rsize_t);
// sub32
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp_curves.c line 971
static inline void sub32(uint32_t *dst, uint32_t src, signed char *carry);
// swprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1528
inline signed int swprintf_s(wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, ...);
// swscanf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 2037
inline signed int swscanf(const wchar_t * const _Buffer, const wchar_t * const _Format, ...);
// swscanf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 2078
inline signed int swscanf_s(const wchar_t * const _Buffer, const wchar_t * const _Format, ...);
// szH32
// file ..\..\..\..\lib\ota\aws_rsprintf.c line 235
char * szH32(char *dest, uint32_t val, uint8_t iFieldWidth);
// szS32
// file ..\..\..\..\lib\ota\aws_rsprintf.c line 165
char * szS32(char *dest, int32_t val, uint8_t iFieldWidth);
// szU32
// file ..\..\..\..\lib\ota\aws_rsprintf.c line 109
char * szU32(char *dest, uint32_t val, uint8_t iFieldWidth);
// tanhl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 930
// tanl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 935
// timeBeginPeriod
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\timeapi.h line 89
MMRESULT timeBeginPeriod(UINT);
// timeEndPeriod
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\timeapi.h line 96
MMRESULT timeEndPeriod(UINT);
// timeGetDevCaps
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\timeapi.h line 81
MMRESULT timeGetDevCaps(LPTIMECAPS, UINT);
// tls_prf_generic
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 378
static signed int tls_prf_generic(mbedtls_md_type_t md_type, const unsigned char *secret, size_t slen, const char *label, const unsigned char *random, size_t rlen, unsigned char *dstbuf, size_t dlen);
// tls_prf_sha256
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 442
static signed int tls_prf_sha256(const unsigned char *secret, size_t slen, const char *label, const unsigned char *random, size_t rlen, unsigned char *dstbuf, size_t dlen);
// ucQueueGetQueueType
// file ..\..\..\..\lib\FreeRTOS\queue.c line 2006
uint8_t ucQueueGetQueueType(QueueHandle_t xQueue);
// ucStreamBufferGetStreamBufferType
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 1193
uint8_t ucStreamBufferGetStreamBufferType(StreamBufferHandle_t xStreamBuffer);
// uiIndexOfObject
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2316
uint16_t uiIndexOfObject(traceHandle objecthandle, uint8_t objectclass);
// uiTraceGetTraceBufferSize
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 427
uint32_t uiTraceGetTraceBufferSize(void);
// uiTraceIsObjectExcluded
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcKernelPort.c line 559
uint8_t uiTraceIsObjectExcluded(traceObjectClass objectclass, traceHandle handle);
// uiTraceStart
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 308
uint32_t uiTraceStart(void);
// ulChar2u32
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP_Private.h line 713
static inline uint32_t ulChar2u32(const uint8_t *apChr);
// ulDNSHandlePacket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DNS.c line 810
uint32_t ulDNSHandlePacket(NetworkBufferDescriptor_t *pxNetworkBuffer);
// ulGetNextSequenceNumber
// file ..\..\..\..\lib\secure_sockets\portable\freertos_plus_tcp\aws_secure_sockets.c line 621
uint32_t ulGetNextSequenceNumber(uint32_t ulSourceAddress, uint16_t usSourcePort, uint32_t ulDestinationAddress, uint16_t usDestinationPort);
// ulGetRunTimeCounterValue
// file ..\common\application_code\aws_run-time-stats-utils.c line 74
unsigned long int ulGetRunTimeCounterValue(void);
// ulRand
// file ..\..\..\..\lib\secure_sockets\portable\freertos_plus_tcp\aws_secure_sockets.c line 584
extern uint32_t ulRand(void);
// ulTCPWindowTxAck
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 1636
uint32_t ulTCPWindowTxAck(TCPWindow_t *pxWindow, uint32_t ulSequenceNumber);
// ulTCPWindowTxGet
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 1259
uint32_t ulTCPWindowTxGet(TCPWindow_t *pxWindow, uint32_t ulWindowSize, int32_t *plPosition);
// ulTCPWindowTxSack
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 1661
uint32_t ulTCPWindowTxSack(TCPWindow_t *pxWindow, uint32_t ulFirst, uint32_t ulLast);
// ulTaskNotifyTake
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 4486
uint32_t ulTaskNotifyTake(BaseType_t xClearCountOnExit, TickType_t xTicksToWait);
// ulTimerGetAge
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 273
static inline uint32_t ulTimerGetAge(TCPTimer_t *pxTimer);
// usChar2u16
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP_Private.h line 722
static inline uint16_t usChar2u16(const uint8_t *apChr);
// usChar2u16$link1
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP_Private.h line 722
static inline uint16_t usChar2u16$link1(const uint8_t *apChr$link1);
// usGenerateChecksum
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 2031
uint16_t usGenerateChecksum(uint32_t ulSum, const uint8_t *pucNextData, size_t uxDataLengthBytes);
// usGenerateProtocolChecksum
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 1794
uint16_t usGenerateProtocolChecksum(const uint8_t * const pucEthernetBuffer, size_t uxBufferLength, BaseType_t xOutgoingPacket);
// utf8EscapedDump
// file ..\..\..\..\lib\third_party\tinycbor\cborpretty.c line 125
static signed int utf8EscapedDump(FILE *out, const char *buffer, size_t n);
// uxEventGroupGetNumber
// file ..\..\..\..\lib\FreeRTOS\event_groups.c line 708
UBaseType_t uxEventGroupGetNumber(void *xEventGroup);
// uxGetMinimumFreeNetworkBuffers
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\BufferManagement\BufferAllocation_2.c line 354
UBaseType_t uxGetMinimumFreeNetworkBuffers(void);
// uxGetNumberOfFreeNetworkBuffers
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\BufferManagement\BufferAllocation_2.c line 348
UBaseType_t uxGetNumberOfFreeNetworkBuffers(void);
// uxListRemove
// file ..\..\..\..\lib\FreeRTOS\list.c line 170
UBaseType_t uxListRemove(ListItem_t * const pxItemToRemove);
// uxQueueGetQueueNumber
// file ..\..\..\..\lib\FreeRTOS\queue.c line 1986
UBaseType_t uxQueueGetQueueNumber(QueueHandle_t xQueue);
// uxQueueMessagesWaiting
// file ..\..\..\..\lib\FreeRTOS\queue.c line 1896
UBaseType_t uxQueueMessagesWaiting(const QueueHandle_t xQueue);
// uxQueueMessagesWaitingFromISR
// file ..\..\..\..\lib\FreeRTOS\queue.c line 1930
UBaseType_t uxQueueMessagesWaitingFromISR(const QueueHandle_t xQueue);
// uxQueueSpacesAvailable
// file ..\..\..\..\lib\FreeRTOS\queue.c line 1912
UBaseType_t uxQueueSpacesAvailable(const QueueHandle_t xQueue);
// uxStreamBufferAdd
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Stream_Buffer.c line 47
size_t uxStreamBufferAdd(StreamBuffer_t *pxBuffer, size_t uxOffset, const uint8_t *pucData, size_t uxCount);
// uxStreamBufferDistance
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 114
static inline size_t uxStreamBufferDistance(const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper);
// uxStreamBufferDistance$link1
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 114
static inline size_t uxStreamBufferDistance$link1(const StreamBuffer_t *pxBuffer$link1, const size_t uxLower$link1, const size_t uxUpper$link1);
// uxStreamBufferDistance$link2
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 114
static inline size_t uxStreamBufferDistance$link2(const StreamBuffer_t *pxBuffer$link2, const size_t uxLower$link2, const size_t uxUpper$link2);
// uxStreamBufferDistance$link3
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 114
static inline size_t uxStreamBufferDistance$link3(const StreamBuffer_t *pxBuffer$link3, const size_t uxLower$link3, const size_t uxUpper$link3);
// uxStreamBufferDistance$link4
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_Stream_Buffer.h line 114
static inline size_t uxStreamBufferDistance$link4(const StreamBuffer_t *pxBuffer$link4, const size_t uxLower$link4, const size_t uxUpper$link4);
// uxStreamBufferFrontSpace
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 146
static inline size_t uxStreamBufferFrontSpace(const StreamBuffer_t *pxBuffer);
// uxStreamBufferFrontSpace$link1
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 146
static inline size_t uxStreamBufferFrontSpace$link1(const StreamBuffer_t *pxBuffer$link1);
// uxStreamBufferGet
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Stream_Buffer.c line 130
size_t uxStreamBufferGet( StreamBuffer_t *pxBuffer, size_t uxOffset, uint8_t *pucData, size_t uxMaxCount, BaseType_t xPeek);
// uxStreamBufferGetPtr
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 283
static inline size_t uxStreamBufferGetPtr(const StreamBuffer_t *pxBuffer, uint8_t **ppucData);
// uxStreamBufferGetSize
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 162
static inline size_t uxStreamBufferGetSize(const StreamBuffer_t *pxBuffer);
// uxStreamBufferGetSize$link1
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 162
static inline size_t uxStreamBufferGetSize$link1(const StreamBuffer_t *pxBuffer$link1);
// uxStreamBufferGetSize$link2
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 162
static inline size_t uxStreamBufferGetSize$link2(const StreamBuffer_t *pxBuffer$link2);
// uxStreamBufferGetSize$link3
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_Stream_Buffer.h line 162
static inline size_t uxStreamBufferGetSize$link3(const StreamBuffer_t *pxBuffer$link3);
// uxStreamBufferGetSpace
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 132
static inline size_t uxStreamBufferGetSpace(const StreamBuffer_t *pxBuffer);
// uxStreamBufferGetSpace$link1
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 132
static inline size_t uxStreamBufferGetSpace$link1(const StreamBuffer_t *pxBuffer$link1);
// uxStreamBufferGetSpace$link2
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 132
static inline size_t uxStreamBufferGetSpace$link2(const StreamBuffer_t *pxBuffer$link2);
// uxStreamBufferGetSpace$link3
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 132
static inline size_t uxStreamBufferGetSpace$link3(const StreamBuffer_t *pxBuffer$link3);
// uxStreamBufferGetSpace$link4
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_Stream_Buffer.h line 132
static inline size_t uxStreamBufferGetSpace$link4(const StreamBuffer_t *pxBuffer$link4);
// uxStreamBufferGetStreamBufferNumber
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 1173
UBaseType_t uxStreamBufferGetStreamBufferNumber(StreamBufferHandle_t xStreamBuffer);
// uxStreamBufferMidSpace
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 177
static inline size_t uxStreamBufferMidSpace(const StreamBuffer_t *pxBuffer);
// uxStreamBufferSpace
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 95
static inline size_t uxStreamBufferSpace(const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper);
// uxStreamBufferSpace$link1
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 95
static inline size_t uxStreamBufferSpace$link1(const StreamBuffer_t *pxBuffer$link1, const size_t uxLower$link1, const size_t uxUpper$link1);
// uxStreamBufferSpace$link2
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 95
static inline size_t uxStreamBufferSpace$link2(const StreamBuffer_t *pxBuffer$link2, const size_t uxLower$link2, const size_t uxUpper$link2);
// uxStreamBufferSpace$link3
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 95
static inline size_t uxStreamBufferSpace$link3(const StreamBuffer_t *pxBuffer$link3, const size_t uxLower$link3, const size_t uxUpper$link3);
// uxStreamBufferSpace$link4
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_Stream_Buffer.h line 95
static inline size_t uxStreamBufferSpace$link4(const StreamBuffer_t *pxBuffer$link4, const size_t uxLower$link4, const size_t uxUpper$link4);
// uxTaskGetNumberOfTasks
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 2318
UBaseType_t uxTaskGetNumberOfTasks(void);
// uxTaskGetStackHighWaterMark
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3719
UBaseType_t uxTaskGetStackHighWaterMark(TaskHandle_t xTask);
// uxTaskGetSystemState
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 2466
UBaseType_t uxTaskGetSystemState(TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime);
// uxTaskGetTaskNumber
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3248
UBaseType_t uxTaskGetTaskNumber(TaskHandle_t xTask);
// uxTaskPriorityGet
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 1415
UBaseType_t uxTaskPriorityGet(TaskHandle_t xTask);
// uxTaskPriorityGetFromISR
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 1437
UBaseType_t uxTaskPriorityGetFromISR(TaskHandle_t xTask);
// uxTaskResetEventItemValue
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 4453
TickType_t uxTaskResetEventItemValue(void);
// uxTimerGetTimerNumber
// file ..\..\..\..\lib\FreeRTOS\timers.c line 1052
UBaseType_t uxTimerGetTimerNumber(TimerHandle_t xTimer);
// vARPAgeCache
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_ARP.c line 493
void vARPAgeCache(void);
// vARPGenerateRequestPacket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_ARP.c line 588
void vARPGenerateRequestPacket(NetworkBufferDescriptor_t * const pxNetworkBuffer);
// vARPRefreshCacheEntry
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_ARP.c line 212
void vARPRefreshCacheEntry(const MACAddress_t *pxMACAddress, const uint32_t ulIPAddress);
// vARPSendGratuitous
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_ARP.c line 545
void vARPSendGratuitous(void);
// vAlternateKeyProvisioning
// file ..\..\..\common\devmode_key_provisioning\aws_dev_mode_key_provisioning.c line 100
void vAlternateKeyProvisioning(ProvisioningParams_t *xParams);
// vApplicationGetIdleTaskMemory
// file ..\common\application_code\main.c line 405
void vApplicationGetIdleTaskMemory(StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize);
// vApplicationGetTimerTaskMemory
// file ..\common\application_code\main.c line 432
void vApplicationGetTimerTaskMemory(StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize);
// vApplicationIPNetworkEventHook
// file ..\common\application_code\main.c line 199
void vApplicationIPNetworkEventHook(eIPCallbackEvent_t eNetworkEvent);
// vApplicationIdleHook
// file ..\common\application_code\main.c line 330
void vApplicationIdleHook(void);
// vApplicationMallocFailedHook
// file ..\common\application_code\main.c line 258
void vApplicationMallocFailedHook();
// vAssertCalled
// file ..\common\application_code\main.c line 375
extern void vAssertCalled(const char *pcFile, uint32_t ulLine);
// vConfigureTimerForRunTimeStats
// file ..\common\application_code\aws_run-time-stats-utils.c line 48
void vConfigureTimerForRunTimeStats(void);
// vDHCPProcess
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DHCP.c line 263
void vDHCPProcess(BaseType_t xReset);
// vDevModeKeyProvisioning
// file ..\..\..\common\devmode_key_provisioning\aws_dev_mode_key_provisioning.c line 227
void vDevModeKeyProvisioning(void);
// vEventGroupClearBitsCallback
// file ..\..\..\..\lib\FreeRTOS\event_groups.c line 650
void vEventGroupClearBitsCallback(void *pvEventGroup, const uint32_t ulBitsToClear);
// vEventGroupDelete
// file ..\..\..\..\lib\FreeRTOS\event_groups.c line 598
void vEventGroupDelete(EventGroupHandle_t xEventGroup);
// vEventGroupSetBitsCallback
// file ..\..\..\..\lib\FreeRTOS\event_groups.c line 642
void vEventGroupSetBitsCallback(void *pvEventGroup, const uint32_t ulBitsToSet);
// vEventGroupSetNumber
// file ..\..\..\..\lib\FreeRTOS\event_groups.c line 730
void vEventGroupSetNumber(void *xEventGroup, UBaseType_t uxEventGroupNumber);
// vIPNetworkUpCalls
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 1321
void vIPNetworkUpCalls(void);
// vIPReloadDHCPTimer
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 2268
void vIPReloadDHCPTimer(uint32_t ulLeaseTime);
// vIPSetDHCPTimerEnableState
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 2253
void vIPSetDHCPTimerEnableState(BaseType_t xEnableState);
// vListInitialise
// file ..\..\..\..\lib\FreeRTOS\list.c line 37
void vListInitialise(List_t * const pxList);
// vListInitialiseItem
// file ..\..\..\..\lib\FreeRTOS\list.c line 62
void vListInitialiseItem(ListItem_t * const pxItem);
// vListInsert
// file ..\..\..\..\lib\FreeRTOS\list.c line 103
void vListInsert(List_t * const pxList, ListItem_t * const pxNewListItem);
// vListInsertEnd
// file ..\..\..\..\lib\FreeRTOS\list.c line 74
void vListInsertEnd(List_t * const pxList, ListItem_t * const pxNewListItem);
// vListInsertFifo
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 258
static inline void vListInsertFifo(List_t * const pxList, ListItem_t * const pxNewListItem);
// vListInsertGeneric
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 284
extern void vListInsertGeneric(List_t * const pxList, ListItem_t * const pxNewListItem, MiniListItem_t * const pxWhere);
// vLoggingInit
// file ..\common\application_code\aws_demo_logging.c line 155
void vLoggingInit(BaseType_t vLoggingInit$$xLogToStdout, BaseType_t vLoggingInit$$xLogToFile, BaseType_t vLoggingInit$$xLogToUDP, uint32_t ulRemoteIPAddress, uint16_t usRemotePort);
// vLoggingPrint
// file ..\common\application_code\aws_demo_logging.c line 469
void vLoggingPrint(const char *pcMessage);
// vLoggingPrintf
// file ..\common\application_code\aws_demo_logging.c line 273
extern void vLoggingPrintf(const char *pcFormat, ...);
// vNetworkSocketsInit
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 191
BaseType_t vNetworkSocketsInit(void);
// vOTAUpdateDemoTask
// file ..\..\..\common\ota\aws_ota_update_demo.c line 67
void vOTAUpdateDemoTask(void *pvParameters);
// vPortCloseRunningThread
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 473
void vPortCloseRunningThread(void *pvTaskToDelete, volatile BaseType_t *pxPendYield);
// vPortDeleteThread
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 439
void vPortDeleteThread(void *pvTaskToDelete);
// vPortEndScheduler
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 512
void vPortEndScheduler(void);
// vPortEnterCritical
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 562
void vPortEnterCritical(void);
// vPortExitCritical
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 578
void vPortExitCritical(void);
// vPortFree
// file ..\..\..\..\lib\FreeRTOS\portable\MemMang\heap_4.c line 263
void vPortFree(void *pv);
// vPortGenerateSimulatedInterrupt
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 519
void vPortGenerateSimulatedInterrupt(uint32_t ulInterruptNumber);
// vPortInitialiseBlocks
// file ..\..\..\..\lib\FreeRTOS\portable\MemMang\heap_4.c line 323
void vPortInitialiseBlocks(void);
// vPortSetInterruptHandler
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 544
void vPortSetInterruptHandler(uint32_t ulInterruptNumber, uint32_t (*pvHandler)(void));
// vProcessGeneratedUDPPacket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_UDP_IP.c line 75
void vProcessGeneratedUDPPacket(NetworkBufferDescriptor_t * const pxNetworkBuffer);
// vQueueDelete
// file ..\..\..\..\lib\FreeRTOS\queue.c line 1942
void vQueueDelete(QueueHandle_t xQueue);
// vQueueSetQueueNumber
// file ..\..\..\..\lib\FreeRTOS\queue.c line 1996
void vQueueSetQueueNumber(QueueHandle_t xQueue, UBaseType_t uxQueueNumber);
// vQueueWaitForMessageRestricted
// file ..\..\..\..\lib\FreeRTOS\queue.c line 2702
void vQueueWaitForMessageRestricted(QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely);
// vReleaseNetworkBuffer
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\BufferManagement\BufferAllocation_2.c line 195
void vReleaseNetworkBuffer(uint8_t *pucEthernetBuffer);
// vReleaseNetworkBufferAndDescriptor
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\BufferManagement\BufferAllocation_2.c line 304
void vReleaseNetworkBufferAndDescriptor(NetworkBufferDescriptor_t * const pxNetworkBuffer);
// vReturnEthernetFrame
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 2147
void vReturnEthernetFrame(NetworkBufferDescriptor_t *pxNetworkBuffer, BaseType_t xReleaseAfterSend);
// vSocketBind
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 969
BaseType_t vSocketBind(FreeRTOS_Socket_t *pxSocket, struct freertos_sockaddr *pxAddress, size_t uxAddressLength, BaseType_t xInternal);
// vSocketClose
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 1138
void * vSocketClose(FreeRTOS_Socket_t *pxSocket);
// vSocketWakeUpUser
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 1840
void vSocketWakeUpUser(FreeRTOS_Socket_t *pxSocket);
// vStartGreenGrassDiscoveryTask
// file ..\..\..\common\greengrass_connectivity\aws_greengrass_discovery_demo.c line 226
extern void vStartGreenGrassDiscoveryTask(void);
// vStartMQTTEchoDemo
// file ..\..\..\common\mqtt\aws_hello_world.c line 505
extern void vStartMQTTEchoDemo(void);
// vStartOTAUpdateDemoTask
// file ..\..\..\common\ota\aws_ota_update_demo.c line 164
extern void vStartOTAUpdateDemoTask(void);
// vStartShadowDemoTasks
// file ..\..\..\common\shadow\aws_shadow_lightbulb_on_off.c line 514
extern void vStartShadowDemoTasks(void);
// vStartSimpleTCPServerTasks
// file ..\..\..\common\tcp\aws_simple_tcp_echo_server.c line 95
extern void vStartSimpleTCPServerTasks(void);
// vStartSubpubDemoTasks
// file ..\..\..\common\mqtt\aws_subscribe_publish_loop.c line 724
extern void vStartSubpubDemoTasks(void);
// vStartTCPEchoClientTasks_SeparateTasks
// file ..\..\..\common\tcp\aws_tcp_echo_client_separate_tasks.c line 113
void vStartTCPEchoClientTasks_SeparateTasks(void);
// vStartTCPEchoClientTasks_SingleTasks
// file ..\..\..\common\tcp\aws_tcp_echo_client_single_task.c line 139
void vStartTCPEchoClientTasks_SingleTasks(void);
// vStreamBufferClear
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 83
static inline void vStreamBufferClear( StreamBuffer_t *pxBuffer);
// vStreamBufferDelete
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 335
void vStreamBufferDelete(StreamBufferHandle_t xStreamBuffer);
// vStreamBufferMoveMid
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 194
static inline void vStreamBufferMoveMid( StreamBuffer_t *pxBuffer, size_t uxCount);
// vStreamBufferSetStreamBufferNumber
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 1183
void vStreamBufferSetStreamBufferNumber(StreamBufferHandle_t xStreamBuffer, UBaseType_t uxStreamBufferNumber);
// vTCPNetStat
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 3337
void vTCPNetStat(void);
// vTCPStateChange
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 1434
void vTCPStateChange(FreeRTOS_Socket_t *pxSocket, enum eTCP_STATE eTCPState);
// vTCPTimerSet
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 266
static inline void vTCPTimerSet(TCPTimer_t *pxTimer);
// vTCPWindowCreate
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 588
void vTCPWindowCreate(TCPWindow_t *pxWindow, uint32_t ulRxWindowLength, uint32_t ulTxWindowLength, uint32_t ulAckNumber, uint32_t ulSequenceNumber, uint32_t ulMSS);
// vTCPWindowDestroy
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 553
void vTCPWindowDestroy(TCPWindow_t *pxWindow);
// vTCPWindowFree
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 523
static void vTCPWindowFree(TCPSegment_t *pxSegment);
// vTCPWindowInit
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 622
void vTCPWindowInit(TCPWindow_t *pxWindow, uint32_t ulAckNumber, uint32_t ulSequenceNumber, uint32_t ulMSS);
// vTaskDelay
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 1299
void vTaskDelay(const TickType_t xTicksToDelay);
// vTaskDelayUntil
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 1215
void vTaskDelayUntil(TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement);
// vTaskDelete
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 1123
void vTaskDelete(TaskHandle_t xTaskToDelete);
// vTaskEndScheduler
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 2032
void vTaskEndScheduler(void);
// vTaskGetInfo
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3570
void vTaskGetInfo(TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState);
// vTaskGetRunTimeStats
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 4328
void vTaskGetRunTimeStats(char *pcWriteBuffer);
// vTaskInternalSetTimeOutState
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3169
void vTaskInternalSetTimeOutState(TimeOut_t * const pxTimeOut);
// vTaskList
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 4230
void vTaskList(char *pcWriteBuffer);
// vTaskMissedYield
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3240
void vTaskMissedYield(void);
// vTaskNotifyGiveFromISR
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 4864
void vTaskNotifyGiveFromISR(TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken);
// vTaskPlaceOnEventList
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 2981
void vTaskPlaceOnEventList(List_t * const pxEventList, const TickType_t xTicksToWait);
// vTaskPlaceOnEventListRestricted
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3024
void vTaskPlaceOnEventListRestricted(List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely);
// vTaskPlaceOnUnorderedEventList
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 2998
void vTaskPlaceOnUnorderedEventList(List_t *pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait);
// vTaskPriorityDisinheritAfterTimeout
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 4039
void vTaskPriorityDisinheritAfterTimeout(const TaskHandle_t pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask);
// vTaskPrioritySet
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 1477
void vTaskPrioritySet(TaskHandle_t xTask, UBaseType_t uxNewPriority);
// vTaskRemoveFromUnorderedEventList
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3123
void vTaskRemoveFromUnorderedEventList(ListItem_t *pxEventListItem, const TickType_t xItemValue);
// vTaskResume
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 1788
void vTaskResume(TaskHandle_t xTaskToResume);
// vTaskSetTaskNumber
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3271
void vTaskSetTaskNumber(TaskHandle_t xTask, const UBaseType_t uxHandle);
// vTaskSetThreadLocalStoragePointer
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3454
void vTaskSetThreadLocalStoragePointer(TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue);
// vTaskSetTimeOutState
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3157
void vTaskSetTimeOutState(TimeOut_t * const pxTimeOut);
// vTaskStartScheduler
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 1912
void vTaskStartScheduler(void);
// vTaskSuspend
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 1641
void vTaskSuspend(TaskHandle_t xTaskToSuspend);
// vTaskSuspendAll
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 2043
void vTaskSuspendAll(void);
// vTaskSwitchContext
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 2908
void vTaskSwitchContext(void);
// vTimerSetTimerID
// file ..\..\..\..\lib\FreeRTOS\timers.c line 983
void vTimerSetTimerID(TimerHandle_t xTimer, void *pvNewID);
// vTimerSetTimerNumber
// file ..\..\..\..\lib\FreeRTOS\timers.c line 1062
void vTimerSetTimerNumber(TimerHandle_t xTimer, UBaseType_t uxTimerNumber);
// vTraceClear
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 277
void vTraceClear(void);
// vTraceClearError
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 398
void vTraceClearError(void);
// vTraceEnable
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 228
void vTraceEnable(signed int startOption);
// vTraceInitObjectHandleStack
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcKernelPort.c line 515
void vTraceInitObjectHandleStack(void);
// vTraceInitObjectPropertyTable
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcKernelPort.c line 480
void vTraceInitObjectPropertyTable(void);
// vTraceInstanceFinishedNext
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 489
void vTraceInstanceFinishedNext(void);
// vTraceInstanceFinishedNow
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 521
void vTraceInstanceFinishedNow(void);
// vTracePrint
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 1447
void vTracePrint(traceString chn, const char *str);
// vTracePrintF
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 1311
void vTracePrintF(traceString eventLabel, const char *formatStr, ...);
// vTracePrintF_Helper
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 1322
static void vTracePrintF_Helper(traceString eventLabel, const char *formatStr, va_list vl);
// vTraceSetFrequency
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2516
void vTraceSetFrequency(uint32_t frequency);
// vTraceSetMutexName
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcKernelPort.c line 447
void vTraceSetMutexName(void *object, const char *name);
// vTraceSetQueueName
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcKernelPort.c line 421
void vTraceSetQueueName(void *object, const char *name);
// vTraceSetSemaphoreName
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcKernelPort.c line 434
void vTraceSetSemaphoreName(void *object, const char *name);
// vTraceSetStopHook
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 266
void vTraceSetStopHook(TRACE_STOP_HOOK stopHookFunction);
// vTraceStart
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 358
void vTraceStart(void);
// vTraceStop
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 369
void vTraceStop(void);
// vTraceStoreISRBegin
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 583
void vTraceStoreISRBegin(traceHandle handle);
// vTraceStoreISREnd
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 662
void vTraceStoreISREnd(signed int pendingISR);
// vTraceStoreMemMangEvent
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 1642
extern void vTraceStoreMemMangEvent(uint32_t ecode, uint32_t address, int32_t signed_size);
// value_to_pretty
// file ..\..\..\..\lib\third_party\tinycbor\cborpretty.c line 267
static CborError value_to_pretty(FILE *out, CborValue *it);
// vfprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 675
inline signed int vfprintf_s(FILE * const _Stream, const char * const _Format, va_list _ArgList);
// vfscanf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1100
inline signed int vfscanf_s(FILE * const _Stream, const char * const _Format, va_list _ArgList);
// vfwprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 340
inline signed int vfwprintf_s(FILE * const _Stream, const wchar_t * const _Format, va_list _ArgList);
// vfwscanf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 726
inline signed int vfwscanf(FILE * const _Stream, const wchar_t * const _Format, va_list _ArgList);
// vfwscanf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 759
inline signed int vfwscanf_s(FILE * const _Stream, const wchar_t * const _Format, va_list _ArgList);
// vprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 763
inline signed int vprintf_s(const char * const _Format, va_list _ArgList);
// vscanf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1159
inline signed int vscanf_s(const char * const _Format, va_list _ArgList);
// vsnprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1619
inline signed int vsnprintf_s(char * const _Buffer, const size_t _BufferCount, const size_t _MaxCount, const char * const _Format, va_list _ArgList);
// vsprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1506
inline signed int vsprintf_s(char * const _Buffer, const size_t _BufferCount, const char * const _Format, va_list _ArgList);
// vsscanf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 2210
inline signed int vsscanf_s(const char * const _Buffer, const char * const _Format, va_list _ArgList);
// vswprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1274
inline signed int vswprintf_s(wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, va_list _ArgList);
// vswscanf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1919
inline signed int vswscanf(const wchar_t *_Buffer, const wchar_t *_Format, va_list _ArgList);
// vswscanf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1954
inline signed int vswscanf_s(const wchar_t * const _Buffer, const wchar_t * const _Format, va_list _ArgList);
// vwprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 428
inline signed int vwprintf_s(const wchar_t * const _Format, va_list _ArgList);
// vwscanf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 788
inline signed int vwscanf(const wchar_t * const _Format, va_list _ArgList);
// vwscanf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 817
inline signed int vwscanf_s(const wchar_t * const _Format, va_list _ArgList);
// would_overflow
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 239
static inline _Bool would_overflow(CborEncoder *encoder, size_t len);
// wprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 640
inline signed int wprintf_s(const wchar_t * const _Format, ...);
// writeInt16
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 773
static uint8_t writeInt16(void *buffer, uint8_t i, uint16_t value);
// writeInt32
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 801
static uint8_t writeInt32(void *buffer, uint8_t i, uint32_t value);
// writeInt8
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 752
static uint8_t writeInt8(void *buffer, uint8_t i, uint8_t value);
// wscanf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 928
inline signed int wscanf(const wchar_t * const _Format, ...);
// wscanf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 965
inline signed int wscanf_s(const wchar_t * const _Format, ...);
// x509_check_wildcard
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 1773
static signed int x509_check_wildcard(const char *cn, const mbedtls_x509_buf *name);
// x509_crt_check_cn
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 2218
static signed int x509_crt_check_cn(const mbedtls_x509_buf *name, const char *cn, size_t cn_len);
// x509_crt_check_ee_locally_trusted
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 2064
static signed int x509_crt_check_ee_locally_trusted(mbedtls_x509_crt *crt, mbedtls_x509_crt *trust_ca);
// x509_crt_check_parent
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 1903
static signed int x509_crt_check_parent(const mbedtls_x509_crt *child, const mbedtls_x509_crt *parent, signed int top);
// x509_crt_check_signature
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 1874
static signed int x509_crt_check_signature(const mbedtls_x509_crt *child, mbedtls_x509_crt *parent);
// x509_crt_find_parent
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 2038
static mbedtls_x509_crt * x509_crt_find_parent(mbedtls_x509_crt *child, mbedtls_x509_crt *trust_ca, signed int *parent_is_trusted, size_t path_cnt, size_t self_cnt);
// x509_crt_find_parent_in
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 1973
static mbedtls_x509_crt * x509_crt_find_parent_in(mbedtls_x509_crt *child, mbedtls_x509_crt *candidates, signed int top, size_t path_cnt, size_t self_cnt);
// x509_crt_merge_flags_with_cb
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 2278
static signed int x509_crt_merge_flags_with_cb(uint32_t *flags, x509_crt_verify_chain_item *ver_chain, size_t chain_len, signed int (*f_vrfy)(void *, mbedtls_x509_crt *, signed int, uint32_t *), void *p_vrfy);
// x509_crt_parse_der_core
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 684
static signed int x509_crt_parse_der_core(mbedtls_x509_crt *crt, const unsigned char *buf, size_t buflen);
// x509_crt_verify_chain
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 2115
static signed int x509_crt_verify_chain(mbedtls_x509_crt *crt, mbedtls_x509_crt *trust_ca, mbedtls_x509_crl *ca_crl, const mbedtls_x509_crt_profile *profile, x509_crt_verify_chain_item *ver_chain, size_t *chain_len);
// x509_crt_verify_name
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 2240
static void x509_crt_verify_name(const mbedtls_x509_crt *crt, const char *cn, uint32_t *flags);
// x509_date_is_valid
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 499
static signed int x509_date_is_valid(const mbedtls_x509_time *t);
// x509_get_attr_type_value
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 356
static signed int x509_get_attr_type_value(unsigned char **p, const unsigned char *end, mbedtls_x509_name *cur);
// x509_get_basic_constraints
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 320
static signed int x509_get_basic_constraints(unsigned char **p, const unsigned char *end, signed int *ca_istrue, signed int *max_pathlen);
// x509_get_crt_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 542
static signed int x509_get_crt_ext(unsigned char **p, const unsigned char *end, mbedtls_x509_crt *crt);
// x509_get_dates
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 264
static signed int x509_get_dates(unsigned char **p, const unsigned char *end, mbedtls_x509_time *from, mbedtls_x509_time *to);
// x509_get_ext_key_usage
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 419
static signed int x509_get_ext_key_usage(unsigned char **p, const unsigned char *end, mbedtls_x509_sequence *ext_key_usage);
// x509_get_key_usage
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 389
static signed int x509_get_key_usage(unsigned char **p, const unsigned char *end, unsigned int *key_usage);
// x509_get_ns_cert_type
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 370
static signed int x509_get_ns_cert_type(unsigned char **p, const unsigned char *end, unsigned char *ns_cert_type);
// x509_get_subject_alt_name
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 462
static signed int x509_get_subject_alt_name(unsigned char **p, const unsigned char *end, mbedtls_x509_sequence *subject_alt_name);
// x509_get_uid
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 294
static signed int x509_get_uid(unsigned char **p, const unsigned char *end, mbedtls_x509_buf *uid, signed int n);
// x509_get_version
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 228
static signed int x509_get_version(unsigned char **p, const unsigned char *end, signed int *ver);
// x509_info_cert_type
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 1297
static signed int x509_info_cert_type(char **buf, size_t *size, unsigned char ns_cert_type);
// x509_info_ext_key_usage
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 1348
static signed int x509_info_ext_key_usage(char **buf, size_t *size, const mbedtls_x509_sequence *extended_key_usage);
// x509_info_key_usage
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 1324
static signed int x509_info_key_usage(char **buf, size_t *size, unsigned int key_usage);
// x509_info_subject_alt_name
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 1248
static signed int x509_info_subject_alt_name(char **buf, size_t *size, const mbedtls_x509_sequence *subject_alt_name);
// x509_memcasecmp
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 1744
static signed int x509_memcasecmp(const void *s1, const void *s2, size_t len);
// x509_name_cmp
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 1839
static signed int x509_name_cmp(const mbedtls_x509_name *a, const mbedtls_x509_name *b);
// x509_parse_int
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 483
static signed int x509_parse_int(unsigned char **p, size_t n, signed int *res);
// x509_parse_time
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 536
static signed int x509_parse_time(unsigned char **p, size_t len, size_t yearlen, mbedtls_x509_time *tm);
// x509_profile_check_key
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 193
static signed int x509_profile_check_key(const mbedtls_x509_crt_profile *profile, const mbedtls_pk_context *pk);
// x509_profile_check_md_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 167
static signed int x509_profile_check_md_alg(const mbedtls_x509_crt_profile *profile, mbedtls_md_type_t md_alg);
// x509_profile_check_pk_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 180
static signed int x509_profile_check_pk_alg(const mbedtls_x509_crt_profile *profile, mbedtls_pk_type_t pk_alg);
// x509_string_cmp
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 1809
static signed int x509_string_cmp(const mbedtls_x509_buf *a, const mbedtls_x509_buf *b);
// xAreSeparateTaskTCPEchoClientsStillRunning
// file ..\..\..\common\tcp\aws_tcp_echo_client_separate_tasks.c line 408
BaseType_t xAreSeparateTaskTCPEchoClientsStillRunning(void);
// xAreSingleTaskTCPEchoClientsStillRunning
// file ..\..\..\common\tcp\aws_tcp_echo_client_single_task.c line 390
BaseType_t xAreSingleTaskTCPEchoClientsStillRunning(void);
// xAreTCPEchoServersStillRunning
// file ..\..\..\common\tcp\aws_simple_tcp_echo_server.c line 230
BaseType_t xAreTCPEchoServersStillRunning(void);
// xEventGroupClearBits
// file ..\..\..\..\lib\FreeRTOS\event_groups.c line 446
EventBits_t xEventGroupClearBits(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear);
// xEventGroupClearBitsFromISR
// file ..\..\..\..\lib\FreeRTOS\event_groups.c line 475
BaseType_t xEventGroupClearBitsFromISR(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear);
// xEventGroupCreate
// file ..\..\..\..\lib\FreeRTOS\event_groups.c line 142
EventGroupHandle_t xEventGroupCreate(void);
// xEventGroupCreateStatic
// file ..\..\..\..\lib\FreeRTOS\event_groups.c line 93
EventGroupHandle_t xEventGroupCreateStatic(StaticEventGroup_t *pxEventGroupBuffer);
// xEventGroupGetBitsFromISR
// file ..\..\..\..\lib\FreeRTOS\event_groups.c line 488
EventBits_t xEventGroupGetBitsFromISR(EventGroupHandle_t xEventGroup);
// xEventGroupSetBits
// file ..\..\..\..\lib\FreeRTOS\event_groups.c line 504
EventBits_t xEventGroupSetBits(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet);
// xEventGroupSetBitsFromISR
// file ..\..\..\..\lib\FreeRTOS\event_groups.c line 693
BaseType_t xEventGroupSetBitsFromISR(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken);
// xEventGroupSync
// file ..\..\..\..\lib\FreeRTOS\event_groups.c line 176
EventBits_t xEventGroupSync(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait);
// xEventGroupWaitBits
// file ..\..\..\..\lib\FreeRTOS\event_groups.c line 296
EventBits_t xEventGroupWaitBits(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait);
// xIPIsNetworkTaskReady
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 2298
BaseType_t xIPIsNetworkTaskReady(void);
// xIsCallingFromIPTask
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 517
BaseType_t xIsCallingFromIPTask(void);
// xIsDHCPSocket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DHCP.c line 246
BaseType_t xIsDHCPSocket(Socket_t xSocket);
// xNetworkBuffersInitialise
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\BufferManagement\BufferAllocation_2.c line 96
BaseType_t xNetworkBuffersInitialise(void);
// xNetworkInterfaceInitialise
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 139
BaseType_t xNetworkInterfaceInitialise(void);
// xNetworkInterfaceOutput
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 191
BaseType_t xNetworkInterfaceOutput(NetworkBufferDescriptor_t * const pxNetworkBuffer, BaseType_t bReleaseAfterSend);
// xPortGetFreeHeapSize
// file ..\..\..\..\lib\FreeRTOS\portable\MemMang\heap_4.c line 311
size_t xPortGetFreeHeapSize(void);
// xPortGetMinimumEverFreeHeapSize
// file ..\..\..\..\lib\FreeRTOS\portable\MemMang\heap_4.c line 317
size_t xPortGetMinimumEverFreeHeapSize(void);
// xPortStartScheduler
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 235
BaseType_t xPortStartScheduler(void);
// xProcessReceivedTCPPacket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 2897
BaseType_t xProcessReceivedTCPPacket(NetworkBufferDescriptor_t *pxNetworkBuffer);
// xProcessReceivedUDPPacket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_UDP_IP.c line 239
BaseType_t xProcessReceivedUDPPacket(NetworkBufferDescriptor_t *pxNetworkBuffer, uint16_t usPort);
// xQueueCreateCountingSemaphore
// file ..\..\..\..\lib\FreeRTOS\queue.c line 699
QueueHandle_t xQueueCreateCountingSemaphore(const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount);
// xQueueCreateCountingSemaphoreStatic
// file ..\..\..\..\lib\FreeRTOS\queue.c line 671
QueueHandle_t xQueueCreateCountingSemaphoreStatic(const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue);
// xQueueCreateMutex
// file ..\..\..\..\lib\FreeRTOS\queue.c line 482
QueueHandle_t xQueueCreateMutex(const uint8_t ucQueueType);
// xQueueCreateMutexStatic
// file ..\..\..\..\lib\FreeRTOS\queue.c line 498
QueueHandle_t xQueueCreateMutexStatic(const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue);
// xQueueGenericCreate
// file ..\..\..\..\lib\FreeRTOS\queue.c line 358
QueueHandle_t xQueueGenericCreate(const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType);
// xQueueGenericCreateStatic
// file ..\..\..\..\lib\FreeRTOS\queue.c line 302
QueueHandle_t xQueueGenericCreateStatic(const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType);
// xQueueGenericReset
// file ..\..\..\..\lib\FreeRTOS\queue.c line 247
BaseType_t xQueueGenericReset(QueueHandle_t xQueue, BaseType_t xNewQueue);
// xQueueGenericSend
// file ..\..\..\..\lib\FreeRTOS\queue.c line 725
BaseType_t xQueueGenericSend(QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition);
// xQueueGenericSendFromISR
// file ..\..\..\..\lib\FreeRTOS\queue.c line 923
BaseType_t xQueueGenericSendFromISR(QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition);
// xQueueGetMutexHolder
// file ..\..\..\..\lib\FreeRTOS\queue.c line 518
void * xQueueGetMutexHolder(QueueHandle_t xSemaphore);
// xQueueGetMutexHolderFromISR
// file ..\..\..\..\lib\FreeRTOS\queue.c line 548
void * xQueueGetMutexHolderFromISR(QueueHandle_t xSemaphore);
// xQueueGiveFromISR
// file ..\..\..\..\lib\FreeRTOS\queue.c line 1074
BaseType_t xQueueGiveFromISR(QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken);
// xQueueGiveMutexRecursive
// file ..\..\..\..\lib\FreeRTOS\queue.c line 574
BaseType_t xQueueGiveMutexRecursive(QueueHandle_t xMutex);
// xQueueIsQueueEmptyFromISR
// file ..\..\..\..\lib\FreeRTOS\queue.c line 2279
BaseType_t xQueueIsQueueEmptyFromISR(const QueueHandle_t xQueue);
// xQueueIsQueueFullFromISR
// file ..\..\..\..\lib\FreeRTOS\queue.c line 2318
BaseType_t xQueueIsQueueFullFromISR(const QueueHandle_t xQueue);
// xQueuePeek
// file ..\..\..\..\lib\FreeRTOS\queue.c line 1601
BaseType_t xQueuePeek(QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait);
// xQueuePeekFromISR
// file ..\..\..\..\lib\FreeRTOS\queue.c line 1842
BaseType_t xQueuePeekFromISR(QueueHandle_t xQueue, void * const pvBuffer);
// xQueueReceive
// file ..\..\..\..\lib\FreeRTOS\queue.c line 1240
BaseType_t xQueueReceive(QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait);
// xQueueReceiveFromISR
// file ..\..\..\..\lib\FreeRTOS\queue.c line 1751
BaseType_t xQueueReceiveFromISR(QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken);
// xQueueSemaphoreTake
// file ..\..\..\..\lib\FreeRTOS\queue.c line 1382
BaseType_t xQueueSemaphoreTake(QueueHandle_t xQueue, TickType_t xTicksToWait);
// xQueueTakeMutexRecursive
// file ..\..\..\..\lib\FreeRTOS\queue.c line 629
BaseType_t xQueueTakeMutexRecursive(QueueHandle_t xMutex, TickType_t xTicksToWait);
// xSendEventStructToIPTask
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 1154
BaseType_t xSendEventStructToIPTask(const IPStackEvent_t *pxEvent, TickType_t xTimeout);
// xSendEventToIPTask
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 1142
BaseType_t xSendEventToIPTask(eIPEvent_t eEvent);
// xSequenceGreaterThan
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 240
static inline BaseType_t xSequenceGreaterThan(uint32_t a, uint32_t b);
// xSequenceGreaterThanOrEqual
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 249
static inline BaseType_t xSequenceGreaterThanOrEqual(uint32_t a, uint32_t b);
// xSequenceLessThan
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 230
static inline BaseType_t xSequenceLessThan(uint32_t a, uint32_t b);
// xSequenceLessThanOrEqual
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 218
static inline BaseType_t xSequenceLessThanOrEqual(uint32_t a, uint32_t b);
// xStreamBufferBytesAvailable
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 475
size_t xStreamBufferBytesAvailable(StreamBufferHandle_t xStreamBuffer);
// xStreamBufferGenericCreate
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 219
StreamBufferHandle_t xStreamBufferGenericCreate(size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer);
// xStreamBufferGenericCreateStatic
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 271
StreamBufferHandle_t xStreamBufferGenericCreateStatic(size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer, uint8_t * const pucStreamBufferStorageArea, StaticStreamBuffer_t * const pxStaticStreamBuffer);
// xStreamBufferIsEmpty
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 902
BaseType_t xStreamBufferIsEmpty(StreamBufferHandle_t xStreamBuffer);
// xStreamBufferIsFull
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 925
BaseType_t xStreamBufferIsFull(StreamBufferHandle_t xStreamBuffer);
// xStreamBufferLessThenEqual
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 246
static inline BaseType_t xStreamBufferLessThenEqual(const StreamBuffer_t *pxBuffer, const size_t uxLeft, const size_t uxRight);
// xStreamBufferReceive
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 691
size_t xStreamBufferReceive(StreamBufferHandle_t xStreamBuffer, void *pvRxData, size_t xBufferLengthBytes, TickType_t xTicksToWait);
// xStreamBufferReceiveCompletedFromISR
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 990
BaseType_t xStreamBufferReceiveCompletedFromISR(StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken);
// xStreamBufferReceiveFromISR
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 795
size_t xStreamBufferReceiveFromISR(StreamBufferHandle_t xStreamBuffer, void *pvRxData, size_t xBufferLengthBytes, BaseType_t * const pxHigherPriorityTaskWoken);
// xStreamBufferReset
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 368
BaseType_t xStreamBufferReset(StreamBufferHandle_t xStreamBuffer);
// xStreamBufferSend
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 487
size_t xStreamBufferSend(StreamBufferHandle_t xStreamBuffer, const void *pvTxData, size_t xDataLengthBytes, TickType_t xTicksToWait);
// xStreamBufferSendCompletedFromISR
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 960
BaseType_t xStreamBufferSendCompletedFromISR(StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken);
// xStreamBufferSendFromISR
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 588
size_t xStreamBufferSendFromISR(StreamBufferHandle_t xStreamBuffer, const void *pvTxData, size_t xDataLengthBytes, BaseType_t * const pxHigherPriorityTaskWoken);
// xStreamBufferSetTriggerLevel
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 422
BaseType_t xStreamBufferSetTriggerLevel(StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel);
// xStreamBufferSpacesAvailable
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 451
size_t xStreamBufferSpacesAvailable(StreamBufferHandle_t xStreamBuffer);
// xTCPCheckNewClient
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 3280
BaseType_t xTCPCheckNewClient(FreeRTOS_Socket_t *pxSocket);
// xTCPSocketCheck
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 466
BaseType_t xTCPSocketCheck(FreeRTOS_Socket_t *pxSocket);
// xTCPTimerCheck
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 2734
TickType_t xTCPTimerCheck(BaseType_t xWillSleep);
// xTCPWindowGetHead
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 473
static TCPSegment_t * xTCPWindowGetHead(List_t *pxList);
// xTCPWindowNew
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 378
static TCPSegment_t * xTCPWindowNew(TCPWindow_t *pxWindow, uint32_t ulSequenceNumber, int32_t lCount, BaseType_t xIsForRx);
// xTCPWindowPeekHead
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 499
static TCPSegment_t * xTCPWindowPeekHead(List_t *pxList);
// xTCPWindowRxConfirm
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 693
static TCPSegment_t * xTCPWindowRxConfirm(TCPWindow_t *pxWindow, uint32_t ulSequenceNumber, uint32_t ulLength);
// xTCPWindowRxEmpty
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 437
BaseType_t xTCPWindowRxEmpty(TCPWindow_t *pxWindow);
// xTCPWindowRxFind
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 346
static TCPSegment_t * xTCPWindowRxFind(TCPWindow_t *pxWindow, uint32_t ulSequenceNumber);
// xTCPWindowTxDone
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 1114
BaseType_t xTCPWindowTxDone(TCPWindow_t *pxWindow);
// xTCPWindowTxHasData
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 1183
BaseType_t xTCPWindowTxHasData(TCPWindow_t *pxWindow, uint32_t ulWindowSize, TickType_t *pulDelay);
// xTaskAbortDelay
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 2572
BaseType_t xTaskAbortDelay(TaskHandle_t xTask);
// xTaskCheckForTimeOut
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3177
BaseType_t xTaskCheckForTimeOut(TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait);
// xTaskCreate
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 743
BaseType_t xTaskCreate(TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask);
// xTaskCreateStatic
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 592
TaskHandle_t xTaskCreateStatic(TaskFunction_t pxTaskCode, const char * const pcName, const uint32_t ulStackDepth, void * const pvParameters, UBaseType_t uxPriority, StackType_t * const puxStackBuffer, StaticTask_t * const pxTaskBuffer);
// xTaskGenericNotify
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 4634
BaseType_t xTaskGenericNotify(TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue);
// xTaskGenericNotifyFromISR
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 4740
BaseType_t xTaskGenericNotifyFromISR(TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken);
// xTaskGetCurrentTaskHandle
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3827
TaskHandle_t xTaskGetCurrentTaskHandle(void);
// xTaskGetIdleTickCount
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 2241
TickType_t xTaskGetIdleTickCount(void);
// xTaskGetIdleTickCountFromISR
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 2287
TickType_t xTaskGetIdleTickCountFromISR(void);
// xTaskGetSchedulerState
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3844
BaseType_t xTaskGetSchedulerState(void);
// xTaskGetTickCount
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 2226
TickType_t xTaskGetTickCount(void);
// xTaskGetTickCountFromISR
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 2256
TickType_t xTaskGetTickCountFromISR(void);
// xTaskIncrementTick
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 2646
BaseType_t xTaskIncrementTick(void);
// xTaskNotifyStateClear
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 4953
BaseType_t xTaskNotifyStateClear(TaskHandle_t xTask);
// xTaskNotifyWait
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 4554
BaseType_t xTaskNotifyWait(uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait);
// xTaskPriorityDisinherit
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3959
BaseType_t xTaskPriorityDisinherit(const TaskHandle_t pxMutexHolder);
// xTaskPriorityInherit
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3872
BaseType_t xTaskPriorityInherit(const TaskHandle_t pxMutexHolder);
// xTaskRemoveFromEventList
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3055
BaseType_t xTaskRemoveFromEventList(const List_t * const pxEventList);
// xTaskResumeAll
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 2116
BaseType_t xTaskResumeAll(void);
// xTaskResumeFromISR
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 1842
BaseType_t xTaskResumeFromISR(TaskHandle_t xTaskToResume);
// xTimerCreate
// file ..\..\..\..\lib\FreeRTOS\timers.c line 278
TimerHandle_t xTimerCreate(const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction);
// xTimerCreateStatic
// file ..\..\..\..\lib\FreeRTOS\timers.c line 310
TimerHandle_t xTimerCreateStatic(const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction, StaticTimer_t *pxTimerBuffer);
// xTimerCreateTimerTask
// file ..\..\..\..\lib\FreeRTOS\timers.c line 223
BaseType_t xTimerCreateTimerTask(void);
// xTimerGenericCommand
// file ..\..\..\..\lib\FreeRTOS\timers.c line 381
BaseType_t xTimerGenericCommand(TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait);
// xTimerGetExpiryTime
// file ..\..\..\..\lib\FreeRTOS\timers.c line 442
TickType_t xTimerGetExpiryTime(TimerHandle_t xTimer);
// xTimerGetPeriod
// file ..\..\..\..\lib\FreeRTOS\timers.c line 433
TickType_t xTimerGetPeriod(TimerHandle_t xTimer);
// xTimerGetTimerDaemonTaskHandle
// file ..\..\..\..\lib\FreeRTOS\timers.c line 424
TaskHandle_t xTimerGetTimerDaemonTaskHandle(void);
// xTimerIsTimerActive
// file ..\..\..\..\lib\FreeRTOS\timers.c line 945
BaseType_t xTimerIsTimerActive(TimerHandle_t xTimer);
// xTimerPendFunctionCall
// file ..\..\..\..\lib\FreeRTOS\timers.c line 1023
BaseType_t xTimerPendFunctionCall(PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait);
// xTimerPendFunctionCallFromISR
// file ..\..\..\..\lib\FreeRTOS\timers.c line 999
BaseType_t xTimerPendFunctionCallFromISR(PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken);
// xTraceGetLastError
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 385
const char * xTraceGetLastError(void);
// xTraceGetTraceBuffer
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 415
void * xTraceGetTraceBuffer(void);
// xTraceRegisterString
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 1504
traceString xTraceRegisterString(const char *label);
// xTraceSetISRProperties
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 551
traceHandle xTraceSetISRProperties(const char *name, uint8_t priority);


typedef struct anonymous$71
{
  // f_source
  mbedtls_entropy_f_source_ptr f_source;
  // p_source
  void *p_source;
  // size
  size_t size;
  // threshold
  size_t threshold;
  // strong
  signed int strong;
} mbedtls_entropy_source_state;

typedef struct anonymous$110
{
  // crt
  mbedtls_x509_crt *crt;
  // flags
  uint32_t flags;
} x509_crt_verify_chain_item;

typedef struct anonymous$93
{
  // buf
  unsigned char *buf;
  // buflen
  size_t buflen;
  // info
  unsigned char *info;
} mbedtls_pem_context;

union anonymous$22
{
  // iFileHandle
  int32_t iFileHandle;
  // pstFile
  FILE *pstFile;
  // pucFile
  uint8_t *pucFile;
};

typedef struct anonymous$29
{
  // pacFilepath
  uint8_t *pacFilepath;
  // $anon0
  union anonymous$22 $anon0;
  // pvRequestTimer
  TimerHandle_t pvRequestTimer;
  // iFileSize
  uint32_t iFileSize;
  // iBlocksRemaining
  uint32_t iBlocksRemaining;
  // usSigSize
  uint16_t usSigSize;
  // ulFileAttributes
  uint32_t ulFileAttributes;
  // ulServerFileID
  uint32_t ulServerFileID;
  // ulRequestMomentum
  uint32_t ulRequestMomentum;
  // pacJobName
  uint8_t *pacJobName;
  // pacStreamName
  uint8_t *pacStreamName;
  // pacSignature
  uint8_t *pacSignature;
  // pacRxBlockBitmap
  uint8_t *pacRxBlockBitmap;
  // pacCertFilepath
  uint8_t *pacCertFilepath;
  // ulUpdaterVersion
  uint32_t ulUpdaterVersion;
} OTA_FileContext_t;

typedef struct anonymous$94
{
  // key
  void *key;
  // decrypt_func
  mbedtls_pk_rsa_alt_decrypt_func decrypt_func;
  // sign_func
  mbedtls_pk_rsa_alt_sign_func sign_func;
  // key_len_func
  mbedtls_pk_rsa_alt_key_len_func key_len_func;
} mbedtls_rsa_alt_context;

typedef struct anonymous$76
{
  // pvThread
  void *pvThread;
} xThreadState;

typedef struct anonymous$128
{
  // xTaskHandle
  TaskHandle_t xTaskHandle;
  // cTaskName
  char cTaskName[15ll];
} ShadowTaskParam_t;

typedef struct anonymous$127
{
  // xTaskToNotify
  TaskHandle_t xTaskToNotify;
  // ulDataLength
  uint32_t ulDataLength;
  // pcUpdateBuffer
  char pcUpdateBuffer[128ll];
} ShadowQueueData_t;

typedef struct anonymous$0
{
  // asn1
  const char *asn1;
  // asn1_len
  size_t asn1_len;
  // name
  const char *name;
  // description
  const char *description;
} mbedtls_oid_descriptor_t;

typedef struct anonymous$49
{
  // pcGroupName
  const char *pcGroupName;
  // pcCoreAddress
  const char *pcCoreAddress;
  // ucInterface
  uint8_t ucInterface;
} HostParameters_t;

typedef struct anonymous$53
{
  // pcHostAddress
  const char *pcHostAddress;
  // pcCertificate
  char *pcCertificate;
  // ulCertificateSize
  uint32_t ulCertificateSize;
  // usPort
  uint16_t usPort;
} GGD_HostAddressData_t;

typedef struct anonymous$20
{
  // pcSrcKey
  const char *pcSrcKey;
  // bRequired
  const uint8_t bRequired;
  // ulDestOffset
  const uint32_t ulDestOffset;
  // eModelParamType
  const JobParamType_t eModelParamType;
  // eJasmineType
  const jsmntype_t eJasmineType;
} JobParamDeterminer_t;

typedef struct anonymous$109
{
  // pszName
  const char *pszName;
  // pfAddress
  FARPROC pfAddress;
} WSPIAPI_FUNCTION;

typedef struct anonymous$14
{
  // cipher_info
  const mbedtls_cipher_info_t *cipher_info;
  // key_bitlen
  signed int key_bitlen;
  // operation
  mbedtls_operation_t operation;
  // add_padding
  void (*add_padding)(unsigned char *, size_t, size_t);
  // get_padding
  signed int (*get_padding)(unsigned char *, size_t, size_t *);
  // unprocessed_data
  unsigned char unprocessed_data[16ll];
  // unprocessed_len
  size_t unprocessed_len;
  // iv
  unsigned char iv[16ll];
  // iv_size
  size_t iv_size;
  // cipher_ctx
  void *cipher_ctx;
} mbedtls_cipher_context_t;

typedef struct anonymous$3
{
  // md_info
  const mbedtls_md_info_t *md_info;
  // md_ctx
  void *md_ctx;
  // hmac_ctx
  void *hmac_ctx;
} mbedtls_md_context_t;

typedef struct anonymous$70
{
  // pk_info
  const mbedtls_pk_info_t *pk_info;
  // pk_ctx
  void *pk_ctx;
} mbedtls_pk_context;

typedef struct anonymous$18
{
  // nr
  signed int nr;
  // rk
  uint32_t *rk;
  // buf
  uint32_t buf[68ll];
} mbedtls_aes_context;

typedef struct anonymous$63
{
  // counter
  unsigned char counter[16ll];
  // reseed_counter
  signed int reseed_counter;
  // prediction_resistance
  signed int prediction_resistance;
  // entropy_len
  size_t entropy_len;
  // reseed_interval
  signed int reseed_interval;
  // aes_ctx
  mbedtls_aes_context aes_ctx;
  // f_entropy
  signed int (*f_entropy)(void *, unsigned char *, size_t);
  // p_entropy
  void *p_entropy;
} mbedtls_ctr_drbg_context;

typedef struct anonymous$68
{
  // total
  uint32_t total[2ll];
  // state
  uint32_t state[5ll];
  // buffer
  unsigned char buffer[64ll];
} mbedtls_sha1_context;

typedef struct anonymous$72
{
  // total
  uint32_t total[2ll];
  // state
  uint32_t state[8ll];
  // buffer
  unsigned char buffer[64ll];
  // is224
  signed int is224;
} mbedtls_sha256_context;

typedef struct xMAC_ADDRESS
{
  // ucBytes
  uint8_t ucBytes[6ll];
} __attribute__ ((__packed__)) MACAddress_t;

typedef struct xETH_HEADER
{
  // xDestinationAddress
  MACAddress_t xDestinationAddress;
  // xSourceAddress
  MACAddress_t xSourceAddress;
  // usFrameType
  uint16_t usFrameType;
} __attribute__ ((__packed__)) EthernetHeader_t;

typedef struct xIP_HEADER
{
  // ucVersionHeaderLength
  uint8_t ucVersionHeaderLength;
  // ucDifferentiatedServicesCode
  uint8_t ucDifferentiatedServicesCode;
  // usLength
  uint16_t usLength;
  // usIdentification
  uint16_t usIdentification;
  // usFragmentOffset
  uint16_t usFragmentOffset;
  // ucTimeToLive
  uint8_t ucTimeToLive;
  // ucProtocol
  uint8_t ucProtocol;
  // usHeaderChecksum
  uint16_t usHeaderChecksum;
  // ulSourceIPAddress
  uint32_t ulSourceIPAddress;
  // ulDestinationIPAddress
  uint32_t ulDestinationIPAddress;
} __attribute__ ((__packed__)) IPHeader_t;

typedef struct xTCP_HEADER
{
  // usSourcePort
  uint16_t usSourcePort;
  // usDestinationPort
  uint16_t usDestinationPort;
  // ulSequenceNumber
  uint32_t ulSequenceNumber;
  // ulAckNr
  uint32_t ulAckNr;
  // ucTCPOffset
  uint8_t ucTCPOffset;
  // ucTCPFlags
  uint8_t ucTCPFlags;
  // usWindow
  uint16_t usWindow;
  // usChecksum
  uint16_t usChecksum;
  // usUrgent
  uint16_t usUrgent;
  // ucOptdata
  uint8_t ucOptdata[16ll];
} __attribute__ ((__packed__)) TCPHeader_t;

typedef struct xTCP_PACKET
{
  // xEthernetHeader
  EthernetHeader_t xEthernetHeader;
  // xIPHeader
  IPHeader_t xIPHeader;
  // xTCPHeader
  TCPHeader_t xTCPHeader;
} __attribute__ ((__packed__)) TCPPacket_t;

struct anonymous$98
{
  // ucFillPacket
  uint8_t ucFillPacket[2ll];
  // ucLastPacket
  uint8_t ucLastPacket[(signed long long int)sizeof(TCPPacket_t) /*70ll*/ ];
};

typedef struct anonymous$112
{
  // indexOfNextAvailableHandle
  uint16_t indexOfNextAvailableHandle[7ll];
  // lowestIndexOfClass
  uint16_t lowestIndexOfClass[7ll];
  // highestIndexOfClass
  uint16_t highestIndexOfClass[7ll];
  // handleCountWaterMarksOfClass
  uint16_t handleCountWaterMarksOfClass[7ll];
  // objectHandles
  traceHandle objectHandles[850ll];
} objectHandleStackType;

struct anonymous$100
{
  // bHasInit
  uint32_t bHasInit : 1;
  // bSendFullSize
  uint32_t bSendFullSize : 1;
  // bTimeStamps
  uint32_t bTimeStamps : 1;
};

struct anonymous$104
{
  // bMssChange
  uint32_t bMssChange : 1;
  // bPassAccept
  uint32_t bPassAccept : 1;
  // bPassQueued
  uint32_t bPassQueued : 1;
  // bReuseSocket
  uint32_t bReuseSocket : 1;
  // bCloseAfterSend
  uint32_t bCloseAfterSend : 1;
  // bUserShutdown
  uint32_t bUserShutdown : 1;
  // bCloseRequested
  uint32_t bCloseRequested : 1;
  // bLowWater
  uint32_t bLowWater : 1;
  // bWinChange
  uint32_t bWinChange : 1;
  // bSendKeepAlive
  uint32_t bSendKeepAlive : 1;
  // bWaitKeepAlive
  uint32_t bWaitKeepAlive : 1;
  // bConnPrepared
  uint32_t bConnPrepared : 1;
  // bFinAccepted
  uint32_t bFinAccepted : 1;
  // bFinSent
  uint32_t bFinSent : 1;
  // bFinRecv
  uint32_t bFinRecv : 1;
  // bFinAcked
  uint32_t bFinAcked : 1;
  // bFinLast
  uint32_t bFinLast : 1;
  // bRxStopped
  uint32_t bRxStopped : 1;
  // bMallocError
  uint32_t bMallocError : 1;
  // bWinScaling
  uint32_t bWinScaling : 1;
};

struct anonymous$95
{
  // ucTransmitCount
  uint32_t ucTransmitCount : 8;
  // ucDupAckCount
  uint32_t ucDupAckCount : 8;
  // bOutstanding
  uint32_t bOutstanding : 1;
  // bAcked
  uint32_t bAcked : 1;
  // bIsForRx
  uint32_t bIsForRx : 1;
};

typedef struct anonymous$83
{
  // accumulator_started
  signed int accumulator_started;
  // accumulator
  mbedtls_sha256_context accumulator;
  // source_count
  signed int source_count;
  // source
  mbedtls_entropy_source_state source[20ll];
} mbedtls_entropy_context;

typedef struct anonymous$17
{
  // s
  signed int s;
  // n
  size_t n;
  // p
  mbedtls_mpi_uint *p;
} mbedtls_mpi;

typedef struct anonymous$1
{
  // ver
  signed int ver;
  // len
  size_t len;
  // N
  mbedtls_mpi N;
  // E
  mbedtls_mpi E;
  // D
  mbedtls_mpi D;
  // P
  mbedtls_mpi P;
  // Q
  mbedtls_mpi Q;
  // DP
  mbedtls_mpi DP;
  // DQ
  mbedtls_mpi DQ;
  // QP
  mbedtls_mpi QP;
  // RN
  mbedtls_mpi RN;
  // RP
  mbedtls_mpi RP;
  // RQ
  mbedtls_mpi RQ;
  // Vi
  mbedtls_mpi Vi;
  // Vf
  mbedtls_mpi Vf;
  // padding
  signed int padding;
  // hash_id
  signed int hash_id;
} mbedtls_rsa_context;

typedef struct anonymous$75
{
  // dummy
  char dummy;
} mbedtls_platform_context;

typedef struct anonymous$51
{
  // type
  jsmntype_t type;
  // start
  signed int start;
  // end
  signed int end;
  // size
  signed int size;
  // parent
  signed int parent;
} jsmntok_t;

typedef struct anonymous$10
{
  // type
  mbedtls_cipher_type_t type;
  // mode
  mbedtls_cipher_mode_t mode;
  // key_bitlen
  unsigned int key_bitlen;
  // name
  const char *name;
  // iv_size
  unsigned int iv_size;
  // flags
  signed int flags;
  // block_size
  unsigned int block_size;
  // base
  const mbedtls_cipher_base_t *base;
} mbedtls_cipher_info_t;

typedef struct anonymous$7
{
  // type
  mbedtls_cipher_type_t type;
  // info
  const mbedtls_cipher_info_t *info;
} mbedtls_cipher_definition_t;

typedef struct anonymous$2
{
  // grp_id
  mbedtls_ecp_group_id grp_id;
  // tls_id
  uint16_t tls_id;
  // bit_size
  uint16_t bit_size;
  // name
  const char *name;
} mbedtls_ecp_curve_info;

typedef struct anonymous$16
{
  // X
  mbedtls_mpi X;
  // Y
  mbedtls_mpi Y;
  // Z
  mbedtls_mpi Z;
} mbedtls_ecp_point;

typedef struct anonymous$78
{
  // id
  mbedtls_ecp_group_id id;
  // P
  mbedtls_mpi P;
  // A
  mbedtls_mpi A;
  // B
  mbedtls_mpi B;
  // G
  mbedtls_ecp_point G;
  // N
  mbedtls_mpi N;
  // pbits
  size_t pbits;
  // nbits
  size_t nbits;
  // h
  unsigned int h;
  // modp
  signed int (*modp)(mbedtls_mpi *);
  // t_pre
  signed int (*t_pre)(mbedtls_ecp_point *, void *);
  // t_post
  signed int (*t_post)(mbedtls_ecp_point *, void *);
  // t_data
  void *t_data;
  // T
  mbedtls_ecp_point *T;
  // T_size
  size_t T_size;
} mbedtls_ecp_group;

typedef struct anonymous$92
{
  // type
  mbedtls_pk_debug_type type;
  // name
  const char *name;
  // value
  void *value;
} mbedtls_pk_debug_item;

typedef struct anonymous$89
{
  // descriptor
  mbedtls_oid_descriptor_t descriptor;
  // short_name
  const char *short_name;
} oid_x520_attr_t;

typedef struct anonymous$90
{
  // descriptor
  mbedtls_oid_descriptor_t descriptor;
  // ext_type
  signed int ext_type;
} oid_x509_ext_t;

typedef struct anonymous$59
{
  // descriptor
  mbedtls_oid_descriptor_t descriptor;
  // cipher_alg
  mbedtls_cipher_type_t cipher_alg;
} oid_cipher_alg_t;

typedef struct anonymous$91
{
  // descriptor
  mbedtls_oid_descriptor_t descriptor;
  // grp_id
  mbedtls_ecp_group_id grp_id;
} oid_ecp_grp_t;

typedef struct anonymous
{
  // descriptor
  mbedtls_oid_descriptor_t descriptor;
  // md_alg
  mbedtls_md_type_t md_alg;
  // pk_alg
  mbedtls_pk_type_t pk_alg;
} oid_sig_alg_t;

typedef struct anonymous$84
{
  // descriptor
  mbedtls_oid_descriptor_t descriptor;
  // md_alg
  mbedtls_md_type_t md_alg;
} oid_md_alg_t;

typedef struct anonymous$88
{
  // descriptor
  mbedtls_oid_descriptor_t descriptor;
  // md_hmac
  mbedtls_md_type_t md_hmac;
} oid_md_hmac_t;

typedef struct anonymous$82
{
  // descriptor
  mbedtls_oid_descriptor_t descriptor;
  // pk_alg
  mbedtls_pk_type_t pk_alg;
} oid_pk_alg_t;

typedef struct anonymous$8
{
  // cipher_ctx
  mbedtls_cipher_context_t cipher_ctx;
  // HL
  uint64_t HL[16ll];
  // HH
  uint64_t HH[16ll];
  // len
  uint64_t len;
  // add_len
  uint64_t add_len;
  // base_ectr
  unsigned char base_ectr[16ll];
  // y
  unsigned char y[16ll];
  // buf
  unsigned char buf[16ll];
  // mode
  signed int mode;
} mbedtls_gcm_context;

typedef struct anonymous$4
{
  // md_ctx
  mbedtls_md_context_t md_ctx;
  // V
  unsigned char V[32ll];
  // reseed_counter
  signed int reseed_counter;
  // entropy_len
  size_t entropy_len;
  // prediction_resistance
  signed int prediction_resistance;
  // reseed_interval
  signed int reseed_interval;
  // f_entropy
  signed int (*f_entropy)(void *, unsigned char *, size_t);
  // p_entropy
  void *p_entropy;
} mbedtls_hmac_drbg_context;

typedef struct anonymous$19
{
  // grp
  mbedtls_ecp_group grp;
  // d
  mbedtls_mpi d;
  // Q
  mbedtls_ecp_point Q;
} mbedtls_ecp_keypair;

typedef struct anonymous$5
{
  // grp
  mbedtls_ecp_group grp;
  // d
  mbedtls_mpi d;
  // Q
  mbedtls_ecp_point Q;
  // Qp
  mbedtls_ecp_point Qp;
  // z
  mbedtls_mpi z;
  // point_format
  signed int point_format;
  // Vi
  mbedtls_ecp_point Vi;
  // Vf
  mbedtls_ecp_point Vf;
  // _d
  mbedtls_mpi _d;
} mbedtls_ecdh_context;

struct anonymous$74
{
  // usBuild
  uint16_t usBuild;
  // ucMinor
  uint8_t ucMinor;
  // ucMajor
  uint8_t ucMajor;
} __attribute__ ((__packed__));

union anonymous$66
{
  // x
  struct anonymous$74 x;
  // ulVersion32
  uint32_t ulVersion32;
} __attribute__ ((__packed__));

typedef struct anonymous$21
{
  // u
  union anonymous$66 u;
} __attribute__ ((__packed__)) AppVersion32_t;

struct anonymous$107
{
  // s_w1
  USHORT s_w1;
  // s_w2
  USHORT s_w2;
};

struct anonymous$80
{
  // wProcessorArchitecture
  WORD wProcessorArchitecture;
  // wReserved
  WORD wReserved;
};

struct anonymous$129
{
  // LowPart
  DWORD LowPart;
  // HighPart
  LONG HighPart;
};

typedef struct anonymous$113
{
  // NumberOfObjectClasses
  uint32_t NumberOfObjectClasses;
  // ObjectPropertyTableSizeInBytes
  uint32_t ObjectPropertyTableSizeInBytes;
  // NumberOfObjectsPerClass
  traceHandle NumberOfObjectsPerClass[8ll];
  // NameLengthPerClass
  uint8_t NameLengthPerClass[8ll];
  // TotalPropertyBytesPerClass
  uint8_t TotalPropertyBytesPerClass[8ll];
  // StartIndexOfClass
  uint16_t StartIndexOfClass[8ll];
  // objbytes
  uint8_t objbytes[14412ll];
} ObjectPropertyTableType;

struct anonymous$79
{
  // Offset
  DWORD Offset;
  // OffsetHigh
  DWORD OffsetHigh;
};

typedef struct anonymous$73
{
  // allowed_mds
  uint32_t allowed_mds;
  // allowed_pks
  uint32_t allowed_pks;
  // allowed_curves
  uint32_t allowed_curves;
  // rsa_min_bitlen
  uint32_t rsa_min_bitlen;
} mbedtls_x509_crt_profile;

typedef struct anonymous$50
{
  // pos
  unsigned int pos;
  // toknext
  unsigned int toknext;
  // toksuper
  signed int toksuper;
} jsmn_parser;

typedef struct anonymous$111
{
  // symTableSize
  uint32_t symTableSize;
  // nextFreeSymbolIndex
  uint32_t nextFreeSymbolIndex;
  // symbytes
  uint8_t symbytes[5000ll];
  // latestEntryOfChecksum
  uint16_t latestEntryOfChecksum[64ll];
} symbolTableType;

struct anonymous$103
{
  // ulFirstSequenceNumber
  uint32_t ulFirstSequenceNumber;
  // ulCurrentSequenceNumber
  uint32_t ulCurrentSequenceNumber;
  // ulFINSequenceNumber
  uint32_t ulFINSequenceNumber;
  // ulHighestSequenceNumber
  uint32_t ulHighestSequenceNumber;
};

struct anonymous$97
{
  // ullAlignmentWord
  uint64_t ullAlignmentWord;
};

struct anonymous$106
{
  // s_b1
  UCHAR s_b1;
  // s_b2
  UCHAR s_b2;
  // s_b3
  UCHAR s_b3;
  // s_b4
  UCHAR s_b4;
};

typedef struct anonymous$116
{
  // type
  uint8_t type;
  // addr_high
  uint8_t addr_high;
  // addr_low
  uint16_t addr_low;
} MemEventAddr;

typedef struct anonymous$122
{
  // type
  uint8_t type;
  // arg1
  uint8_t arg1;
  // arg2
  uint8_t arg2;
  // arg3
  uint8_t arg3;
} ObjClosePropEvent;

typedef struct anonymous$121
{
  // type
  uint8_t type;
  // dts
  uint8_t dts;
  // param
  uint16_t param;
} KernelCallWithParam16;

typedef struct anonymous$123
{
  // type
  uint8_t type;
  // dts
  uint8_t dts;
  // payload
  uint16_t payload;
} UserEvent;

typedef struct anonymous$118
{
  // type
  uint8_t type;
  // dts
  uint8_t dts;
  // size
  uint16_t size;
} MemEventSize;

typedef struct anonymous$119
{
  // type
  uint8_t type;
  // dummy
  uint8_t dummy;
  // dts
  uint16_t dts;
} LPEvent;

typedef struct anonymous$117
{
  // type
  uint8_t type;
  // objHandle
  uint8_t objHandle;
  // dts
  uint16_t dts;
} TSEvent;

typedef struct anonymous$125
{
  // type
  uint8_t type;
  // objHandle
  uint8_t objHandle;
  // symbolIndex
  uint16_t symbolIndex;
} ObjCloseNameEvent;

typedef struct anonymous$120
{
  // type
  uint8_t type;
  // objHandle
  uint8_t objHandle;
  // param
  uint8_t param;
  // dts
  uint8_t dts;
} KernelCallWithParamAndHandle;

typedef struct anonymous$124
{
  // type
  uint8_t type;
  // unused1
  uint8_t unused1;
  // unused2
  uint8_t unused2;
  // dts
  uint8_t dts;
} TaskInstanceStatusEvent;

typedef struct anonymous$126
{
  // type
  uint8_t type;
  // xps_8
  uint8_t xps_8;
  // xps_16
  uint16_t xps_16;
} XPSEvent;

typedef struct anonymous$115
{
  // type
  uint8_t type;
  // xts_8
  uint8_t xts_8;
  // xts_16
  uint16_t xts_16;
} XTSEvent;

typedef struct anonymous$114
{
  // startmarker0
  volatile uint8_t startmarker0;
  // startmarker1
  volatile uint8_t startmarker1;
  // startmarker2
  volatile uint8_t startmarker2;
  // startmarker3
  volatile uint8_t startmarker3;
  // startmarker4
  volatile uint8_t startmarker4;
  // startmarker5
  volatile uint8_t startmarker5;
  // startmarker6
  volatile uint8_t startmarker6;
  // startmarker7
  volatile uint8_t startmarker7;
  // startmarker8
  volatile uint8_t startmarker8;
  // startmarker9
  volatile uint8_t startmarker9;
  // startmarker10
  volatile uint8_t startmarker10;
  // startmarker11
  volatile uint8_t startmarker11;
  // version
  uint16_t version;
  // minor_version
  uint8_t minor_version;
  // irq_priority_order
  uint8_t irq_priority_order;
  // filesize
  uint32_t filesize;
  // numEvents
  uint32_t numEvents;
  // maxEvents
  uint32_t maxEvents;
  // nextFreeIndex
  uint32_t nextFreeIndex;
  // bufferIsFull
  uint32_t bufferIsFull;
  // frequency
  uint32_t frequency;
  // absTimeLastEvent
  uint32_t absTimeLastEvent;
  // absTimeLastEventSecond
  uint32_t absTimeLastEventSecond;
  // recorderActive
  uint32_t recorderActive;
  // isrTailchainingThreshold
  uint32_t isrTailchainingThreshold;
  // notused
  uint8_t notused[24ll];
  // heapMemUsage
  uint32_t heapMemUsage;
  // debugMarker0
  int32_t debugMarker0;
  // isUsing16bitHandles
  uint32_t isUsing16bitHandles;
  // ObjectPropertyTable
  ObjectPropertyTableType ObjectPropertyTable;
  // debugMarker1
  int32_t debugMarker1;
  // SymbolTable
  symbolTableType SymbolTable;
  // exampleFloatEncoding
  uint32_t exampleFloatEncoding;
  // internalErrorOccured
  uint32_t internalErrorOccured;
  // debugMarker2
  int32_t debugMarker2;
  // systemInfo
  char systemInfo[80ll];
  // debugMarker3
  int32_t debugMarker3;
  // eventData
  uint8_t eventData[60000ll];
  // endOfSecondaryBlocks
  uint32_t endOfSecondaryBlocks;
  // endmarker0
  uint8_t endmarker0;
  // endmarker1
  uint8_t endmarker1;
  // endmarker2
  uint8_t endmarker2;
  // endmarker3
  uint8_t endmarker3;
  // endmarker4
  uint8_t endmarker4;
  // endmarker5
  uint8_t endmarker5;
  // endmarker6
  uint8_t endmarker6;
  // endmarker7
  uint8_t endmarker7;
  // endmarker8
  uint8_t endmarker8;
  // endmarker9
  uint8_t endmarker9;
  // endmarker10
  uint8_t endmarker10;
  // endmarker11
  uint8_t endmarker11;
} RecorderDataType;

union anonymous$58
{
  // pcReadFrom
  int8_t *pcReadFrom;
  // uxRecursiveCallCount
  UBaseType_t uxRecursiveCallCount;
};

union anonymous$30
{
  // ptr
  uint8_t *ptr;
  // bytes_needed
  ptrdiff_t bytes_needed;
};

union anonymous$57
{
  // pvDummy2
  void *pvDummy2;
  // uxDummy2
  UBaseType_t uxDummy2;
};

union anonymous$31
{
  // pxConnectParams
  const MQTTAgentConnectParams_t *pxConnectParams;
  // pxSubscribeParams
  const MQTTAgentSubscribeParams_t *pxSubscribeParams;
  // pxUnsubscribeParams
  const MQTTAgentUnsubscribeParams_t *pxUnsubscribeParams;
  // pxPublishParams
  const MQTTAgentPublishParams_t *pxPublishParams;
};

union anonymous$101
{
  // bits
  struct anonymous$100 bits;
  // ulFlags
  uint32_t ulFlags;
};

union anonymous$96
{
  // bits
  struct anonymous$95 bits;
  // ulFlags
  uint32_t ulFlags;
};

union anonymous$108
{
  // $anon0
  struct anonymous$79 $anon0;
  // Pointer
  PVOID Pointer;
};

typedef union anonymous$99
{
  // a
  struct anonymous$97 a;
  // u
  struct anonymous$98 u;
} LastTCPPacket_t;

union anonymous$87
{
  // S_un_b
  struct anonymous$106 S_un_b;
  // S_un_w
  struct anonymous$107 S_un_w;
  // S_addr
  ULONG S_addr;
};

typedef struct MQTTConnACKData
{
  // xConnACkReturnCode
  MQTTConnACKReturnCode_t xConnACkReturnCode;
  // usPacketIdentifier
  uint16_t usPacketIdentifier;
} MQTTConnACKData_t;

typedef struct MQTTSubACKData
{
  // xSubACKReturnCode
  MQTTSubACKReturnCode_t xSubACKReturnCode;
  // usPacketIdentifier
  uint16_t usPacketIdentifier;
} MQTTSubACKData_t;

typedef struct MQTTUnSubACKData
{
  // usPacketIdentifier
  uint16_t usPacketIdentifier;
} MQTTUnSubACKData_t;

typedef struct MQTTPubACKData
{
  // usPacketIdentifier
  uint16_t usPacketIdentifier;
} MQTTPubACKData_t;

typedef struct MQTTPublishData
{
  // xQos
  MQTTQoS_t xQos;
  // pucTopic
  const uint8_t *pucTopic;
  // usTopicLength
  uint16_t usTopicLength;
  // pvData
  const void *pvData;
  // ulDataLength
  uint32_t ulDataLength;
  // xBuffer
  MQTTBufferHandle_t xBuffer;
} MQTTPublishData_t;

typedef struct MQTTTimeoutData
{
  // usPacketIdentifier
  uint16_t usPacketIdentifier;
} MQTTTimeoutData_t;

typedef struct MQTTDisconnectData
{
  // xDisconnectReason
  MQTTDisconnectReason_t xDisconnectReason;
} MQTTDisconnectData_t;

union anonymous$32
{
  // xMQTTConnACKData
  MQTTConnACKData_t xMQTTConnACKData;
  // xMQTTSubACKData
  MQTTSubACKData_t xMQTTSubACKData;
  // xMQTTUnSubACKData
  MQTTUnSubACKData_t xMQTTUnSubACKData;
  // xMQTTPubACKData
  MQTTPubACKData_t xMQTTPubACKData;
  // xPublishData
  MQTTPublishData_t xPublishData;
  // xTimeoutData
  MQTTTimeoutData_t xTimeoutData;
  // xDisconnectData
  MQTTDisconnectData_t xDisconnectData;
};

union anonymous$42
{
  // xPublishData
  MQTTPublishData_t xPublishData;
};

typedef struct xMINI_LIST_ITEM
{
  // xItemValue
  TickType_t xItemValue;
  // pxNext
  struct xLIST_ITEM *pxNext;
  // pxPrevious
  struct xLIST_ITEM *pxPrevious;
} MiniListItem_t;

typedef struct xLIST
{
  // uxNumberOfItems
  volatile UBaseType_t uxNumberOfItems;
  // pxIndex
  ListItem_t *pxIndex;
  // xListEnd
  MiniListItem_t xListEnd;
} List_t;

typedef struct UDPSOCKET
{
  // xWaitingPacketsList
  List_t xWaitingPacketsList;
} IPUDPSocket_t;

typedef struct xTCP_WINSIZE
{
  // ulRxWindowLength
  uint32_t ulRxWindowLength;
  // ulTxWindowLength
  uint32_t ulTxWindowLength;
} TCPWinSize_t;

typedef struct xTCP_WINDOW
{
  // u
  union anonymous$101 u;
  // xSize
  TCPWinSize_t xSize;
  // rx
  struct anonymous$103 rx;
  // tx
  struct anonymous$103 tx;
  // ulOurSequenceNumber
  uint32_t ulOurSequenceNumber;
  // ulUserDataLength
  uint32_t ulUserDataLength;
  // ulNextTxSequenceNumber
  uint32_t ulNextTxSequenceNumber;
  // lSRTT
  int32_t lSRTT;
  // ucOptionLength
  uint8_t ucOptionLength;
  // xPriorityQueue
  List_t xPriorityQueue;
  // xTxQueue
  List_t xTxQueue;
  // xWaitQueue
  List_t xWaitQueue;
  // pxHeadSegment
  TCPSegment_t *pxHeadSegment;
  // ulOptionsData
  uint32_t ulOptionsData[4ll];
  // xTxSegments
  List_t xTxSegments;
  // xRxSegments
  List_t xRxSegments;
  // usOurPortNumber
  uint16_t usOurPortNumber;
  // usPeerPortNumber
  uint16_t usPeerPortNumber;
  // usMSS
  uint16_t usMSS;
  // usMSSInit
  uint16_t usMSSInit;
} TCPWindow_t;

typedef struct TCPSOCKET
{
  // ulRemoteIP
  uint32_t ulRemoteIP;
  // usRemotePort
  uint16_t usRemotePort;
  // bits
  struct anonymous$104 bits;
  // ulHighestRxAllowed
  uint32_t ulHighestRxAllowed;
  // usTimeout
  uint16_t usTimeout;
  // usCurMSS
  uint16_t usCurMSS;
  // usInitMSS
  uint16_t usInitMSS;
  // usChildCount
  uint16_t usChildCount;
  // usBacklog
  uint16_t usBacklog;
  // ucRepCount
  uint8_t ucRepCount;
  // ucTCPState
  uint8_t ucTCPState;
  // pxPeerSocket
  struct XSOCKET *pxPeerSocket;
  // ucKeepRepCount
  uint8_t ucKeepRepCount;
  // xLastAliveTime
  TickType_t xLastAliveTime;
  // xLastActTime
  TickType_t xLastActTime;
  // uxLittleSpace
  size_t uxLittleSpace;
  // uxEnoughSpace
  size_t uxEnoughSpace;
  // uxRxStreamSize
  size_t uxRxStreamSize;
  // uxTxStreamSize
  size_t uxTxStreamSize;
  // rxStream
  const StreamBuffer_t *rxStream;
  // txStream
  const StreamBuffer_t *txStream;
  // pxAckMessage
  NetworkBufferDescriptor_t *pxAckMessage;
  // xPacket
  LastTCPPacket_t xPacket;
  // tcpflags
  uint8_t tcpflags;
  // ucMyWinScaleFactor
  uint8_t ucMyWinScaleFactor;
  // ucPeerWinScaleFactor
  uint8_t ucPeerWinScaleFactor;
  // ulWindowSize
  uint32_t ulWindowSize;
  // ulRxCurWinSize
  uint32_t ulRxCurWinSize;
  // uxRxWinSize
  size_t uxRxWinSize;
  // uxTxWinSize
  size_t uxTxWinSize;
  // xTCPWindow
  TCPWindow_t xTCPWindow;
} IPTCPSocket_t;

union anonymous$105
{
  // xUDP
  IPUDPSocket_t xUDP;
  // xTCP
  IPTCPSocket_t xTCP;
  // ullTCPAlignment
  uint64_t ullTCPAlignment;
};

typedef struct tmrTimerParameters
{
  // xMessageValue
  TickType_t xMessageValue;
  // pxTimer
  Timer_t *pxTimer;
} TimerParameter_t;

typedef struct tmrCallbackParameters
{
  // pxCallbackFunction
  PendedFunction_t pxCallbackFunction;
  // pvParameter1
  void *pvParameter1;
  // ulParameter2
  uint32_t ulParameter2;
} CallbackParameters_t;

union anonymous$54
{
  // xTimerParameters
  TimerParameter_t xTimerParameters;
  // xCallbackParameters
  CallbackParameters_t xCallbackParameters;
};

union anonymous$81
{
  // dwOemId
  DWORD dwOemId;
  // $anon0
  struct anonymous$80 $anon0;
};

typedef struct A_BLOCK_LINK
{
  // pxNextFreeBlock
  struct A_BLOCK_LINK *pxNextFreeBlock;
  // xBlockSize
  size_t xBlockSize;
} BlockLink_t;

typedef struct BufferMetadata
{
  // ucBufferInUse
  uint8_t ucBufferInUse;
} BufferMetadata_t;

typedef struct CK_ATTRIBUTE
{
  // type
  CK_ATTRIBUTE_TYPE type;
  // pValue
  CK_VOID_PTR pValue;
  // ulValueLen
  CK_ULONG ulValueLen;
} CK_ATTRIBUTE;

typedef struct CK_VERSION
{
  // major
  CK_BYTE major;
  // minor
  CK_BYTE minor;
} CK_VERSION;

typedef struct CK_FUNCTION_LIST
{
  // version
  CK_VERSION version;
  // C_Initialize
  CK_C_Initialize C_Initialize;
  // C_Finalize
  CK_C_Finalize C_Finalize;
  // C_GetInfo
  CK_C_GetInfo C_GetInfo;
  // C_GetFunctionList
  CK_C_GetFunctionList C_GetFunctionList;
  // C_GetSlotList
  CK_C_GetSlotList C_GetSlotList;
  // C_GetSlotInfo
  CK_C_GetSlotInfo C_GetSlotInfo;
  // C_GetTokenInfo
  CK_C_GetTokenInfo C_GetTokenInfo;
  // C_GetMechanismList
  CK_C_GetMechanismList C_GetMechanismList;
  // C_GetMechanismInfo
  CK_C_GetMechanismInfo C_GetMechanismInfo;
  // C_InitToken
  CK_C_InitToken C_InitToken;
  // C_InitPIN
  CK_C_InitPIN C_InitPIN;
  // C_SetPIN
  CK_C_SetPIN C_SetPIN;
  // C_OpenSession
  CK_C_OpenSession C_OpenSession;
  // C_CloseSession
  CK_C_CloseSession C_CloseSession;
  // C_CloseAllSessions
  CK_C_CloseAllSessions C_CloseAllSessions;
  // C_GetSessionInfo
  CK_C_GetSessionInfo C_GetSessionInfo;
  // C_GetOperationState
  CK_C_GetOperationState C_GetOperationState;
  // C_SetOperationState
  CK_C_SetOperationState C_SetOperationState;
  // C_Login
  CK_C_Login C_Login;
  // C_Logout
  CK_C_Logout C_Logout;
  // C_CreateObject
  CK_C_CreateObject C_CreateObject;
  // C_CopyObject
  CK_C_CopyObject C_CopyObject;
  // C_DestroyObject
  CK_C_DestroyObject C_DestroyObject;
  // C_GetObjectSize
  CK_C_GetObjectSize C_GetObjectSize;
  // C_GetAttributeValue
  CK_C_GetAttributeValue C_GetAttributeValue;
  // C_SetAttributeValue
  CK_C_SetAttributeValue C_SetAttributeValue;
  // C_FindObjectsInit
  CK_C_FindObjectsInit C_FindObjectsInit;
  // C_FindObjects
  CK_C_FindObjects C_FindObjects;
  // C_FindObjectsFinal
  CK_C_FindObjectsFinal C_FindObjectsFinal;
  // C_EncryptInit
  CK_C_EncryptInit C_EncryptInit;
  // C_Encrypt
  CK_C_Encrypt C_Encrypt;
  // C_EncryptUpdate
  CK_C_EncryptUpdate C_EncryptUpdate;
  // C_EncryptFinal
  CK_C_EncryptFinal C_EncryptFinal;
  // C_DecryptInit
  CK_C_DecryptInit C_DecryptInit;
  // C_Decrypt
  CK_C_Decrypt C_Decrypt;
  // C_DecryptUpdate
  CK_C_DecryptUpdate C_DecryptUpdate;
  // C_DecryptFinal
  CK_C_DecryptFinal C_DecryptFinal;
  // C_DigestInit
  CK_C_DigestInit C_DigestInit;
  // C_Digest
  CK_C_Digest C_Digest;
  // C_DigestUpdate
  CK_C_DigestUpdate C_DigestUpdate;
  // C_DigestKey
  CK_C_DigestKey C_DigestKey;
  // C_DigestFinal
  CK_C_DigestFinal C_DigestFinal;
  // C_SignInit
  CK_C_SignInit C_SignInit;
  // C_Sign
  CK_C_Sign C_Sign;
  // C_SignUpdate
  CK_C_SignUpdate C_SignUpdate;
  // C_SignFinal
  CK_C_SignFinal C_SignFinal;
  // C_SignRecoverInit
  CK_C_SignRecoverInit C_SignRecoverInit;
  // C_SignRecover
  CK_C_SignRecover C_SignRecover;
  // C_VerifyInit
  CK_C_VerifyInit C_VerifyInit;
  // C_Verify
  CK_C_Verify C_Verify;
  // C_VerifyUpdate
  CK_C_VerifyUpdate C_VerifyUpdate;
  // C_VerifyFinal
  CK_C_VerifyFinal C_VerifyFinal;
  // C_VerifyRecoverInit
  CK_C_VerifyRecoverInit C_VerifyRecoverInit;
  // C_VerifyRecover
  CK_C_VerifyRecover C_VerifyRecover;
  // C_DigestEncryptUpdate
  CK_C_DigestEncryptUpdate C_DigestEncryptUpdate;
  // C_DecryptDigestUpdate
  CK_C_DecryptDigestUpdate C_DecryptDigestUpdate;
  // C_SignEncryptUpdate
  CK_C_SignEncryptUpdate C_SignEncryptUpdate;
  // C_DecryptVerifyUpdate
  CK_C_DecryptVerifyUpdate C_DecryptVerifyUpdate;
  // C_GenerateKey
  CK_C_GenerateKey C_GenerateKey;
  // C_GenerateKeyPair
  CK_C_GenerateKeyPair C_GenerateKeyPair;
  // C_WrapKey
  CK_C_WrapKey C_WrapKey;
  // C_UnwrapKey
  CK_C_UnwrapKey C_UnwrapKey;
  // C_DeriveKey
  CK_C_DeriveKey C_DeriveKey;
  // C_SeedRandom
  CK_C_SeedRandom C_SeedRandom;
  // C_GenerateRandom
  CK_C_GenerateRandom C_GenerateRandom;
  // C_GetFunctionStatus
  CK_C_GetFunctionStatus C_GetFunctionStatus;
  // C_CancelFunction
  CK_C_CancelFunction C_CancelFunction;
  // C_WaitForSlotEvent
  CK_C_WaitForSlotEvent C_WaitForSlotEvent;
} CK_FUNCTION_LIST;

typedef struct CK_INFO
{
  // cryptokiVersion
  CK_VERSION cryptokiVersion;
  // manufacturerID
  CK_UTF8CHAR manufacturerID[32ll];
  // flags
  CK_FLAGS flags;
  // libraryDescription
  CK_UTF8CHAR libraryDescription[32ll];
  // libraryVersion
  CK_VERSION libraryVersion;
} CK_INFO;

typedef struct CK_MECHANISM
{
  // mechanism
  CK_MECHANISM_TYPE mechanism;
  // pParameter
  CK_VOID_PTR pParameter;
  // ulParameterLen
  CK_ULONG ulParameterLen;
} CK_MECHANISM;

typedef struct CK_MECHANISM_INFO
{
  // ulMinKeySize
  CK_ULONG ulMinKeySize;
  // ulMaxKeySize
  CK_ULONG ulMaxKeySize;
  // flags
  CK_FLAGS flags;
} CK_MECHANISM_INFO;

typedef struct CK_SESSION_INFO
{
  // slotID
  CK_SLOT_ID slotID;
  // state
  CK_STATE state;
  // flags
  CK_FLAGS flags;
  // ulDeviceError
  CK_ULONG ulDeviceError;
} CK_SESSION_INFO;

typedef struct CK_SLOT_INFO
{
  // slotDescription
  CK_UTF8CHAR slotDescription[64ll];
  // manufacturerID
  CK_UTF8CHAR manufacturerID[32ll];
  // flags
  CK_FLAGS flags;
  // hardwareVersion
  CK_VERSION hardwareVersion;
  // firmwareVersion
  CK_VERSION firmwareVersion;
} CK_SLOT_INFO;

typedef struct CK_TOKEN_INFO
{
  // label
  CK_UTF8CHAR label[32ll];
  // manufacturerID
  CK_UTF8CHAR manufacturerID[32ll];
  // model
  CK_UTF8CHAR model[16ll];
  // serialNumber
  CK_CHAR serialNumber[16ll];
  // flags
  CK_FLAGS flags;
  // ulMaxSessionCount
  CK_ULONG ulMaxSessionCount;
  // ulSessionCount
  CK_ULONG ulSessionCount;
  // ulMaxRwSessionCount
  CK_ULONG ulMaxRwSessionCount;
  // ulRwSessionCount
  CK_ULONG ulRwSessionCount;
  // ulMaxPinLen
  CK_ULONG ulMaxPinLen;
  // ulMinPinLen
  CK_ULONG ulMinPinLen;
  // ulTotalPublicMemory
  CK_ULONG ulTotalPublicMemory;
  // ulFreePublicMemory
  CK_ULONG ulFreePublicMemory;
  // ulTotalPrivateMemory
  CK_ULONG ulTotalPrivateMemory;
  // ulFreePrivateMemory
  CK_ULONG ulFreePrivateMemory;
  // hardwareVersion
  CK_VERSION hardwareVersion;
  // firmwareVersion
  CK_VERSION firmwareVersion;
  // utcTime
  CK_CHAR utcTime[16ll];
} CK_TOKEN_INFO;

typedef struct ShadowCallbackParams
{
  // pcThingName
  const char *pcThingName;
  // xShadowUpdatedCallback
  ShadowUpdatedCallback_t xShadowUpdatedCallback;
  // xShadowDeletedCallback
  ShadowDeletedCallback_t xShadowDeletedCallback;
  // xShadowDeltaCallback
  ShadowDeltaCallback_t xShadowDeltaCallback;
} ShadowCallbackParams_t;

typedef struct CallbackCatalogEntry
{
  // xCallbackInfo
  ShadowCallbackParams_t xCallbackInfo;
  // xInUse
  BaseType_t xInUse;
} CallbackCatalogEntry_t;

typedef struct CborEncoder
{
  // data
  union anonymous$30 data;
  // end
  const uint8_t *end;
  // added
  size_t added;
  // flags
  signed int flags;
} CborEncoder;

typedef struct CborParser
{
  // end
  const uint8_t *end;
  // flags
  signed int flags;
} CborParser;

typedef struct CborValue
{
  // parser
  const CborParser *parser;
  // ptr
  const uint8_t *ptr;
  // remaining
  uint32_t remaining;
  // extra
  uint16_t extra;
  // type
  uint8_t type;
  // flags
  uint8_t flags;
} CborValue;

struct HINSTANCE__
{
  // unused
  signed int unused;
};

typedef struct IP_TASK_COMMANDS
{
  // eEventType
  eIPEvent_t eEventType;
  // pvData
  void *pvData;
} IPStackEvent_t;

typedef struct Link
{
  // pxPrev
  struct Link *pxPrev;
  // pxNext
  struct Link *pxNext;
} Link_t;

typedef struct MQTTAgentCallbackParams
{
  // xMQTTEvent
  MQTTAgentEvent_t xMQTTEvent;
  // u
  union anonymous$42 u;
} MQTTAgentCallbackParams_t;

typedef struct MQTTAgentConnectParams
{
  // pcURL
  const char *pcURL;
  // xFlags
  BaseType_t xFlags;
  // xURLIsIPAddress
  BaseType_t xURLIsIPAddress;
  // usPort
  uint16_t usPort;
  // pucClientId
  const uint8_t *pucClientId;
  // usClientIdLength
  uint16_t usClientIdLength;
  // xSecuredConnection
  BaseType_t xSecuredConnection;
  // pvUserData
  void *pvUserData;
  // pxCallback
  MQTTAgentCallback_t pxCallback;
  // pcCertificate
  char *pcCertificate;
  // ulCertificateSize
  uint32_t ulCertificateSize;
} MQTTAgentConnectParams_t;

typedef struct MQTTAgentPublishParams
{
  // pucTopic
  const uint8_t *pucTopic;
  // usTopicLength
  uint16_t usTopicLength;
  // xQoS
  MQTTQoS_t xQoS;
  // pvData
  const void *pvData;
  // ulDataLength
  uint32_t ulDataLength;
} MQTTAgentPublishParams_t;

typedef struct MQTTAgentSubscribeParams
{
  // pucTopic
  const uint8_t *pucTopic;
  // usTopicLength
  uint16_t usTopicLength;
  // xQoS
  MQTTQoS_t xQoS;
  // pvPublishCallbackContext
  void *pvPublishCallbackContext;
  // pxPublishCallback
  MQTTPublishCallback_t pxPublishCallback;
} MQTTAgentSubscribeParams_t;

typedef struct MQTTAgentUnsubscribeParams
{
  // pucTopic
  const uint8_t *pucTopic;
  // usTopicLength
  uint16_t usTopicLength;
} MQTTAgentUnsubscribeParams_t;

typedef struct MQTTRxMessageState
{
  // xRxNextByte
  MQTTRxNextByte_t xRxNextByte;
  // xRxMessageAction
  MQTTRxMessageAction_t xRxMessageAction;
  // ucRemaingingLengthFieldBytes
  uint8_t ucRemaingingLengthFieldBytes;
  // ulTotalMessageLength
  uint32_t ulTotalMessageLength;
} MQTTRxMessageState_t;

typedef struct MQTTBufferPoolInterface
{
  // pxGetBufferFxn
  MQTTGetFreeBuffer_t pxGetBufferFxn;
  // pxReturnBufferFxn
  MQTTReturnBuffer_t pxReturnBufferFxn;
} MQTTBufferPoolInterface_t;

typedef struct MQTTSubscription
{
  // ucTopicFilter
  uint8_t ucTopicFilter[128ll];
  // usTopicFilterLength
  uint16_t usTopicFilterLength;
  // pvPublishCallbackContext
  void *pvPublishCallbackContext;
  // pxPublishCallback
  MQTTPublishCallback_t pxPublishCallback;
  // xInUse
  MQTTBool_t xInUse;
  // xTopicFilterType
  MQTTTopicFilterType_t xTopicFilterType;
} MQTTSubscription_t;

typedef struct MQTTSubscriptionManager
{
  // xSubscriptions
  MQTTSubscription_t xSubscriptions[8ll];
  // ulInUseSubscriptions
  uint32_t ulInUseSubscriptions;
} MQTTSubscriptionManager_t;

typedef struct MQTTContext
{
  // xTxBufferListHead
  Link_t xTxBufferListHead;
  // xRxBuffer
  MQTTBufferHandle_t xRxBuffer;
  // xRxMessageState
  MQTTRxMessageState_t xRxMessageState;
  // ucRxFixedHeaderBuffer
  uint8_t ucRxFixedHeaderBuffer[5ll];
  // ulRxMessageReceivedLength
  uint32_t ulRxMessageReceivedLength;
  // pvCallbackContext
  void *pvCallbackContext;
  // pxCallback
  MQTTEventCallback_t pxCallback;
  // pvSendContext
  void *pvSendContext;
  // pxMQTTSendFxn
  MQTTSend_t pxMQTTSendFxn;
  // pxGetTicksFxn
  MQTTGetTicks_t pxGetTicksFxn;
  // xBufferPoolInterface
  MQTTBufferPoolInterface_t xBufferPoolInterface;
  // xConnectionState
  MQTTConnectionState_t xConnectionState;
  // xLastSentMessageTimestamp
  uint64_t xLastSentMessageTimestamp;
  // ulNextPeriodicInvokeTicks
  uint32_t ulNextPeriodicInvokeTicks;
  // ulKeepAliveActualIntervalTicks
  uint32_t ulKeepAliveActualIntervalTicks;
  // ulPingRequestTimeoutTicks
  uint32_t ulPingRequestTimeoutTicks;
  // xWaitingForPingResp
  MQTTBool_t xWaitingForPingResp;
  // xSubscriptionManager
  MQTTSubscriptionManager_t xSubscriptionManager;
} MQTTContext_t;

typedef struct MQTTNotificationData
{
  // xTaskToNotify
  TaskHandle_t xTaskToNotify;
  // ulMessageIdentifier
  uint32_t ulMessageIdentifier;
} MQTTNotificationData_t;

typedef struct MQTTBrokerConnection
{
  // xSocket
  Socket_t xSocket;
  // xMQTTContext
  MQTTContext_t xMQTTContext;
  // xWaitingTasks
  MQTTNotificationData_t xWaitingTasks[5ll];
  // pvUserData
  void *pvUserData;
  // pxCallback
  MQTTAgentCallback_t pxCallback;
  // uxFlags
  UBaseType_t uxFlags;
  // xConnectionInUse
  BaseType_t xConnectionInUse;
  // ucRxBuffer
  uint8_t ucRxBuffer[1152ll];
} MQTTBrokerConnection_t;

typedef struct MQTTBufferState
{
  // xRecordedTickCount
  uint64_t xRecordedTickCount;
  // ulTimeoutTicks
  uint32_t ulTimeoutTicks;
  // usPacketIdentifier
  uint16_t usPacketIdentifier;
} MQTTBufferState_t;

typedef struct MQTTBufferMetadata
{
  // xBufferState
  MQTTBufferState_t xBufferState;
  // xLink
  Link_t xLink;
  // ulBufferLength
  uint32_t ulBufferLength;
  // ulDataLength
  uint32_t ulDataLength;
} MQTTBufferMetadata_t;

typedef struct MQTTCallbackParams
{
  // xEventType
  MQTTEventType_t xEventType;
  // u
  union anonymous$32 u;
} MQTTEventCallbackParams_t;

typedef struct MQTTConnectParams
{
  // usKeepAliveIntervlSeconds
  uint16_t usKeepAliveIntervlSeconds;
  // ulKeepAliveActualIntervalTicks
  uint32_t ulKeepAliveActualIntervalTicks;
  // ulPingRequestTimeoutTicks
  uint32_t ulPingRequestTimeoutTicks;
  // pucClientId
  const uint8_t *pucClientId;
  // usClientIdLength
  uint16_t usClientIdLength;
  // pucUserName
  const uint8_t *pucUserName;
  // usUserNameLength
  uint16_t usUserNameLength;
  // usPacketIdentifier
  uint16_t usPacketIdentifier;
  // ulTimeoutTicks
  uint32_t ulTimeoutTicks;
} MQTTConnectParams_t;

typedef struct xTIME_OUT
{
  // xOverflowCount
  BaseType_t xOverflowCount;
  // xTimeOnEntering
  TickType_t xTimeOnEntering;
} TimeOut_t;

typedef struct MQTTEventData
{
  // uxBrokerNumber
  UBaseType_t uxBrokerNumber;
  // xEventType
  MQTTAction_t xEventType;
  // xNotificationData
  MQTTNotificationData_t xNotificationData;
  // xEventCreationTimestamp
  TimeOut_t xEventCreationTimestamp;
  // xTicksToWait
  TickType_t xTicksToWait;
  // u
  union anonymous$31 u;
} MQTTEventData_t;

typedef struct MQTTInitParams
{
  // pvCallbackContext
  void *pvCallbackContext;
  // pxCallback
  MQTTEventCallback_t pxCallback;
  // pvSendContext
  void *pvSendContext;
  // pxMQTTSendFxn
  MQTTSend_t pxMQTTSendFxn;
  // pxGetTicksFxn
  MQTTGetTicks_t pxGetTicksFxn;
  // xBufferPoolInterface
  MQTTBufferPoolInterface_t xBufferPoolInterface;
} MQTTInitParams_t;

typedef struct MQTTPublishParams
{
  // pucTopic
  const uint8_t *pucTopic;
  // usTopicLength
  uint16_t usTopicLength;
  // xQos
  MQTTQoS_t xQos;
  // pvData
  const void *pvData;
  // ulDataLength
  uint32_t ulDataLength;
  // usPacketIdentifier
  uint16_t usPacketIdentifier;
  // ulTimeoutTicks
  uint32_t ulTimeoutTicks;
} MQTTPublishParams_t;

typedef struct MQTTSubscribeParams
{
  // pucTopic
  const uint8_t *pucTopic;
  // usTopicLength
  uint16_t usTopicLength;
  // xQos
  MQTTQoS_t xQos;
  // usPacketIdentifier
  uint16_t usPacketIdentifier;
  // ulTimeoutTicks
  uint32_t ulTimeoutTicks;
  // pvPublishCallbackContext
  void *pvPublishCallbackContext;
  // pxPublishCallback
  MQTTPublishCallback_t pxPublishCallback;
} MQTTSubscribeParams_t;

typedef struct MQTTUnsubscribeParams
{
  // pucTopic
  const uint8_t *pucTopic;
  // usTopicLength
  uint16_t usTopicLength;
  // usPacketIdentifier
  uint16_t usPacketIdentifier;
  // ulTimeoutTicks
  uint32_t ulTimeoutTicks;
} MQTTUnsubscribeParams_t;

typedef struct mbedtls_asn1_buf
{
  // tag
  signed int tag;
  // len
  size_t len;
  // p
  unsigned char *p;
} mbedtls_x509_buf;

typedef struct mbedtls_asn1_named_data
{
  // oid
  mbedtls_asn1_buf oid;
  // val
  mbedtls_asn1_buf val;
  // next
  struct mbedtls_asn1_named_data *next;
  // next_merged
  unsigned char next_merged;
} mbedtls_x509_name;

typedef struct mbedtls_x509_time
{
  // year
  signed int year;
  // mon
  signed int mon;
  // day
  signed int day;
  // hour
  signed int hour;
  // min
  signed int min;
  // sec
  signed int sec;
} mbedtls_x509_time;

typedef struct mbedtls_asn1_sequence
{
  // buf
  mbedtls_asn1_buf buf;
  // next
  struct mbedtls_asn1_sequence *next;
} mbedtls_x509_sequence;

typedef struct mbedtls_x509_crt
{
  // raw
  mbedtls_x509_buf raw;
  // tbs
  mbedtls_x509_buf tbs;
  // version
  signed int version;
  // serial
  mbedtls_x509_buf serial;
  // sig_oid
  mbedtls_x509_buf sig_oid;
  // issuer_raw
  mbedtls_x509_buf issuer_raw;
  // subject_raw
  mbedtls_x509_buf subject_raw;
  // issuer
  mbedtls_x509_name issuer;
  // subject
  mbedtls_x509_name subject;
  // valid_from
  mbedtls_x509_time valid_from;
  // valid_to
  mbedtls_x509_time valid_to;
  // pk
  mbedtls_pk_context pk;
  // issuer_id
  mbedtls_x509_buf issuer_id;
  // subject_id
  mbedtls_x509_buf subject_id;
  // v3_ext
  mbedtls_x509_buf v3_ext;
  // subject_alt_names
  mbedtls_x509_sequence subject_alt_names;
  // ext_types
  signed int ext_types;
  // ca_istrue
  signed int ca_istrue;
  // max_pathlen
  signed int max_pathlen;
  // key_usage
  unsigned int key_usage;
  // ext_key_usage
  mbedtls_x509_sequence ext_key_usage;
  // ns_cert_type
  unsigned char ns_cert_type;
  // sig
  mbedtls_x509_buf sig;
  // sig_md
  mbedtls_md_type_t sig_md;
  // sig_pk
  mbedtls_pk_type_t sig_pk;
  // sig_opts
  void *sig_opts;
  // next
  struct mbedtls_x509_crt *next;
} mbedtls_x509_crt;

typedef struct mbedtls_pk_info_t
{
  // type
  mbedtls_pk_type_t type;
  // name
  const char *name;
  // get_bitlen
  size_t (*get_bitlen)(const void *);
  // can_do
  signed int (*can_do)(mbedtls_pk_type_t);
  // verify_func
  signed int (*verify_func)(void *, mbedtls_md_type_t, const unsigned char *, size_t, const unsigned char *, size_t);
  // sign_func
  signed int (*sign_func)(void *, mbedtls_md_type_t, const unsigned char *, size_t, unsigned char *, size_t *, signed int (*)(void *, unsigned char *, size_t), void *);
  // decrypt_func
  signed int (*decrypt_func)(void *, const unsigned char *, size_t, unsigned char *, size_t *, size_t, signed int (*)(void *, unsigned char *, size_t), void *);
  // encrypt_func
  signed int (*encrypt_func)(void *, const unsigned char *, size_t, unsigned char *, size_t *, size_t, signed int (*)(void *, unsigned char *, size_t), void *);
  // check_pair_func
  signed int (*check_pair_func)(const void *, const void *);
  // ctx_alloc_func
  void * (*ctx_alloc_func)(void);
  // ctx_free_func
  void (*ctx_free_func)(void *);
  // debug_func
  void (*debug_func)(const void *, mbedtls_pk_debug_item *);
} mbedtls_pk_info_t;

typedef struct P11Key
{
  // xMbedPkCtx
  mbedtls_pk_context xMbedPkCtx;
  // xMbedX509Cli
  mbedtls_x509_crt xMbedX509Cli;
  // xMbedPkInfo
  mbedtls_pk_info_t xMbedPkInfo;
  // pfnSavedMbedSign
  pfnMbedTlsSign pfnSavedMbedSign;
  // pvSavedMbedPkCtx
  void *pvSavedMbedPkCtx;
} P11Key_t;

typedef struct P11Session
{
  // pxCurrentKey
  P11KeyPtr_t pxCurrentKey;
  // ulState
  CK_ULONG ulState;
  // xOpened
  CK_BBOOL xOpened;
  // xOperationInProgress
  CK_MECHANISM_TYPE xOperationInProgress;
  // xFindObjectInit
  CK_BBOOL xFindObjectInit;
  // xFindObjectComplete
  CK_BBOOL xFindObjectComplete;
  // xFindObjectClass
  CK_OBJECT_CLASS xFindObjectClass;
  // xMbedDrbgCtx
  mbedtls_ctr_drbg_context xMbedDrbgCtx;
  // xMbedEntropyContext
  mbedtls_entropy_context xMbedEntropyContext;
  // xPublicKey
  mbedtls_pk_context xPublicKey;
  // xSHA256Context
  mbedtls_sha256_context xSHA256Context;
} P11Session_t;

typedef struct ProvisioningParams_t
{
  // ulClientPrivateKeyType
  uint32_t ulClientPrivateKeyType;
  // pcClientPrivateKey
  uint8_t *pcClientPrivateKey;
  // ulClientPrivateKeyLength
  uint32_t ulClientPrivateKeyLength;
  // pcClientCertificate
  uint8_t *pcClientCertificate;
  // ulClientCertificateLength
  uint32_t ulClientCertificateLength;
} ProvisioningParams_t;

typedef struct QueueDefinition
{
  // pcHead
  int8_t *pcHead;
  // pcTail
  int8_t *pcTail;
  // pcWriteTo
  int8_t *pcWriteTo;
  // u
  union anonymous$58 u;
  // xTasksWaitingToSend
  List_t xTasksWaitingToSend;
  // xTasksWaitingToReceive
  List_t xTasksWaitingToReceive;
  // uxMessagesWaiting
  volatile UBaseType_t uxMessagesWaiting;
  // uxLength
  UBaseType_t uxLength;
  // uxItemSize
  UBaseType_t uxItemSize;
  // cRxLock
  volatile int8_t cRxLock;
  // cTxLock
  volatile int8_t cTxLock;
  // ucStaticallyAllocated
  uint8_t ucStaticallyAllocated;
  // uxQueueNumber
  UBaseType_t uxQueueNumber;
  // ucQueueType
  uint8_t ucQueueType;
} Queue_t;

typedef struct SSOCKETContext
{
  // xSocket
  Socket_t xSocket;
  // pcDestination
  char *pcDestination;
  // pvTLSContext
  void *pvTLSContext;
  // xRequireTLS
  BaseType_t xRequireTLS;
  // xSendFlags
  BaseType_t xSendFlags;
  // xRecvFlags
  BaseType_t xRecvFlags;
  // pcServerCertificate
  char *pcServerCertificate;
  // ulServerCertificateLength
  uint32_t ulServerCertificateLength;
  // ppcAlpnProtocols
  char **ppcAlpnProtocols;
  // ulAlpnProtocolsCount
  uint32_t ulAlpnProtocolsCount;
  // xConnectAttempted
  BaseType_t xConnectAttempted;
} SSOCKETContext_t;

typedef struct xSTATIC_MINI_LIST_ITEM
{
  // xDummy1
  TickType_t xDummy1;
  // pvDummy2
  void *pvDummy2[2ll];
} StaticMiniListItem_t;

typedef struct xSTATIC_LIST
{
  // uxDummy1
  UBaseType_t uxDummy1;
  // pvDummy2
  void *pvDummy2;
  // xDummy3
  StaticMiniListItem_t xDummy3;
} StaticList_t;

typedef struct xSTATIC_QUEUE
{
  // pvDummy1
  void *pvDummy1[3ll];
  // u
  union anonymous$57 u;
  // xDummy3
  StaticList_t xDummy3[2ll];
  // uxDummy4
  UBaseType_t uxDummy4[3ll];
  // ucDummy5
  uint8_t ucDummy5[2ll];
  // ucDummy6
  uint8_t ucDummy6;
  // uxDummy8
  UBaseType_t uxDummy8;
  // ucDummy9
  uint8_t ucDummy9;
} StaticSemaphore_t;

typedef struct ShadowClient
{
  // xMQTTClient
  MQTTAgentHandle_t xMQTTClient;
  // xInUse
  BaseType_t xInUse;
  // xUpdateSubscribed
  BaseType_t xUpdateSubscribed;
  // xGetSubscribed
  BaseType_t xGetSubscribed;
  // xDeleteSubscribed
  BaseType_t xDeleteSubscribed;
  // xOperationMutex
  SemaphoreHandle_t xOperationMutex;
  // xCallbackSemaphore
  SemaphoreHandle_t xCallbackSemaphore;
  // xOperationMutexBuffer
  StaticSemaphore_t xOperationMutexBuffer;
  // xCallbackSemaphoreBuffer
  StaticSemaphore_t xCallbackSemaphoreBuffer;
  // pxOperationData
  ShadowOperationData_t *pxOperationData;
  // xOperationResult
  volatile ShadowReturnCode_t xOperationResult;
  // pxCallbackCatalog
  CallbackCatalogEntry_t pxCallbackCatalog[1ll];
  // pucTopicBuffer
  uint8_t pucTopicBuffer[(signed long long int)(sizeof(char [39ll]) * 4ul + 11ul) /*167ll*/ ];
} ShadowClient_t;

typedef struct ShadowCreateParams
{
  // xMQTTClientType
  ShadowMQTTClientType_t xMQTTClientType;
  // xMQTTClientHandle
  MQTTAgentHandle_t xMQTTClientHandle;
} ShadowCreateParams_t;

typedef struct ShadowOperationCallParams
{
  // xShadowClientID
  BaseType_t xShadowClientID;
  // xOperationName
  ShadowOperationName_t xOperationName;
  // pcOperationName
  const char *pcOperationName;
  // pcOperationTopic
  const char *pcOperationTopic;
  // pcOperationAcceptedTopic
  const char *pcOperationAcceptedTopic;
  // pcOperationRejectedTopic
  const char *pcOperationRejectedTopic;
  // pcPublishMessage
  const char *pcPublishMessage;
  // ulPublishMessageLength
  uint32_t ulPublishMessageLength;
  // pxOperationParams
  ShadowOperationParams_t *pxOperationParams;
  // xTimeoutTicks
  TickType_t xTimeoutTicks;
} ShadowOperationCallParams_t;

typedef struct ShadowOperationData
{
  // xOperationInProgress
  ShadowOperationName_t xOperationInProgress;
  // pxOperationParams
  ShadowOperationParams_t *pxOperationParams;
} ShadowOperationData_t;

typedef struct ShadowOperationParams
{
  // pcThingName
  const char *pcThingName;
  // pcData
  const char *pcData;
  // ulDataLength
  uint32_t ulDataLength;
  // xBuffer
  MQTTBufferHandle_t xBuffer;
  // ucKeepSubscriptions
  uint8_t ucKeepSubscriptions;
  // xQoS
  MQTTQoS_t xQoS;
} ShadowOperationParams_t;

struct SignatureVerificationState
{
  // xAsymmetricAlgorithm
  BaseType_t xAsymmetricAlgorithm;
  // xHashAlgorithm
  BaseType_t xHashAlgorithm;
  // xSHA1Context
  mbedtls_sha1_context xSHA1Context;
  // xSHA256Context
  mbedtls_sha256_context xSHA256Context;
};

typedef struct SocketsSockaddr
{
  // ucLength
  uint8_t ucLength;
  // ucSocketDomain
  uint8_t ucSocketDomain;
  // usPort
  uint16_t usPort;
  // ulAddress
  uint32_t ulAddress;
} SocketsSockaddr_t;

typedef struct SubpubUserData
{
  // pcExpectedString
  const char *pcExpectedString;
  // ulExpectedUint32
  uint32_t ulExpectedUint32;
  // xCallbackStatus
  BaseType_t xCallbackStatus;
  // xWakeUpSemaphore
  SemaphoreHandle_t xWakeUpSemaphore;
  // cTopic
  char cTopic[(signed long long int)(sizeof(char [9ll]) * 2ul + 1ul) /*19ll*/ ];
} SubpubUserData_t;

typedef struct mbedtls_ssl_context
{
  // conf
  const mbedtls_ssl_config *conf;
  // state
  signed int state;
  // major_ver
  signed int major_ver;
  // minor_ver
  signed int minor_ver;
  // f_send
  mbedtls_ssl_send_t (*f_send);
  // f_recv
  mbedtls_ssl_recv_t (*f_recv);
  // f_recv_timeout
  mbedtls_ssl_recv_timeout_t (*f_recv_timeout);
  // p_bio
  void *p_bio;
  // session_in
  mbedtls_ssl_session *session_in;
  // session_out
  mbedtls_ssl_session *session_out;
  // session
  mbedtls_ssl_session *session;
  // session_negotiate
  mbedtls_ssl_session *session_negotiate;
  // handshake
  mbedtls_ssl_handshake_params *handshake;
  // transform_in
  mbedtls_ssl_transform *transform_in;
  // transform_out
  mbedtls_ssl_transform *transform_out;
  // transform
  mbedtls_ssl_transform *transform;
  // transform_negotiate
  mbedtls_ssl_transform *transform_negotiate;
  // p_timer
  void *p_timer;
  // f_set_timer
  mbedtls_ssl_set_timer_t (*f_set_timer);
  // f_get_timer
  mbedtls_ssl_get_timer_t (*f_get_timer);
  // in_buf
  unsigned char *in_buf;
  // in_ctr
  unsigned char *in_ctr;
  // in_hdr
  unsigned char *in_hdr;
  // in_len
  unsigned char *in_len;
  // in_iv
  unsigned char *in_iv;
  // in_msg
  unsigned char *in_msg;
  // in_offt
  unsigned char *in_offt;
  // in_msgtype
  signed int in_msgtype;
  // in_msglen
  size_t in_msglen;
  // in_left
  size_t in_left;
  // in_hslen
  size_t in_hslen;
  // nb_zero
  signed int nb_zero;
  // keep_current_message
  signed int keep_current_message;
  // out_buf
  unsigned char *out_buf;
  // out_ctr
  unsigned char *out_ctr;
  // out_hdr
  unsigned char *out_hdr;
  // out_len
  unsigned char *out_len;
  // out_iv
  unsigned char *out_iv;
  // out_msg
  unsigned char *out_msg;
  // out_msgtype
  signed int out_msgtype;
  // out_msglen
  size_t out_msglen;
  // out_left
  size_t out_left;
  // client_auth
  signed int client_auth;
  // hostname
  char *hostname;
  // alpn_chosen
  const char *alpn_chosen;
  // secure_renegotiation
  signed int secure_renegotiation;
} mbedtls_ssl_context;

typedef struct mbedtls_ssl_config
{
  // ciphersuite_list
  const signed int *ciphersuite_list[4ll];
  // f_dbg
  void (*f_dbg)(void *, signed int, const char *, signed int, const char *);
  // p_dbg
  void *p_dbg;
  // f_rng
  signed int (*f_rng)(void *, unsigned char *, size_t);
  // p_rng
  void *p_rng;
  // f_get_cache
  signed int (*f_get_cache)(void *, mbedtls_ssl_session *);
  // f_set_cache
  signed int (*f_set_cache)(void *, const mbedtls_ssl_session *);
  // p_cache
  void *p_cache;
  // f_sni
  signed int (*f_sni)(void *, mbedtls_ssl_context *, const unsigned char *, size_t);
  // p_sni
  void *p_sni;
  // f_vrfy
  signed int (*f_vrfy)(void *, mbedtls_x509_crt *, signed int, uint32_t *);
  // p_vrfy
  void *p_vrfy;
  // cert_profile
  const mbedtls_x509_crt_profile *cert_profile;
  // key_cert
  mbedtls_ssl_key_cert *key_cert;
  // ca_chain
  mbedtls_x509_crt *ca_chain;
  // ca_crl
  mbedtls_x509_crl *ca_crl;
  // sig_hashes
  const signed int *sig_hashes;
  // curve_list
  const mbedtls_ecp_group_id *curve_list;
  // alpn_list
  const char **alpn_list;
  // read_timeout
  uint32_t read_timeout;
  // max_major_ver
  unsigned char max_major_ver;
  // max_minor_ver
  unsigned char max_minor_ver;
  // min_major_ver
  unsigned char min_major_ver;
  // min_minor_ver
  unsigned char min_minor_ver;
  // endpoint
  unsigned int endpoint : 1;
  // transport
  unsigned int transport : 1;
  // authmode
  unsigned int authmode : 2;
  // allow_legacy_renegotiation
  unsigned int allow_legacy_renegotiation : 2;
  // mfl_code
  unsigned int mfl_code : 3;
  // encrypt_then_mac
  unsigned int encrypt_then_mac : 1;
  // extended_ms
  unsigned int extended_ms : 1;
} mbedtls_ssl_config;

typedef struct TLSContext
{
  // pcDestination
  const char *pcDestination;
  // pcServerCertificate
  const char *pcServerCertificate;
  // ulServerCertificateLength
  uint32_t ulServerCertificateLength;
  // ppcAlpnProtocols
  const char **ppcAlpnProtocols;
  // ulAlpnProtocolsCount
  uint32_t ulAlpnProtocolsCount;
  // pxNetworkRecv
  NetworkRecv_t pxNetworkRecv;
  // pxNetworkSend
  NetworkSend_t pxNetworkSend;
  // pvCallerContext
  void *pvCallerContext;
  // mbedSslCtx
  mbedtls_ssl_context mbedSslCtx;
  // mbedSslConfig
  mbedtls_ssl_config mbedSslConfig;
  // mbedX509CA
  mbedtls_x509_crt mbedX509CA;
  // mbedX509Cli
  mbedtls_x509_crt mbedX509Cli;
  // mbedPkCtx
  mbedtls_pk_context mbedPkCtx;
  // xMbedInitialized
  BaseType_t xMbedInitialized;
  // pxP11FunctionList
  CK_FUNCTION_LIST_PTR pxP11FunctionList;
  // xP11Session
  CK_SESSION_HANDLE xP11Session;
  // xP11PrivateKey
  CK_OBJECT_HANDLE xP11PrivateKey;
  // ulP11ModulusBytes
  CK_ULONG ulP11ModulusBytes;
} TLSContext_t;

typedef struct TimeOutData
{
  // xTimeOut
  TimeOut_t xTimeOut;
  // xTicksRemaining
  TickType_t xTicksRemaining;
} TimeOutData_t;

typedef struct xARP_HEADER
{
  // usHardwareType
  uint16_t usHardwareType;
  // usProtocolType
  uint16_t usProtocolType;
  // ucHardwareAddressLength
  uint8_t ucHardwareAddressLength;
  // ucProtocolAddressLength
  uint8_t ucProtocolAddressLength;
  // usOperation
  uint16_t usOperation;
  // xSenderHardwareAddress
  MACAddress_t xSenderHardwareAddress;
  // ucSenderProtocolAddress
  uint8_t ucSenderProtocolAddress[4ll];
  // xTargetHardwareAddress
  MACAddress_t xTargetHardwareAddress;
  // ulTargetProtocolAddress
  uint32_t ulTargetProtocolAddress;
} __attribute__ ((__packed__)) ARPHeader_t;

typedef struct xARP_PACKET
{
  // xEthernetHeader
  EthernetHeader_t xEthernetHeader;
  // xARPHeader
  ARPHeader_t xARPHeader;
} __attribute__ ((__packed__)) ARPPacket_t;

typedef struct xUDP_HEADER
{
  // usSourcePort
  uint16_t usSourcePort;
  // usDestinationPort
  uint16_t usDestinationPort;
  // usLength
  uint16_t usLength;
  // usChecksum
  uint16_t usChecksum;
} __attribute__ ((__packed__)) UDPHeader_t;

typedef struct xUDP_PACKET
{
  // xEthernetHeader
  EthernetHeader_t xEthernetHeader;
  // xIPHeader
  IPHeader_t xIPHeader;
  // xUDPHeader
  UDPHeader_t xUDPHeader;
} __attribute__ ((__packed__)) UDPPacket_t;

typedef struct xICMP_HEADER
{
  // ucTypeOfMessage
  uint8_t ucTypeOfMessage;
  // ucTypeOfService
  uint8_t ucTypeOfService;
  // usChecksum
  uint16_t usChecksum;
  // usIdentifier
  uint16_t usIdentifier;
  // usSequenceNumber
  uint16_t usSequenceNumber;
} __attribute__ ((__packed__)) ICMPHeader_t;

typedef struct xICMP_PACKET
{
  // xEthernetHeader
  EthernetHeader_t xEthernetHeader;
  // xIPHeader
  IPHeader_t xIPHeader;
  // xICMPHeader
  ICMPHeader_t xICMPHeader;
} __attribute__ ((__packed__)) ICMPPacket_t;

typedef union XPROT_PACKET
{
  // xARPPacket
  ARPPacket_t xARPPacket;
  // xTCPPacket
  TCPPacket_t xTCPPacket;
  // xUDPPacket
  UDPPacket_t xUDPPacket;
  // xICMPPacket
  ICMPPacket_t xICMPPacket;
} ProtocolPacket_t;

typedef struct xLIST_ITEM
{
  // xItemValue
  TickType_t xItemValue;
  // pxNext
  struct xLIST_ITEM *pxNext;
  // pxPrevious
  struct xLIST_ITEM *pxPrevious;
  // pvOwner
  void *pvOwner;
  // pvContainer
  void *pvContainer;
} ListItem_t;

typedef struct XSOCKET
{
  // xEventBits
  EventBits_t xEventBits;
  // xEventGroup
  EventGroupHandle_t xEventGroup;
  // xBoundSocketListItem
  ListItem_t xBoundSocketListItem;
  // xReceiveBlockTime
  TickType_t xReceiveBlockTime;
  // xSendBlockTime
  TickType_t xSendBlockTime;
  // usLocalPort
  uint16_t usLocalPort;
  // ucSocketOptions
  uint8_t ucSocketOptions;
  // ucProtocol
  uint8_t ucProtocol;
  // pxUserWakeCallback
  SocketWakeupCallback_t pxUserWakeCallback;
  // u
  union anonymous$105 u;
} FreeRTOS_Socket_t;

typedef struct _FLOATING_SAVE_AREA
{
  // ControlWord
  DWORD ControlWord;
  // StatusWord
  DWORD StatusWord;
  // TagWord
  DWORD TagWord;
  // ErrorOffset
  DWORD ErrorOffset;
  // ErrorSelector
  DWORD ErrorSelector;
  // DataOffset
  DWORD DataOffset;
  // DataSelector
  DWORD DataSelector;
  // RegisterArea
  BYTE RegisterArea[80ll];
  // Spare0
  DWORD Spare0;
} FLOATING_SAVE_AREA;

typedef struct _CONTEXT
{
  // ContextFlags
  DWORD ContextFlags;
  // Dr0
  DWORD Dr0;
  // Dr1
  DWORD Dr1;
  // Dr2
  DWORD Dr2;
  // Dr3
  DWORD Dr3;
  // Dr6
  DWORD Dr6;
  // Dr7
  DWORD Dr7;
  // FloatSave
  FLOATING_SAVE_AREA FloatSave;
  // SegGs
  DWORD SegGs;
  // SegFs
  DWORD SegFs;
  // SegEs
  DWORD SegEs;
  // SegDs
  DWORD SegDs;
  // Edi
  DWORD Edi;
  // Esi
  DWORD Esi;
  // Ebx
  DWORD Ebx;
  // Edx
  DWORD Edx;
  // Ecx
  DWORD Ecx;
  // Eax
  DWORD Eax;
  // Ebp
  DWORD Ebp;
  // Eip
  DWORD Eip;
  // SegCs
  DWORD SegCs;
  // EFlags
  DWORD EFlags;
  // Esp
  DWORD Esp;
  // SegSs
  DWORD SegSs;
  // ExtendedRegisters
  BYTE ExtendedRegisters[512ll];
} CONTEXT;

typedef union _LARGE_INTEGER
{
  // $anon0
  struct anonymous$129 $anon0;
  // u
  struct anonymous$129 u;
  // QuadPart
  LONGLONG QuadPart;
} LARGE_INTEGER;

struct _OVERLAPPED
{
  // Internal
  ULONG_PTR Internal;
  // InternalHigh
  ULONG_PTR InternalHigh;
  // $anon0
  union anonymous$108 $anon0;
  // hEvent
  HANDLE hEvent;
};

struct _SECURITY_ATTRIBUTES
{
  // nLength
  DWORD nLength;
  // lpSecurityDescriptor
  LPVOID lpSecurityDescriptor;
  // bInheritHandle
  BOOL bInheritHandle;
};

typedef struct _SYSTEM_INFO
{
  // $anon0
  union anonymous$81 $anon0;
  // dwPageSize
  DWORD dwPageSize;
  // lpMinimumApplicationAddress
  LPVOID lpMinimumApplicationAddress;
  // lpMaximumApplicationAddress
  LPVOID lpMaximumApplicationAddress;
  // dwActiveProcessorMask
  DWORD_PTR dwActiveProcessorMask;
  // dwNumberOfProcessors
  DWORD dwNumberOfProcessors;
  // dwProcessorType
  DWORD dwProcessorType;
  // dwAllocationGranularity
  DWORD dwAllocationGranularity;
  // wProcessorLevel
  WORD wProcessorLevel;
  // wProcessorRevision
  WORD wProcessorRevision;
} SYSTEM_INFO;

typedef struct __crt_locale_data_public
{
  // _locale_pctype
  const unsigned short int *_locale_pctype;
  // _locale_mb_cur_max
  signed int _locale_mb_cur_max;
  // _locale_lc_codepage
  unsigned int _locale_lc_codepage;
} __crt_locale_data_public;

typedef struct __crt_locale_pointers
{
  // locinfo
  struct __crt_locale_data *locinfo;
  // mbcinfo
  struct __crt_multibyte_data *mbcinfo;
} __crt_locale_pointers;


typedef union _xUnion32
{
  // u32
  uint32_t u32;
  // u16
  uint16_t u16[2ll];
  // u8
  uint8_t u8[4ll];
} xUnion32;

typedef union _xUnionPtr
{
  // u32ptr
  uint32_t *u32ptr;
  // u16ptr
  uint16_t *u16ptr;
  // u8ptr
  uint8_t *u8ptr;
} xUnionPtr;

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  size_t ai_addrlen;
  // ai_canonname
  char *ai_canonname;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_next
  struct addrinfo *ai_next;
};

struct bpf_insn
{
  // code
  u_short code;
  // jt
  u_char jt;
  // jf
  u_char jf;
  // k
  bpf_u_int32 k;
};

struct bpf_program
{
  // bf_len
  u_int bf_len;
  // bf_insns
  struct bpf_insn *bf_insns;
};

struct freertos_sockaddr
{
  // sin_len
  uint8_t sin_len;
  // sin_family
  uint8_t sin_family;
  // sin_port
  uint16_t sin_port;
  // sin_addr
  uint32_t sin_addr;
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed short int h_addrtype;
  // h_length
  signed short int h_length;
  // h_addr_list
  char **h_addr_list;
};

typedef struct in_addr
{
  // S_un
  union anonymous$87 S_un;
} IN_ADDR;

typedef struct ip_msfilter
{
  // imsf_multiaddr
  IN_ADDR imsf_multiaddr;
  // imsf_interface
  IN_ADDR imsf_interface;
  // imsf_fmode
  MULTICAST_MODE_TYPE imsf_fmode;
  // imsf_numsrc
  ULONG imsf_numsrc;
  // imsf_slist
  IN_ADDR imsf_slist[1ll];
} IP_MSFILTER;

typedef struct mbedtls_asn1_bitstring
{
  // len
  size_t len;
  // unused_bits
  unsigned char unused_bits;
  // p
  unsigned char *p;
} mbedtls_x509_bitstring;

typedef struct mbedtls_cipher_base_t
{
  // cipher
  mbedtls_cipher_id_t cipher;
  // ecb_func
  signed int (*ecb_func)(void *, mbedtls_operation_t, const unsigned char *, unsigned char *);
  // cbc_func
  signed int (*cbc_func)(void *, mbedtls_operation_t, size_t, unsigned char *, const unsigned char *, unsigned char *);
  // cfb_func
  signed int (*cfb_func)(void *, mbedtls_operation_t, size_t, size_t *, unsigned char *, const unsigned char *, unsigned char *);
  // ctr_func
  signed int (*ctr_func)(void *, size_t, size_t *, unsigned char *, unsigned char *, const unsigned char *, unsigned char *);
  // setkey_enc_func
  signed int (*setkey_enc_func)(void *, const unsigned char *, unsigned int);
  // setkey_dec_func
  signed int (*setkey_dec_func)(void *, const unsigned char *, unsigned int);
  // ctx_alloc_func
  void * (*ctx_alloc_func)(void);
  // ctx_free_func
  void (*ctx_free_func)(void *);
} mbedtls_cipher_base_t;

typedef struct mbedtls_md_info_t
{
  // type
  mbedtls_md_type_t type;
  // name
  const char *name;
  // size
  signed int size;
  // block_size
  signed int block_size;
  // starts_func
  signed int (*starts_func)(void *);
  // update_func
  signed int (*update_func)(void *, const unsigned char *, size_t);
  // finish_func
  signed int (*finish_func)(void *, unsigned char *);
  // digest_func
  signed int (*digest_func)(const unsigned char *, size_t, unsigned char *);
  // ctx_alloc_func
  void * (*ctx_alloc_func)(void);
  // ctx_free_func
  void (*ctx_free_func)(void *);
  // clone_func
  void (*clone_func)(void *, const void *);
  // process_func
  signed int (*process_func)(void *, const unsigned char *);
} mbedtls_md_info_t;

typedef struct mbedtls_ssl_ciphersuite_t
{
  // id
  signed int id;
  // name
  const char *name;
  // cipher
  mbedtls_cipher_type_t cipher;
  // mac
  mbedtls_md_type_t mac;
  // key_exchange
  mbedtls_key_exchange_type_t key_exchange;
  // min_major_ver
  signed int min_major_ver;
  // min_minor_ver
  signed int min_minor_ver;
  // max_major_ver
  signed int max_major_ver;
  // max_minor_ver
  signed int max_minor_ver;
  // flags
  unsigned char flags;
} mbedtls_ssl_ciphersuite_t;

typedef struct mbedtls_ssl_sig_hash_set_t
{
  // rsa
  mbedtls_md_type_t rsa;
  // ecdsa
  mbedtls_md_type_t ecdsa;
} mbedtls_ssl_sig_hash_set_t;

union mbedtls_ssl_premaster_secret
{
  // _pms_ecdh
  unsigned char _pms_ecdh[66ll];
};

typedef struct mbedtls_ssl_handshake_params
{
  // hash_algs
  mbedtls_ssl_sig_hash_set_t hash_algs;
  // ecdh_ctx
  mbedtls_ecdh_context ecdh_ctx;
  // curves
  const mbedtls_ecp_curve_info **curves;
  // key_cert
  mbedtls_ssl_key_cert *key_cert;
  // sni_authmode
  signed int sni_authmode;
  // sni_key_cert
  mbedtls_ssl_key_cert *sni_key_cert;
  // sni_ca_chain
  mbedtls_x509_crt *sni_ca_chain;
  // sni_ca_crl
  mbedtls_x509_crl *sni_ca_crl;
  // fin_sha256
  mbedtls_sha256_context fin_sha256;
  // update_checksum
  void (*update_checksum)(mbedtls_ssl_context *, const unsigned char *, size_t);
  // calc_verify
  void (*calc_verify)(mbedtls_ssl_context *, unsigned char *);
  // calc_finished
  void (*calc_finished)(mbedtls_ssl_context *, unsigned char *, signed int);
  // tls_prf
  signed int (*tls_prf)(const unsigned char *, size_t, const char *, const unsigned char *, size_t, unsigned char *, size_t);
  // pmslen
  size_t pmslen;
  // randbytes
  unsigned char randbytes[64ll];
  // premaster
  unsigned char premaster[(signed long long int)sizeof(union mbedtls_ssl_premaster_secret) /*66ll*/ ];
  // resume
  signed int resume;
  // max_major_ver
  signed int max_major_ver;
  // max_minor_ver
  signed int max_minor_ver;
  // cli_exts
  signed int cli_exts;
  // extended_ms
  signed int extended_ms;
} mbedtls_ssl_handshake_params;

typedef struct mbedtls_ssl_key_cert
{
  // cert
  mbedtls_x509_crt *cert;
  // key
  mbedtls_pk_context *key;
  // next
  mbedtls_ssl_key_cert *next;
} mbedtls_ssl_key_cert;

typedef struct mbedtls_ssl_session
{
  // ciphersuite
  signed int ciphersuite;
  // compression
  signed int compression;
  // id_len
  size_t id_len;
  // id
  unsigned char id[32ll];
  // master
  unsigned char master[48ll];
  // peer_cert
  mbedtls_x509_crt *peer_cert;
  // verify_result
  uint32_t verify_result;
  // mfl_code
  unsigned char mfl_code;
  // encrypt_then_mac
  signed int encrypt_then_mac;
} mbedtls_ssl_session;

typedef struct mbedtls_ssl_transform
{
  // ciphersuite_info
  const mbedtls_ssl_ciphersuite_t *ciphersuite_info;
  // keylen
  unsigned int keylen;
  // minlen
  size_t minlen;
  // ivlen
  size_t ivlen;
  // fixed_ivlen
  size_t fixed_ivlen;
  // maclen
  size_t maclen;
  // iv_enc
  unsigned char iv_enc[16ll];
  // iv_dec
  unsigned char iv_dec[16ll];
  // md_ctx_enc
  mbedtls_md_context_t md_ctx_enc;
  // md_ctx_dec
  mbedtls_md_context_t md_ctx_dec;
  // cipher_ctx_enc
  mbedtls_cipher_context_t cipher_ctx_enc;
  // cipher_ctx_dec
  mbedtls_cipher_context_t cipher_ctx_dec;
} mbedtls_ssl_transform;

typedef struct mbedtls_x509_crl_entry
{
  // raw
  mbedtls_x509_buf raw;
  // serial
  mbedtls_x509_buf serial;
  // revocation_date
  mbedtls_x509_time revocation_date;
  // entry_ext
  mbedtls_x509_buf entry_ext;
  // next
  struct mbedtls_x509_crl_entry *next;
} mbedtls_x509_crl_entry;

typedef struct mbedtls_x509_crl
{
  // raw
  mbedtls_x509_buf raw;
  // tbs
  mbedtls_x509_buf tbs;
  // version
  signed int version;
  // sig_oid
  mbedtls_x509_buf sig_oid;
  // issuer_raw
  mbedtls_x509_buf issuer_raw;
  // issuer
  mbedtls_x509_name issuer;
  // this_update
  mbedtls_x509_time this_update;
  // next_update
  mbedtls_x509_time next_update;
  // entry
  mbedtls_x509_crl_entry entry;
  // crl_ext
  mbedtls_x509_buf crl_ext;
  // sig_oid2
  mbedtls_x509_buf sig_oid2;
  // sig
  mbedtls_x509_buf sig;
  // sig_md
  mbedtls_md_type_t sig_md;
  // sig_pk
  mbedtls_pk_type_t sig_pk;
  // sig_opts
  void *sig_opts;
  // next
  struct mbedtls_x509_crl *next;
} mbedtls_x509_crl;

struct pcap_addr
{
  // next
  struct pcap_addr *next;
  // addr
  struct sockaddr *addr;
  // netmask
  struct sockaddr *netmask;
  // broadaddr
  struct sockaddr *broadaddr;
  // dstaddr
  struct sockaddr *dstaddr;
};

typedef struct pcap_if
{
  // next
  struct pcap_if *next;
  // name
  char *name;
  // description
  char *description;
  // addresses
  struct pcap_addr *addresses;
  // flags
  bpf_u_int32 flags;
} pcap_if_t;

struct pcap_pkthdr
{
  // ts
  struct timeval ts;
  // caplen
  bpf_u_int32 caplen;
  // len
  bpf_u_int32 len;
};

struct pcap_rmtauth
{
  // type
  signed int type;
  // username
  char *username;
  // password
  char *password;
};

struct servent
{
  // s_name
  char *s_name;
  // s_aliases
  char **s_aliases;
  // s_proto
  char *s_proto;
  // s_port
  signed short int s_port;
};

struct sockaddr_in
{
  // sin_family
  signed short int sin_family;
  // sin_port
  USHORT sin_port;
  // sin_addr
  IN_ADDR sin_addr;
  // sin_zero
  CHAR sin_zero[8ll];
};

typedef struct timecaps_tag
{
  // wPeriodMin
  UINT wPeriodMin;
  // wPeriodMax
  UINT wPeriodMax;
} __attribute__ ((__packed__)) TIMECAPS;

typedef struct tmrTimerControl
{
  // pcTimerName
  const char *pcTimerName;
  // xTimerListItem
  ListItem_t xTimerListItem;
  // xTimerPeriodInTicks
  TickType_t xTimerPeriodInTicks;
  // uxAutoReload
  UBaseType_t uxAutoReload;
  // pvTimerID
  void *pvTimerID;
  // pxCallbackFunction
  TimerCallbackFunction_t pxCallbackFunction;
  // uxTimerNumber
  UBaseType_t uxTimerNumber;
  // ucStaticallyAllocated
  uint8_t ucStaticallyAllocated;
} Timer_t;

typedef struct tmrTimerQueueMessage
{
  // xMessageID
  BaseType_t xMessageID;
  // u
  union anonymous$54 u;
} DaemonTaskMessage_t;

typedef struct tskTaskControlBlock
{
  // pxTopOfStack
  volatile StackType_t *pxTopOfStack;
  // xStateListItem
  ListItem_t xStateListItem;
  // xEventListItem
  ListItem_t xEventListItem;
  // uxPriority
  UBaseType_t uxPriority;
  // pxStack
  StackType_t *pxStack;
  // pcTaskName
  char pcTaskName[15ll];
  // pxEndOfStack
  StackType_t *pxEndOfStack;
  // uxTCBNumber
  UBaseType_t uxTCBNumber;
  // uxTaskNumber
  UBaseType_t uxTaskNumber;
  // uxBasePriority
  UBaseType_t uxBasePriority;
  // uxMutexesHeld
  UBaseType_t uxMutexesHeld;
  // pvThreadLocalStoragePointers
  void *pvThreadLocalStoragePointers[3ll];
  // ulRunTimeCounter
  uint32_t ulRunTimeCounter;
  // ulNotifiedValue
  volatile uint32_t ulNotifiedValue;
  // ucNotifyState
  volatile uint8_t ucNotifyState;
  // ucStaticallyAllocated
  uint8_t ucStaticallyAllocated;
  // ucDelayAborted
  uint8_t ucDelayAborted;
} TCB_t;

struct x509_crt_verify_string
{
  // code
  signed int code;
  // string
  const char *string;
};

typedef struct xARP_CACHE_TABLE_ROW
{
  // ulIPAddress
  uint32_t ulIPAddress;
  // xMACAddress
  MACAddress_t xMACAddress;
  // ucAge
  uint8_t ucAge;
  // ucValid
  uint8_t ucValid;
} ARPCacheRow_t;

typedef struct xDHCPMessage
{
  // ucOpcode
  uint8_t ucOpcode;
  // ucAddressType
  uint8_t ucAddressType;
  // ucAddressLength
  uint8_t ucAddressLength;
  // ucHops
  uint8_t ucHops;
  // ulTransactionID
  uint32_t ulTransactionID;
  // usElapsedTime
  uint16_t usElapsedTime;
  // usFlags
  uint16_t usFlags;
  // ulClientIPAddress_ciaddr
  uint32_t ulClientIPAddress_ciaddr;
  // ulYourIPAddress_yiaddr
  uint32_t ulYourIPAddress_yiaddr;
  // ulServerIPAddress_siaddr
  uint32_t ulServerIPAddress_siaddr;
  // ulRelayAgentIPAddress_giaddr
  uint32_t ulRelayAgentIPAddress_giaddr;
  // ucClientHardwareAddress
  uint8_t ucClientHardwareAddress[16ll];
  // ucServerHostName
  uint8_t ucServerHostName[64ll];
  // ucBootFileName
  uint8_t ucBootFileName[128ll];
  // ulDHCPCookie
  uint32_t ulDHCPCookie;
  // ucFirstOptionByte
  uint8_t ucFirstOptionByte;
} __attribute__ ((__packed__)) DHCPMessage_t;

typedef struct xDHCP_DATA
{
  // ulTransactionId
  uint32_t ulTransactionId;
  // ulOfferedIPAddress
  uint32_t ulOfferedIPAddress;
  // ulDHCPServerAddress
  uint32_t ulDHCPServerAddress;
  // ulLeaseTime
  uint32_t ulLeaseTime;
  // xDHCPTxTime
  TickType_t xDHCPTxTime;
  // xDHCPTxPeriod
  TickType_t xDHCPTxPeriod;
  // xUseBroadcast
  BaseType_t xUseBroadcast;
  // eDHCPState
  eDHCPState_t eDHCPState;
  // xDHCPSocket
  Socket_t xDHCPSocket;
} DHCPData_t;

typedef struct xDNSAnswerRecord
{
  // usType
  uint16_t usType;
  // usClass
  uint16_t usClass;
  // ulTTL
  uint32_t ulTTL;
  // usDataLength
  uint16_t usDataLength;
} __attribute__ ((__packed__)) DNSAnswerRecord_t;

typedef struct xDNSMessage
{
  // usIdentifier
  uint16_t usIdentifier;
  // usFlags
  uint16_t usFlags;
  // usQuestions
  uint16_t usQuestions;
  // usAnswers
  uint16_t usAnswers;
  // usAuthorityRRs
  uint16_t usAuthorityRRs;
  // usAdditionalRRs
  uint16_t usAdditionalRRs;
} __attribute__ ((__packed__)) DNSMessage_t;

typedef struct xDNSTail
{
  // usType
  uint16_t usType;
  // usClass
  uint16_t usClass;
} __attribute__ ((__packed__)) DNSTail_t;

typedef struct xDNS_CACHE_TABLE_ROW
{
  // ulIPAddress
  uint32_t ulIPAddress;
  // pcName
  char pcName[254ll];
  // ulTTL
  uint32_t ulTTL;
  // ulTimeWhenAddedInSeconds
  uint32_t ulTimeWhenAddedInSeconds;
} DNSCacheRow_t;

typedef struct xEventGroupDefinition
{
  // uxEventBits
  EventBits_t uxEventBits;
  // xTasksWaitingForBits
  List_t xTasksWaitingForBits;
  // uxEventGroupNumber
  UBaseType_t uxEventGroupNumber;
  // ucStaticallyAllocated
  uint8_t ucStaticallyAllocated;
} EventGroup_t;

typedef struct xIP_PACKET
{
  // xEthernetHeader
  EthernetHeader_t xEthernetHeader;
  // xIPHeader
  IPHeader_t xIPHeader;
} __attribute__ ((__packed__)) IPPacket_t;

typedef struct xIP_TIMER
{
  // bActive
  uint32_t bActive : 1;
  // bExpired
  uint32_t bExpired : 1;
  // xTimeOut
  TimeOut_t xTimeOut;
  // ulRemainingTime
  TickType_t ulRemainingTime;
  // ulReloadTime
  TickType_t ulReloadTime;
} IPTimer_t;

typedef struct xMEMORY_REGION
{
  // pvBaseAddress
  void *pvBaseAddress;
  // ulLengthInBytes
  uint32_t ulLengthInBytes;
  // ulParameters
  uint32_t ulParameters;
} MemoryRegion_t;

typedef struct xNETWORK_BUFFER
{
  // xBufferListItem
  ListItem_t xBufferListItem;
  // ulIPAddress
  uint32_t ulIPAddress;
  // pucEthernetBuffer
  uint8_t *pucEthernetBuffer;
  // xDataLength
  size_t xDataLength;
  // usPort
  uint16_t usPort;
  // usBoundPort
  uint16_t usBoundPort;
} NetworkBufferDescriptor_t;

typedef struct xNetworkAddressingParameters
{
  // ulDefaultIPAddress
  uint32_t ulDefaultIPAddress;
  // ulNetMask
  uint32_t ulNetMask;
  // ulGatewayAddress
  uint32_t ulGatewayAddress;
  // ulDNSServerAddress
  uint32_t ulDNSServerAddress;
  // ulBroadcastAddress
  uint32_t ulBroadcastAddress;
} NetworkAddressingParameters_t;

typedef struct xSTATIC_EVENT_GROUP
{
  // xDummy1
  TickType_t xDummy1;
  // xDummy2
  StaticList_t xDummy2;
  // uxDummy3
  UBaseType_t uxDummy3;
  // ucDummy4
  uint8_t ucDummy4;
} StaticEventGroup_t;

typedef struct xSTATIC_LIST_ITEM
{
  // xDummy1
  TickType_t xDummy1;
  // pvDummy2
  void *pvDummy2[4ll];
} StaticListItem_t;

typedef struct xSTATIC_STREAM_BUFFER
{
  // uxDummy1
  size_t uxDummy1[4ll];
  // pvDummy2
  void *pvDummy2[3ll];
  // ucDummy3
  uint8_t ucDummy3;
  // uxDummy4
  UBaseType_t uxDummy4;
} StaticStreamBuffer_t;

typedef struct xSTATIC_TCB
{
  // pxDummy1
  void *pxDummy1;
  // xDummy3
  StaticListItem_t xDummy3[2ll];
  // uxDummy5
  UBaseType_t uxDummy5;
  // pxDummy6
  void *pxDummy6;
  // ucDummy7
  uint8_t ucDummy7[15ll];
  // pxDummy8
  void *pxDummy8;
  // uxDummy10
  UBaseType_t uxDummy10[2ll];
  // uxDummy12
  UBaseType_t uxDummy12[2ll];
  // pvDummy15
  void *pvDummy15[3ll];
  // ulDummy16
  uint32_t ulDummy16;
  // ulDummy18
  uint32_t ulDummy18;
  // ucDummy19
  uint8_t ucDummy19;
  // uxDummy20
  uint8_t uxDummy20;
  // ucDummy21
  uint8_t ucDummy21;
} StaticTask_t;

typedef struct xSTATIC_TIMER
{
  // pvDummy1
  void *pvDummy1;
  // xDummy2
  StaticListItem_t xDummy2;
  // xDummy3
  TickType_t xDummy3;
  // uxDummy4
  UBaseType_t uxDummy4;
  // pvDummy5
  void *pvDummy5[2ll];
  // uxDummy6
  UBaseType_t uxDummy6;
  // ucDummy7
  uint8_t ucDummy7;
} StaticTimer_t;


typedef struct xTASK_STATUS
{
  // xHandle
  TaskHandle_t xHandle;
  // pcTaskName
  const char *pcTaskName;
  // xTaskNumber
  UBaseType_t xTaskNumber;
  // eCurrentState
  eTaskState eCurrentState;
  // uxCurrentPriority
  UBaseType_t uxCurrentPriority;
  // uxBasePriority
  UBaseType_t uxBasePriority;
  // ulRunTimeCounter
  uint32_t ulRunTimeCounter;
  // pxStackBase
  StackType_t *pxStackBase;
  // usStackHighWaterMark
  uint16_t usStackHighWaterMark;
} TaskStatus_t;

typedef struct xTCPTimer
{
  // ulBorn
  uint32_t ulBorn;
} TCPTimer_t;

typedef struct xTCP_SEGMENT
{
  // ulSequenceNumber
  uint32_t ulSequenceNumber;
  // lMaxLength
  int32_t lMaxLength;
  // lDataLength
  int32_t lDataLength;
  // lStreamPos
  int32_t lStreamPos;
  // xTransmitTimer
  TCPTimer_t xTransmitTimer;
  // u
  union anonymous$96 u;
  // xQueueItem
  struct xLIST_ITEM xQueueItem;
  // xListItem
  struct xLIST_ITEM xListItem;
} TCPSegment_t;

typedef struct xTLS_PARAMS
{
  // ulSize
  uint32_t ulSize;
  // pcDestination
  const char *pcDestination;
  // pcServerCertificate
  const char *pcServerCertificate;
  // ulServerCertificateLength
  uint32_t ulServerCertificateLength;
  // ppcAlpnProtocols
  const char **ppcAlpnProtocols;
  // ulAlpnProtocolsCount
  uint32_t ulAlpnProtocolsCount;
  // pxNetworkRecv
  NetworkRecv_t pxNetworkRecv;
  // pxNetworkSend
  NetworkSend_t pxNetworkSend;
  // pvCallerContext
  void *pvCallerContext;
} TLSParams_t;

typedef union xUDPPacketHeader
{
  // ucBytes
  uint8_t ucBytes[24ll];
  // ulWords
  uint32_t ulWords[6ll];
} UDPPacketHeader_t;

typedef struct xWIN_PROPS
{
  // lTxBufSize
  int32_t lTxBufSize;
  // lTxWinSize
  int32_t lTxWinSize;
  // lRxBufSize
  int32_t lRxBufSize;
  // lRxWinSize
  int32_t lRxWinSize;
} WinProperties_t;


// CborIndefiniteLength
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 175
static const size_t CborIndefiniteLength=18446744073709551615ull;
// FSb
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 94
static const unsigned char FSb[256ll]={ 99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22 };
// FT0
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 201
static const uint32_t FT0[256ll]={ 0xA56363C6u, 0x847C7CF8u, 0x997777EEu, 0x8D7B7BF6u, 234025727u, 0xBD6B6BD6u, 0xB16F6FDEu, 1422247313u, 1345335392u, 50397442u, 0xA96767CEu, 2099981142u, 436141799u, 1658312629u, 0xE6ABAB4Du, 0x9A7676ECu, 1170918031u, 0x9D82821Fu, 1086966153u, 0x877D7DFAu, 368769775u, 0xEB5959B2u, 0xC947478Eu, 200339707u, 0xECADAD41u, 1742001331u, 0xFDA2A25Fu, 0xEAAFAF45u, 0xBF9C9C23u, 0xF7A4A453u, 0x967272E4u, 1539358875u, 0xC2B7B775u, 486407649u, 0xAE93933Du, 1780885068u, 1513502316u, 1094664062u, 49805301u, 1338821763u, 1546925160u, 0xF4A5A551u, 887481809u, 150073849u, 0x937171E2u, 1943591083u, 1395732834u, 1058346282u, 201589768u, 1388824469u, 1696801606u, 1589887901u, 672667696u, 0xA1969637u, 251987210u, 0xB59A9A2Fu, 151455502u, 907153956u, 0x9B80801Bu, 1038279391u, 652995533u, 1764173646u, 0xCDB2B27Fu, 0x9F7575EAu, 453576978u, 0x9E83831Du, 1949051992u, 773462580u, 756751158u, 0xB26E6EDCu, 0xEE5A5AB4u, 0xFBA0A05Bu, 0xF65252A4u, 1295727478u, 1641469623u, 0xCEB3B37Du, 2066295122u, 1055122397u, 1898917726u, 0x97848413u, 0xF55353A6u, 1758581177u, 0u, 753790401u, 1612718144u, 536673507u, 0xC8B1B179u, 0xED5B5BB6u, 0xBE6A6AD4u, 1187761037u, 0xD9BEBE67u, 1262041458u, 0xDE4A4A94u, 0xD44C4C98u, 0xE85858B0u, 1255133061u, 1808847035u, 720367557u, 0xE5AAAA4Fu, 385612781u, 0xC5434386u, 0xD74D4D9Au, 1429418854u, 0x94858511u, 0xCF45458Au, 284817897u, 100794884u, 0x817F7FFEu, 0xF05050A0u, 1144798328u, 0xBA9F9F25u, 0xE3A8A84Bu, 0xF35151A2u, 0xFEA3A35Du, 0xC0404080u, 0x8A8F8F05u, 0xAD92923Fu, 0xBC9D9D21u, 1211644016u, 83228145u, 0xDFBCBC63u, 0xC1B6B677u, 1977277103u, 1663115586u, 806359072u, 452984805u, 250868733u, 1842533055u, 1288555905u, 336333848u, 890442534u, 804056259u, 0xE15F5FBEu, 0xA2979735u, 0xCC444488u, 957814574u, 1472513171u, 0xF2A7A755u, 0x827E7EFCu, 1195195770u, 0xAC6464C8u, 0xE75D5DBAu, 723065138u, 0x957373E6u, 0xA06060C0u, 0x98818119u, 0xD14F4F9Eu, 2145180835u, 1713513028u, 2116692564u, 0xAB90903Bu, 0x8388880Bu, 0xCA46468Cu, 703524551u, 0xD3B8B86Bu, 1007948840u, 2044649127u, 0xE25E5EBCu, 487262998u, 1994120109u, 1004593371u, 1446130276u, 1312438900u, 503974420u, 0xDB494992u, 168166924u, 1814307912u, 0xE45C5CB8u, 1573044895u, 1859376061u, 0xEFACAC43u, 0xA66262C4u, 0xA8919139u, 0xA4959531u, 937747667u, 0x8B7979F2u, 854058965u, 1137232011u, 1496790894u, 0xB76D6DDAu, 0x8C8D8D01u, 1691735473u, 0xD24E4E9Cu, 0xE0A9A949u, 0xB46C6CD8u, 0xFA5656ACu, 133494003u, 636152527u, 0xAF6565CAu, 0x8E7A7AF4u, 0xE9AEAE47u, 403179536u, 0xD5BABA6Fu, 0x887878F0u, 1864705354u, 1915629148u, 605822008u, 0xF1A6A657u, 0xC7B4B473u, 1371981463u, 602466507u, 2094914977u, 0x9C7474E8u, 555687742u, 0xDD4B4B96u, 0xDCBDBD61u, 0x868B8B0Du, 0x858A8A0Fu, 0x907070E0u, 1111375484u, 0xC4B5B571u, 0xAA6666CCu, 0xD8484890u, 84083462u, 32962295u, 302911004u, 0xA36161C2u, 1597322602u, 0xF95757AEu, 0xD0B9B969u, 0x91868617u, 1489093017u, 656219450u, 0xB99E9E27u, 954327513u, 335083755u, 0xB398982Bu, 856756514u, 0xBB6969D2u, 1893325225u, 0x898E8E07u, 0xA7949433u, 0xB69B9B2Du, 572399164u, 0x92878715u, 552200649u, 1238290055u, 0xFF5555AAu, 2015897680u, 2061492133u, 0x8F8C8C03u, 0xF8A1A159u, 0x80898909u, 386731290u, 0xDABFBF65u, 837215959u, 0xC6424284u, 0xB86868D0u, 0xC3414182u, 0xB0999929u, 1999449434u, 286199582u, 0xCBB0B07Bu, 0xFC5454A8u, 0xD6BBBB6Du, 974525996u };
// FT1
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 207
static const uint32_t FT1[256ll]={ 1667483301u, 2088564868u, 2004348569u, 2071721613u, 0xF2F2FF0Du, 1802229437u, 1869602481u, 0xC5C59154u, 808476752u, 16843267u, 1734856361u, 724260477u, 0xFEFEE719u, 0xD7D7B562u, 0xABAB4DE6u, 1987505306u, 0xCACA8F45u, 0x82821F9Du, 0xC9C98940u, 2105408135u, 0xFAFAEF15u, 1499050731u, 1195871945u, 0xF0F0FB0Bu, 0xADAD41ECu, 0xD4D4B367u, 0xA2A25FFDu, 0xAFAF45EAu, 0x9C9C23BFu, 0xA4A453F7u, 1920132246u, 0xC0C09B5Bu, 0xB7B775C2u, 0xFDFDE11Cu, 0x93933DAEu, 640044138u, 909536346u, 1061125697u, 0xF7F7F502u, 0xCCCC834Fu, 875849820u, 0xA5A551F4u, 0xE5E5D134u, 0xF1F1F908u, 1903288979u, 0xD8D8AB73u, 825320019u, 353708607u, 67373068u, 0xC7C79552u, 589514341u, 0xC3C39D5Eu, 404238376u, 0x969637A1u, 84216335u, 0x9A9A2FB5u, 117902857u, 303178806u, 0x80801B9Bu, 0xE2E2DF3Du, 0xEBEBCD26u, 656887401u, 0xB2B27FCDu, 1970662047u, 151589403u, 0x83831D9Eu, 741103732u, 437924910u, 454768173u, 1852759218u, 1515893998u, 0xA0A05BFBu, 1381147894u, 993752653u, 0xD6D6B761u, 0xB3B37DCEu, 690573947u, 0xE3E3DD3Eu, 791633521u, 0x84841397u, 1397991157u, 0xD1D1B968u, 0u, 0xEDEDC12Cu, 538984544u, 0xFCFCE31Fu, 0xB1B179C8u, 1532737261u, 1785386174u, 0xCBCB8D46u, 0xBEBE67D9u, 960066123u, 1246401758u, 1280088276u, 1482207464u, 0xCFCF854Au, 0xD0D0BB6Bu, 0xEFEFC52Au, 0xAAAA4FE5u, 0xFBFBED16u, 1128498885u, 1296931543u, 859006549u, 0x85851194u, 1162185423u, 0xF9F9E910u, 33686534u, 2139094657u, 1347461360u, 1010595908u, 0x9F9F25BAu, 0xA8A84BE3u, 1364304627u, 0xA3A35DFEu, 1077969088u, 0x8F8F058Au, 0x92923FADu, 0x9D9D21BCu, 943222856u, 0xF5F5F104u, 0xBCBC63DFu, 0xB6B677C1u, 0xDADAAF75u, 555827811u, 269492272u, 0xFFFFE51Au, 0xF3F3FD0Eu, 0xD2D2BF6Du, 0xCDCD814Cu, 202119188u, 320022069u, 0xECECC32Fu, 1600110305u, 0x979735A2u, 1145342156u, 387395129u, 0xC4C49357u, 0xA7A755F2u, 2122251394u, 1027439175u, 1684326572u, 1566423783u, 421081643u, 1936975509u, 1616953504u, 0x81811998u, 1330618065u, 0xDCDCA37Fu, 572671078u, 707417214u, 0x90903BABu, 0x88880B83u, 1179028682u, 0xEEEEC729u, 0xB8B86BD3u, 336865340u, 0xDEDEA779u, 1583267042u, 185275933u, 0xDBDBAD76u, 0xE0E0DB3Bu, 842163286u, 976909390u, 168432670u, 1229558491u, 101059594u, 606357612u, 1549580516u, 0xC2C29F5Du, 0xD3D3BD6Eu, 0xACAC43EFu, 1650640038u, 0x919139A8u, 0x959531A4u, 0xE4E4D337u, 2038035083u, 0xE7E7D532u, 0xC8C88B43u, 926379609u, 1835915959u, 0x8D8D018Cu, 0xD5D5B164u, 1313774802u, 0xA9A949E0u, 1819072692u, 1448520954u, 0xF4F4F307u, 0xEAEACF25u, 1701169839u, 2054878350u, 0xAEAE47E9u, 134746136u, 0xBABA6FD5u, 2021191816u, 623200879u, 774790258u, 471611428u, 0xA6A657F1u, 0xB4B473C7u, 0xC6C69751u, 0xE8E8CB23u, 0xDDDDA17Cu, 1953818780u, 522141217u, 1263245021u, 0xBDBD61DCu, 0x8B8B0D86u, 0x8A8A0F85u, 1886445712u, 1044282434u, 0xB5B571C4u, 1718013098u, 1212715224u, 50529797u, 0xF6F6F701u, 235805714u, 1633796771u, 892693087u, 1465364217u, 0xB9B969D0u, 0x86861791u, 0xC1C19958u, 488454695u, 0x9E9E27B9u, 0xE1E1D938u, 0xF8F8EB13u, 0x98982BB3u, 286335539u, 1768542907u, 0xD9D9A970u, 0x8E8E0789u, 0x949433A7u, 0x9B9B2DB6u, 505297954u, 0x87871592u, 0xE9E9C920u, 0xCECE8749u, 1431677695u, 673730680u, 0xDFDFA57Au, 0x8C8C038Fu, 0xA1A159F8u, 0x89890980u, 218962455u, 0xBFBF65DAu, 0xE6E6D731u, 1111655622u, 1751699640u, 1094812355u, 0x999929B0u, 757946999u, 252648977u, 0xB0B07BCBu, 1414834428u, 0xBBBB6DD6u, 370551866u };
// FT2
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 211
static const uint32_t FT2[256ll]={ 1673962851u, 2096661628u, 2012125559u, 2079755643u, 0xF2FF0DF2u, 1809235307u, 1876865391u, 0xC59154C5u, 811618352u, 16909057u, 1741597031u, 727088427u, 0xFEE719FEu, 0xD7B562D7u, 0xAB4DE6ABu, 1995217526u, 0xCA8F45CAu, 0x821F9D82u, 0xC98940C9u, 2113570685u, 0xFAEF15FAu, 1504897881u, 1200539975u, 0xF0FB0BF0u, 0xAD41ECADu, 0xD4B367D4u, 0xA25FFDA2u, 0xAF45EAAFu, 0x9C23BF9Cu, 0xA453F7A4u, 1927583346u, 0xC09B5BC0u, 0xB775C2B7u, 0xFDE11CFDu, 0x933DAE93u, 642542118u, 913070646u, 1065238847u, 0xF7F502F7u, 0xCC834FCCu, 879254580u, 0xA551F4A5u, 0xE5D134E5u, 0xF1F908F1u, 1910674289u, 0xD8AB73D8u, 828527409u, 355090197u, 67636228u, 0xC79552C7u, 591815971u, 0xC39D5EC3u, 405809176u, 0x9637A196u, 84545285u, 0x9A2FB59Au, 118360327u, 304363026u, 0x801B9B80u, 0xE2DF3DE2u, 0xEBCD26EBu, 659450151u, 0xB27FCDB2u, 1978310517u, 152181513u, 0x831D9E83u, 743994412u, 439627290u, 456535323u, 1859957358u, 1521806938u, 0xA05BFBA0u, 1386542674u, 997608763u, 0xD6B761D6u, 0xB37DCEB3u, 693271337u, 0xE3DD3EE3u, 794718511u, 0x84139784u, 1403450707u, 0xD1B968D1u, 0u, 0xEDC12CEDu, 541089824u, 0xFCE31FFCu, 0xB179C8B1u, 1538714971u, 1792327274u, 0xCB8D46CBu, 0xBE67D9BEu, 963791673u, 1251270218u, 1285084236u, 1487988824u, 0xCF854ACFu, 0xD0BB6BD0u, 0xEFC52AEFu, 0xAA4FE5AAu, 0xFBED16FBu, 1132905795u, 1301993293u, 862344499u, 0x85119485u, 1166724933u, 0xF9E910F9u, 33818114u, 2147385727u, 1352724560u, 1014514748u, 0x9F25BA9Fu, 0xA84BE3A8u, 1369633617u, 0xA35DFEA3u, 1082179648u, 0x8F058A8Fu, 0x923FAD92u, 0x9D21BC9Du, 946882616u, 0xF5F104F5u, 0xBC63DFBCu, 0xB677C1B6u, 0xDAAF75DAu, 557998881u, 270544912u, 0xFFE51AFFu, 0xF3FD0EF3u, 0xD2BF6DD2u, 0xCD814CCDu, 202904588u, 321271059u, 0xECC32FECu, 1606345055u, 0x9735A297u, 1149815876u, 388905239u, 0xC49357C4u, 0xA755F2A7u, 2130477694u, 1031423805u, 1690872932u, 1572530013u, 422718233u, 1944491379u, 1623236704u, 0x81199881u, 1335808335u, 0xDCA37FDCu, 574907938u, 710180394u, 0x903BAB90u, 0x880B8388u, 1183631942u, 0xEEC729EEu, 0xB86BD3B8u, 338181140u, 0xDEA779DEu, 1589437022u, 185998603u, 0xDBAD76DBu, 0xE0DB3BE0u, 845436466u, 980700730u, 169090570u, 1234361161u, 101452294u, 608726052u, 1555620956u, 0xC29F5DC2u, 0xD3BD6ED3u, 0xAC43EFACu, 1657054818u, 0x9139A891u, 0x9531A495u, 0xE4D337E4u, 2045938553u, 0xE7D532E7u, 0xC88B43C8u, 929978679u, 1843050349u, 0x8D018C8Du, 0xD5B164D5u, 1318900302u, 0xA949E0A9u, 1826141292u, 1454176854u, 0xF4F307F4u, 0xEACF25EAu, 1707781989u, 2062847610u, 0xAE47E9AEu, 135272456u, 0xBA6FD5BAu, 2029029496u, 625635109u, 777810478u, 473441308u, 0xA657F1A6u, 0xB473C7B4u, 0xC69751C6u, 0xE8CB23E8u, 0xDDA17CDDu, 1961401460u, 524165407u, 1268178251u, 0xBD61DCBDu, 0x8B0D868Bu, 0x8A0F858Au, 1893765232u, 1048330814u, 0xB571C4B5u, 1724688998u, 1217452104u, 50726147u, 0xF6F701F6u, 236720654u, 1640145761u, 896163637u, 1471084887u, 0xB969D0B9u, 0x86179186u, 0xC19958C1u, 490350365u, 0x9E27B99Eu, 0xE1D938E1u, 0xF8EB13F8u, 0x982BB398u, 287453969u, 1775418217u, 0xD9A970D9u, 0x8E07898Eu, 0x9433A794u, 0x9B2DB69Bu, 507257374u, 0x87159287u, 0xE9C920E9u, 0xCE8749CEu, 1437269845u, 676362280u, 0xDFA57ADFu, 0x8C038F8Cu, 0xA159F8A1u, 0x89098089u, 219813645u, 0xBF65DABFu, 0xE6D731E6u, 1115997762u, 1758509160u, 1099088705u, 0x9929B099u, 760903469u, 253628687u, 0xB07BCBB0u, 1420360788u, 0xBB6DD6BBu, 371997206u };
// FT3
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 215
static const uint32_t FT3[256ll]={ 0xC6A56363u, 0xF8847C7Cu, 0xEE997777u, 0xF68D7B7Bu, 0xFF0DF2F2u, 0xD6BD6B6Bu, 0xDEB16F6Fu, 0x9154C5C5u, 1615867952u, 33751297u, 0xCEA96767u, 1451043627u, 0xE719FEFEu, 0xB562D7D7u, 1306962859u, 0xEC9A7676u, 0x8F45CACAu, 530416258u, 0x8940C9C9u, 0xFA877D7Du, 0xEF15FAFAu, 0xB2EB5959u, 0x8EC94747u, 0xFB0BF0F0u, 1106029997u, 0xB367D4D4u, 1610457762u, 1173008303u, 599760028u, 1408738468u, 0xE4967272u, 0x9B5BC0C0u, 1975695287u, 0xE11CFDFDu, 1034851219u, 1282024998u, 1817851446u, 2118205247u, 0xF502F7F7u, 0x834FCCCCu, 1750873140u, 1374987685u, 0xD134E5E5u, 0xF908F1F1u, 0xE2937171u, 0xAB73D8D8u, 1649619249u, 708777237u, 135005188u, 0x9552C7C7u, 1181033251u, 0x9D5EC3C3u, 807933976u, 933336726u, 168756485u, 800430746u, 235472647u, 607523346u, 463175808u, 0xDF3DE2E2u, 0xCD26EBEBu, 1315514151u, 2144187058u, 0xEA9F7575u, 303761673u, 496927619u, 1484008492u, 875436570u, 908925723u, 0xDCB26E6Eu, 0xB4EE5A5Au, 1543217312u, 0xA4F65252u, 1984772923u, 0xB761D6D6u, 2110698419u, 1383803177u, 0xDD3EE3E3u, 1584475951u, 328696964u, 0xA6F55353u, 0xB968D1D1u, 0u, 0xC12CEDEDu, 1080041504u, 0xE31FFCFCu, 2043195825u, 0xB6ED5B5Bu, 0xD4BE6A6Au, 0x8D46CBCBu, 1742323390u, 1917532473u, 0x94DE4A4Au, 0x98D44C4Cu, 0xB0E85858u, 0x854ACFCFu, 0xBB6BD0D0u, 0xC52AEFEFu, 1340451498u, 0xED16FBFBu, 0x86C54343u, 0x9AD74D4Du, 1716859699u, 294946181u, 0x8ACF4545u, 0xE910F9F9u, 67502594u, 0xFE817F7Fu, 0xA0F05050u, 2017737788u, 632987551u, 1273211048u, 0xA2F35151u, 1576969123u, 0x80C04040u, 92966799u, 1068339858u, 566009245u, 1883781176u, 0xF104F5F5u, 1675607228u, 2009183926u, 0xAF75DADAu, 1113792801u, 540020752u, 0xE51AFFFFu, 0xFD0EF3F3u, 0xBF6DD2D2u, 0x814CCDCDu, 403966988u, 641012499u, 0xC32FECECu, 0xBEE15F5Fu, 899848087u, 0x88CC4444u, 775493399u, 0x9357C4C4u, 1441965991u, 0xFC827E7Eu, 2051489085u, 0xC8AC6464u, 0xBAE75D5Du, 841685273u, 0xE6957373u, 0xC0A06060u, 429425025u, 0x9ED14F4Fu, 0xA37FDCDCu, 1147544098u, 1417554474u, 1001099408u, 193169544u, 0x8CCA4646u, 0xC729EEEEu, 1809037496u, 675025940u, 0xA779DEDEu, 0xBCE25E5Eu, 371002123u, 0xAD76DBDBu, 0xDB3BE0E0u, 1683370546u, 1951283770u, 337512970u, 0x92DB4949u, 201983494u, 1215046692u, 0xB8E45C5Cu, 0x9F5DC2C2u, 0xBD6ED3D3u, 1139780780u, 0xC4A66262u, 967348625u, 832869781u, 0xD337E4E4u, 0xF28B7979u, 0xD532E7E7u, 0x8B43C8C8u, 1851340599u, 0xDAB76D6Du, 25988493u, 0xB164D5D5u, 0x9CD24E4Eu, 1239460265u, 0xD8B46C6Cu, 0xACFA5656u, 0xF307F4F4u, 0xCF25EAEAu, 0xCAAF6565u, 0xF48E7A7Au, 1206496942u, 270010376u, 1876277946u, 0xF0887878u, 1248797989u, 1550986798u, 941890588u, 1475454630u, 1942467764u, 0x9751C6C6u, 0xCB23E8E8u, 0xA17CDDDDu, 0xE89C7474u, 1042358047u, 0x96DD4B4Bu, 1641856445u, 226921355u, 260409994u, 0xE0907070u, 2084716094u, 1908716981u, 0xCCAA6666u, 0x90D84848u, 100991747u, 0xF701F6F6u, 470945294u, 0xC2A36161u, 1784624437u, 0xAEF95757u, 1775286713u, 395413126u, 0x9958C1C1u, 975641885u, 666476190u, 0xD938E1E1u, 0xEB13F8F8u, 733190296u, 573772049u, 0xD2BB6969u, 0xA970D9D9u, 126455438u, 866620564u, 766942107u, 1008868894u, 361924487u, 0xC920E9E9u, 0x8749CECEu, 0xAAFF5555u, 1350051880u, 0xA57ADFDFu, 59739276u, 1509466529u, 159418761u, 437718285u, 1708834751u, 0xD731E6E6u, 0x84C64242u, 0xD0B86868u, 0x82C34141u, 699439513u, 1517759789u, 504434447u, 2076946608u, 0xA8FC5454u, 1842789307u, 742004246u };
// K
// file ..\..\..\..\lib\third_party\mbedtls\library\sha256.c line 147
static const uint32_t K[64ll]={ 1116352408u, 1899447441u, 0xB5C0FBCFu, 0xE9B5DBA5u, 961987163u, 1508970993u, 0x923F82A4u, 0xAB1C5ED5u, 0xD807AA98u, 310598401u, 607225278u, 1426881987u, 1925078388u, 0x80DEB1FEu, 0x9BDC06A7u, 0xC19BF174u, 0xE49B69C1u, 0xEFBE4786u, 264347078u, 604807628u, 770255983u, 1249150122u, 1555081692u, 1996064986u, 0x983E5152u, 0xA831C66Du, 0xB00327C8u, 0xBF597FC7u, 0xC6E00BF3u, 0xD5A79147u, 113926993u, 338241895u, 666307205u, 773529912u, 1294757372u, 1396182291u, 1695183700u, 1986661051u, 0x81C2C92Eu, 0x92722C85u, 0xA2BFE8A1u, 0xA81A664Bu, 0xC24B8B70u, 0xC76C51A3u, 0xD192E819u, 0xD6990624u, 0xF40E3585u, 275423344u, 430227734u, 506948616u, 659060556u, 883997877u, 958139571u, 1322822218u, 1537002063u, 1747873779u, 1955562222u, 2024104815u, 0x84C87814u, 0x8CC70208u, 0x90BEFFFAu, 0xA4506CEBu, 0xBEF9A3F7u, 0xC67178F2u };
// RCON
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 356
static const uint32_t RCON[10ll]={ 1u, 2u, 4u, 8u, 16u, 32u, 64u, 128u, 27u, 54u };
// RSb
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 225
static const unsigned char RSb[256ll]={ 82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125 };
// RT0
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 332
static const uint32_t RT0[256ll]={ 1353184337u, 1399144830u, 0xC3A4171Au, 0x965E273Au, 0xCB6BAB3Bu, 0xF1459D1Fu, 0xAB58FAACu, 0x9303E34Bu, 1442459680u, 0xF66D76ADu, 0x9176CC88u, 625738485u, 0xFCD7E54Fu, 0xD7CB2AC5u, 0x80443526u, 0x8FA362B5u, 1230680542u, 1729870373u, 0x980EEA45u, 0xE1C0FE5Du, 41234371u, 317738113u, 0xA397468Du, 0xC6F9D36Bu, 0xE75F8F03u, 0x959C9215u, 0xEB7A6DBFu, 0xDA595295u, 763608788u, 0xD3217458u, 694804553u, 1154009486u, 1787413109u, 2021232372u, 1799248025u, 0xDD71B927u, 0xB64FE1BEu, 397248752u, 1722556617u, 0xB43ACE7Du, 407560035u, 0x82311AE5u, 1613975959u, 1165972322u, 0xE07764B1u, 0x84AE6BBBu, 480281086u, 0x942B08F9u, 1483229296u, 436028815u, 0x876CDE94u, 0xB7F87B52u, 601060267u, 0xE2024B72u, 1468997603u, 715871590u, 120122290u, 63092015u, 0x9A7BC586u, 0xA50837D3u, 0xF2872830u, 0xB2A5BF23u, 0xBA6A0302u, 1552029421u, 723308426u, 0x92B479A7u, 0xF0F207F3u, 0xA1E2694Eu, 0xCDF4DA65u, 0xD5BE0506u, 526529745u, 0x8AFEA6C4u, 0x9D532E34u, 0xA055F3A2u, 853641733u, 1978398372u, 971801355u, 0xAAEF6040u, 111112542u, 1360031421u, 0xF98A213Eu, 1023860118u, 0xAE053EDDu, 1186850381u, 0xB58D5491u, 90031217u, 1876166148u, 0xFF155060u, 620468249u, 0x97E9BDD6u, 0xCC434089u, 2006899047u, 0xBD42E8B0u, 0x888B8907u, 945494503u, 0xDBEEC879u, 1191869601u, 0xE90F427Cu, 0xC91E84F8u, 0u, 0x83868009u, 1223502642u, 0xAC70111Eu, 1316117100u, 0xFBFF0EFDu, 1446544655u, 517320253u, 658058550u, 1691946762u, 564550760u, 0xD1545B9Bu, 976107044u, 0xB1670A0Cu, 266819475u, 0xD296EEB4u, 0x9E919B1Bu, 1338359936u, 0xA220DC61u, 1766553434u, 370807324u, 179999714u, 0xE52AA0C0u, 1138762300u, 488053522u, 185403662u, 0xADC78BF2u, 0xB9A8B62Du, 0xC8A91E14u, 0x8519F157u, 1275557295u, 0xBBDD99EEu, 0xFD607FA3u, 0x9F2601F7u, 0xBCF5725Cu, 0xC53B6644u, 880737115u, 1982415755u, 0xDCC623CBu, 1761406390u, 1676797112u, 0xCADC31D7u, 277177154u, 1076008723u, 538035844u, 2099530373u, 0xF83DBBD2u, 288553390u, 1839278535u, 1261411869u, 0xF330B2DCu, 0xEC52860Du, 0xD0E3C177u, 1813426987u, 0x99B970A9u, 0xFA489411u, 577038663u, 0xC48CFCA8u, 440397984u, 0xD82C7D56u, 0xEF903322u, 0xC74E4987u, 0xC1D138D9u, 0xFEA2CA8Cu, 906744984u, 0xCF81F5A6u, 685669029u, 646887386u, 0xA4BFAD3Fu, 0xE49D3A2Cu, 227702864u, 0x9BCC5F6Au, 1648787028u, 0xC2138DF6u, 0xE8B8D890u, 1593260334u, 0xF5AFC382u, 0xBE805D9Fu, 2090061929u, 0xA92DD56Fu, 0xB31225CFu, 999926984u, 0xA77D1810u, 1852021992u, 2075868123u, 158869197u, 0xF418596Eu, 28809964u, 0xA89A4F83u, 1701746150u, 2129067946u, 147831841u, 0xE6E815EFu, 0xD99BE7BAu, 0xCE366F4Au, 0xD4099FEAu, 0xD67CB029u, 0xAFB2A431u, 824393514u, 815048134u, 0xC066A235u, 935087732u, 0xA6CA82FCu, 0xB0D090E0u, 366520115u, 1251476721u, 0xF7DAEC41u, 240176511u, 804688151u, 0x8DD64D76u, 1303441219u, 1414376140u, 0xDF0496E4u, 0xE3B5D19Eu, 461924940u, 0xB81F2CC1u, 2136040774u, 82468509u, 1563790337u, 1937016826u, 776014843u, 1511876531u, 1389550482u, 861278441u, 323475053u, 0x8C61D79Au, 2047648055u, 0x8E14F859u, 0x893C13EBu, 0xEE27A9CEu, 902390199u, 0xEDE51CE1u, 1018251130u, 1507840668u, 1064563285u, 2043548696u, 0xBF37C773u, 0xEACDF753u, 1537932639u, 342834655u, 0x86DB4478u, 0x81F3AFCAu, 1053059257u, 741614648u, 1598071746u, 1925389590u, 203809468u, 0x8B493C28u, 1100287487u, 1895934009u, 0xDEB30C08u, 0x9CE4B4D8u, 0x90C15664u, 1636092795u, 1890988757u, 1952214088u, 1113045200u };
// RT1
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 338
static const uint32_t RT1[256ll]={ 0xA7F45150u, 1698790995u, 0xA4171AC3u, 1579629206u, 1806384075u, 1167925233u, 1492823211u, 65227667u, 0xFA302055u, 1836494326u, 1993115793u, 1275262245u, 0xD7E54FFCu, 0xCB2AC5D7u, 1144333952u, 0xA362B58Fu, 1521606217u, 465184103u, 250234264u, 0xC0FE5DE1u, 1966064386u, 0xF04C8112u, 0x97468DA3u, 0xF9D36BC6u, 1603208167u, 0x9C921595u, 2054012907u, 1498584538u, 0x83BED42Du, 561273043u, 1776306473u, 0xC8C98E44u, 0x89C2756Au, 2039411832u, 1045993835u, 1907959773u, 1340194486u, 0xAD88F017u, 0xAC20C966u, 986611124u, 1256153880u, 823846274u, 860985184u, 2136171077u, 2003087840u, 0xAE6BBB84u, 0xA081FE1Cu, 722008468u, 1749577816u, 0xFD458F19u, 1826526343u, 0xF87B52B7u, 0xD373AB23u, 38499042u, 0x8F1FE357u, 0xAB55662Au, 686535175u, 0xC2B52F03u, 2076542618u, 137876389u, 0x872830F2u, 0xA5BF23B2u, 1778582202u, 0x8216ED5Cu, 483363371u, 0xB479A792u, 0xF207F3F0u, 0xE2694EA1u, 0xF4DA65CDu, 0xBE0506D5u, 1647628575u, 0xFEA6C48Au, 1395537053u, 1442030240u, 0xE18A0532u, 0xEBF6A475u, 0xEC830B39u, 0xEF6040AAu, 0x9F715E06u, 275692881u, 0x8A213EF9u, 115185213u, 88006062u, 0xBDE64D46u, 0x8D5491B5u, 1573155077u, 0xD406046Fu, 357589247u, 0xFB981924u, 0xE9BDD697u, 1128303052u, 0x9ED96777u, 1122545853u, 0x8B890788u, 1528424248u, 0xEEC879DBu, 175939911u, 256015593u, 512030921u, 0u, 0x86800983u, 0xED2B3248u, 1880170156u, 1918528590u, 0xFF0EFDFBu, 948244310u, 0xD5AE3D1Eu, 959264295u, 0xD90F0A64u, 0xA65C6821u, 1415289809u, 775300154u, 1728711857u, 0xE757930Fu, 0x96EEB4D2u, 0x919B1B9Eu, 0xC5C0804Fu, 551313826u, 1266113129u, 437394454u, 0xBA93E20Au, 715178213u, 0xE0223C43u, 387650077u, 218697227u, 0xC78BF2ADu, 0xA8B62DB9u, 0xA91E14C8u, 435246981u, 125153100u, 0xDD99EEBBu, 1618977789u, 637663135u, 0xF5725CBCu, 996558021u, 2130402100u, 692292470u, 0xC623CBDCu, 0xFCEDB668u, 0xF1E4B863u, 0xDC31D7CAu, 0x85634210u, 580326208u, 298222624u, 608863613u, 1035719416u, 855223825u, 0xA129C76Du, 798891339u, 817028339u, 1384517100u, 0xE3C177D0u, 380840812u, 0xB970A999u, 1217663482u, 1693009698u, 0x8CFCA8C4u, 1072734234u, 746411736u, 0x903322EFu, 1313441735u, 0xD138D9C1u, 0xA2CA8CFEu, 198481974u, 0x81F5A6CFu, 0xDE7AA528u, 0x8EB7DA26u, 0xBFAD3FA4u, 0x9D3A2CE4u, 0x9278500Du, 0xCC5F6A9Bu, 1182684258u, 328070850u, 0xB8D890E8u, 0xF7392E5Eu, 0xAFC382F5u, 0x805D9FBEu, 0x93D0697Cu, 768962473u, 304467891u, 0x99ACC83Bu, 2098729127u, 1671227502u, 0xBB3BDB7Bu, 2015808777u, 408514292u, 0xB79AEC01u, 0x9A4F83A8u, 1855317605u, 0xE6FFAA7Eu, 0xCFBC2108u, 0xE815EFE6u, 0x9BE7BAD9u, 913263310u, 161475284u, 2091919830u, 0xB2A431AFu, 591342129u, 0x94A5C630u, 1721906624u, 0xBC4E7437u, 0xCA82FCA6u, 0xD090E0B0u, 0xD8A73315u, 0x9804F14Au, 0xDAEC41F7u, 1355644686u, 0xF691172Fu, 0xD64D768Du, 0xB0EF434Du, 1303039060u, 76997855u, 0xB5D19EE3u, 0x886A4C1Bu, 523026872u, 1365591679u, 0xEA5E9D04u, 898367837u, 1955068531u, 1091304238u, 493335386u, 0xD2DB9252u, 1443948851u, 1205234963u, 1641519756u, 211892090u, 351820174u, 1007938441u, 665439982u, 0xC961B735u, 0xE51CE1EDu, 0xB1477A3Cu, 0xDFD29C59u, 1945261375u, 0xCE141879u, 935818175u, 0xCDF753EAu, 0xAAFD5F5Bu, 1866325780u, 0xDB447886u, 0xF3AFCA81u, 0xC468B93Eu, 874788908u, 1084473951u, 0xC31D1672u, 635616268u, 1228679307u, 0x950DFF41u, 27801969u, 0xB30C08DEu, 0xE4B4D89Cu, 0xC1566490u, 0x84CB7B61u, 0xB632D570u, 1550600308u, 1471729730u };
// RT2
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 342
static const uint32_t RT2[256ll]={ 0xF45150A7u, 1098797925u, 387629988u, 658151006u, 0xAB3BCB6Bu, 0x9D1FF145u, 0xFAACAB58u, 0xE34B9303u, 807425530u, 1991112301u, 0xCC889176u, 49620300u, 0xE54FFCD7u, 717608907u, 891715652u, 1656065955u, 0xB1DE495Au, 0xBA25671Bu, 0xEA45980Eu, 0xFE5DE1C0u, 801309301u, 1283527408u, 1183687575u, 0xD36BC6F9u, 0x8F03E75Fu, 0x9215959Cu, 1841294202u, 1385552473u, 0xBED42D83u, 1951978273u, 0xE0492969u, 0xC98E44C8u, 0xC2756A89u, 0x8EF47879u, 1486449470u, 0xB927DD71u, 0xE1BEB64Fu, 0x88F017ADu, 550069932u, 0xCE7DB43Au, 0xDF63184Au, 451248689u, 1368875059u, 1398949247u, 1689378935u, 1807451310u, 0x81FE1CA0u, 150574123u, 1215322216u, 1167006205u, 0xDE94876Cu, 2069018616u, 1940595667u, 1265820162u, 534992783u, 1432758955u, 0xEBB20728u, 0xB52F03C2u, 0xC5869A7Bu, 936617224u, 674296455u, 0xBF23B2A5u, 50510442u, 384654466u, 0xCF8A2B1Cu, 2041025204u, 133427442u, 1766760930u, 0xDA65CDF4u, 84334014u, 886120290u, 0xA6C48AFEu, 775200083u, 0xF3A2A055u, 0x8A0532E1u, 0xF6A475EBu, 0x830B39ECu, 1614850799u, 1901987487u, 1857900816u, 557775242u, 0xDD963D06u, 1054715397u, 0xE64D46BDu, 1418835341u, 0xC471055Du, 100954068u, 1348534037u, 0x981924FBu, 0xBDD697E9u, 1082772547u, 0xD967779Eu, 0xE8B0BD42u, 0x8907888Bu, 434583643u, 0xC879DBEEu, 2090944266u, 1115482383u, 0x84F8C91Eu, 0u, 0x80098386u, 724715757u, 287222896u, 1517047410u, 251526143u, 0x850F5638u, 0xAE3D1ED5u, 758523705u, 252339417u, 1550328230u, 1536938324u, 908343854u, 168604007u, 1469255655u, 0xEEB4D296u, 0x9B1B9E91u, 0xC0804FC5u, 0xDC61A220u, 2002413899u, 303830554u, 0x93E20ABAu, 0xA0C0E52Au, 574374880u, 454171927u, 151915277u, 0x8BF2ADC7u, 0xB62DB9A8u, 504678569u, 0xF1578519u, 1974422535u, 0x99EEBBDDu, 2141453664u, 33005350u, 1918680309u, 1715782971u, 0xFB5B347Eu, 1133213225u, 600562886u, 0xEDB668FCu, 0xE4B863F1u, 836225756u, 1665273989u, 0x97134022u, 0xC6842011u, 1250262308u, 0xBBD2F83Du, 0xF9AE1132u, 700935585u, 0x9E1D4B2Fu, 0xB2DCF330u, 0x860DEC52u, 0xC177D0E3u, 0xB32B6C16u, 1890163129u, 0x9411FA48u, 0xE9472264u, 0xFCA8C48Cu, 0xF0A01A3Fu, 2102843436u, 857927568u, 1233635150u, 953795025u, 0xCA8CFEA2u, 0xD498360Bu, 0xF5A6CF81u, 2057644254u, 0xB7DA268Eu, 0xAD3FA4BFu, 976020637u, 2018512274u, 1600822220u, 2119459398u, 0x8DF6C213u, 0xD890E8B8u, 959340279u, 0xC382F5AFu, 1570750080u, 0xD0697C93u, 0xD56FA92Du, 634368786u, 0xACC83B99u, 403744637u, 0x9CE86E63u, 1004239803u, 650971512u, 1500443672u, 0x9AEC01B7u, 1334028442u, 0x95E6656Eu, 0xFFAA7EE6u, 0xBC2108CFu, 368043752u, 0xE7BAD99Bu, 1867173430u, 0x9FEAD409u, 0xB029D67Cu, 0xA431AFB2u, 1059729699u, 0xA5C63094u, 0xA235C066u, 1316239292u, 0x82FCA6CAu, 0x90E0B0D0u, 0xA73315D8u, 82922136u, 0xEC41F7DAu, 0xCD7F0E50u, 0x91172FF6u, 1299615190u, 0xEF434DB0u, 0xAACC544Du, 0x96E4DF04u, 0xD19EE3B5u, 1783372680u, 750893087u, 1699118929u, 1587348714u, 0x8C015D35u, 0x87FA7374u, 201010753u, 1739807261u, 0xDB9252D2u, 283718486u, 0xD66D1347u, 0xD79A8C61u, 0xA1377A0Cu, 0xF8598E14u, 334203196u, 0xA9CEEE27u, 1639396809u, 484568549u, 1199193265u, 0xD29C59DFu, 0xF2553F73u, 337148366u, 0xC773BF37u, 0xF753EACDu, 0xFD5F5BAAu, 1038029935u, 1148749531u, 0xAFCA81F3u, 1756970692u, 607661108u, 0xA3C25F40u, 488010435u, 0xE2BC0C25u, 1009290057u, 234832277u, 0xA8397101u, 201907891u, 0xB4D89CE4u, 1449431233u, 0xCB7B6184u, 852848822u, 1816687708u, 0xB8D04257u };
// RT3
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 346
static const uint32_t RT3[256ll]={ 1364240372u, 2119394625u, 449029143u, 982933031u, 1003187115u, 535905693u, 0xACAB58FAu, 1267925987u, 542505520u, 0xADF66D76u, 0x889176CCu, 0xF5254C02u, 1341970405u, 0xC5D7CB2Au, 645940277u, 0xB58FA362u, 0xDE495AB1u, 627514298u, 1167593194u, 1575076094u, 0xC302752Fu, 0x8112F04Cu, 0x8DA39746u, 1808202195u, 65494927u, 362126482u, 0xBFEB7A6Du, 0x95DA5952u, 0xD42D83BEu, 1490231668u, 1227450848u, 0x8E44C8C9u, 1969916354u, 0xF478798Eu, 0x996B3E58u, 668823993u, 0xBEB64FE1u, 0xF017AD88u, 0xC966AC20u, 2108963534u, 1662536415u, 0xE582311Au, 0x97603351u, 1648721747u, 0xB1E07764u, 0xBB84AE6Bu, 0xFE1CA081u, 0xF9942B08u, 1884842056u, 0x8F19FD45u, 0x94876CDEu, 1387788411u, 0xAB23D373u, 1927414347u, 0xE3578F1Fu, 1714072405u, 0xB20728EBu, 788775605u, 0x869A7BC5u, 0xD3A50837u, 821200680u, 598910399u, 45771267u, 0xED5C8216u, 0x8A2B1CCFu, 0xA792B479u, 0xF3F0F207u, 1319232105u, 1707996378u, 114671109u, 0xD11F6234u, 0xC48AFEA6u, 882725678u, 0xA2A055F3u, 87220618u, 0xA475EBF6u, 188345475u, 1084944224u, 1577492337u, 0xBD51106Eu, 1056541217u, 0x963D06DDu, 0xDDAE053Eu, 1296481766u, 0x91B58D54u, 1896177092u, 74437638u, 1627329872u, 421854104u, 0xD697E9BDu, 0x89CC4340u, 1735892697u, 0xB0BD42E8u, 126389129u, 0xE7385B19u, 2044456648u, 0xA1470A7Cu, 2095648578u, 0xF8C91E84u, 0u, 159614592u, 843640107u, 514617361u, 1817080410u, 0xFDFBFF0Eu, 257308805u, 1025430958u, 908540205u, 174381327u, 1747035740u, 0x9BD1545Bu, 607792694u, 212952842u, 0x930FE757u, 0xB4D296EEu, 463376795u, 0x804FC5C0u, 1638015196u, 1516850039u, 471210514u, 0xE20ABA93u, 0xC0E52AA0u, 1011081250u, 303896347u, 235605257u, 0xF2ADC78Bu, 767142070u, 348694814u, 1468340721u, 0xAF4C0775u, 0xEEBBDD99u, 0xA3FD607Fu, 0xF79F2601u, 1555887474u, 1153776486u, 1530167035u, 0x8B762943u, 0xCBDCC623u, 0xB668FCEDu, 0xB863F1E4u, 0xD7CADC31u, 1108378979u, 322970263u, 0x842011C6u, 0x857D244Au, 0xD2F83DBBu, 0xAE1132F9u, 0xC76DA129u, 491466654u, 0xDCF330B2u, 233591430u, 2010178497u, 728503987u, 0xA999B970u, 301615252u, 1193436393u, 0xA8C48CFCu, 0xA01A3FF0u, 1457007741u, 586125363u, 0x87C74E49u, 0xD9C1D138u, 0x8CFEA2CAu, 0x98360BD4u, 0xA6CF81F5u, 0xA528DE7Au, 0xDA268EB7u, 1067761581u, 753179962u, 1343066744u, 1788595295u, 1415726718u, 0xF6C2138Du, 0x90E8B8D8u, 777975609u, 0x82F5AFC3u, 0x9FBE805Du, 1769771984u, 1873358293u, 0xCFB31225u, 0xC83B99ACu, 279411992u, 0xE86E639Cu, 0xDB7BBB3Bu, 0xCD097826u, 1861490777u, 0xEC01B79Au, 0x83A89A4Fu, 0xE6656E95u, 0xAA7EE6FFu, 554225596u, 0xEFE6E815u, 0xBAD99BE7u, 1255028335u, 0xEAD4099Fu, 701922480u, 833598116u, 707863359u, 0xC63094A5u, 901801634u, 1949809742u, 0xFCA6CA82u, 0xE0B0D090u, 857069735u, 0xF14A9804u, 1106762476u, 2131644621u, 389019281u, 1989006925u, 1129165039u, 0xCC544DAAu, 0xE4DF0496u, 0x9EE3B5D1u, 1276872810u, 0xC1B81F2Cu, 1182749029u, 0x9D04EA5Eu, 22885772u, 0xFA737487u, 0xFB2E410Bu, 0xB35A1D67u, 0x9252D2DBu, 0xE9335610u, 1829980118u, 0x9A8C61D7u, 930745505u, 1502483704u, 0xEB893C13u, 0xCEEE27A9u, 0xB735C961u, 0xE1EDE51Cu, 2050797895u, 0x9C59DFD2u, 1430221810u, 410635796u, 1941911495u, 1407897079u, 1599843069u, 0xDF146F3Du, 2022103876u, 0xCA81F3AFu, 0xB93EC468u, 942421028u, 0xC25F40A3u, 376619805u, 0xBC0C25E2u, 680216892u, 0xFF41950Du, 963707304u, 148812556u, 0xD89CE4B4u, 1687208278u, 2069988555u, 0xD570B632u, 1215585388u, 0xD04257B8u };
// RecorderData
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2175
RecorderDataType RecorderData;
// RecorderDataPtr
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2183
RecorderDataType *RecorderDataPtr=((RecorderDataType *)NULL);
// TraceObjectClassTable
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcKernelPort.c line 405
traceObjectClass TraceObjectClassTable[5ll]={ 0, 2, 1, 1, 2 };
// acOTA_GetNextAccepted_Topic
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 232
const char acOTA_GetNextAccepted_Topic[67ll]={ '$', 'a', 'w', 's', '/', 't', 'h', 'i', 'n', 'g', 's', '/', 'P', 'a', 's', 't', 'e', ' ', 'A', 'W', 'S', ' ', 'I', 'o', 'T', ' ', 'T', 'h', 'i', 'n', 'g', ' ', 'n', 'a', 'm', 'e', ' ', 'h', 'e', 'r', 'e', '.', '/', 'j', 'o', 'b', 's', '/', '$', 'n', 'e', 'x', 't', '/', 'g', 'e', 't', '/', 'a', 'c', 'c', 'e', 'p', 't', 'e', 'd', 0 };
// acOTA_GetNextJob_MsgTemplate
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 235
const char acOTA_GetNextJob_MsgTemplate[24ll]={ '{', '"', 'c', 'l', 'i', 'e', 'n', 't', 'T', 'o', 'k', 'e', 'n', '"', ':', '"', '%', 'u', ':', '%', 's', '"', '}', 0 };
// acOTA_GetNextJob_Topic
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 234
const char acOTA_GetNextJob_Topic[58ll]={ '$', 'a', 'w', 's', '/', 't', 'h', 'i', 'n', 'g', 's', '/', 'P', 'a', 's', 't', 'e', ' ', 'A', 'W', 'S', ' ', 'I', 'o', 'T', ' ', 'T', 'h', 'i', 'n', 'g', ' ', 'n', 'a', 'm', 'e', ' ', 'h', 'e', 'r', 'e', '.', '/', 'j', 'o', 'b', 's', '/', '$', 'n', 'e', 'x', 't', '/', 'g', 'e', 't', 0 };
// acOTA_JSON_ClientTokenKey
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 122
static const char acOTA_JSON_ClientTokenKey[12ll]={ 'c', 'l', 'i', 'e', 'n', 't', 'T', 'o', 'k', 'e', 'n', 0 };
// acOTA_JSON_ExecutionKey
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 123
static const char acOTA_JSON_ExecutionKey[10ll]={ 'e', 'x', 'e', 'c', 'u', 't', 'i', 'o', 'n', 0 };
// acOTA_JSON_FileAttributeKey
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 135
static const char acOTA_JSON_FileAttributeKey[5ll]={ 'a', 't', 't', 'r', 0 };
// acOTA_JSON_FileCertNameKey
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 136
static const char acOTA_JSON_FileCertNameKey[9ll]={ 'c', 'e', 'r', 't', 'f', 'i', 'l', 'e', 0 };
// acOTA_JSON_FileGroupKey
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 130
static const char acOTA_JSON_FileGroupKey[6ll]={ 'f', 'i', 'l', 'e', 's', 0 };
// acOTA_JSON_FileIDKey
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 134
static const char acOTA_JSON_FileIDKey[7ll]={ 'f', 'i', 'l', 'e', 'i', 'd', 0 };
// acOTA_JSON_FilePathKey
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 132
static const char acOTA_JSON_FilePathKey[9ll]={ 'f', 'i', 'l', 'e', 'p', 'a', 't', 'h', 0 };
// acOTA_JSON_FileSignatureKey
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 139
static const char acOTA_JSON_FileSignatureKey[32ll]={ 's', 'i', 'g', '-', 's', 'h', 'a', '2', '5', '6', '-', 'r', 's', 'a', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// acOTA_JSON_FileSizeKey
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 133
static const char acOTA_JSON_FileSizeKey[9ll]={ 'f', 'i', 'l', 'e', 's', 'i', 'z', 'e', 0 };
// acOTA_JSON_JobDocKey
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 128
static const char acOTA_JSON_JobDocKey[12ll]={ 'j', 'o', 'b', 'D', 'o', 'c', 'u', 'm', 'e', 'n', 't', 0 };
// acOTA_JSON_JobIDKey
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 124
static const char acOTA_JSON_JobIDKey[6ll]={ 'j', 'o', 'b', 'I', 'd', 0 };
// acOTA_JSON_OTAUnitKey
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 129
static const char acOTA_JSON_OTAUnitKey[7ll]={ 't', 's', '_', 'o', 't', 'a', 0 };
// acOTA_JSON_SelfTestKey
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 126
static const char acOTA_JSON_SelfTestKey[10ll]={ 's', 'e', 'l', 'f', '_', 't', 'e', 's', 't', 0 };
// acOTA_JSON_StatusDetailsKey
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 125
static const char acOTA_JSON_StatusDetailsKey[14ll]={ 's', 't', 'a', 't', 'u', 's', 'D', 'e', 't', 'a', 'i', 'l', 's', 0 };
// acOTA_JSON_StreamNameKey
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 131
static const char acOTA_JSON_StreamNameKey[11ll]={ 's', 't', 'r', 'e', 'a', 'm', 'n', 'a', 'm', 'e', 0 };
// acOTA_JSON_UpdatedByKey
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 127
static const char acOTA_JSON_UpdatedByKey[10ll]={ 'u', 'p', 'd', 'a', 't', 'e', 'd', 'B', 'y', 0 };
// acOTA_JobReason_Strings
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 155
const char *acOTA_JobReason_Strings[6ll]={ "", "ready", "active", "accepted", "rejected", "aborted" };
// acOTA_JobStatus_ReasonStrTemplate
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 243
const char acOTA_JobStatus_ReasonStrTemplate[16ll]={ '"', 'r', 'e', 'a', 's', 'o', 'n', '"', ':', '"', '%', 's', '"', '}', '}', 0 };
// acOTA_JobStatus_ReasonValTemplate
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 244
const char acOTA_JobStatus_ReasonValTemplate[16ll]={ '"', 'r', 'e', 'a', 's', 'o', 'n', '"', ':', '"', '%', 'd', '"', '}', '}', 0 };
// acOTA_JobStatus_ReceiveDetailsTemplate
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 241
const char acOTA_JobStatus_ReceiveDetailsTemplate[15ll]={ '"', '%', 's', '"', ':', '"', '%', 'u', '/', '%', 'u', '"', '}', '}', 0 };
// acOTA_JobStatus_SelfTestDetailsTemplate
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 242
const char acOTA_JobStatus_SelfTestDetailsTemplate[31ll]={ '"', '%', 's', '"', ':', '"', '%', 's', '"', ',', '"', 'u', 'p', 'd', 'a', 't', 'e', 'd', 'B', 'y', '"', ':', '"', '0', 'x', '%', 'x', '"', '}', '}', 0 };
// acOTA_JobStatus_StatusTemplate
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 240
const char acOTA_JobStatus_StatusTemplate[33ll]={ '{', '"', 's', 't', 'a', 't', 'u', 's', '"', ':', '"', '%', 's', '"', ',', '"', 's', 't', 'a', 't', 'u', 's', 'D', 'e', 't', 'a', 'i', 'l', 's', '"', ':', '{', 0 };
// acOTA_JobStatus_Strings
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 175
const char *acOTA_JobStatus_Strings[5ll];
// acOTA_String_Failed
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 171
const char acOTA_String_Failed[7ll]={ 'F', 'A', 'I', 'L', 'E', 'D', 0 };
// acOTA_String_InProgress
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 170
const char acOTA_String_InProgress[12ll]={ 'I', 'N', '_', 'P', 'R', 'O', 'G', 'R', 'E', 'S', 'S', 0 };
// acOTA_String_Rejected
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 173
const char acOTA_String_Rejected[9ll]={ 'R', 'E', 'J', 'E', 'C', 'T', 'E', 'D', 0 };
// acOTA_String_Succeeded
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 172
const char acOTA_String_Succeeded[10ll]={ 'S', 'U', 'C', 'C', 'E', 'E', 'D', 'E', 'D', 0 };
// acOTA_JobStatus_Strings
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 175
const char *acOTA_JobStatus_Strings[5ll]={ acOTA_String_InProgress, acOTA_String_Failed, acOTA_String_Succeeded, acOTA_String_Rejected, acOTA_String_Failed };
// acOTA_JobStatus_TopicTemplate
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 239
const char acOTA_JobStatus_TopicTemplate[58ll]={ '$', 'a', 'w', 's', '/', 't', 'h', 'i', 'n', 'g', 's', '/', 'P', 'a', 's', 't', 'e', ' ', 'A', 'W', 'S', ' ', 'I', 'o', 'T', ' ', 'T', 'h', 'i', 'n', 'g', ' ', 'n', 'a', 'm', 'e', ' ', 'h', 'e', 'r', 'e', '.', '/', 'j', 'o', 'b', 's', '/', '%', 's', '/', 'u', 'p', 'd', 'a', 't', 'e', 0 };
// acOTA_NotifyNext_Topic
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 233
const char acOTA_NotifyNext_Topic[60ll]={ '$', 'a', 'w', 's', '/', 't', 'h', 'i', 'n', 'g', 's', '/', 'P', 'a', 's', 't', 'e', ' ', 'A', 'W', 'S', ' ', 'I', 'o', 'T', ' ', 'T', 'h', 'i', 'n', 'g', ' ', 'n', 'a', 'm', 'e', ' ', 'h', 'e', 'r', 'e', '.', '/', 'j', 'o', 'b', 's', '/', 'n', 'o', 't', 'i', 'f', 'y', '-', 'n', 'e', 'x', 't', 0 };
// acOTA_RequestAccepted_TopicTemplate
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 238
const char acOTA_RequestAccepted_TopicTemplate[71ll]={ '$', 'a', 'w', 's', '/', 'b', 'i', 'n', '/', 't', 'h', 'i', 'n', 'g', 's', '/', 'P', 'a', 's', 't', 'e', ' ', 'A', 'W', 'S', ' ', 'I', 'o', 'T', ' ', 'T', 'h', 'i', 'n', 'g', ' ', 'n', 'a', 'm', 'e', ' ', 'h', 'e', 'r', 'e', '.', '/', 's', 't', 'r', 'e', 'a', 'm', 's', '/', '%', 's', '/', 'g', 'e', 't', '/', 'a', 'c', 'c', 'e', 'p', 't', 'e', 'd', 0 };
// acOTA_Request_TopicTemplate
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 236
const char acOTA_Request_TopicTemplate[62ll]={ '$', 'a', 'w', 's', '/', 'b', 'i', 'n', '/', 't', 'h', 'i', 'n', 'g', 's', '/', 'P', 'a', 's', 't', 'e', ' ', 'A', 'W', 'S', ' ', 'I', 'o', 'T', ' ', 'T', 'h', 'i', 'n', 'g', ' ', 'n', 'a', 'm', 'e', ' ', 'h', 'e', 'r', 'e', '.', '/', 's', 't', 'r', 'e', 'a', 'm', 's', '/', '%', 's', '/', 'g', 'e', 't', 0 };
// acOTA_RxStream_TopicTemplate
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 237
const char acOTA_RxStream_TopicTemplate[54ll]={ '$', 'a', 'w', 's', '/', 't', 'h', 'i', 'n', 'g', 's', '/', 'P', 'a', 's', 't', 'e', ' ', 'A', 'W', 'S', ' ', 'I', 'o', 'T', ' ', 'T', 'h', 'i', 'n', 'g', ' ', 'n', 'a', 'm', 'e', ' ', 'h', 'e', 'r', 'e', '.', '/', 's', 't', 'r', 'e', 'a', 'm', 's', '/', '%', 's', 0 };
// acOTA_String_Receive
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 245
const char acOTA_String_Receive[8ll]={ 'r', 'e', 'c', 'e', 'i', 'v', 'e', 0 };
// acOTA_String_SelfTest
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 246
const char acOTA_String_SelfTest[10ll]={ 's', 'e', 'l', 'f', '_', 't', 'e', 's', 't', 0 };
// add_count
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 86
static unsigned long int add_count;
// add_index
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 564
static const signed int add_index[6ll]={ 0, 0, 0, 1, 1, 1 };
// add_len
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 561
static const size_t add_len[6ll]={ 0ull, 0ull, 0ull, 20ull, 20ull, 20ull };
// additional
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 567
static const unsigned char additional[6ll][64ll]={ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 254, 237, 250, 206, 222, 173, 190, 239, 254, 237, 250, 206, 222, 173, 190, 239, 171, 173, 218, 210, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } };
// aes_128_cbc_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 236
static const mbedtls_cipher_info_t aes_128_cbc_info;
// aes_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 181
static const mbedtls_cipher_base_t aes_info;
// aes_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 181
static const mbedtls_cipher_base_t aes_info={ .cipher=/*enum*/MBEDTLS_CIPHER_ID_AES, .ecb_func=aes_crypt_ecb_wrap,
    .cbc_func=aes_crypt_cbc_wrap, .cfb_func=aes_crypt_cfb128_wrap,
    .ctr_func=aes_crypt_ctr_wrap, .setkey_enc_func=aes_setkey_enc_wrap,
    .setkey_dec_func=aes_setkey_dec_wrap,
    .ctx_alloc_func=aes_ctx_alloc,
    .ctx_free_func=aes_ctx_free };
// aes_128_cbc_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 236
static const mbedtls_cipher_info_t aes_128_cbc_info={ .type=/*enum*/MBEDTLS_CIPHER_AES_128_CBC, .mode=/*enum*/MBEDTLS_MODE_CBC,
    .key_bitlen=128u, .name="AES-128-CBC",
    .iv_size=16u, .flags=0, .block_size=16u,
    .base=&aes_info };
// aes_128_cfb128_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 271
static const mbedtls_cipher_info_t aes_128_cfb128_info;
// aes_128_cfb128_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 271
static const mbedtls_cipher_info_t aes_128_cfb128_info={ .type=/*enum*/MBEDTLS_CIPHER_AES_128_CFB128, .mode=/*enum*/MBEDTLS_MODE_CFB,
    .key_bitlen=128u, .name="AES-128-CFB128",
    .iv_size=16u, .flags=0,
    .block_size=16u, .base=&aes_info };
// aes_128_ctr_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 306
static const mbedtls_cipher_info_t aes_128_ctr_info;
// aes_128_ctr_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 306
static const mbedtls_cipher_info_t aes_128_ctr_info={ .type=/*enum*/MBEDTLS_CIPHER_AES_128_CTR, .mode=/*enum*/MBEDTLS_MODE_CTR,
    .key_bitlen=128u, .name="AES-128-CTR",
    .iv_size=16u, .flags=0, .block_size=16u,
    .base=&aes_info };
// aes_128_ecb_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 202
static const mbedtls_cipher_info_t aes_128_ecb_info;
// aes_128_ecb_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 202
static const mbedtls_cipher_info_t aes_128_ecb_info={ .type=/*enum*/MBEDTLS_CIPHER_AES_128_ECB, .mode=/*enum*/MBEDTLS_MODE_ECB,
    .key_bitlen=128u, .name="AES-128-ECB",
    .iv_size=16u, .flags=0, .block_size=16u,
    .base=&aes_info };
// aes_128_gcm_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 369
static const mbedtls_cipher_info_t aes_128_gcm_info;
// gcm_aes_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 348
static const mbedtls_cipher_base_t gcm_aes_info;
// gcm_aes_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 348
static const mbedtls_cipher_base_t gcm_aes_info={ .cipher=/*enum*/MBEDTLS_CIPHER_ID_AES, .ecb_func=((signed int (*)(void *, mbedtls_operation_t, const unsigned char *, unsigned char *))NULL),
    .cbc_func=((signed int (*)(void *, mbedtls_operation_t, size_t, unsigned char *, const unsigned char *, unsigned char *))NULL),
    .cfb_func=((signed int (*)(void *, mbedtls_operation_t, size_t, size_t *, unsigned char *, const unsigned char *, unsigned char *))NULL),
    .ctr_func=((signed int (*)(void *, size_t, size_t *, unsigned char *, unsigned char *, const unsigned char *, unsigned char *))NULL),
    .setkey_enc_func=gcm_aes_setkey_wrap,
    .setkey_dec_func=gcm_aes_setkey_wrap,
    .ctx_alloc_func=gcm_ctx_alloc,
    .ctx_free_func=gcm_ctx_free };
// aes_128_gcm_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 369
static const mbedtls_cipher_info_t aes_128_gcm_info={ .type=/*enum*/MBEDTLS_CIPHER_AES_128_GCM, .mode=/*enum*/MBEDTLS_MODE_GCM,
    .key_bitlen=128u, .name="AES-128-GCM",
    .iv_size=12u, .flags=0x1, .block_size=16u,
    .base=&gcm_aes_info };
// aes_192_cbc_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 247
static const mbedtls_cipher_info_t aes_192_cbc_info;
// aes_192_cbc_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 247
static const mbedtls_cipher_info_t aes_192_cbc_info={ .type=/*enum*/MBEDTLS_CIPHER_AES_192_CBC, .mode=/*enum*/MBEDTLS_MODE_CBC,
    .key_bitlen=192u, .name="AES-192-CBC",
    .iv_size=16u, .flags=0, .block_size=16u,
    .base=&aes_info };
// aes_192_cfb128_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 282
static const mbedtls_cipher_info_t aes_192_cfb128_info;
// aes_192_cfb128_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 282
static const mbedtls_cipher_info_t aes_192_cfb128_info={ .type=/*enum*/MBEDTLS_CIPHER_AES_192_CFB128, .mode=/*enum*/MBEDTLS_MODE_CFB,
    .key_bitlen=192u, .name="AES-192-CFB128",
    .iv_size=16u, .flags=0,
    .block_size=16u, .base=&aes_info };
// aes_192_ctr_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 317
static const mbedtls_cipher_info_t aes_192_ctr_info;
// aes_192_ctr_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 317
static const mbedtls_cipher_info_t aes_192_ctr_info={ .type=/*enum*/MBEDTLS_CIPHER_AES_192_CTR, .mode=/*enum*/MBEDTLS_MODE_CTR,
    .key_bitlen=192u, .name="AES-192-CTR",
    .iv_size=16u, .flags=0, .block_size=16u,
    .base=&aes_info };
// aes_192_ecb_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 213
static const mbedtls_cipher_info_t aes_192_ecb_info;
// aes_192_ecb_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 213
static const mbedtls_cipher_info_t aes_192_ecb_info={ .type=/*enum*/MBEDTLS_CIPHER_AES_192_ECB, .mode=/*enum*/MBEDTLS_MODE_ECB,
    .key_bitlen=192u, .name="AES-192-ECB",
    .iv_size=16u, .flags=0, .block_size=16u,
    .base=&aes_info };
// aes_192_gcm_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 380
static const mbedtls_cipher_info_t aes_192_gcm_info;
// aes_192_gcm_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 380
static const mbedtls_cipher_info_t aes_192_gcm_info={ .type=/*enum*/MBEDTLS_CIPHER_AES_192_GCM, .mode=/*enum*/MBEDTLS_MODE_GCM,
    .key_bitlen=192u, .name="AES-192-GCM",
    .iv_size=12u, .flags=0x1, .block_size=16u,
    .base=&gcm_aes_info };
// aes_256_cbc_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 258
static const mbedtls_cipher_info_t aes_256_cbc_info;
// aes_256_cbc_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 258
static const mbedtls_cipher_info_t aes_256_cbc_info={ .type=/*enum*/MBEDTLS_CIPHER_AES_256_CBC, .mode=/*enum*/MBEDTLS_MODE_CBC,
    .key_bitlen=256u, .name="AES-256-CBC",
    .iv_size=16u, .flags=0, .block_size=16u,
    .base=&aes_info };
// aes_256_cfb128_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 293
static const mbedtls_cipher_info_t aes_256_cfb128_info;
// aes_256_cfb128_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 293
static const mbedtls_cipher_info_t aes_256_cfb128_info={ .type=/*enum*/MBEDTLS_CIPHER_AES_256_CFB128, .mode=/*enum*/MBEDTLS_MODE_CFB,
    .key_bitlen=256u, .name="AES-256-CFB128",
    .iv_size=16u, .flags=0,
    .block_size=16u, .base=&aes_info };
// aes_256_ctr_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 328
static const mbedtls_cipher_info_t aes_256_ctr_info;
// aes_256_ctr_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 328
static const mbedtls_cipher_info_t aes_256_ctr_info={ .type=/*enum*/MBEDTLS_CIPHER_AES_256_CTR, .mode=/*enum*/MBEDTLS_MODE_CTR,
    .key_bitlen=256u, .name="AES-256-CTR",
    .iv_size=16u, .flags=0, .block_size=16u,
    .base=&aes_info };
// aes_256_ecb_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 224
static const mbedtls_cipher_info_t aes_256_ecb_info;
// aes_256_ecb_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 224
static const mbedtls_cipher_info_t aes_256_ecb_info={ .type=/*enum*/MBEDTLS_CIPHER_AES_256_ECB, .mode=/*enum*/MBEDTLS_MODE_ECB,
    .key_bitlen=256u, .name="AES-256-ECB",
    .iv_size=16u, .flags=0, .block_size=16u,
    .base=&aes_info };
// aes_256_gcm_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 391
static const mbedtls_cipher_info_t aes_256_gcm_info;
// aes_256_gcm_info
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 391
static const mbedtls_cipher_info_t aes_256_gcm_info={ .type=/*enum*/MBEDTLS_CIPHER_AES_256_GCM, .mode=/*enum*/MBEDTLS_MODE_GCM,
    .key_bitlen=256u, .name="AES-256-GCM",
    .iv_size=12u, .flags=0x1, .block_size=16u,
    .base=&gcm_aes_info };
// aes_test_cbc_dec
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 1135
static const unsigned char aes_test_cbc_dec[3ll][16ll]={ { 250, 202, 55, 224, 176, 200, 83, 115, 223, 112, 110, 115, 247, 201, 175, 134 },
    { 93, 246, 120, 221, 23, 186, 78, 117, 182, 23, 104, 198, 173, 239, 124, 123 },
    { 72, 4, 225, 129, 143, 230, 41, 117, 25, 163, 232, 140, 87, 49, 4, 19 } };
// aes_test_cbc_enc
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 1145
static const unsigned char aes_test_cbc_enc[3ll][16ll]={ { 138, 5, 252, 94, 9, 90, 244, 132, 138, 8, 211, 40, 211, 104, 142, 61 },
    { 123, 217, 102, 213, 58, 216, 193, 187, 133, 210, 173, 250, 232, 123, 177, 4 },
    { 254, 60, 83, 101, 62, 47, 69, 181, 111, 205, 136, 178, 204, 137, 143, 240 } };
// aes_test_cfb128_ct
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 1193
static const unsigned char aes_test_cfb128_ct[3ll][64ll]={ { 59, 63, 217, 46, 183, 45, 173, 32, 51, 52, 73, 248, 232, 60, 251, 74, 200, 166, 69, 55, 160, 179, 169, 63, 205, 227, 205, 173, 159, 28, 229, 139, 38, 117, 31, 103, 163, 203, 177, 64, 177, 128, 140, 241, 135, 164, 244, 223, 192, 75, 5, 53, 124, 93, 28, 14, 234, 196, 198, 111, 159, 247, 242, 230 },
    { 205, 200, 13, 111, 221, 241, 140, 171, 52, 194, 89, 9, 201, 154, 65, 116, 103, 206, 127, 127, 129, 23, 54, 33, 150, 26, 43, 112, 23, 29, 61, 122, 46, 30, 138, 29, 213, 155, 136, 177, 200, 230, 15, 237, 30, 250, 196, 201, 192, 95, 159, 156, 169, 131, 79, 160, 66, 174, 143, 186, 88, 75, 9, 255 },
    { 220, 126, 132, 191, 218, 121, 22, 75, 126, 205, 132, 134, 152, 93, 56, 96, 57, 255, 237, 20, 59, 40, 177, 200, 50, 17, 60, 99, 49, 229, 64, 123, 223, 16, 19, 36, 21, 229, 75, 146, 161, 62, 208, 168, 38, 122, 226, 249, 117, 163, 133, 116, 26, 185, 206, 248, 32, 49, 98, 61, 85, 177, 228, 113 } };
// aes_test_cfb128_iv
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 1175
static const unsigned char aes_test_cfb128_iv[16ll]={ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
// aes_test_cfb128_key
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 1162
static const unsigned char aes_test_cfb128_key[3ll][32ll]={ { 43, 126, 21, 22, 40, 174, 210, 166, 171, 247, 21, 136, 9, 207, 79, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 142, 115, 176, 247, 218, 14, 100, 82, 200, 16, 243, 43, 128, 144, 121, 229, 98, 248, 234, 210, 82, 44, 107, 123, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 96, 61, 235, 16, 21, 202, 113, 190, 43, 115, 174, 240, 133, 125, 119, 129, 31, 53, 44, 7, 59, 97, 8, 215, 45, 152, 16, 163, 9, 20, 223, 244 } };
// aes_test_cfb128_pt
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 1181
static const unsigned char aes_test_cfb128_pt[64ll]={ 107, 193, 190, 226, 46, 64, 159, 150, 233, 61, 126, 17, 115, 147, 23, 42, 174, 45, 138, 87, 30, 3, 172, 156, 158, 183, 111, 172, 69, 175, 142, 81, 48, 200, 28, 70, 163, 92, 228, 17, 229, 251, 193, 25, 26, 10, 82, 239, 246, 159, 36, 69, 223, 79, 155, 23, 173, 43, 65, 123, 230, 108, 55, 16 };
// aes_test_ctr_ct
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 1266
static const unsigned char aes_test_ctr_ct[3ll][48ll]={ { 228, 9, 93, 79, 183, 167, 179, 121, 45, 97, 117, 163, 38, 19, 17, 184, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 81, 4, 161, 6, 22, 138, 114, 217, 121, 13, 65, 238, 142, 218, 211, 136, 235, 46, 30, 252, 70, 218, 87, 200, 252, 230, 48, 223, 145, 65, 190, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 193, 207, 72, 168, 159, 47, 253, 217, 207, 70, 82, 233, 239, 219, 114, 215, 69, 64, 164, 43, 222, 109, 120, 54, 213, 154, 92, 234, 174, 243, 16, 83, 37, 178, 7, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } };
// aes_test_ctr_key
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 1229
static const unsigned char aes_test_ctr_key[3ll][16ll]={ { 174, 104, 82, 248, 18, 16, 103, 204, 75, 247, 165, 118, 85, 119, 243, 158 },
    { 126, 36, 6, 120, 23, 250, 224, 215, 67, 214, 206, 31, 50, 83, 145, 99 },
    { 118, 145, 190, 3, 94, 80, 32, 168, 172, 110, 97, 133, 41, 249, 160, 220 } };
// aes_test_ctr_len
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 1281
static const signed int aes_test_ctr_len[3ll]={ 16, 32, 36 };
// aes_test_ctr_nonce_counter
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 1239
static const unsigned char aes_test_ctr_nonce_counter[3ll][16ll]={ { 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
    { 0, 108, 182, 219, 192, 84, 59, 89, 218, 72, 217, 11, 0, 0, 0, 1 },
    { 0, 224, 1, 123, 39, 119, 127, 63, 74, 23, 134, 240, 0, 0, 0, 1 } };
// aes_test_ctr_pt
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 1249
static const unsigned char aes_test_ctr_pt[3ll][48ll]={ { 83, 105, 110, 103, 108, 101, 32, 98, 108, 111, 99, 107, 32, 109, 115, 103, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } };
// aes_test_ecb_dec
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 1114
static const unsigned char aes_test_ecb_dec[3ll][16ll]={ { 68, 65, 106, 194, 209, 245, 60, 88, 51, 3, 145, 126, 107, 233, 235, 224 },
    { 72, 227, 30, 158, 37, 103, 24, 242, 146, 41, 49, 156, 25, 241, 91, 164 },
    { 5, 140, 207, 253, 187, 203, 56, 45, 31, 111, 86, 88, 93, 138, 74, 222 } };
// aes_test_ecb_enc
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 1124
static const unsigned char aes_test_ecb_enc[3ll][16ll]={ { 195, 76, 5, 44, 192, 218, 141, 115, 69, 26, 254, 95, 3, 190, 41, 127 },
    { 243, 246, 117, 42, 232, 215, 131, 17, 56, 240, 65, 86, 6, 49, 177, 20 },
    { 139, 121, 238, 204, 147, 160, 238, 93, 255, 48, 180, 234, 33, 99, 109, 164 } };
// astOTA_Files
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 346
static OTA_FileContext_t astOTA_Files[1ll];
// bOTA_Singleton_SelfTestMode
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 350
static uint8_t bOTA_Singleton_SelfTestMode=0;
// base64_dec_map
// file ..\..\..\..\lib\third_party\mbedtls\library\base64.c line 55
static const unsigned char base64_dec_map[128ll]={ 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 62, 127, 127, 127, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 127, 127, 127, 64, 127, 127, 127, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 127, 127, 127, 127, 127, 127, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 127, 127, 127, 127, 127 };
// base64_enc_map
// file ..\..\..\..\lib\third_party\mbedtls\library\base64.c line 44
static const unsigned char base64_enc_map[64ll]={ 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47 };
// base64_test_dec
// file ..\..\..\..\lib\third_party\mbedtls\library\base64.c line 232
static const unsigned char base64_test_dec[64ll]={ 36, 72, 110, 86, 135, 98, 90, 189, 191, 23, 217, 162, 196, 23, 26, 1, 148, 237, 143, 30, 17, 179, 215, 9, 12, 182, 233, 16, 111, 34, 238, 19, 202, 179, 7, 5, 118, 201, 250, 49, 108, 8, 52, 255, 141, 194, 108, 56, 0, 67, 233, 84, 151, 175, 80, 75, 209, 65, 186, 149, 49, 90, 11, 151 };
// base64_test_enc
// file ..\..\..\..\lib\third_party\mbedtls\library\base64.c line 244
static const unsigned char base64_test_enc[89ll]={ 74, 69, 104, 117, 86, 111, 100, 105, 87, 114, 50, 47, 70, 57, 109, 105, 120, 66, 99, 97, 65, 90, 84, 116, 106, 120, 52, 82, 115, 57, 99, 74, 68, 76, 98, 112, 69, 71, 56, 105, 55, 104, 80, 75, 115, 119, 99, 70, 100, 115, 110, 54, 77, 87, 119, 73, 78, 80, 43, 78, 119, 109, 119, 52, 65, 69, 80, 112, 86, 74, 101, 118, 85, 69, 118, 82, 81, 98, 113, 86, 77, 86, 111, 76, 108, 119, 61, 61, 0 };
// cErrorBuffer
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 110
static char cErrorBuffer[256ll];
// cRxBuffers
// file ..\..\..\common\tcp\aws_tcp_echo_client_single_task.c line 135
static char cRxBuffers[1ll][2000ll];
// cTxBuffers
// file ..\..\..\common\tcp\aws_tcp_echo_client_single_task.c line 134
static char cTxBuffers[1ll][2000ll];
// cUserName
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 228
static const char cUserName[52ll]={ '?', 'S', 'D', 'K', '=', 'A', 'm', 'a', 'z', 'o', 'n', 'F', 'r', 'e', 'e', 'R', 'T', 'O', 'S', '&', 'V', 'e', 'r', 's', 'i', 'o', 'n', '=', 'V', '1', '0', '.', '0', '.', '1', '&', 'P', 'l', 'a', 't', 'f', 'o', 'r', 'm', '=', 'W', 'i', 'n', 'S', 'i', 'm', 0 };
// ciphersuite_definitions
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_ciphersuites.c line 267
static const mbedtls_ssl_ciphersuite_t ciphersuite_definitions[9ll]={ { .id=0xC009, .name="TLS-ECDHE-ECDSA-WITH-AES-128-CBC-SHA", .cipher=/*enum*/MBEDTLS_CIPHER_AES_128_CBC,
    .mac=/*enum*/MBEDTLS_MD_SHA1,
    .key_exchange=/*enum*/MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA, .min_major_ver=3,
    .min_minor_ver=1, .max_major_ver=3, .max_minor_ver=3,
    .flags=0 },
    { .id=0xC00A, .name="TLS-ECDHE-ECDSA-WITH-AES-256-CBC-SHA", .cipher=/*enum*/MBEDTLS_CIPHER_AES_256_CBC,
    .mac=/*enum*/MBEDTLS_MD_SHA1,
    .key_exchange=/*enum*/MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA, .min_major_ver=3,
    .min_minor_ver=1, .max_major_ver=3, .max_minor_ver=3,
    .flags=0 },
    { .id=0xC023, .name="TLS-ECDHE-ECDSA-WITH-AES-128-CBC-SHA256", .cipher=/*enum*/MBEDTLS_CIPHER_AES_128_CBC,
    .mac=/*enum*/MBEDTLS_MD_SHA256,
    .key_exchange=/*enum*/MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA, .min_major_ver=3,
    .min_minor_ver=3, .max_major_ver=3, .max_minor_ver=3,
    .flags=0 },
    { .id=0xC02B, .name="TLS-ECDHE-ECDSA-WITH-AES-128-GCM-SHA256", .cipher=/*enum*/MBEDTLS_CIPHER_AES_128_GCM,
    .mac=/*enum*/MBEDTLS_MD_SHA256,
    .key_exchange=/*enum*/MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA, .min_major_ver=3,
    .min_minor_ver=3, .max_major_ver=3, .max_minor_ver=3,
    .flags=0 },
    { .id=0xC013, .name="TLS-ECDHE-RSA-WITH-AES-128-CBC-SHA", .cipher=/*enum*/MBEDTLS_CIPHER_AES_128_CBC,
    .mac=/*enum*/MBEDTLS_MD_SHA1,
    .key_exchange=/*enum*/MBEDTLS_KEY_EXCHANGE_ECDHE_RSA, .min_major_ver=3,
    .min_minor_ver=1, .max_major_ver=3, .max_minor_ver=3,
    .flags=0 },
    { .id=0xC014, .name="TLS-ECDHE-RSA-WITH-AES-256-CBC-SHA", .cipher=/*enum*/MBEDTLS_CIPHER_AES_256_CBC,
    .mac=/*enum*/MBEDTLS_MD_SHA1,
    .key_exchange=/*enum*/MBEDTLS_KEY_EXCHANGE_ECDHE_RSA, .min_major_ver=3,
    .min_minor_ver=1, .max_major_ver=3, .max_minor_ver=3,
    .flags=0 },
    { .id=0xC027, .name="TLS-ECDHE-RSA-WITH-AES-128-CBC-SHA256", .cipher=/*enum*/MBEDTLS_CIPHER_AES_128_CBC,
    .mac=/*enum*/MBEDTLS_MD_SHA256,
    .key_exchange=/*enum*/MBEDTLS_KEY_EXCHANGE_ECDHE_RSA, .min_major_ver=3,
    .min_minor_ver=3, .max_major_ver=3, .max_minor_ver=3,
    .flags=0 },
    { .id=0xC02F, .name="TLS-ECDHE-RSA-WITH-AES-128-GCM-SHA256", .cipher=/*enum*/MBEDTLS_CIPHER_AES_128_GCM,
    .mac=/*enum*/MBEDTLS_MD_SHA256,
    .key_exchange=/*enum*/MBEDTLS_KEY_EXCHANGE_ECDHE_RSA, .min_major_ver=3,
    .min_minor_ver=3, .max_major_ver=3, .max_minor_ver=3,
    .flags=0 },
    { .id=0, .name="", .cipher=/*enum*/MBEDTLS_CIPHER_NONE, .mac=/*enum*/MBEDTLS_MD_NONE,
    .key_exchange=/*enum*/MBEDTLS_KEY_EXCHANGE_NONE, .min_major_ver=0,
    .min_minor_ver=0, .max_major_ver=0, .max_minor_ver=0,
    .flags=0 } };
// ciphersuite_preference
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_ciphersuites.c line 55
static const signed int ciphersuite_preference[163ll]={ 0xC02C, 0xC030, 0x9F, 0xC0AD, 0xC09F, 0xC024, 0xC028, 0x6B, 0xC00A, 0xC014, 0x39, 0xC0AF, 0xC0A3, 0xC087, 0xC08B, 0xC07D, 0xC073, 0xC077, 0xC4, 0x88, 0xC02B, 0xC02F, 0x9E, 0xC0AC, 0xC09E, 0xC023, 0xC027, 0x67, 0xC009, 0xC013, 0x33, 0xC0AE, 0xC0A2, 0xC086, 0xC08A, 0xC07C, 0xC072, 0xC076, 0xBE, 0x45, 0xC008, 0xC012, 0x16, 0xAB, 0xC0A7, 0xC038, 0xB3, 0xC036, 0x91, 0xC091, 0xC09B, 0xC097, 0xC0AB, 0xAA, 0xC0A6, 0xC037, 0xB2, 0xC035, 0x90, 0xC090, 0xC096, 0xC09A, 0xC0AA, 0xC034, 0x8F, 0xC0FF, 0x9D, 0xC09D, 0x3D, 0x35, 0xC032, 0xC02A, 0xC00F, 0xC02E, 0xC026, 0xC005, 0xC0A1, 0xC07B, 0xC0, 0x84, 0xC08D, 0xC079, 0xC089, 0xC075, 0x9C, 0xC09C, 0x3C, 0x2F, 0xC031, 0xC029, 0xC00E, 0xC02D, 0xC025, 0xC004, 0xC0A0, 0xC07A, 0xBA, 0x41, 0xC08C, 0xC078, 0xC088, 0xC074, 0xA, 0xC00D, 0xC003, 0xAD, 0xB7, 0x95, 0xC093, 0xC099, 0xAC, 0xB6, 0x94, 0xC092, 0xC098, 0x93, 0xA9, 0xC0A5, 0xAF, 0x8D, 0xC08F, 0xC095, 0xC0A9, 0xA8, 0xC0A4, 0xAE, 0x8C, 0xC08E, 0xC094, 0xC0A8, 0x8B, 0xC007, 0xC011, 0xC033, 0x8E, 0x5, 0x4, 0xC00C, 0xC002, 0x92, 0x8A, 0x15, 0x9, 0xC006, 0xC010, 0xC03B, 0xC03A, 0xC039, 0xB5, 0xB4, 0x2D, 0x3B, 0x2, 0x1, 0xC00B, 0xC001, 0xB9, 0xB8, 0x2E, 0xB1, 0xB0, 0x2C, 0 };
// clientcredentialCLIENT_CERTIFICATE_LENGTH
// file ..\..\..\..\demos\common\include\aws_clientcredential.h line 76
static const uint32_t clientcredentialCLIENT_CERTIFICATE_LENGTH=(const uint32_t)sizeof(const char [31ll]) /*31u*/ ;
// clientcredentialCLIENT_CERTIFICATE_LENGTH$link1
// file ..\..\..\..\demos\common\include\aws_clientcredential.h line 76
static const uint32_t clientcredentialCLIENT_CERTIFICATE_LENGTH$link1=(const uint32_t)sizeof(const char [31ll]) /*31u*/ ;
// clientcredentialCLIENT_CERTIFICATE_PEM
// file d:\tuttle\freertos\demos\common\include\aws_clientcredential_keys.h line 9
static const char clientcredentialCLIENT_CERTIFICATE_PEM[31ll]={ 'P', 'a', 's', 't', 'e', ' ', 'c', 'l', 'i', 'e', 'n', 't', ' ', 'c', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', ' ', 'h', 'e', 'r', 'e', '.', 0 };
// clientcredentialCLIENT_CERTIFICATE_PEM$link1
// file d:\tuttle\freertos\demos\common\include\aws_clientcredential_keys.h line 9
static const char clientcredentialCLIENT_CERTIFICATE_PEM$link1[31ll]={ 'P', 'a', 's', 't', 'e', ' ', 'c', 'l', 'i', 'e', 'n', 't', ' ', 'c', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', ' ', 'h', 'e', 'r', 'e', '.', 0 };
// clientcredentialCLIENT_PRIVATE_KEY_LENGTH
// file ..\..\..\..\demos\common\include\aws_clientcredential.h line 82
static const uint32_t clientcredentialCLIENT_PRIVATE_KEY_LENGTH=(const uint32_t)sizeof(const char [31ll]) /*31u*/ ;
// clientcredentialCLIENT_PRIVATE_KEY_LENGTH$link1
// file ..\..\..\..\demos\common\include\aws_clientcredential.h line 82
static const uint32_t clientcredentialCLIENT_PRIVATE_KEY_LENGTH$link1=(const uint32_t)sizeof(const char [31ll]) /*31u*/ ;
// clientcredentialCLIENT_PRIVATE_KEY_PEM
// file d:\tuttle\freertos\demos\common\include\aws_clientcredential_keys.h line 37
static const char clientcredentialCLIENT_PRIVATE_KEY_PEM[31ll]={ 'P', 'a', 's', 't', 'e', ' ', 'c', 'l', 'i', 'e', 'n', 't', ' ', 'p', 'r', 'i', 'v', 'a', 't', 'e', ' ', 'k', 'e', 'y', ' ', 'h', 'e', 'r', 'e', '.', 0 };
// clientcredentialCLIENT_PRIVATE_KEY_PEM$link1
// file d:\tuttle\freertos\demos\common\include\aws_clientcredential_keys.h line 37
static const char clientcredentialCLIENT_PRIVATE_KEY_PEM$link1[31ll]={ 'P', 'a', 's', 't', 'e', ' ', 'c', 'l', 'i', 'e', 'n', 't', ' ', 'p', 'r', 'i', 'v', 'a', 't', 'e', ' ', 'k', 'e', 'y', ' ', 'h', 'e', 'r', 'e', '.', 0 };
// clientcredentialJITR_DEVICE_CERTIFICATE_AUTHORITY_PEM
// file d:\tuttle\freertos\demos\common\include\aws_clientcredential_keys.h line 27
static const char *clientcredentialJITR_DEVICE_CERTIFICATE_AUTHORITY_PEM=((const char *)NULL);
// clientcredentialMQTT_BROKER_ENDPOINT
// file ..\..\..\..\demos\common\include\aws_clientcredential.h line 38
static const char clientcredentialMQTT_BROKER_ENDPOINT[36ll]={ 'P', 'a', 's', 't', 'e', ' ', 'A', 'W', 'S', ' ', 'I', 'o', 'T', ' ', 'B', 'r', 'o', 'k', 'e', 'r', ' ', 'e', 'n', 'd', 'p', 'o', 'i', 'n', 't', ' ', 'h', 'e', 'r', 'e', '.', 0 };
// clientcredentialMQTT_BROKER_ENDPOINT$link1
// file ..\..\..\..\demos\common\include\aws_clientcredential.h line 38
static const char clientcredentialMQTT_BROKER_ENDPOINT$link1[36ll]={ 'P', 'a', 's', 't', 'e', ' ', 'A', 'W', 'S', ' ', 'I', 'o', 'T', ' ', 'B', 'r', 'o', 'k', 'e', 'r', ' ', 'e', 'n', 'd', 'p', 'o', 'i', 'n', 't', ' ', 'h', 'e', 'r', 'e', '.', 0 };
// clientcredentialMQTT_BROKER_ENDPOINT$link2
// file ..\..\..\..\demos\common\include\aws_clientcredential.h line 38
static const char clientcredentialMQTT_BROKER_ENDPOINT$link2[36ll]={ 'P', 'a', 's', 't', 'e', ' ', 'A', 'W', 'S', ' ', 'I', 'o', 'T', ' ', 'B', 'r', 'o', 'k', 'e', 'r', ' ', 'e', 'n', 'd', 'p', 'o', 'i', 'n', 't', ' ', 'h', 'e', 'r', 'e', '.', 0 };
// clientcredentialMQTT_BROKER_ENDPOINT$link3
// file ..\..\..\..\demos\common\include\aws_clientcredential.h line 38
static const char clientcredentialMQTT_BROKER_ENDPOINT$link3[36ll]={ 'P', 'a', 's', 't', 'e', ' ', 'A', 'W', 'S', ' ', 'I', 'o', 'T', ' ', 'B', 'r', 'o', 'k', 'e', 'r', ' ', 'e', 'n', 'd', 'p', 'o', 'i', 'n', 't', ' ', 'h', 'e', 'r', 'e', '.', 0 };
// clientcredentialMQTT_BROKER_ENDPOINT$link4
// file ..\..\..\..\demos\common\include\aws_clientcredential.h line 38
static const char clientcredentialMQTT_BROKER_ENDPOINT$link4[36ll]={ 'P', 'a', 's', 't', 'e', ' ', 'A', 'W', 'S', ' ', 'I', 'o', 'T', ' ', 'B', 'r', 'o', 'k', 'e', 'r', ' ', 'e', 'n', 'd', 'p', 'o', 'i', 'n', 't', ' ', 'h', 'e', 'r', 'e', '.', 0 };
// ct
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 595
static const unsigned char ct[18ll][64ll]={ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 3, 136, 218, 206, 96, 182, 163, 146, 243, 40, 194, 185, 113, 178, 254, 120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 66, 131, 30, 194, 33, 119, 116, 36, 75, 114, 33, 183, 132, 208, 212, 156, 227, 170, 33, 47, 44, 2, 164, 224, 53, 193, 126, 35, 41, 172, 161, 46, 33, 213, 20, 178, 84, 102, 147, 28, 125, 143, 106, 90, 172, 132, 170, 5, 27, 163, 11, 57, 106, 10, 172, 151, 61, 88, 224, 145, 71, 63, 89, 133 },
    { 66, 131, 30, 194, 33, 119, 116, 36, 75, 114, 33, 183, 132, 208, 212, 156, 227, 170, 33, 47, 44, 2, 164, 224, 53, 193, 126, 35, 41, 172, 161, 46, 33, 213, 20, 178, 84, 102, 147, 28, 125, 143, 106, 90, 172, 132, 170, 5, 27, 163, 11, 57, 106, 10, 172, 151, 61, 88, 224, 145, 0, 0, 0, 0 },
    { 97, 53, 59, 76, 40, 6, 147, 74, 119, 127, 245, 31, 162, 42, 71, 85, 105, 155, 42, 113, 79, 205, 198, 248, 55, 102, 229, 249, 123, 108, 116, 35, 115, 128, 105, 0, 228, 159, 36, 178, 43, 9, 117, 68, 212, 137, 107, 66, 73, 137, 181, 225, 235, 172, 15, 7, 194, 63, 69, 152, 0, 0, 0, 0 },
    { 140, 226, 73, 152, 98, 86, 21, 182, 3, 160, 51, 172, 161, 63, 184, 148, 190, 145, 18, 165, 195, 162, 17, 168, 186, 38, 42, 60, 202, 126, 44, 167, 1, 228, 169, 164, 251, 164, 60, 144, 204, 220, 178, 129, 212, 140, 124, 111, 214, 40, 117, 210, 172, 164, 23, 3, 76, 52, 174, 229, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 152, 231, 36, 124, 7, 240, 254, 65, 28, 38, 126, 67, 132, 176, 246, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 57, 128, 202, 11, 60, 0, 232, 65, 235, 6, 250, 196, 135, 42, 39, 87, 133, 158, 28, 234, 166, 239, 217, 132, 98, 133, 147, 180, 12, 161, 225, 156, 125, 119, 61, 0, 193, 68, 197, 37, 172, 97, 157, 24, 200, 74, 63, 71, 24, 226, 68, 139, 47, 227, 36, 217, 204, 218, 39, 16, 172, 173, 226, 86 },
    { 57, 128, 202, 11, 60, 0, 232, 65, 235, 6, 250, 196, 135, 42, 39, 87, 133, 158, 28, 234, 166, 239, 217, 132, 98, 133, 147, 180, 12, 161, 225, 156, 125, 119, 61, 0, 193, 68, 197, 37, 172, 97, 157, 24, 200, 74, 63, 71, 24, 226, 68, 139, 47, 227, 36, 217, 204, 218, 39, 16, 0, 0, 0, 0 },
    { 15, 16, 245, 153, 174, 20, 161, 84, 237, 36, 179, 110, 37, 50, 77, 184, 197, 102, 99, 46, 242, 187, 179, 79, 131, 71, 40, 15, 196, 80, 112, 87, 253, 220, 41, 223, 154, 71, 31, 117, 198, 101, 65, 212, 212, 218, 209, 201, 233, 58, 25, 165, 142, 139, 71, 63, 160, 240, 98, 247, 0, 0, 0, 0 },
    { 210, 126, 136, 104, 28, 227, 36, 60, 72, 48, 22, 90, 143, 220, 249, 255, 29, 233, 161, 216, 230, 180, 71, 239, 110, 247, 183, 152, 40, 102, 110, 69, 129, 231, 144, 18, 175, 52, 221, 217, 226, 240, 55, 88, 155, 41, 45, 179, 230, 124, 3, 103, 69, 250, 34, 231, 233, 183, 55, 59, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 206, 167, 64, 61, 77, 96, 107, 110, 7, 78, 197, 211, 186, 243, 157, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 82, 45, 193, 240, 153, 86, 125, 7, 244, 127, 55, 163, 42, 132, 66, 125, 100, 58, 140, 220, 191, 229, 192, 201, 117, 152, 162, 189, 37, 85, 209, 170, 140, 176, 142, 72, 89, 13, 187, 61, 167, 176, 139, 16, 86, 130, 136, 56, 197, 246, 30, 99, 147, 186, 122, 10, 188, 201, 246, 98, 137, 128, 21, 173 },
    { 82, 45, 193, 240, 153, 86, 125, 7, 244, 127, 55, 163, 42, 132, 66, 125, 100, 58, 140, 220, 191, 229, 192, 201, 117, 152, 162, 189, 37, 85, 209, 170, 140, 176, 142, 72, 89, 13, 187, 61, 167, 176, 139, 16, 86, 130, 136, 56, 197, 246, 30, 99, 147, 186, 122, 10, 188, 201, 246, 98, 0, 0, 0, 0 },
    { 195, 118, 45, 241, 202, 120, 125, 50, 174, 71, 193, 59, 241, 152, 68, 203, 175, 26, 225, 77, 11, 151, 106, 250, 197, 47, 247, 215, 155, 186, 157, 224, 254, 181, 130, 211, 57, 52, 164, 240, 149, 76, 194, 54, 59, 199, 63, 120, 98, 172, 67, 14, 100, 171, 228, 153, 244, 124, 155, 31, 0, 0, 0, 0 },
    { 90, 141, 239, 47, 12, 158, 83, 241, 247, 93, 120, 83, 101, 158, 42, 32, 238, 178, 178, 42, 175, 222, 100, 25, 160, 88, 171, 79, 111, 116, 107, 244, 15, 192, 195, 183, 128, 242, 68, 69, 45, 163, 235, 241, 197, 216, 44, 222, 162, 65, 137, 151, 32, 14, 248, 46, 68, 174, 126, 63, 0, 0, 0, 0 } };
// dbl_count
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 86
static unsigned long int dbl_count;
// eOTA_AgentState
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 344
static OTA_State_t eOTA_AgentState=/*enum*/eOTA_AgentState_NotReady;
// eOTA_FinalImageState
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 349
static OTA_ImageState_t eOTA_FinalImageState=/*enum*/eOTA_ImageState_Unknown;
// ecp_supported_curves
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 130
static const mbedtls_ecp_curve_info ecp_supported_curves[2ll]={ { .grp_id=/*enum*/MBEDTLS_ECP_DP_SECP256R1, .tls_id=23,
    .bit_size=256, .name="secp256r1" },
    { .grp_id=/*enum*/MBEDTLS_ECP_DP_NONE, .tls_id=0, .bit_size=0,
    .name=((const char *)NULL) } };
// ecp_supported_grp_id
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 171
static mbedtls_ecp_group_id ecp_supported_grp_id[2ll];
// entropy_nopr
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 439
static const unsigned char entropy_nopr[40ll]={ 121, 52, 155, 191, 124, 221, 165, 121, 149, 87, 134, 102, 33, 201, 19, 131, 17, 70, 115, 58, 191, 140, 53, 200, 199, 33, 91, 91, 150, 196, 142, 155, 51, 140, 116, 227, 233, 157, 254, 223 };
// entropy_pr
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 423
static const unsigned char entropy_pr[56ll]={ 160, 201, 171, 88, 241, 226, 229, 164, 222, 62, 189, 79, 247, 62, 156, 91, 100, 239, 216, 202, 2, 140, 248, 17, 72, 165, 132, 254, 105, 171, 90, 238, 66, 170, 77, 66, 23, 96, 153, 212, 94, 19, 151, 220, 64, 77, 134, 163, 123, 245, 89, 84, 117, 105, 81, 228 };
// entropy_source_nopr
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 554
static const unsigned char entropy_source_nopr[64ll]={ 90, 25, 77, 94, 43, 49, 88, 20, 84, 222, 246, 117, 251, 121, 88, 254, 199, 219, 135, 62, 86, 137, 252, 157, 3, 33, 124, 104, 216, 3, 56, 32, 249, 230, 94, 4, 216, 86, 243, 169, 196, 74, 76, 189, 193, 208, 8, 70, 245, 152, 61, 119, 28, 27, 19, 126, 78, 15, 157, 142, 244, 9, 249, 46 };
// entropy_source_pr
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 540
static const unsigned char entropy_source_pr[96ll]={ 193, 128, 129, 166, 93, 68, 2, 22, 25, 179, 241, 128, 177, 201, 32, 2, 106, 84, 111, 12, 112, 129, 73, 139, 110, 166, 98, 82, 109, 81, 177, 203, 88, 59, 250, 213, 55, 95, 251, 201, 255, 70, 210, 25, 199, 34, 62, 149, 69, 157, 130, 225, 231, 34, 159, 99, 49, 105, 210, 107, 87, 71, 79, 163, 55, 201, 152, 28, 11, 251, 145, 49, 77, 85, 185, 233, 28, 90, 94, 228, 147, 146, 207, 197, 35, 18, 213, 86, 44, 74, 110, 255, 220, 16, 208, 104 };
// features
// file ..\..\..\..\lib\third_party\mbedtls\library\version_features.c line 34
static const char *features[62ll]={ "MBEDTLS_HAVE_ASM", "MBEDTLS_PLATFORM_MEMORY", "MBEDTLS_PLATFORM_SNPRINTF_ALT", "MBEDTLS_DEPRECATED_REMOVED", "MBEDTLS_ENTROPY_HARDWARE_ALT", "MBEDTLS_AES_ROM_TABLES", "MBEDTLS_CIPHER_MODE_CBC", "MBEDTLS_CIPHER_MODE_CFB", "MBEDTLS_CIPHER_MODE_CTR", "MBEDTLS_CIPHER_PADDING_PKCS7", "MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS", "MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN", "MBEDTLS_CIPHER_PADDING_ZEROS", "MBEDTLS_ECP_DP_SECP256R1_ENABLED", "MBEDTLS_ECP_NIST_OPTIM", "MBEDTLS_ECDSA_DETERMINISTIC", "MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED",
    "MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED",
    "MBEDTLS_GENPRIME", "MBEDTLS_NO_PLATFORM_ENTROPY", "MBEDTLS_ENTROPY_FORCE_SHA256", "MBEDTLS_PK_RSA_ALT_SUPPORT", "MBEDTLS_PKCS1_V15", "MBEDTLS_SELF_TEST", "MBEDTLS_SSL_ALL_ALERT_MESSAGES", "MBEDTLS_SSL_ENCRYPT_THEN_MAC", "MBEDTLS_SSL_EXTENDED_MASTER_SECRET", "MBEDTLS_SSL_MAX_FRAGMENT_LENGTH", "MBEDTLS_SSL_PROTO_TLS1_2", "MBEDTLS_SSL_ALPN", "MBEDTLS_SSL_SERVER_NAME_INDICATION", "MBEDTLS_VERSION_FEATURES", "MBEDTLS_X509_CHECK_KEY_USAGE", "MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE",
    "MBEDTLS_AES_C", "MBEDTLS_ASN1_PARSE_C", "MBEDTLS_ASN1_WRITE_C", "MBEDTLS_BASE64_C", "MBEDTLS_BIGNUM_C", "MBEDTLS_CIPHER_C", "MBEDTLS_CTR_DRBG_C", "MBEDTLS_ECDH_C", "MBEDTLS_ECDSA_C", "MBEDTLS_ECP_C", "MBEDTLS_ENTROPY_C", "MBEDTLS_GCM_C", "MBEDTLS_HMAC_DRBG_C", "MBEDTLS_MD_C", "MBEDTLS_OID_C", "MBEDTLS_PEM_PARSE_C", "MBEDTLS_PK_C", "MBEDTLS_PK_PARSE_C", "MBEDTLS_PLATFORM_C", "MBEDTLS_RSA_C", "MBEDTLS_SHA1_C", "MBEDTLS_SHA256_C", "MBEDTLS_SSL_CLI_C", "MBEDTLS_SSL_TLS_C", "MBEDTLS_VERSION_C", "MBEDTLS_X509_USE_C", "MBEDTLS_X509_CRT_PARSE_C", ((const char *)NULL) };
// gcd_pairs
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 2293
static const signed int gcd_pairs[3ll][3ll]={ { 693, 609, 21 }, { 1764, 868, 28 }, { 768454923, 542167814, 1 } };
// handle_of_last_logged_task
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 92
traceHandle handle_of_last_logged_task=0;
// heapMemUsage
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 141
static uint32_t heapMemUsage=0u;
// inExcludedTask
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 93
uint8_t inExcludedTask=0;
// init_hwtc_count
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2164
uint32_t init_hwtc_count;
// isPendingContextSwitch
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 63
int32_t isPendingContextSwitch=0;
// isrstack
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 62
static traceHandle isrstack[8ll];
// iv
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 545
static const unsigned char iv[6ll][64ll]={ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 202, 254, 186, 190, 250, 206, 219, 173, 222, 202, 248, 136, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 147, 19, 34, 93, 248, 132, 6, 229, 85, 144, 156, 90, 255, 82, 105, 170, 106, 122, 149, 56, 83, 79, 125, 161, 228, 195, 3, 210, 163, 24, 167, 40, 195, 192, 201, 81, 86, 128, 149, 57, 252, 240, 226, 66, 154, 107, 82, 84, 22, 174, 219, 245, 160, 222, 106, 87, 166, 55, 179, 155, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } };
// iv_index
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 542
static const signed int iv_index[6ll]={ 0, 0, 1, 1, 1, 2 };
// iv_len
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 539
static const size_t iv_len[6ll]={ 12ull, 12ull, 12ull, 12ull, 8ull, 60ull };
// key
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 527
static const unsigned char key[6ll][32ll]={ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 254, 255, 233, 146, 134, 101, 115, 28, 109, 106, 143, 148, 103, 48, 131, 8, 254, 255, 233, 146, 134, 101, 115, 28, 109, 106, 143, 148, 103, 48, 131, 8 },
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } };
// key_index
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 524
static const signed int key_index[6ll]={ 0, 0, 1, 1, 1, 1 };
// lShuttingDown
// file ..\..\..\common\tcp\aws_tcp_echo_client_separate_tasks.c line 109
int32_t lShuttingDown=0;
// last4
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 201
static const uint64_t last4[16ll]={ 0ull, 7200ull, 14400ull, 9312ull, 28800ull, 27808ull, 18624ull, 21728ull, 57600ull, 64800ull, 55616ull, 50528ull, 37248ull, 36256ull, 43456ull, 46560ull };
// last_timestamp
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 80
static uint32_t last_timestamp=0u;
// llInitialRunTimeCounterValue
// file ..\common\application_code\aws_run-time-stats-utils.c line 44
static signed long long int llInitialRunTimeCounterValue=0ll;
// llTicksPerHundedthMillisecond
// file ..\common\application_code\aws_run-time-stats-utils.c line 44
static signed long long int llTicksPerHundedthMillisecond=0ll;
// mbedtls_calloc
// file ..\..\..\..\lib\third_party\mbedtls\library\platform.c line 61
void * (*mbedtls_calloc)(size_t, size_t);
// mbedtls_calloc
// file ..\..\..\..\lib\third_party\mbedtls\library\platform.c line 61
void * (*mbedtls_calloc)(size_t, size_t)=calloc;
// mbedtls_cipher_definitions
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 1349
const mbedtls_cipher_definition_t mbedtls_cipher_definitions[16ll];
// mbedtls_cipher_definitions
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 1349
const mbedtls_cipher_definition_t mbedtls_cipher_definitions[16ll]={ { .type=/*enum*/MBEDTLS_CIPHER_AES_128_ECB, .info=&aes_128_ecb_info },
    { .type=/*enum*/MBEDTLS_CIPHER_AES_192_ECB, .info=&aes_192_ecb_info },
    { .type=/*enum*/MBEDTLS_CIPHER_AES_256_ECB, .info=&aes_256_ecb_info },
    { .type=/*enum*/MBEDTLS_CIPHER_AES_128_CBC, .info=&aes_128_cbc_info },
    { .type=/*enum*/MBEDTLS_CIPHER_AES_192_CBC, .info=&aes_192_cbc_info },
    { .type=/*enum*/MBEDTLS_CIPHER_AES_256_CBC, .info=&aes_256_cbc_info },
    { .type=/*enum*/MBEDTLS_CIPHER_AES_128_CFB128, .info=&aes_128_cfb128_info },
    { .type=/*enum*/MBEDTLS_CIPHER_AES_192_CFB128, .info=&aes_192_cfb128_info },
    { .type=/*enum*/MBEDTLS_CIPHER_AES_256_CFB128, .info=&aes_256_cfb128_info },
    { .type=/*enum*/MBEDTLS_CIPHER_AES_128_CTR, .info=&aes_128_ctr_info },
    { .type=/*enum*/MBEDTLS_CIPHER_AES_192_CTR, .info=&aes_192_ctr_info },
    { .type=/*enum*/MBEDTLS_CIPHER_AES_256_CTR, .info=&aes_256_ctr_info },
    { .type=/*enum*/MBEDTLS_CIPHER_AES_128_GCM, .info=&aes_128_gcm_info },
    { .type=/*enum*/MBEDTLS_CIPHER_AES_192_GCM, .info=&aes_192_gcm_info },
    { .type=/*enum*/MBEDTLS_CIPHER_AES_256_GCM, .info=&aes_256_gcm_info },
    { .type=/*enum*/MBEDTLS_CIPHER_NONE, .info=((const mbedtls_cipher_info_t *)NULL) } };
// mbedtls_cipher_supported
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 1449
signed int mbedtls_cipher_supported[16ll];
// mbedtls_ecdsa_info
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 391
const mbedtls_pk_info_t mbedtls_ecdsa_info;
// mbedtls_ecdsa_info
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 391
const mbedtls_pk_info_t mbedtls_ecdsa_info={ .type=/*enum*/MBEDTLS_PK_ECDSA, .name="ECDSA", .get_bitlen=eckey_get_bitlen,
    .can_do=ecdsa_can_do, .verify_func=ecdsa_verify_wrap,
    .sign_func=ecdsa_sign_wrap, .decrypt_func=((signed int (*)(void *, const unsigned char *, size_t, unsigned char *, size_t *, size_t, signed int (*)(void *, unsigned char *, size_t), void *))NULL),
    .encrypt_func=((signed int (*)(void *, const unsigned char *, size_t, unsigned char *, size_t *, size_t, signed int (*)(void *, unsigned char *, size_t), void *))NULL),
    .check_pair_func=eckey_check_pair,
    .ctx_alloc_func=ecdsa_alloc_wrap, .ctx_free_func=ecdsa_free_wrap,
    .debug_func=eckey_debug };
// mbedtls_eckey_info
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 299
const mbedtls_pk_info_t mbedtls_eckey_info;
// mbedtls_eckey_info
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 299
const mbedtls_pk_info_t mbedtls_eckey_info={ .type=/*enum*/MBEDTLS_PK_ECKEY, .name="EC", .get_bitlen=eckey_get_bitlen,
    .can_do=eckey_can_do, .verify_func=eckey_verify_wrap,
    .sign_func=eckey_sign_wrap, .decrypt_func=((signed int (*)(void *, const unsigned char *, size_t, unsigned char *, size_t *, size_t, signed int (*)(void *, unsigned char *, size_t), void *))NULL),
    .encrypt_func=((signed int (*)(void *, const unsigned char *, size_t, unsigned char *, size_t *, size_t, signed int (*)(void *, unsigned char *, size_t), void *))NULL),
    .check_pair_func=eckey_check_pair,
    .ctx_alloc_func=eckey_alloc_wrap, .ctx_free_func=eckey_free_wrap,
    .debug_func=eckey_debug };
// mbedtls_eckeydh_info
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 328
const mbedtls_pk_info_t mbedtls_eckeydh_info;
// mbedtls_eckeydh_info
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 328
const mbedtls_pk_info_t mbedtls_eckeydh_info={ .type=/*enum*/MBEDTLS_PK_ECKEY_DH, .name="EC_DH", .get_bitlen=eckey_get_bitlen,
    .can_do=eckeydh_can_do, .verify_func=((signed int (*)(void *, mbedtls_md_type_t, const unsigned char *, size_t, const unsigned char *, size_t))NULL),
    .sign_func=((signed int (*)(void *, mbedtls_md_type_t, const unsigned char *, size_t, unsigned char *, size_t *, signed int (*)(void *, unsigned char *, size_t), void *))NULL),
    .decrypt_func=((signed int (*)(void *, const unsigned char *, size_t, unsigned char *, size_t *, size_t, signed int (*)(void *, unsigned char *, size_t), void *))NULL),
    .encrypt_func=((signed int (*)(void *, const unsigned char *, size_t, unsigned char *, size_t *, size_t, signed int (*)(void *, unsigned char *, size_t), void *))NULL),
    .check_pair_func=eckey_check_pair,
    .ctx_alloc_func=eckey_alloc_wrap, .ctx_free_func=eckey_free_wrap,
    .debug_func=eckey_debug };
// mbedtls_free
// file ..\..\..\..\lib\third_party\mbedtls\library\platform.c line 62
void (*mbedtls_free)(void *);
// mbedtls_free
// file ..\..\..\..\lib\third_party\mbedtls\library\platform.c line 62
void (*mbedtls_free)(void *)=free;
// mbedtls_rsa_alt_info
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 505
const mbedtls_pk_info_t mbedtls_rsa_alt_info;
// mbedtls_rsa_alt_info
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 505
const mbedtls_pk_info_t mbedtls_rsa_alt_info={ .type=/*enum*/MBEDTLS_PK_RSA_ALT, .name="RSA-alt", .get_bitlen=rsa_alt_get_bitlen,
    .can_do=rsa_alt_can_do, .verify_func=((signed int (*)(void *, mbedtls_md_type_t, const unsigned char *, size_t, const unsigned char *, size_t))NULL),
    .sign_func=rsa_alt_sign_wrap,
    .decrypt_func=rsa_alt_decrypt_wrap, .encrypt_func=((signed int (*)(void *, const unsigned char *, size_t, unsigned char *, size_t *, size_t, signed int (*)(void *, unsigned char *, size_t), void *))NULL),
    .check_pair_func=rsa_alt_check_pair,
    .ctx_alloc_func=rsa_alt_alloc_wrap,
    .ctx_free_func=rsa_alt_free_wrap, .debug_func=((void (*)(const void *, mbedtls_pk_debug_item *))NULL) };
// mbedtls_rsa_info
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 189
const mbedtls_pk_info_t mbedtls_rsa_info;
// mbedtls_rsa_info
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 189
const mbedtls_pk_info_t mbedtls_rsa_info={ .type=/*enum*/MBEDTLS_PK_RSA, .name="RSA", .get_bitlen=rsa_get_bitlen,
    .can_do=rsa_can_do, .verify_func=rsa_verify_wrap,
    .sign_func=rsa_sign_wrap, .decrypt_func=rsa_decrypt_wrap,
    .encrypt_func=rsa_encrypt_wrap, .check_pair_func=rsa_check_pair_wrap,
    .ctx_alloc_func=rsa_alloc_wrap,
    .ctx_free_func=rsa_free_wrap, .debug_func=rsa_debug };
// mbedtls_sha1_info
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 372
const mbedtls_md_info_t mbedtls_sha1_info;
// mbedtls_sha1_info
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 372
const mbedtls_md_info_t mbedtls_sha1_info={ .type=/*enum*/MBEDTLS_MD_SHA1, .name="SHA1", .size=20,
    .block_size=64, .starts_func=sha1_starts_wrap, .update_func=sha1_update_wrap,
    .finish_func=sha1_finish_wrap, .digest_func=mbedtls_sha1_ret,
    .ctx_alloc_func=sha1_ctx_alloc, .ctx_free_func=sha1_ctx_free,
    .clone_func=sha1_clone_wrap, .process_func=sha1_process_wrap };
// mbedtls_sha224_info
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 446
const mbedtls_md_info_t mbedtls_sha224_info;
// mbedtls_sha224_info
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 446
const mbedtls_md_info_t mbedtls_sha224_info={ .type=/*enum*/MBEDTLS_MD_SHA224, .name="SHA224", .size=28,
    .block_size=64, .starts_func=sha224_starts_wrap, .update_func=sha224_update_wrap,
    .finish_func=sha224_finish_wrap, .digest_func=sha224_wrap,
    .ctx_alloc_func=sha224_ctx_alloc, .ctx_free_func=sha224_ctx_free,
    .clone_func=sha224_clone_wrap, .process_func=sha224_process_wrap };
// mbedtls_sha256_info
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 472
const mbedtls_md_info_t mbedtls_sha256_info;
// mbedtls_sha256_info
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 472
const mbedtls_md_info_t mbedtls_sha256_info={ .type=/*enum*/MBEDTLS_MD_SHA256, .name="SHA256", .size=32,
    .block_size=64, .starts_func=sha256_starts_wrap, .update_func=sha224_update_wrap,
    .finish_func=sha224_finish_wrap, .digest_func=sha256_wrap,
    .ctx_alloc_func=sha224_ctx_alloc, .ctx_free_func=sha224_ctx_free,
    .clone_func=sha224_clone_wrap, .process_func=sha224_process_wrap };
// mbedtls_snprintf
// file ..\..\..\..\lib\third_party\mbedtls\library\platform.c line 118
signed int (*mbedtls_snprintf)(char *, size_t, const char *, ...);
// mbedtls_snprintf
// file ..\..\..\..\lib\third_party\mbedtls\library\platform.c line 118
signed int (*mbedtls_snprintf)(char *, size_t, const char *, ...)=mbedtls_platform_win32_snprintf;
// mbedtls_x509_crt_profile_default
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 101
const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_default={ .allowed_mds=(uint32_t)(1 << 5 - 1 | 1 << 6 - 1 | 1 << 7 - 1 | 1 << 8 - 1), .allowed_pks=268435455u,
    .allowed_curves=268435455u, .rsa_min_bitlen=2048u };
// mbedtls_x509_crt_profile_next
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 120
const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_next={ .allowed_mds=(uint32_t)(1 << 6 - 1 | 1 << 7 - 1 | 1 << 8 - 1), .allowed_pks=268435455u,
    .allowed_curves=(uint32_t)(1 << 3 - 1 | 1 << 4 - 1 | 1 << 5 - 1 | 1 << 6 - 1 | 1 << 7 - 1 | 1 << 8 - 1 | 1 << 13 - 1), .rsa_min_bitlen=2048u };
// mbedtls_x509_crt_profile_suiteb
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 145
const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_suiteb={ .allowed_mds=(uint32_t)(1 << 6 - 1 | 1 << 7 - 1), .allowed_pks=(uint32_t)(1 << 4 - 1 | 1 << 2 - 1),
    .allowed_curves=(uint32_t)(1 << 3 - 1 | 1 << 4 - 1),
    .rsa_min_bitlen=0u };
// mfl_code_to_length
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 148
static unsigned int mfl_code_to_length[5ll]={ 8192u, 512u, 1024u, 2048u, 4096u };
// mul_count
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 86
static unsigned long int mul_count;
// nISRactive
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 91
int8_t nISRactive=0;
// nonce_pers_nopr
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 568
static const unsigned char nonce_pers_nopr[16ll]={ 27, 84, 184, 255, 6, 66, 191, 245, 33, 241, 92, 28, 11, 102, 95, 63 };
// nonce_pers_pr
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 564
static const unsigned char nonce_pers_pr[16ll]={ 210, 84, 252, 255, 2, 30, 105, 210, 41, 201, 207, 173, 133, 250, 72, 108 };
// objectHandleStacks
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2159
objectHandleStackType objectHandleStacks={ .indexOfNextAvailableHandle={ 0, 0, 0, 0, 0, 0, 0 }, .lowestIndexOfClass={ 0, 0, 0, 0, 0, 0, 0 },
    .highestIndexOfClass={ 0, 0, 0, 0, 0, 0, 0 },
    .handleCountWaterMarksOfClass={ 0, 0, 0, 0, 0, 0, 0 },
    .objectHandles={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } };
// oid_cipher_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 544
static const oid_cipher_alg_t oid_cipher_alg[3ll]={ { .descriptor={ .asn1="+\\\\a", .asn1_len=sizeof(char [6ll]) /*6ull*/  - 1ull, .name="desCBC",
    .description="DES-CBC" }, .cipher_alg=/*enum*/MBEDTLS_CIPHER_DES_CBC },
    { .descriptor={ .asn1="*H\r\\a", .asn1_len=sizeof(char [9ll]) /*9ull*/  - 1ull, .name="des-ede3-cbc",
    .description="DES-EDE3-CBC" }, .cipher_alg=/*enum*/MBEDTLS_CIPHER_DES_EDE3_CBC },
    { .descriptor={ .asn1=((const char *)NULL), .asn1_len=0ull, .name=((const char *)NULL),
    .description=((const char *)NULL) }, .cipher_alg=/*enum*/MBEDTLS_CIPHER_NONE } };
// oid_ecp_grp
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 456
static const oid_ecp_grp_t oid_ecp_grp[2ll]={ { .descriptor={ .asn1="*H=\\\a", .asn1_len=sizeof(char [9ll]) /*9ull*/  - 1ull, .name="secp256r1",
    .description="secp256r1" }, .grp_id=/*enum*/MBEDTLS_ECP_DP_SECP256R1 },
    { .descriptor={ .asn1=((const char *)NULL), .asn1_len=0ull, .name=((const char *)NULL),
    .description=((const char *)NULL) }, .grp_id=/*enum*/MBEDTLS_ECP_DP_NONE } };
// oid_ext_key_usage
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 290
static const mbedtls_oid_descriptor_t oid_ext_key_usage[7ll]={ { .asn1="+\\\\\a\\", .asn1_len=sizeof(char [9ll]) /*9ull*/  - 1ull, .name="id-kp-serverAuth",
    .description="TLS Web Server Authentication" },
    { .asn1="+\\\\\a\\", .asn1_len=sizeof(char [9ll]) /*9ull*/  - 1ull, .name="id-kp-clientAuth",
    .description="TLS Web Client Authentication" },
    { .asn1="+\\\\\a\\", .asn1_len=sizeof(char [9ll]) /*9ull*/  - 1ull, .name="id-kp-codeSigning",
    .description="Code Signing" },
    { .asn1="+\\\\\a\\", .asn1_len=sizeof(char [9ll]) /*9ull*/  - 1ull, .name="id-kp-emailProtection",
    .description="E-mail Protection" },
    { .asn1="+\\\\\a\\b", .asn1_len=sizeof(char [9ll]) /*9ull*/  - 1ull, .name="id-kp-timeStamping",
    .description="Time Stamping" },
    { .asn1="+\\\\\a\\t", .asn1_len=sizeof(char [9ll]) /*9ull*/  - 1ull, .name="id-kp-OCSPSigning",
    .description="OCSP Signing" },
    { .asn1=((const char *)NULL), .asn1_len=0ull, .name=((const char *)NULL),
    .description=((const char *)NULL) } };
// oid_md_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 573
static const oid_md_alg_t oid_md_alg[4ll]={ { .descriptor={ .asn1="+\\\\", .asn1_len=sizeof(char [6ll]) /*6ull*/  - 1ull, .name="id-sha1",
    .description="SHA-1" }, .md_alg=/*enum*/MBEDTLS_MD_SHA1 },
    { .descriptor={ .asn1="`H\e\\\\", .asn1_len=sizeof(char [10ll]) /*10ull*/  - 1ull, .name="id-sha224",
    .description="SHA-224" }, .md_alg=/*enum*/MBEDTLS_MD_SHA224 },
    { .descriptor={ .asn1="`H\e\\\\", .asn1_len=sizeof(char [10ll]) /*10ull*/  - 1ull, .name="id-sha256",
    .description="SHA-256" }, .md_alg=/*enum*/MBEDTLS_MD_SHA256 },
    { .descriptor={ .asn1=((const char *)NULL), .asn1_len=0ull, .name=((const char *)NULL),
    .description=((const char *)NULL) }, .md_alg=/*enum*/MBEDTLS_MD_NONE } };
// oid_md_hmac
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 637
static const oid_md_hmac_t oid_md_hmac[4ll]={ { .descriptor={ .asn1="*H\r\\a", .asn1_len=sizeof(char [9ll]) /*9ull*/  - 1ull, .name="hmacSHA1",
    .description="HMAC-SHA-1" }, .md_hmac=/*enum*/MBEDTLS_MD_SHA1 },
    { .descriptor={ .asn1="*H\r\\b", .asn1_len=sizeof(char [9ll]) /*9ull*/  - 1ull, .name="hmacSHA224",
    .description="HMAC-SHA-224" }, .md_hmac=/*enum*/MBEDTLS_MD_SHA224 },
    { .descriptor={ .asn1="*H\r\\t", .asn1_len=sizeof(char [9ll]) /*9ull*/  - 1ull, .name="hmacSHA256",
    .description="HMAC-SHA-256" }, .md_hmac=/*enum*/MBEDTLS_MD_SHA256 },
    { .descriptor={ .asn1=((const char *)NULL), .asn1_len=0ull, .name=((const char *)NULL),
    .description=((const char *)NULL) }, .md_hmac=/*enum*/MBEDTLS_MD_NONE } };
// oid_pk_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 423
static const oid_pk_alg_t oid_pk_alg[4ll]={ { .descriptor={ .asn1="*H\r\\\", .asn1_len=sizeof(char [10ll]) /*10ull*/  - 1ull, .name="rsaEncryption",
    .description="RSA" }, .pk_alg=/*enum*/MBEDTLS_PK_RSA },
    { .descriptor={ .asn1="*H=\\", .asn1_len=sizeof(char [8ll]) /*8ull*/  - 1ull, .name="id-ecPublicKey",
    .description="Generic EC key" }, .pk_alg=/*enum*/MBEDTLS_PK_ECKEY },
    { .descriptor={ .asn1="+\\\f", .asn1_len=sizeof(char [6ll]) /*6ull*/  - 1ull, .name="id-ecDH",
    .description="EC key for ECDH" }, .pk_alg=/*enum*/MBEDTLS_PK_ECKEY_DH },
    { .descriptor={ .asn1=((const char *)NULL), .asn1_len=0ull, .name=((const char *)NULL),
    .description=((const char *)NULL) }, .pk_alg=/*enum*/MBEDTLS_PK_NONE } };
// oid_sig_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 315
static const oid_sig_alg_t oid_sig_alg[9ll]={ { .descriptor={ .asn1="*H\r\\\", .asn1_len=sizeof(char [10ll]) /*10ull*/  - 1ull, .name="sha-1WithRSAEncryption",
    .description="RSA with SHA1" }, .md_alg=/*enum*/MBEDTLS_MD_SHA1,
    .pk_alg=/*enum*/MBEDTLS_PK_RSA },
    { .descriptor={ .asn1="*H\r\\\", .asn1_len=sizeof(char [10ll]) /*10ull*/  - 1ull, .name="sha224WithRSAEncryption",
    .description="RSA with SHA-224" }, .md_alg=/*enum*/MBEDTLS_MD_SHA224,
    .pk_alg=/*enum*/MBEDTLS_PK_RSA },
    { .descriptor={ .asn1="*H\r\\\v", .asn1_len=sizeof(char [10ll]) /*10ull*/  - 1ull, .name="sha256WithRSAEncryption",
    .description="RSA with SHA-256" }, .md_alg=/*enum*/MBEDTLS_MD_SHA256,
    .pk_alg=/*enum*/MBEDTLS_PK_RSA },
    { .descriptor={ .asn1="+\\\\", .asn1_len=sizeof(char [6ll]) /*6ull*/  - 1ull, .name="sha-1WithRSAEncryption",
    .description="RSA with SHA1" }, .md_alg=/*enum*/MBEDTLS_MD_SHA1,
    .pk_alg=/*enum*/MBEDTLS_PK_RSA },
    { .descriptor={ .asn1="*H=\\", .asn1_len=sizeof(char [8ll]) /*8ull*/  - 1ull, .name="ecdsa-with-SHA1",
    .description="ECDSA with SHA1" }, .md_alg=/*enum*/MBEDTLS_MD_SHA1,
    .pk_alg=/*enum*/MBEDTLS_PK_ECDSA },
    { .descriptor={ .asn1="*H=\\\", .asn1_len=sizeof(char [9ll]) /*9ull*/  - 1ull, .name="ecdsa-with-SHA224",
    .description="ECDSA with SHA224" }, .md_alg=/*enum*/MBEDTLS_MD_SHA224,
    .pk_alg=/*enum*/MBEDTLS_PK_ECDSA },
    { .descriptor={ .asn1="*H=\\\", .asn1_len=sizeof(char [9ll]) /*9ull*/  - 1ull, .name="ecdsa-with-SHA256",
    .description="ECDSA with SHA256" }, .md_alg=/*enum*/MBEDTLS_MD_SHA256,
    .pk_alg=/*enum*/MBEDTLS_PK_ECDSA },
    { .descriptor={ .asn1="*H\r\\\n", .asn1_len=sizeof(char [10ll]) /*10ull*/  - 1ull, .name="RSASSA-PSS",
    .description="RSASSA-PSS" }, .md_alg=/*enum*/MBEDTLS_MD_NONE,
    .pk_alg=/*enum*/MBEDTLS_PK_RSASSA_PSS },
    { .descriptor={ .asn1=((const char *)NULL), .asn1_len=0ull, .name=((const char *)NULL),
    .description=((const char *)NULL) }, .md_alg=/*enum*/MBEDTLS_MD_NONE,
    .pk_alg=/*enum*/MBEDTLS_PK_NONE } };
// oid_x509_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 259
static const oid_x509_ext_t oid_x509_ext[6ll]={ { .descriptor={ .asn1="U\\", .asn1_len=sizeof(char [4ll]) /*4ull*/  - 1ull, .name="id-ce-basicConstraints",
    .description="Basic Constraints" }, .ext_type=1 << 8 },
    { .descriptor={ .asn1="U\\", .asn1_len=sizeof(char [4ll]) /*4ull*/  - 1ull, .name="id-ce-keyUsage",
    .description="Key Usage" }, .ext_type=1 << 2 },
    { .descriptor={ .asn1="U\%", .asn1_len=sizeof(char [4ll]) /*4ull*/  - 1ull, .name="id-ce-extKeyUsage",
    .description="Extended Key Usage" }, .ext_type=1 << 11 },
    { .descriptor={ .asn1="U\\", .asn1_len=sizeof(char [4ll]) /*4ull*/  - 1ull, .name="id-ce-subjectAltName",
    .description="Subject Alt Name" }, .ext_type=1 << 5 },
    { .descriptor={ .asn1="`H\B\\", .asn1_len=sizeof(char [10ll]) /*10ull*/  - 1ull, .name="id-netscape-certtype",
    .description="Netscape Certificate Type" }, .ext_type=1 << 16 },
    { .descriptor={ .asn1=((const char *)NULL), .asn1_len=0ull, .name=((const char *)NULL),
    .description=((const char *)NULL) }, .ext_type=0 } };
// oid_x520_attr_type
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 164
static const oid_x520_attr_t oid_x520_attr_type[20ll]={ { .descriptor={ .asn1="U\\", .asn1_len=sizeof(char [4ll]) /*4ull*/  - 1ull, .name="id-at-commonName",
    .description="Common Name" }, .short_name="CN" },
    { .descriptor={ .asn1="U\\", .asn1_len=sizeof(char [4ll]) /*4ull*/  - 1ull, .name="id-at-countryName",
    .description="Country" }, .short_name="C" },
    { .descriptor={ .asn1="U\\a", .asn1_len=sizeof(char [4ll]) /*4ull*/  - 1ull, .name="id-at-locality",
    .description="Locality" }, .short_name="L" },
    { .descriptor={ .asn1="U\\b", .asn1_len=sizeof(char [4ll]) /*4ull*/  - 1ull, .name="id-at-state",
    .description="State" }, .short_name="ST" },
    { .descriptor={ .asn1="U\\n", .asn1_len=sizeof(char [4ll]) /*4ull*/  - 1ull, .name="id-at-organizationName",
    .description="Organization" }, .short_name="O" },
    { .descriptor={ .asn1="U\\v", .asn1_len=sizeof(char [4ll]) /*4ull*/  - 1ull, .name="id-at-organizationalUnitName",
    .description="Org Unit" }, .short_name="OU" },
    { .descriptor={ .asn1="*H\r\\t\", .asn1_len=sizeof(char [10ll]) /*10ull*/  - 1ull, .name="emailAddress",
    .description="E-mail address" }, .short_name="emailAddress" },
    { .descriptor={ .asn1="U\\", .asn1_len=sizeof(char [4ll]) /*4ull*/  - 1ull, .name="id-at-serialNumber",
    .description="Serial number" }, .short_name="serialNumber" },
    { .descriptor={ .asn1="U\\", .asn1_len=sizeof(char [4ll]) /*4ull*/  - 1ull, .name="id-at-postalAddress",
    .description="Postal address" }, .short_name="postalAddress" },
    { .descriptor={ .asn1="U\\", .asn1_len=sizeof(char [4ll]) /*4ull*/  - 1ull, .name="id-at-postalCode",
    .description="Postal code" }, .short_name="postalCode" },
    { .descriptor={ .asn1="U\\", .asn1_len=sizeof(char [4ll]) /*4ull*/  - 1ull, .name="id-at-surName",
    .description="Surname" }, .short_name="SN" },
    { .descriptor={ .asn1="U\*", .asn1_len=sizeof(char [4ll]) /*4ull*/  - 1ull, .name="id-at-givenName",
    .description="Given name" }, .short_name="GN" },
    { .descriptor={ .asn1="U\+", .asn1_len=sizeof(char [4ll]) /*4ull*/  - 1ull, .name="id-at-initials",
    .description="Initials" }, .short_name="initials" },
    { .descriptor={ .asn1="U\,", .asn1_len=sizeof(char [4ll]) /*4ull*/  - 1ull, .name="id-at-generationQualifier",
    .description="Generation qualifier" }, .short_name="generationQualifier" },
    { .descriptor={ .asn1="U\\f", .asn1_len=sizeof(char [4ll]) /*4ull*/  - 1ull, .name="id-at-title",
    .description="Title" }, .short_name="title" },
    { .descriptor={ .asn1="U\.", .asn1_len=sizeof(char [4ll]) /*4ull*/  - 1ull, .name="id-at-dnQualifier",
    .description="Distinguished Name qualifier" }, .short_name="dnQualifier" },
    { .descriptor={ .asn1="U\A", .asn1_len=sizeof(char [4ll]) /*4ull*/  - 1ull, .name="id-at-pseudonym",
    .description="Pseudonym" }, .short_name="pseudonym" },
    { .descriptor={ .asn1="\t&,d\\", .asn1_len=sizeof(char [11ll]) /*11ull*/  - 1ull, .name="id-domainComponent",
    .description="Domain component" }, .short_name="DC" },
    { .descriptor={ .asn1="U\-", .asn1_len=sizeof(char [4ll]) /*4ull*/  - 1ull, .name="id-at-uniqueIdentifier",
    .description="Unique Identifier" }, .short_name="uniqueIdentifier" },
    { .descriptor={ .asn1=((const char *)NULL), .asn1_len=0ull, .name=((const char *)NULL),
    .description=((const char *)NULL) }, .short_name=((const char *)NULL) } };
// pacClientTokenFromJob
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 352
static char *pacClientTokenFromJob=((char *)NULL);
// pacOTA_Singleton_ActiveJobName
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 351
static uint8_t *pacOTA_Singleton_ActiveJobName=((uint8_t *)NULL);
// pcFullLogFileName
// file ..\common\application_code\aws_demo_logging.c line 144
static const char *pcFullLogFileName="RTOSDemo.ful";
// pcJSONFile
// file ..\..\..\common\greengrass_connectivity\aws_greengrass_discovery_demo.c line 80
static char pcJSONFile[2500ll];
// pcLogFileName
// file ..\common\application_code\aws_demo_logging.c line 143
static const char *pcLogFileName="RTOSDemo.log";
// pcLongString
// file ..\..\..\common\mqtt\aws_subscribe_publish_loop.c line 208
const char * const pcLongString="This is a long string that requires a length encoding greater than one byte. This tests the encoding and decoding of Remaining Length field in a MQTT packet.";
// pcStateNames
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 168
static const char *pcStateNames[13ll]={ "eCLOSED", "eTCP_LISTEN", "eCONNECT_SYN", "eSYN_FIRST", "eSYN_RECEIVED", "eESTABLISHED", "eFIN_WAIT_1", "eFIN_WAIT_2", "eCLOSE_WAIT", "eCLOSING", "eLAST_ACK", "eTIME_WAIT", "eUNKNOWN" };
// prvP11FunctionList
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 400
static CK_FUNCTION_LIST prvP11FunctionList;
// prvP11FunctionList
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 400
static CK_FUNCTION_LIST prvP11FunctionList={ .version={ .major=2, .minor=40 }, .C_Initialize=C_Initialize, .C_Finalize=C_Finalize,
    .C_GetInfo=((CK_C_GetInfo)NULL), .C_GetFunctionList=C_GetFunctionList,
    .C_GetSlotList=C_GetSlotList,
    .C_GetSlotInfo=((CK_C_GetSlotInfo)NULL), .C_GetTokenInfo=((CK_C_GetTokenInfo)NULL),
    .C_GetMechanismList=((CK_C_GetMechanismList)NULL),
    .C_GetMechanismInfo=((CK_C_GetMechanismInfo)NULL),
    .C_InitToken=((CK_C_InitToken)NULL),
    .C_InitPIN=((CK_C_InitPIN)NULL),
    .C_SetPIN=((CK_C_SetPIN)NULL), .C_OpenSession=C_OpenSession,
    .C_CloseSession=C_CloseSession, .C_CloseAllSessions=((CK_C_CloseAllSessions)NULL),
    .C_GetSessionInfo=((CK_C_GetSessionInfo)NULL),
    .C_GetOperationState=((CK_C_GetOperationState)NULL),
    .C_SetOperationState=((CK_C_SetOperationState)NULL),
    .C_Login=((CK_C_Login)NULL),
    .C_Logout=((CK_C_Logout)NULL), .C_CreateObject=C_CreateObject,
    .C_CopyObject=((CK_C_CopyObject)NULL), .C_DestroyObject=C_DestroyObject,
    .C_GetObjectSize=((CK_C_GetObjectSize)NULL), .C_GetAttributeValue=C_GetAttributeValue,
    .C_SetAttributeValue=((CK_C_SetAttributeValue)NULL),
    .C_FindObjectsInit=C_FindObjectsInit,
    .C_FindObjects=C_FindObjects,
    .C_FindObjectsFinal=C_FindObjectsFinal, .C_EncryptInit=((CK_C_EncryptInit)NULL),
    .C_Encrypt=((CK_C_Encrypt)NULL),
    .C_EncryptUpdate=((CK_C_EncryptUpdate)NULL), .C_EncryptFinal=((CK_C_EncryptFinal)NULL),
    .C_DecryptInit=((CK_C_DecryptInit)NULL),
    .C_Decrypt=((CK_C_Decrypt)NULL),
    .C_DecryptUpdate=((CK_C_DecryptUpdate)NULL), .C_DecryptFinal=((CK_C_DecryptFinal)NULL),
    .C_DigestInit=C_DigestInit,
    .C_Digest=((CK_C_Digest)NULL), .C_DigestUpdate=C_DigestUpdate,
    .C_DigestKey=((CK_C_DigestKey)NULL), .C_DigestFinal=C_DigestFinal,
    .C_SignInit=C_SignInit, .C_Sign=C_Sign,
    .C_SignUpdate=((CK_C_SignUpdate)NULL), .C_SignFinal=((CK_C_SignFinal)NULL),
    .C_SignRecoverInit=((CK_C_SignRecoverInit)NULL),
    .C_SignRecover=((CK_C_SignRecover)NULL),
    .C_VerifyInit=C_VerifyInit,
    .C_Verify=C_Verify, .C_VerifyUpdate=((CK_C_VerifyUpdate)NULL),
    .C_VerifyFinal=((CK_C_VerifyFinal)NULL),
    .C_VerifyRecoverInit=((CK_C_VerifyRecoverInit)NULL),
    .C_VerifyRecover=((CK_C_VerifyRecover)NULL),
    .C_DigestEncryptUpdate=((CK_C_DigestEncryptUpdate)NULL),
    .C_DecryptDigestUpdate=((CK_C_DecryptDigestUpdate)NULL),
    .C_SignEncryptUpdate=((CK_C_SignEncryptUpdate)NULL),
    .C_DecryptVerifyUpdate=((CK_C_DecryptVerifyUpdate)NULL),
    .C_GenerateKey=((CK_C_GenerateKey)NULL),
    .C_GenerateKeyPair=C_GenerateKeyPair,
    .C_WrapKey=((CK_C_WrapKey)NULL),
    .C_UnwrapKey=((CK_C_UnwrapKey)NULL), .C_DeriveKey=((CK_C_DeriveKey)NULL),
    .C_SeedRandom=((CK_C_SeedRandom)NULL),
    .C_GenerateRandom=C_GenerateRandom,
    .C_GetFunctionStatus=((CK_C_GetFunctionStatus)NULL), .C_CancelFunction=((CK_C_CancelFunction)NULL),
    .C_WaitForSlotEvent=((CK_C_WaitForSlotEvent)NULL) };
// pt
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 581
static const unsigned char pt[6ll][64ll]={ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 217, 49, 50, 37, 248, 132, 6, 229, 165, 89, 9, 197, 175, 245, 38, 154, 134, 167, 169, 83, 21, 52, 247, 218, 46, 76, 48, 61, 138, 49, 138, 114, 28, 60, 12, 149, 149, 104, 9, 83, 47, 207, 14, 36, 73, 166, 181, 37, 177, 106, 237, 245, 170, 13, 230, 87, 186, 99, 123, 57, 26, 175, 210, 85 },
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } };
// pt_index
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 578
static const signed int pt_index[6ll]={ 0, 0, 1, 1, 1, 1 };
// pt_len
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 575
static const size_t pt_len[6ll]={ 0ull, 16ull, 64ull, 60ull, 60ull, 60ull };
// pvInterruptEvent
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 98
static void *pvInterruptEvent=NULL;
// pvInterruptEventMutex
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 102
static void *pvInterruptEventMutex=NULL;
// pvLoggingThreadEvent
// file ..\common\application_code\aws_demo_logging.c line 120
static void *pvLoggingThreadEvent=NULL;
// pvPubSubClient
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 345
static void *pvPubSubClient=NULL;
// pvSendEvent
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 114
static void *pvSendEvent=NULL;
// pxCurrentTCB
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 352
TCB_t *pxCurrentTCB=((TCB_t *)NULL);
// pxCurrentTimerList
// file ..\..\..\..\lib\FreeRTOS\timers.c line 133
static List_t *pxCurrentTimerList;
// pxDelayedTaskList
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 358
static List_t * volatile pxDelayedTaskList;
// pxEnd
// file ..\..\..\..\lib\FreeRTOS\portable\MemMang\heap_4.c line 98
static BlockLink_t *pxEnd=((BlockLink_t *)NULL);
// pxLoggingFileHandle
// file ..\common\application_code\aws_demo_logging.c line 135
static FILE *pxLoggingFileHandle=((FILE *)NULL);
// pxOTAJobCompleteCallback
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 348
static pxOTACompleteCallback_t pxOTAJobCompleteCallback=((pxOTACompleteCallback_t)NULL);
// pxOpenedInterfaceHandle
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 125
static pcap_t *pxOpenedInterfaceHandle=((pcap_t *)NULL);
// pxOverflowDelayedTaskList
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 359
static List_t * volatile pxOverflowDelayedTaskList;
// pxOverflowTimerList
// file ..\..\..\..\lib\FreeRTOS\timers.c line 134
static List_t *pxOverflowTimerList;
// pxReadyTasksLists
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 355
static List_t pxReadyTasksLists[7ll];
// pxShadowClients
// file ..\..\..\..\lib\shadow\aws_shadow.c line 331
static ShadowClient_t pxShadowClients[1ll];
// readyEventsEnabled
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 67
static signed int readyEventsEnabled=1;
// recorder_busy
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 82
volatile signed int recorder_busy=0;
// result_nopr
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 576
static const unsigned char result_nopr[16ll]={ 160, 84, 48, 61, 138, 126, 169, 136, 157, 144, 62, 7, 124, 111, 33, 143 };
// result_nopr$link1
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 444
static const unsigned char result_nopr$link1[80ll]={ 198, 161, 106, 184, 212, 32, 112, 111, 15, 52, 171, 127, 236, 90, 220, 169, 216, 202, 58, 19, 62, 21, 156, 166, 172, 67, 198, 248, 162, 190, 34, 131, 74, 76, 10, 10, 255, 177, 13, 113, 148, 241, 193, 165, 207, 115, 34, 236, 26, 224, 150, 78, 212, 191, 18, 39, 70, 224, 135, 253, 181, 179, 233, 27, 52, 147, 213, 187, 152, 250, 237, 73, 232, 95, 19, 15, 200, 164, 89, 183 };
// result_pr
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 572
static const unsigned char result_pr[16ll]={ 52, 1, 22, 86, 180, 41, 0, 143, 53, 99, 236, 181, 242, 89, 7, 35 };
// result_pr$link1
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 429
static const unsigned char result_pr$link1[80ll]={ 154, 0, 162, 208, 14, 213, 155, 254, 49, 236, 177, 57, 155, 96, 129, 72, 209, 150, 157, 37, 13, 60, 30, 148, 16, 16, 152, 18, 147, 37, 202, 184, 252, 204, 45, 84, 115, 25, 112, 192, 16, 122, 164, 137, 37, 25, 149, 94, 75, 198, 0, 29, 127, 78, 106, 43, 248, 163, 1, 171, 70, 5, 92, 9, 166, 113, 136, 241, 167, 64, 238, 243, 225, 92, 2, 155, 68, 175, 3, 68 };
// secp256r1_b
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp_curves.c line 162
static const mbedtls_mpi_uint secp256r1_b[4ll]={ 75ull << 0 | 96ull << 8 | 210ull << 16 | 39ull << 24 | 62ull << 32 | 60ull << 40 | 206ull << 48 | 59ull << 56,
    246ull << 0 | 176ull << 8 | 83ull << 16 | 204ull << 24 | 176ull << 32 | 6ull << 40 | 29ull << 48 | 101ull << 56,
    188ull << 0 | 134ull << 8 | 152ull << 16 | 118ull << 24 | 85ull << 32 | 189ull << 40 | 235ull << 48 | 179ull << 56,
    231ull << 0 | 147ull << 8 | 58ull << 16 | 170ull << 24 | 216ull << 32 | 53ull << 40 | 198ull << 48 | 90ull << 56 };
// secp256r1_gx
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp_curves.c line 168
static const mbedtls_mpi_uint secp256r1_gx[4ll]={ 150ull << 0 | 194ull << 8 | 152ull << 16 | 216ull << 24 | 69ull << 32 | 57ull << 40 | 161ull << 48 | 244ull << 56,
    160ull << 0 | 51ull << 8 | 235ull << 16 | 45ull << 24 | 129ull << 32 | 125ull << 40 | 3ull << 48 | 119ull << 56,
    242ull << 0 | 64ull << 8 | 164ull << 16 | 99ull << 24 | 229ull << 32 | 230ull << 40 | 188ull << 48 | 248ull << 56,
    71ull << 0 | 66ull << 8 | 44ull << 16 | 225ull << 24 | 242ull << 32 | 209ull << 40 | 23ull << 48 | 107ull << 56 };
// secp256r1_gy
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp_curves.c line 174
static const mbedtls_mpi_uint secp256r1_gy[4ll]={ 245ull << 0 | 81ull << 8 | 191ull << 16 | 55ull << 24 | 104ull << 32 | 64ull << 40 | 182ull << 48 | 203ull << 56,
    206ull << 0 | 94ull << 8 | 49ull << 16 | 107ull << 24 | 87ull << 32 | 51ull << 40 | 206ull << 48 | 43ull << 56,
    22ull << 0 | 158ull << 8 | 15ull << 16 | 124ull << 24 | 74ull << 32 | 235ull << 40 | 231ull << 48 | 142ull << 56,
    155ull << 0 | 127ull << 8 | 26ull << 16 | 254ull << 24 | 226ull << 32 | 66ull << 40 | 227ull << 48 | 79ull << 56 };
// secp256r1_n
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp_curves.c line 180
static const mbedtls_mpi_uint secp256r1_n[4ll]={ 81ull << 0 | 37ull << 8 | 99ull << 16 | 252ull << 24 | 194ull << 32 | 202ull << 40 | 185ull << 48 | 243ull << 56,
    132ull << 0 | 158ull << 8 | 23ull << 16 | 167ull << 24 | 173ull << 32 | 250ull << 40 | 230ull << 48 | 188ull << 56,
    255ull << 0 | 255ull << 8 | 255ull << 16 | 255ull << 24 | 255ull << 32 | 255ull << 40 | 255ull << 48 | 255ull << 56,
    0ull << 0 | 0ull << 8 | 0ull << 16 | 0ull << 24 | 255ull << 32 | 255ull << 40 | 255ull << 48 | 255ull << 56 };
// secp256r1_p
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp_curves.c line 156
static const mbedtls_mpi_uint secp256r1_p[4ll]={ 255ull << 0 | 255ull << 8 | 255ull << 16 | 255ull << 24 | 255ull << 32 | 255ull << 40 | 255ull << 48 | 255ull << 56,
    255ull << 0 | 255ull << 8 | 255ull << 16 | 255ull << 24 | 0ull << 32 | 0ull << 40 | 0ull << 48 | 0ull << 56,
    0ull << 0 | 0ull << 8 | 0ull << 16 | 0ull << 24 | 0ull << 32 | 0ull << 40 | 0ull << 48 | 0ull << 56,
    1ull << 0 | 0ull << 8 | 0ull << 16 | 0ull << 24 | 255ull << 32 | 255ull << 40 | 255ull << 48 | 255ull << 56 };
// sha1_padding
// file ..\..\..\..\lib\third_party\mbedtls\library\sha1.c line 349
static const unsigned char sha1_padding[64ll]={ 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// sha1_test_buf
// file ..\..\..\..\lib\third_party\mbedtls\library\sha1.c line 442
static const unsigned char sha1_test_buf[3ll][57ll]={ { 97, 98, 99, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 97, 98, 99, 100, 98, 99, 100, 101, 99, 100, 101, 102, 100, 101, 102, 103, 101, 102, 103, 104, 102, 103, 104, 105, 103, 104, 105, 106, 104, 105, 106, 107, 105, 106, 107, 108, 106, 107, 108, 109, 107, 108, 109, 110, 108, 109, 110, 111, 109, 110, 111, 112, 110, 111, 112, 113, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } };
// sha1_test_buflen
// file ..\..\..\..\lib\third_party\mbedtls\library\sha1.c line 449
static const size_t sha1_test_buflen[3ll]={ 3ull, 56ull, 1000ull };
// sha1_test_sum
// file ..\..\..\..\lib\third_party\mbedtls\library\sha1.c line 454
static const unsigned char sha1_test_sum[3ll][20ll]={ { 169, 153, 62, 54, 71, 6, 129, 106, 186, 62, 37, 113, 120, 80, 194, 108, 156, 208, 216, 157 },
    { 132, 152, 62, 68, 28, 59, 210, 110, 186, 174, 74, 161, 249, 81, 41, 229, 229, 70, 112, 241 },
    { 52, 170, 151, 60, 212, 196, 218, 164, 246, 30, 235, 43, 219, 173, 39, 49, 101, 52, 1, 111 } };
// sha256_padding
// file ..\..\..\..\lib\third_party\mbedtls\library\sha256.c line 318
static const unsigned char sha256_padding[64ll]={ 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// sha256_test_buf
// file ..\..\..\..\lib\third_party\mbedtls\library\sha256.c line 419
static const unsigned char sha256_test_buf[3ll][57ll]={ { 97, 98, 99, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 97, 98, 99, 100, 98, 99, 100, 101, 99, 100, 101, 102, 100, 101, 102, 103, 101, 102, 103, 104, 102, 103, 104, 105, 103, 104, 105, 106, 104, 105, 106, 107, 105, 106, 107, 108, 106, 107, 108, 109, 107, 108, 109, 110, 108, 109, 110, 111, 109, 110, 111, 112, 110, 111, 112, 113, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } };
// sha256_test_buflen
// file ..\..\..\..\lib\third_party\mbedtls\library\sha256.c line 426
static const size_t sha256_test_buflen[3ll]={ 3ull, 56ull, 1000ull };
// sha256_test_sum
// file ..\..\..\..\lib\third_party\mbedtls\library\sha256.c line 431
static const unsigned char sha256_test_sum[6ll][32ll]={ { 35, 9, 125, 34, 52, 5, 216, 34, 134, 66, 164, 119, 189, 162, 85, 179, 42, 173, 188, 228, 189, 160, 179, 247, 227, 108, 157, 167, 0, 0, 0, 0 },
    { 117, 56, 139, 22, 81, 39, 118, 204, 93, 186, 93, 161, 253, 137, 1, 80, 176, 198, 69, 92, 180, 245, 139, 25, 82, 82, 37, 37, 0, 0, 0, 0 },
    { 32, 121, 70, 85, 152, 12, 145, 216, 187, 180, 193, 234, 151, 97, 138, 75, 240, 63, 66, 88, 25, 72, 178, 238, 78, 231, 173, 103, 0, 0, 0, 0 },
    { 186, 120, 22, 191, 143, 1, 207, 234, 65, 65, 64, 222, 93, 174, 34, 35, 176, 3, 97, 163, 150, 23, 122, 156, 180, 16, 255, 97, 242, 0, 21, 173 },
    { 36, 141, 106, 97, 210, 6, 56, 184, 229, 192, 38, 147, 12, 62, 96, 57, 163, 60, 228, 89, 100, 255, 33, 103, 246, 236, 237, 212, 25, 219, 6, 193 },
    { 205, 199, 110, 92, 153, 20, 251, 146, 129, 161, 199, 226, 132, 215, 62, 103, 241, 128, 154, 72, 164, 151, 32, 14, 4, 109, 57, 204, 199, 17, 44, 208 } };
// small_prime
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 2001
static const signed int small_prime[168ll]={ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, -103 };
// ssl_preset_default_hashes
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7596
static signed int ssl_preset_default_hashes[3ll]={ 6, 5, 0 };
// ssl_preset_suiteb_ciphersuites
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7612
static signed int ssl_preset_suiteb_ciphersuites[3ll]={ 0xC02B, 0xC02C, 0 };
// ssl_preset_suiteb_curves
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7627
static mbedtls_ecp_group_id ssl_preset_suiteb_curves[3ll]={ /*enum*/MBEDTLS_ECP_DP_SECP256R1, /*enum*/MBEDTLS_ECP_DP_SECP384R1, /*enum*/MBEDTLS_ECP_DP_NONE };
// ssl_preset_suiteb_hashes
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7619
static signed int ssl_preset_suiteb_hashes[3ll]={ 6, 7, 0 };
// stJobsNotificationSubscription
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 362
static const MQTTAgentSubscribeParams_t stJobsNotificationSubscription;
// stJobsNotificationSubscription
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 362
static const MQTTAgentSubscribeParams_t stJobsNotificationSubscription={ .pucTopic=(const uint8_t *)acOTA_GetNextAccepted_Topic, .usTopicLength=(uint16_t)(sizeof(const char [67ll]) /*67ull*/  - 1ull),
    .xQoS=/*enum*/eMQTTQoS1,
    .pvPublishCallbackContext=NULL, .pxPublishCallback=prvOTAPublishCallback };
// stJobsNotifyNextSubscription
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 372
static const MQTTAgentSubscribeParams_t stJobsNotifyNextSubscription;
// stJobsNotifyNextSubscription
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 372
static const MQTTAgentSubscribeParams_t stJobsNotifyNextSubscription={ .pucTopic=(const uint8_t *)acOTA_NotifyNext_Topic, .usTopicLength=(uint16_t)(sizeof(const char [60ll]) /*60ull*/  - 1ull),
    .xQoS=/*enum*/eMQTTQoS1,
    .pvPublishCallbackContext=NULL, .pxPublishCallback=prvOTAPublishCallback };
// supported_ciphersuites
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_ciphersuites.c line 1704
static signed int supported_ciphersuites[9ll];
// supported_digests
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 59
static const signed int supported_digests[4ll]={ 6, 5, 4, 0 };
// supported_init
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 68
static signed int supported_init=0;
// supported_init$link1
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_ciphersuites.c line 1705
static signed int supported_init$link1=0;
// tag
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 704
static const unsigned char tag[18ll][16ll]={ { 88, 226, 252, 206, 250, 126, 48, 97, 54, 127, 29, 87, 164, 231, 69, 90 },
    { 171, 110, 71, 212, 44, 236, 19, 189, 245, 58, 103, 178, 18, 87, 189, 223 },
    { 77, 92, 42, 243, 39, 205, 100, 166, 44, 243, 90, 189, 43, 166, 250, 180 },
    { 91, 201, 79, 188, 50, 33, 165, 219, 148, 250, 233, 90, 231, 18, 26, 71 },
    { 54, 18, 210, 231, 158, 59, 7, 133, 86, 27, 225, 74, 172, 162, 252, 203 },
    { 97, 156, 197, 174, 255, 254, 11, 250, 70, 42, 244, 60, 22, 153, 208, 80 },
    { 205, 51, 178, 138, 199, 115, 247, 75, 160, 14, 209, 243, 18, 87, 36, 53 },
    { 47, 245, 141, 128, 3, 57, 39, 171, 142, 244, 212, 88, 117, 20, 240, 251 },
    { 153, 36, 167, 200, 88, 115, 54, 191, 177, 24, 2, 77, 184, 103, 74, 20 },
    { 37, 25, 73, 142, 128, 241, 71, 143, 55, 186, 85, 189, 109, 39, 97, 140 },
    { 101, 220, 197, 127, 207, 98, 58, 36, 9, 79, 204, 164, 13, 53, 51, 248 },
    { 220, 245, 102, 255, 41, 28, 37, 187, 184, 86, 143, 195, 211, 118, 166, 217 },
    { 83, 15, 138, 251, 199, 69, 54, 185, 169, 99, 180, 241, 196, 203, 115, 139 },
    { 208, 209, 200, 167, 153, 153, 107, 240, 38, 91, 152, 181, 212, 138, 185, 25 },
    { 176, 148, 218, 197, 217, 52, 113, 189, 236, 26, 80, 34, 112, 227, 204, 108 },
    { 118, 252, 110, 206, 15, 78, 23, 104, 205, 223, 136, 83, 187, 45, 85, 27 },
    { 58, 51, 125, 191, 70, 167, 146, 196, 94, 69, 73, 19, 254, 46, 168, 242 },
    { 164, 74, 130, 102, 238, 28, 142, 176, 200, 181, 212, 207, 90, 233, 241, 154 } };
// test_offset
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 580
static size_t test_offset;
// test_offset$link1
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 454
static size_t test_offset$link1;
// timestampFrequency
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 85
uint32_t timestampFrequency=0u;
// tlsATS1_ROOT_CERTIFICATE_LENGTH
// file ..\..\..\..\lib\include\private\aws_default_root_certificates.h line 54
static const uint32_t tlsATS1_ROOT_CERTIFICATE_LENGTH=(const uint32_t)sizeof(const char [1189ll]) /*1189u*/ ;
// tlsATS1_ROOT_CERTIFICATE_PEM
// file ..\..\..\..\lib\include\private\aws_default_root_certificates.h line 33
static const char tlsATS1_ROOT_CERTIFICATE_PEM[1189ll]={ '-', '-', '-', '-', '-', 'B', 'E', 'G', 'I', 'N', ' ', 'C', 'E', 'R', 'T', 'I', 'F', 'I', 'C', 'A', 'T', 'E', '-', '-', '-', '-', '-', '\n', 'M', 'I', 'I', 'D', 'Q', 'T', 'C', 'C', 'A', 'i', 'm', 'g', 'A', 'w', 'I', 'B', 'A', 'g', 'I', 'T', 'B', 'm', 'y', 'f', 'z', '5', 'm', '/', 'j', 'A', 'o', '5', '4', 'v', 'B', '4', 'i', 'k', 'P', 'm', 'l', 'j', 'Z', 'b', 'y', 'j', 'A', 'N', 'B', 'g', 'k', 'q', 'h', 'k', 'i', 'G', '9', 'w', '0', 'B', 'A', 'Q', 's', 'F', '\n', 'A', 'D', 'A', '5', 'M', 'Q', 's', 'w', 'C', 'Q', 'Y', 'D', 'V', 'Q', 'Q', 'G', 'E', 'w', 'J', 'V', 'U', 'z', 'E', 'P', 'M', 'A', '0', 'G', 'A', '1', 'U', 'E', 'C', 'h', 'M', 'G', 'Q', 'W', '1', 'h', 'e', 'm', '9', 'u', 'M', 'R', 'k', 'w', 'F', 'w', 'Y', 'D', 'V', 'Q', 'Q', 'D', 'E', 'x', 'B', 'B', 'b', 'W', 'F', '6', '\n', 'b', '2', '4', 'g', 'U', 'm', '9', 'v', 'd', 'C', 'B', 'D', 'Q', 'S', 'A', 'x', 'M', 'B', '4', 'X', 'D', 'T', 'E', '1', 'M', 'D', 'U', 'y', 'N', 'j', 'A', 'w', 'M', 'D', 'A', 'w', 'M', 'F', 'o', 'X', 'D', 'T', 'M', '4', 'M', 'D', 'E', 'x', 'N', 'z', 'A', 'w', 'M', 'D', 'A', 'w', 'M', 'F', 'o', 'w', 'O', 'T', 'E', 'L', '\n', 'M', 'A', 'k', 'G', 'A', '1', 'U', 'E', 'B', 'h', 'M', 'C', 'V', 'V', 'M', 'x', 'D', 'z', 'A', 'N', 'B', 'g', 'N', 'V', 'B', 'A', 'o', 'T', 'B', 'k', 'F', 't', 'Y', 'X', 'p', 'v', 'b', 'j', 'E', 'Z', 'M', 'B', 'c', 'G', 'A', '1', 'U', 'E', 'A', 'x', 'M', 'Q', 'Q', 'W', '1', 'h', 'e', 'm', '9', 'u', 'I', 'F', 'J', 'v', '\n', 'b', '3', 'Q', 'g', 'Q', '0', 'E', 'g', 'M', 'T', 'C', 'C', 'A', 'S', 'I', 'w', 'D', 'Q', 'Y', 'J', 'K', 'o', 'Z', 'I', 'h', 'v', 'c', 'N', 'A', 'Q', 'E', 'B', 'B', 'Q', 'A', 'D', 'g', 'g', 'E', 'P', 'A', 'D', 'C', 'C', 'A', 'Q', 'o', 'C', 'g', 'g', 'E', 'B', 'A', 'L', 'J', '4', 'g', 'H', 'H', 'K', 'e', 'N', 'X', 'j', '\n', 'c', 'a', '9', 'H', 'g', 'F', 'B', '0', 'f', 'W', '7', 'Y', '1', '4', 'h', '2', '9', 'J', 'l', 'o', '9', '1', 'g', 'h', 'Y', 'P', 'l', '0', 'h', 'A', 'E', 'v', 'r', 'A', 'I', 't', 'h', 't', 'O', 'g', 'Q', '3', 'p', 'O', 's', 'q', 'T', 'Q', 'N', 'r', 'o', 'B', 'v', 'o', '3', 'b', 'S', 'M', 'g', 'H', 'F', 'z', 'Z', 'M', '\n', '9', 'O', '6', 'I', 'I', '8', 'c', '+', '6', 'z', 'f', '1', 't', 'R', 'n', '4', 'S', 'W', 'i', 'w', '3', 't', 'e', '5', 'd', 'j', 'g', 'd', 'Y', 'Z', '6', 'k', '/', 'o', 'I', '2', 'p', 'e', 'V', 'K', 'V', 'u', 'R', 'F', '4', 'f', 'n', '9', 't', 'B', 'b', '6', 'd', 'N', 'q', 'c', 'm', 'z', 'U', '5', 'L', '/', 'q', 'w', '\n', 'I', 'F', 'A', 'G', 'b', 'H', 'r', 'Q', 'g', 'L', 'K', 'm', '+', 'a', '/', 's', 'R', 'x', 'm', 'P', 'U', 'D', 'g', 'H', '3', 'K', 'K', 'H', 'O', 'V', 'j', '4', 'u', 't', 'W', 'p', '+', 'U', 'h', 'n', 'M', 'J', 'b', 'u', 'l', 'H', 'h', 'e', 'b', '4', 'm', 'j', 'U', 'c', 'A', 'w', 'h', 'm', 'a', 'h', 'R', 'W', 'a', '6', '\n', 'V', 'O', 'u', 'j', 'w', '5', 'H', '5', 'S', 'N', 'z', '/', '0', 'e', 'g', 'w', 'L', 'X', '0', 't', 'd', 'H', 'A', '1', '1', '4', 'g', 'k', '9', '5', '7', 'E', 'W', 'W', '6', '7', 'c', '4', 'c', 'X', '8', 'j', 'J', 'G', 'K', 'L', 'h', 'D', '+', 'r', 'c', 'd', 'q', 's', 'q', '0', '8', 'p', '8', 'k', 'D', 'i', '1', 'L', '\n', '9', '3', 'F', 'c', 'X', 'm', 'n', '/', '6', 'p', 'U', 'C', 'y', 'z', 'i', 'K', 'r', 'l', 'A', '4', 'b', '9', 'v', '7', 'L', 'W', 'I', 'b', 'x', 'c', 'c', 'e', 'V', 'O', 'F', '3', '4', 'G', 'f', 'I', 'D', '5', 'y', 'H', 'I', '9', 'Y', '/', 'Q', 'C', 'B', '/', 'I', 'I', 'D', 'E', 'g', 'E', 'w', '+', 'O', 'y', 'Q', 'm', '\n', 'j', 'g', 'S', 'u', 'b', 'J', 'r', 'I', 'q', 'g', '0', 'C', 'A', 'w', 'E', 'A', 'A', 'a', 'N', 'C', 'M', 'E', 'A', 'w', 'D', 'w', 'Y', 'D', 'V', 'R', '0', 'T', 'A', 'Q', 'H', '/', 'B', 'A', 'U', 'w', 'A', 'w', 'E', 'B', '/', 'z', 'A', 'O', 'B', 'g', 'N', 'V', 'H', 'Q', '8', 'B', 'A', 'f', '8', 'E', 'B', 'A', 'M', 'C', '\n', 'A', 'Y', 'Y', 'w', 'H', 'Q', 'Y', 'D', 'V', 'R', '0', 'O', 'B', 'B', 'Y', 'E', 'F', 'I', 'Q', 'Y', 'z', 'I', 'U', '0', '7', 'L', 'w', 'M', 'l', 'J', 'Q', 'u', 'C', 'F', 'm', 'c', 'x', '7', 'I', 'Q', 'T', 'g', 'o', 'I', 'M', 'A', '0', 'G', 'C', 'S', 'q', 'G', 'S', 'I', 'b', '3', 'D', 'Q', 'E', 'B', 'C', 'w', 'U', 'A', '\n', 'A', '4', 'I', 'B', 'A', 'Q', 'C', 'Y', '8', 'j', 'd', 'a', 'Q', 'Z', 'C', 'h', 'G', 's', 'V', '2', 'U', 'S', 'g', 'g', 'N', 'i', 'M', 'O', 'r', 'u', 'Y', 'o', 'u', '6', 'r', '4', 'l', 'K', '5', 'I', 'p', 'D', 'B', '/', 'G', '/', 'w', 'k', 'j', 'U', 'u', '0', 'y', 'K', 'G', 'X', '9', 'r', 'b', 'x', 'e', 'n', 'D', 'I', '\n', 'U', '5', 'P', 'M', 'C', 'C', 'j', 'j', 'm', 'C', 'X', 'P', 'I', '6', 'T', '5', '3', 'i', 'H', 'T', 'f', 'I', 'U', 'J', 'r', 'U', '6', 'a', 'd', 'T', 'r', 'C', 'C', '2', 'q', 'J', 'e', 'H', 'Z', 'E', 'R', 'x', 'h', 'l', 'b', 'I', '1', 'B', 'j', 'j', 't', '/', 'm', 's', 'v', '0', 't', 'a', 'd', 'Q', '1', 'w', 'U', 's', '\n', 'N', '+', 'g', 'D', 'S', '6', '3', 'p', 'Y', 'a', 'A', 'C', 'b', 'v', 'X', 'y', '8', 'M', 'W', 'y', '7', 'V', 'u', '3', '3', 'P', 'q', 'U', 'X', 'H', 'e', 'e', 'E', '6', 'V', '/', 'U', 'q', '2', 'V', '8', 'v', 'i', 'T', 'O', '9', '6', 'L', 'X', 'F', 'v', 'K', 'W', 'l', 'J', 'b', 'Y', 'K', '8', 'U', '9', '0', 'v', 'v', '\n', 'o', '/', 'u', 'f', 'Q', 'J', 'V', 't', 'M', 'V', 'T', '8', 'Q', 't', 'P', 'H', 'R', 'h', '8', 'j', 'r', 'd', 'k', 'P', 'S', 'H', 'C', 'a', '2', 'X', 'V', '4', 'c', 'd', 'F', 'y', 'Q', 'z', 'R', '1', 'b', 'l', 'd', 'Z', 'w', 'g', 'J', 'c', 'J', 'm', 'A', 'p', 'z', 'y', 'M', 'Z', 'F', 'o', '6', 'I', 'Q', '6', 'X', 'U', '\n', '5', 'M', 's', 'I', '+', 'y', 'M', 'R', 'Q', '+', 'h', 'D', 'K', 'X', 'J', 'i', 'o', 'a', 'l', 'd', 'X', 'g', 'j', 'U', 'k', 'K', '6', '4', '2', 'M', '4', 'U', 'w', 't', 'B', 'V', '8', 'o', 'b', '2', 'x', 'J', 'N', 'D', 'd', '2', 'Z', 'h', 'w', 'L', 'n', 'o', 'Q', 'd', 'e', 'X', 'e', 'G', 'A', 'D', 'b', 'k', 'p', 'y', '\n', 'r', 'q', 'X', 'R', 'f', 'b', 'o', 'Q', 'n', 'o', 'Z', 's', 'G', '4', 'q', '5', 'W', 'T', 'P', '4', '6', '8', 'S', 'Q', 'v', 'v', 'G', '5', '\n', '-', '-', '-', '-', '-', 'E', 'N', 'D', ' ', 'C', 'E', 'R', 'T', 'I', 'F', 'I', 'C', 'A', 'T', 'E', '-', '-', '-', '-', '-', '\n', 0 };
// tlsVERISIGN_ROOT_CERTIFICATE_LENGTH
// file ..\..\..\..\lib\include\private\aws_default_root_certificates.h line 165
static const uint32_t tlsVERISIGN_ROOT_CERTIFICATE_LENGTH=(const uint32_t)sizeof(const char [1733ll]) /*1733u*/ ;
// tlsVERISIGN_ROOT_CERTIFICATE_LENGTH$link1
// file ..\..\..\..\lib\include\private\aws_default_root_certificates.h line 165
static const uint32_t tlsVERISIGN_ROOT_CERTIFICATE_LENGTH$link1=(const uint32_t)sizeof(const char [1733ll]) /*1733u*/ ;
// tlsVERISIGN_ROOT_CERTIFICATE_PEM
// file ..\..\..\..\lib\include\private\aws_default_root_certificates.h line 136
static const char tlsVERISIGN_ROOT_CERTIFICATE_PEM[1733ll]={ '-', '-', '-', '-', '-', 'B', 'E', 'G', 'I', 'N', ' ', 'C', 'E', 'R', 'T', 'I', 'F', 'I', 'C', 'A', 'T', 'E', '-', '-', '-', '-', '-', '\n', 'M', 'I', 'I', 'E', '0', 'z', 'C', 'C', 'A', '7', 'u', 'g', 'A', 'w', 'I', 'B', 'A', 'g', 'I', 'Q', 'G', 'N', 'r', 'R', 'n', 'i', 'Z', '9', '6', 'L', 't', 'K', 'I', 'V', 'j', 'N', 'z', 'G', 's', '7', 'S', 'j', 'A', 'N', 'B', 'g', 'k', 'q', 'h', 'k', 'i', 'G', '9', 'w', '0', 'B', 'A', 'Q', 'U', 'F', 'A', 'D', 'C', 'B', '\n', 'y', 'j', 'E', 'L', 'M', 'A', 'k', 'G', 'A', '1', 'U', 'E', 'B', 'h', 'M', 'C', 'V', 'V', 'M', 'x', 'F', 'z', 'A', 'V', 'B', 'g', 'N', 'V', 'B', 'A', 'o', 'T', 'D', 'l', 'Z', 'l', 'c', 'm', 'l', 'T', 'a', 'W', 'd', 'u', 'L', 'C', 'B', 'J', 'b', 'm', 'M', 'u', 'M', 'R', '8', 'w', 'H', 'Q', 'Y', 'D', 'V', 'Q', 'Q', 'L', '\n', 'E', 'x', 'Z', 'W', 'Z', 'X', 'J', 'p', 'U', '2', 'l', 'n', 'b', 'i', 'B', 'U', 'c', 'n', 'V', 'z', 'd', 'C', 'B', 'O', 'Z', 'X', 'R', '3', 'b', '3', 'J', 'r', 'M', 'T', 'o', 'w', 'O', 'A', 'Y', 'D', 'V', 'Q', 'Q', 'L', 'E', 'z', 'E', 'o', 'Y', 'y', 'k', 'g', 'M', 'j', 'A', 'w', 'N', 'i', 'B', 'W', 'Z', 'X', 'J', 'p', '\n', 'U', '2', 'l', 'n', 'b', 'i', 'w', 'g', 'S', 'W', '5', 'j', 'L', 'i', 'A', 't', 'I', 'E', 'Z', 'v', 'c', 'i', 'B', 'h', 'd', 'X', 'R', 'o', 'b', '3', 'J', 'p', 'e', 'm', 'V', 'k', 'I', 'H', 'V', 'z', 'Z', 'S', 'B', 'v', 'b', 'm', 'x', '5', 'M', 'U', 'U', 'w', 'Q', 'w', 'Y', 'D', 'V', 'Q', 'Q', 'D', 'E', 'z', 'x', 'W', '\n', 'Z', 'X', 'J', 'p', 'U', '2', 'l', 'n', 'b', 'i', 'B', 'D', 'b', 'G', 'F', 'z', 'c', 'y', 'A', 'z', 'I', 'F', 'B', '1', 'Y', 'm', 'x', 'p', 'Y', 'y', 'B', 'Q', 'c', 'm', 'l', 't', 'Y', 'X', 'J', '5', 'I', 'E', 'N', 'l', 'c', 'n', 'R', 'p', 'Z', 'm', 'l', 'j', 'Y', 'X', 'R', 'p', 'b', '2', '4', 'g', 'Q', 'X', 'V', '0', '\n', 'a', 'G', '9', 'y', 'a', 'X', 'R', '5', 'I', 'C', '0', 'g', 'R', 'z', 'U', 'w', 'H', 'h', 'c', 'N', 'M', 'D', 'Y', 'x', 'M', 'T', 'A', '4', 'M', 'D', 'A', 'w', 'M', 'D', 'A', 'w', 'W', 'h', 'c', 'N', 'M', 'z', 'Y', 'w', 'N', 'z', 'E', '2', 'M', 'j', 'M', '1', 'O', 'T', 'U', '5', 'W', 'j', 'C', 'B', 'y', 'j', 'E', 'L', '\n', 'M', 'A', 'k', 'G', 'A', '1', 'U', 'E', 'B', 'h', 'M', 'C', 'V', 'V', 'M', 'x', 'F', 'z', 'A', 'V', 'B', 'g', 'N', 'V', 'B', 'A', 'o', 'T', 'D', 'l', 'Z', 'l', 'c', 'm', 'l', 'T', 'a', 'W', 'd', 'u', 'L', 'C', 'B', 'J', 'b', 'm', 'M', 'u', 'M', 'R', '8', 'w', 'H', 'Q', 'Y', 'D', 'V', 'Q', 'Q', 'L', 'E', 'x', 'Z', 'W', '\n', 'Z', 'X', 'J', 'p', 'U', '2', 'l', 'n', 'b', 'i', 'B', 'U', 'c', 'n', 'V', 'z', 'd', 'C', 'B', 'O', 'Z', 'X', 'R', '3', 'b', '3', 'J', 'r', 'M', 'T', 'o', 'w', 'O', 'A', 'Y', 'D', 'V', 'Q', 'Q', 'L', 'E', 'z', 'E', 'o', 'Y', 'y', 'k', 'g', 'M', 'j', 'A', 'w', 'N', 'i', 'B', 'W', 'Z', 'X', 'J', 'p', 'U', '2', 'l', 'n', '\n', 'b', 'i', 'w', 'g', 'S', 'W', '5', 'j', 'L', 'i', 'A', 't', 'I', 'E', 'Z', 'v', 'c', 'i', 'B', 'h', 'd', 'X', 'R', 'o', 'b', '3', 'J', 'p', 'e', 'm', 'V', 'k', 'I', 'H', 'V', 'z', 'Z', 'S', 'B', 'v', 'b', 'm', 'x', '5', 'M', 'U', 'U', 'w', 'Q', 'w', 'Y', 'D', 'V', 'Q', 'Q', 'D', 'E', 'z', 'x', 'W', 'Z', 'X', 'J', 'p', '\n', 'U', '2', 'l', 'n', 'b', 'i', 'B', 'D', 'b', 'G', 'F', 'z', 'c', 'y', 'A', 'z', 'I', 'F', 'B', '1', 'Y', 'm', 'x', 'p', 'Y', 'y', 'B', 'Q', 'c', 'm', 'l', 't', 'Y', 'X', 'J', '5', 'I', 'E', 'N', 'l', 'c', 'n', 'R', 'p', 'Z', 'm', 'l', 'j', 'Y', 'X', 'R', 'p', 'b', '2', '4', 'g', 'Q', 'X', 'V', '0', 'a', 'G', '9', 'y', '\n', 'a', 'X', 'R', '5', 'I', 'C', '0', 'g', 'R', 'z', 'U', 'w', 'g', 'g', 'E', 'i', 'M', 'A', '0', 'G', 'C', 'S', 'q', 'G', 'S', 'I', 'b', '3', 'D', 'Q', 'E', 'B', 'A', 'Q', 'U', 'A', 'A', '4', 'I', 'B', 'D', 'w', 'A', 'w', 'g', 'g', 'E', 'K', 'A', 'o', 'I', 'B', 'A', 'Q', 'C', 'v', 'J', 'A', 'g', 'I', 'K', 'X', 'o', '1', '\n', 'n', 'm', 'A', 'M', 'q', 'u', 'd', 'L', 'O', '0', '7', 'c', 'f', 'L', 'w', '8', 'R', 'R', 'y', '7', 'K', '+', 'D', '+', 'K', 'Q', 'L', '5', 'V', 'w', 'i', 'j', 'Z', 'I', 'U', 'V', 'J', '/', 'X', 'x', 'r', 'c', 'g', 'x', 'i', 'V', '0', 'i', '6', 'C', 'q', 'q', 'p', 'k', 'K', 'z', 'j', '/', 'i', '5', 'V', 'b', 'e', 'x', '\n', 't', '0', 'u', 'z', '/', 'o', '9', '+', 'B', '1', 'f', 's', '7', '0', 'P', 'b', 'Z', 'm', 'I', 'V', 'Y', 'c', '9', 'g', 'D', 'a', 'T', 'Y', '3', 'v', 'j', 'g', 'w', '2', 'I', 'I', 'P', 'V', 'Q', 'T', '6', '0', 'n', 'K', 'W', 'V', 'S', 'F', 'J', 'u', 'U', 'r', 'j', 'x', 'u', 'f', '6', '/', 'W', 'h', 'k', 'c', 'I', 'z', '\n', 'S', 'd', 'h', 'D', 'Y', '2', 'p', 'S', 'S', '9', 'K', 'P', '6', 'H', 'B', 'R', 'T', 'd', 'G', 'J', 'a', 'X', 'v', 'H', 'c', 'P', 'a', 'z', '3', 'B', 'J', '0', '2', '3', 't', 'd', 'S', '1', 'b', 'T', 'l', 'r', '8', 'V', 'd', '6', 'G', 'w', '9', 'K', 'I', 'l', '8', 'q', '8', 'c', 'k', 'm', 'c', 'Y', '5', 'f', 'Q', 'G', '\n', 'B', 'O', '+', 'Q', 'u', 'e', 'Q', 'A', '5', 'N', '0', '6', 't', 'R', 'n', '/', 'A', 'r', 'r', '0', 'P', 'O', '7', 'g', 'i', '+', 's', '3', 'i', '+', 'z', '0', '1', '6', 'z', 'y', '9', 'v', 'A', '9', 'r', '9', '1', '1', 'k', 'T', 'M', 'Z', 'H', 'R', 'x', 'A', 'y', '3', 'Q', 'k', 'G', 'S', 'G', 'T', '2', 'R', 'T', '+', '\n', 'r', 'C', 'p', 'S', 'x', '4', '/', 'V', 'B', 'E', 'n', 'k', 'j', 'W', 'N', 'H', 'i', 'D', 'x', 'p', 'g', '8', 'v', '+', 'R', '7', '0', 'r', 'f', 'k', '/', 'F', 'l', 'a', '4', 'O', 'n', 'd', 'T', 'R', 'Q', '8', 'B', 'n', 'c', '+', 'M', 'U', 'C', 'H', '7', 'l', 'P', '5', '9', 'z', 'u', 'D', 'M', 'K', 'z', '1', '0', '/', '\n', 'N', 'I', 'e', 'W', 'i', 'u', '5', 'T', '6', 'C', 'U', 'V', 'A', 'g', 'M', 'B', 'A', 'A', 'G', 'j', 'g', 'b', 'I', 'w', 'g', 'a', '8', 'w', 'D', 'w', 'Y', 'D', 'V', 'R', '0', 'T', 'A', 'Q', 'H', '/', 'B', 'A', 'U', 'w', 'A', 'w', 'E', 'B', '/', 'z', 'A', 'O', 'B', 'g', 'N', 'V', 'H', 'Q', '8', 'B', 'A', 'f', '8', 'E', '\n', 'B', 'A', 'M', 'C', 'A', 'Q', 'Y', 'w', 'b', 'Q', 'Y', 'I', 'K', 'w', 'Y', 'B', 'B', 'Q', 'U', 'H', 'A', 'Q', 'w', 'E', 'Y', 'T', 'B', 'f', 'o', 'V', '2', 'g', 'W', 'z', 'B', 'Z', 'M', 'F', 'c', 'w', 'V', 'R', 'Y', 'J', 'a', 'W', '1', 'h', 'Z', '2', 'U', 'v', 'Z', '2', 'l', 'm', 'M', 'C', 'E', 'w', 'H', 'z', 'A', 'H', '\n', 'B', 'g', 'U', 'r', 'D', 'g', 'M', 'C', 'G', 'g', 'Q', 'U', 'j', '+', 'X', 'T', 'G', 'o', 'a', 's', 'j', 'Y', '5', 'r', 'w', '8', '+', 'A', 'a', 't', 'R', 'I', 'G', 'C', 'x', '7', 'G', 'S', '4', 'w', 'J', 'R', 'Y', 'j', 'a', 'H', 'R', '0', 'c', 'D', 'o', 'v', 'L', '2', 'x', 'v', 'Z', '2', '8', 'u', 'd', 'm', 'V', 'y', '\n', 'a', 'X', 'N', 'p', 'Z', '2', '4', 'u', 'Y', '2', '9', 't', 'L', '3', 'Z', 'z', 'b', 'G', '9', 'n', 'b', 'y', '5', 'n', 'a', 'W', 'Y', 'w', 'H', 'Q', 'Y', 'D', 'V', 'R', '0', 'O', 'B', 'B', 'Y', 'E', 'F', 'H', '/', 'T', 'Z', 'a', 'f', 'C', '3', 'e', 'y', '7', '8', 'D', 'A', 'J', '8', '0', 'M', '5', '+', 'g', 'K', 'v', '\n', 'M', 'z', 'E', 'z', 'M', 'A', '0', 'G', 'C', 'S', 'q', 'G', 'S', 'I', 'b', '3', 'D', 'Q', 'E', 'B', 'B', 'Q', 'U', 'A', 'A', '4', 'I', 'B', 'A', 'Q', 'C', 'T', 'J', 'E', 'o', 'w', 'X', '2', 'L', 'P', '2', 'B', 'q', 'Y', 'L', 'z', '3', 'q', '3', 'J', 'k', 't', 'v', 'X', 'f', '2', 'p', 'X', 'k', 'i', 'O', 'O', 'z', 'E', '\n', 'p', '6', 'B', '4', 'E', 'q', '1', 'i', 'D', 'k', 'V', 'w', 'Z', 'M', 'X', 'n', 'l', '2', 'Y', 't', 'm', 'A', 'l', '+', 'X', '6', '/', 'W', 'z', 'C', 'h', 'l', '8', 'g', 'G', 'q', 'C', 'B', 'p', 'H', '3', 'v', 'n', '5', 'f', 'J', 'J', 'a', 'C', 'G', 'k', 'g', 'D', 'd', 'k', '+', 'b', 'W', '4', '8', 'D', 'W', '7', 'Y', '\n', '5', 'g', 'a', 'R', 'Q', 'B', 'i', '5', '+', 'M', 'H', 't', '3', '9', 't', 'B', 'q', 'u', 'C', 'W', 'I', 'M', 'n', 'N', 'Z', 'B', 'U', '4', 'g', 'c', 'm', 'U', '7', 'q', 'K', 'E', 'K', 'Q', 's', 'T', 'b', '4', '7', 'b', 'D', 'N', '0', 'l', 'A', 't', 'u', 'k', 'i', 'x', 'l', 'E', '0', 'k', 'F', '6', 'B', 'W', 'l', 'K', '\n', 'W', 'E', '9', 'g', 'y', 'n', '6', 'C', 'a', 'g', 's', 'C', 'q', 'i', 'U', 'X', 'O', 'b', 'X', 'b', 'f', '+', 'e', 'E', 'Z', 'S', 'q', 'V', 'i', 'r', '2', 'G', '3', 'l', '6', 'B', 'F', 'o', 'M', 't', 'E', 'M', 'z', 'e', '/', 'a', 'i', 'C', 'K', 'm', '0', 'o', 'H', 'w', '0', 'L', 'x', 'O', 'X', 'n', 'G', 'i', 'Y', 'Z', '\n', '4', 'f', 'Q', 'R', 'b', 'x', 'C', '1', 'l', 'f', 'z', 'n', 'Q', 'g', 'U', 'y', '2', '8', '6', 'd', 'U', 'V', '4', 'o', 't', 'p', '6', 'F', '0', '1', 'v', 'v', 'p', 'X', '1', 'F', 'Q', 'H', 'K', 'O', 't', 'w', '5', 'r', 'D', 'g', 'b', '7', 'M', 'z', 'V', 'I', 'c', 'b', 'i', 'd', 'J', '4', 'v', 'E', 'Z', 'V', '8', 'N', '\n', 'h', 'n', 'a', 'c', 'R', 'H', 'r', '2', 'l', 'V', 'z', '2', 'X', 'T', 'I', 'I', 'M', '6', 'R', 'U', 't', 'h', 'g', '/', 'a', 'F', 'z', 'y', 'Q', 'k', 'q', 'F', 'O', 'F', 'S', 'D', 'X', '9', 'H', 'o', 'L', 'P', 'K', 's', 'E', 'd', 'a', 'o', '7', 'W', 'N', 'q', '\n', '-', '-', '-', '-', '-', 'E', 'N', 'D', ' ', 'C', 'E', 'R', 'T', 'I', 'F', 'I', 'C', 'A', 'T', 'E', '-', '-', '-', '-', '-', '\n', 0 };
// tlsVERISIGN_ROOT_CERTIFICATE_PEM$link1
// file ..\..\..\..\lib\include\private\aws_default_root_certificates.h line 136
static const char tlsVERISIGN_ROOT_CERTIFICATE_PEM$link1[1733ll]={ '-', '-', '-', '-', '-', 'B', 'E', 'G', 'I', 'N', ' ', 'C', 'E', 'R', 'T', 'I', 'F', 'I', 'C', 'A', 'T', 'E', '-', '-', '-', '-', '-', '\n', 'M', 'I', 'I', 'E', '0', 'z', 'C', 'C', 'A', '7', 'u', 'g', 'A', 'w', 'I', 'B', 'A', 'g', 'I', 'Q', 'G', 'N', 'r', 'R', 'n', 'i', 'Z', '9', '6', 'L', 't', 'K', 'I', 'V', 'j', 'N', 'z', 'G', 's', '7', 'S', 'j', 'A', 'N', 'B', 'g', 'k', 'q', 'h', 'k', 'i', 'G', '9', 'w', '0', 'B', 'A', 'Q', 'U', 'F', 'A', 'D', 'C', 'B', '\n', 'y', 'j', 'E', 'L', 'M', 'A', 'k', 'G', 'A', '1', 'U', 'E', 'B', 'h', 'M', 'C', 'V', 'V', 'M', 'x', 'F', 'z', 'A', 'V', 'B', 'g', 'N', 'V', 'B', 'A', 'o', 'T', 'D', 'l', 'Z', 'l', 'c', 'm', 'l', 'T', 'a', 'W', 'd', 'u', 'L', 'C', 'B', 'J', 'b', 'm', 'M', 'u', 'M', 'R', '8', 'w', 'H', 'Q', 'Y', 'D', 'V', 'Q', 'Q', 'L', '\n', 'E', 'x', 'Z', 'W', 'Z', 'X', 'J', 'p', 'U', '2', 'l', 'n', 'b', 'i', 'B', 'U', 'c', 'n', 'V', 'z', 'd', 'C', 'B', 'O', 'Z', 'X', 'R', '3', 'b', '3', 'J', 'r', 'M', 'T', 'o', 'w', 'O', 'A', 'Y', 'D', 'V', 'Q', 'Q', 'L', 'E', 'z', 'E', 'o', 'Y', 'y', 'k', 'g', 'M', 'j', 'A', 'w', 'N', 'i', 'B', 'W', 'Z', 'X', 'J', 'p', '\n', 'U', '2', 'l', 'n', 'b', 'i', 'w', 'g', 'S', 'W', '5', 'j', 'L', 'i', 'A', 't', 'I', 'E', 'Z', 'v', 'c', 'i', 'B', 'h', 'd', 'X', 'R', 'o', 'b', '3', 'J', 'p', 'e', 'm', 'V', 'k', 'I', 'H', 'V', 'z', 'Z', 'S', 'B', 'v', 'b', 'm', 'x', '5', 'M', 'U', 'U', 'w', 'Q', 'w', 'Y', 'D', 'V', 'Q', 'Q', 'D', 'E', 'z', 'x', 'W', '\n', 'Z', 'X', 'J', 'p', 'U', '2', 'l', 'n', 'b', 'i', 'B', 'D', 'b', 'G', 'F', 'z', 'c', 'y', 'A', 'z', 'I', 'F', 'B', '1', 'Y', 'm', 'x', 'p', 'Y', 'y', 'B', 'Q', 'c', 'm', 'l', 't', 'Y', 'X', 'J', '5', 'I', 'E', 'N', 'l', 'c', 'n', 'R', 'p', 'Z', 'm', 'l', 'j', 'Y', 'X', 'R', 'p', 'b', '2', '4', 'g', 'Q', 'X', 'V', '0', '\n', 'a', 'G', '9', 'y', 'a', 'X', 'R', '5', 'I', 'C', '0', 'g', 'R', 'z', 'U', 'w', 'H', 'h', 'c', 'N', 'M', 'D', 'Y', 'x', 'M', 'T', 'A', '4', 'M', 'D', 'A', 'w', 'M', 'D', 'A', 'w', 'W', 'h', 'c', 'N', 'M', 'z', 'Y', 'w', 'N', 'z', 'E', '2', 'M', 'j', 'M', '1', 'O', 'T', 'U', '5', 'W', 'j', 'C', 'B', 'y', 'j', 'E', 'L', '\n', 'M', 'A', 'k', 'G', 'A', '1', 'U', 'E', 'B', 'h', 'M', 'C', 'V', 'V', 'M', 'x', 'F', 'z', 'A', 'V', 'B', 'g', 'N', 'V', 'B', 'A', 'o', 'T', 'D', 'l', 'Z', 'l', 'c', 'm', 'l', 'T', 'a', 'W', 'd', 'u', 'L', 'C', 'B', 'J', 'b', 'm', 'M', 'u', 'M', 'R', '8', 'w', 'H', 'Q', 'Y', 'D', 'V', 'Q', 'Q', 'L', 'E', 'x', 'Z', 'W', '\n', 'Z', 'X', 'J', 'p', 'U', '2', 'l', 'n', 'b', 'i', 'B', 'U', 'c', 'n', 'V', 'z', 'd', 'C', 'B', 'O', 'Z', 'X', 'R', '3', 'b', '3', 'J', 'r', 'M', 'T', 'o', 'w', 'O', 'A', 'Y', 'D', 'V', 'Q', 'Q', 'L', 'E', 'z', 'E', 'o', 'Y', 'y', 'k', 'g', 'M', 'j', 'A', 'w', 'N', 'i', 'B', 'W', 'Z', 'X', 'J', 'p', 'U', '2', 'l', 'n', '\n', 'b', 'i', 'w', 'g', 'S', 'W', '5', 'j', 'L', 'i', 'A', 't', 'I', 'E', 'Z', 'v', 'c', 'i', 'B', 'h', 'd', 'X', 'R', 'o', 'b', '3', 'J', 'p', 'e', 'm', 'V', 'k', 'I', 'H', 'V', 'z', 'Z', 'S', 'B', 'v', 'b', 'm', 'x', '5', 'M', 'U', 'U', 'w', 'Q', 'w', 'Y', 'D', 'V', 'Q', 'Q', 'D', 'E', 'z', 'x', 'W', 'Z', 'X', 'J', 'p', '\n', 'U', '2', 'l', 'n', 'b', 'i', 'B', 'D', 'b', 'G', 'F', 'z', 'c', 'y', 'A', 'z', 'I', 'F', 'B', '1', 'Y', 'm', 'x', 'p', 'Y', 'y', 'B', 'Q', 'c', 'm', 'l', 't', 'Y', 'X', 'J', '5', 'I', 'E', 'N', 'l', 'c', 'n', 'R', 'p', 'Z', 'm', 'l', 'j', 'Y', 'X', 'R', 'p', 'b', '2', '4', 'g', 'Q', 'X', 'V', '0', 'a', 'G', '9', 'y', '\n', 'a', 'X', 'R', '5', 'I', 'C', '0', 'g', 'R', 'z', 'U', 'w', 'g', 'g', 'E', 'i', 'M', 'A', '0', 'G', 'C', 'S', 'q', 'G', 'S', 'I', 'b', '3', 'D', 'Q', 'E', 'B', 'A', 'Q', 'U', 'A', 'A', '4', 'I', 'B', 'D', 'w', 'A', 'w', 'g', 'g', 'E', 'K', 'A', 'o', 'I', 'B', 'A', 'Q', 'C', 'v', 'J', 'A', 'g', 'I', 'K', 'X', 'o', '1', '\n', 'n', 'm', 'A', 'M', 'q', 'u', 'd', 'L', 'O', '0', '7', 'c', 'f', 'L', 'w', '8', 'R', 'R', 'y', '7', 'K', '+', 'D', '+', 'K', 'Q', 'L', '5', 'V', 'w', 'i', 'j', 'Z', 'I', 'U', 'V', 'J', '/', 'X', 'x', 'r', 'c', 'g', 'x', 'i', 'V', '0', 'i', '6', 'C', 'q', 'q', 'p', 'k', 'K', 'z', 'j', '/', 'i', '5', 'V', 'b', 'e', 'x', '\n', 't', '0', 'u', 'z', '/', 'o', '9', '+', 'B', '1', 'f', 's', '7', '0', 'P', 'b', 'Z', 'm', 'I', 'V', 'Y', 'c', '9', 'g', 'D', 'a', 'T', 'Y', '3', 'v', 'j', 'g', 'w', '2', 'I', 'I', 'P', 'V', 'Q', 'T', '6', '0', 'n', 'K', 'W', 'V', 'S', 'F', 'J', 'u', 'U', 'r', 'j', 'x', 'u', 'f', '6', '/', 'W', 'h', 'k', 'c', 'I', 'z', '\n', 'S', 'd', 'h', 'D', 'Y', '2', 'p', 'S', 'S', '9', 'K', 'P', '6', 'H', 'B', 'R', 'T', 'd', 'G', 'J', 'a', 'X', 'v', 'H', 'c', 'P', 'a', 'z', '3', 'B', 'J', '0', '2', '3', 't', 'd', 'S', '1', 'b', 'T', 'l', 'r', '8', 'V', 'd', '6', 'G', 'w', '9', 'K', 'I', 'l', '8', 'q', '8', 'c', 'k', 'm', 'c', 'Y', '5', 'f', 'Q', 'G', '\n', 'B', 'O', '+', 'Q', 'u', 'e', 'Q', 'A', '5', 'N', '0', '6', 't', 'R', 'n', '/', 'A', 'r', 'r', '0', 'P', 'O', '7', 'g', 'i', '+', 's', '3', 'i', '+', 'z', '0', '1', '6', 'z', 'y', '9', 'v', 'A', '9', 'r', '9', '1', '1', 'k', 'T', 'M', 'Z', 'H', 'R', 'x', 'A', 'y', '3', 'Q', 'k', 'G', 'S', 'G', 'T', '2', 'R', 'T', '+', '\n', 'r', 'C', 'p', 'S', 'x', '4', '/', 'V', 'B', 'E', 'n', 'k', 'j', 'W', 'N', 'H', 'i', 'D', 'x', 'p', 'g', '8', 'v', '+', 'R', '7', '0', 'r', 'f', 'k', '/', 'F', 'l', 'a', '4', 'O', 'n', 'd', 'T', 'R', 'Q', '8', 'B', 'n', 'c', '+', 'M', 'U', 'C', 'H', '7', 'l', 'P', '5', '9', 'z', 'u', 'D', 'M', 'K', 'z', '1', '0', '/', '\n', 'N', 'I', 'e', 'W', 'i', 'u', '5', 'T', '6', 'C', 'U', 'V', 'A', 'g', 'M', 'B', 'A', 'A', 'G', 'j', 'g', 'b', 'I', 'w', 'g', 'a', '8', 'w', 'D', 'w', 'Y', 'D', 'V', 'R', '0', 'T', 'A', 'Q', 'H', '/', 'B', 'A', 'U', 'w', 'A', 'w', 'E', 'B', '/', 'z', 'A', 'O', 'B', 'g', 'N', 'V', 'H', 'Q', '8', 'B', 'A', 'f', '8', 'E', '\n', 'B', 'A', 'M', 'C', 'A', 'Q', 'Y', 'w', 'b', 'Q', 'Y', 'I', 'K', 'w', 'Y', 'B', 'B', 'Q', 'U', 'H', 'A', 'Q', 'w', 'E', 'Y', 'T', 'B', 'f', 'o', 'V', '2', 'g', 'W', 'z', 'B', 'Z', 'M', 'F', 'c', 'w', 'V', 'R', 'Y', 'J', 'a', 'W', '1', 'h', 'Z', '2', 'U', 'v', 'Z', '2', 'l', 'm', 'M', 'C', 'E', 'w', 'H', 'z', 'A', 'H', '\n', 'B', 'g', 'U', 'r', 'D', 'g', 'M', 'C', 'G', 'g', 'Q', 'U', 'j', '+', 'X', 'T', 'G', 'o', 'a', 's', 'j', 'Y', '5', 'r', 'w', '8', '+', 'A', 'a', 't', 'R', 'I', 'G', 'C', 'x', '7', 'G', 'S', '4', 'w', 'J', 'R', 'Y', 'j', 'a', 'H', 'R', '0', 'c', 'D', 'o', 'v', 'L', '2', 'x', 'v', 'Z', '2', '8', 'u', 'd', 'm', 'V', 'y', '\n', 'a', 'X', 'N', 'p', 'Z', '2', '4', 'u', 'Y', '2', '9', 't', 'L', '3', 'Z', 'z', 'b', 'G', '9', 'n', 'b', 'y', '5', 'n', 'a', 'W', 'Y', 'w', 'H', 'Q', 'Y', 'D', 'V', 'R', '0', 'O', 'B', 'B', 'Y', 'E', 'F', 'H', '/', 'T', 'Z', 'a', 'f', 'C', '3', 'e', 'y', '7', '8', 'D', 'A', 'J', '8', '0', 'M', '5', '+', 'g', 'K', 'v', '\n', 'M', 'z', 'E', 'z', 'M', 'A', '0', 'G', 'C', 'S', 'q', 'G', 'S', 'I', 'b', '3', 'D', 'Q', 'E', 'B', 'B', 'Q', 'U', 'A', 'A', '4', 'I', 'B', 'A', 'Q', 'C', 'T', 'J', 'E', 'o', 'w', 'X', '2', 'L', 'P', '2', 'B', 'q', 'Y', 'L', 'z', '3', 'q', '3', 'J', 'k', 't', 'v', 'X', 'f', '2', 'p', 'X', 'k', 'i', 'O', 'O', 'z', 'E', '\n', 'p', '6', 'B', '4', 'E', 'q', '1', 'i', 'D', 'k', 'V', 'w', 'Z', 'M', 'X', 'n', 'l', '2', 'Y', 't', 'm', 'A', 'l', '+', 'X', '6', '/', 'W', 'z', 'C', 'h', 'l', '8', 'g', 'G', 'q', 'C', 'B', 'p', 'H', '3', 'v', 'n', '5', 'f', 'J', 'J', 'a', 'C', 'G', 'k', 'g', 'D', 'd', 'k', '+', 'b', 'W', '4', '8', 'D', 'W', '7', 'Y', '\n', '5', 'g', 'a', 'R', 'Q', 'B', 'i', '5', '+', 'M', 'H', 't', '3', '9', 't', 'B', 'q', 'u', 'C', 'W', 'I', 'M', 'n', 'N', 'Z', 'B', 'U', '4', 'g', 'c', 'm', 'U', '7', 'q', 'K', 'E', 'K', 'Q', 's', 'T', 'b', '4', '7', 'b', 'D', 'N', '0', 'l', 'A', 't', 'u', 'k', 'i', 'x', 'l', 'E', '0', 'k', 'F', '6', 'B', 'W', 'l', 'K', '\n', 'W', 'E', '9', 'g', 'y', 'n', '6', 'C', 'a', 'g', 's', 'C', 'q', 'i', 'U', 'X', 'O', 'b', 'X', 'b', 'f', '+', 'e', 'E', 'Z', 'S', 'q', 'V', 'i', 'r', '2', 'G', '3', 'l', '6', 'B', 'F', 'o', 'M', 't', 'E', 'M', 'z', 'e', '/', 'a', 'i', 'C', 'K', 'm', '0', 'o', 'H', 'w', '0', 'L', 'x', 'O', 'X', 'n', 'G', 'i', 'Y', 'Z', '\n', '4', 'f', 'Q', 'R', 'b', 'x', 'C', '1', 'l', 'f', 'z', 'n', 'Q', 'g', 'U', 'y', '2', '8', '6', 'd', 'U', 'V', '4', 'o', 't', 'p', '6', 'F', '0', '1', 'v', 'v', 'p', 'X', '1', 'F', 'Q', 'H', 'K', 'O', 't', 'w', '5', 'r', 'D', 'g', 'b', '7', 'M', 'z', 'V', 'I', 'c', 'b', 'i', 'd', 'J', '4', 'v', 'E', 'Z', 'V', '8', 'N', '\n', 'h', 'n', 'a', 'c', 'R', 'H', 'r', '2', 'l', 'V', 'z', '2', 'X', 'T', 'I', 'I', 'M', '6', 'R', 'U', 't', 'h', 'g', '/', 'a', 'F', 'z', 'y', 'Q', 'k', 'q', 'F', 'O', 'F', 'S', 'D', 'X', '9', 'H', 'o', 'L', 'P', 'K', 's', 'E', 'd', 'a', 'o', '7', 'W', 'N', 'q', '\n', '-', '-', '-', '-', '-', 'E', 'N', 'D', ' ', 'C', 'E', 'R', 'T', 'I', 'F', 'I', 'C', 'A', 'T', 'E', '-', '-', '-', '-', '-', '\n', 0 };
// traceErrorMessage
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 88
const char *traceErrorMessage=((const char *)NULL);
// trace_disable_timestamp
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 79
uint32_t trace_disable_timestamp=0u;
// trcExcludedEventCodes
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2153
uint8_t trcExcludedEventCodes[33ll]={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// trcExcludedObjects
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2148
uint8_t trcExcludedObjects[108ll]={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// ucBufferPool
// file ..\..\..\..\lib\bufferpool\aws_bufferpool_static_thread_safe.c line 114
static uint8_t ucBufferPool[8ll][2184ll];
// ucDNSServerAddress
// file ..\common\application_code\main.c line 112
static const uint8_t ucDNSServerAddress[4ll]={ 208, 67, 222, 222 };
// ucGatewayAddress
// file ..\common\application_code\main.c line 105
static const uint8_t ucGatewayAddress[4ll]={ 192, 168, 0, 1 };
// ucHeap
// file ..\..\..\..\lib\FreeRTOS\portable\MemMang\heap_4.c line 64
static uint8_t ucHeap[2097152ll];
// ucIPAddress
// file ..\common\application_code\main.c line 91
static const uint8_t ucIPAddress[4ll]={ 192, 168, 0, 105 };
// ucMACAddress
// file ..\common\application_code\main.c line 134
uint8_t ucMACAddress[6ll]={ 0, 17, 34, 51, 68, 33 };
// ucNetMask
// file ..\common\application_code\main.c line 98
static const uint8_t ucNetMask[4ll]={ 255, 255, 255, 0 };
// ucQueueStorageArea
// file ..\..\..\common\shadow\aws_shadow_lightbulb_on_off.c line 166
static uint8_t ucQueueStorageArea[(signed long long int)(sizeof(ShadowQueueData_t) * 8ul) /*1152ll*/ ];
// uiInEventGroupSetBitsFromISR
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcKernelPort.c line 398
signed int uiInEventGroupSetBitsFromISR=0;
// uiTraceTickCount
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 77
uint32_t uiTraceTickCount=0u;
// ulConnectionCount
// file ..\..\..\common\tcp\aws_simple_tcp_echo_server.c line 91
static uint32_t ulConnectionCount=0u;
// ulConnections
// file ..\..\..\common\tcp\aws_tcp_echo_client_single_task.c line 131
static uint32_t ulConnections[1ll]={ 0u };
// ulCriticalNesting
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 111
static uint32_t ulCriticalNesting=9999ul;
// ulIsrHandler
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 116
static uint32_t (*ulIsrHandler[(signed long long int)(sizeof(uint32_t) * 8ul) /*32ll*/ ])(void)={ ((uint32_t (*)(void))NULL), ((uint32_t (*)(void))NULL), ((uint32_t (*)(void))NULL), ((uint32_t (*)(void))NULL), ((uint32_t (*)(void))NULL), ((uint32_t (*)(void))NULL), ((uint32_t (*)(void))NULL), ((uint32_t (*)(void))NULL), ((uint32_t (*)(void))NULL), ((uint32_t (*)(void))NULL), ((uint32_t (*)(void))NULL), ((uint32_t (*)(void))NULL), ((uint32_t (*)(void))NULL), ((uint32_t (*)(void))NULL), ((uint32_t (*)(void))NULL), ((uint32_t (*)(void))NULL), ((uint32_t (*)(void))NULL), ((uint32_t (*)(void))NULL), ((uint32_t (*)(void))NULL), ((uint32_t (*)(void))NULL), ((uint32_t (*)(void))NULL), ((uint32_t (*)(void))NULL), ((uint32_t (*)(void))NULL), ((uint32_t (*)(void))NULL), ((uint32_t (*)(void))NULL), ((uint32_t (*)(void))NULL), ((uint32_t (*)(void))NULL), ((uint32_t (*)(void))NULL), ((uint32_t (*)(void))NULL), ((uint32_t (*)(void))NULL), ((uint32_t (*)(void))NULL), ((uint32_t (*)(void))NULL) };
// ulOTA_PacketsDropped
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 343
static uint32_t ulOTA_PacketsDropped;
// ulOTA_PacketsProcessed
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 342
static uint32_t ulOTA_PacketsProcessed;
// ulOTA_PacketsQueued
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 341
static uint32_t ulOTA_PacketsQueued;
// ulPendingInterrupts
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 93
static volatile uint32_t ulPendingInterrupts=0ul;
// ulQueueMessageIdentifier
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 264
static uint32_t ulQueueMessageIdentifier=0u;
// ulRxTaskCycles
// file ..\..\..\common\tcp\aws_tcp_echo_client_separate_tasks.c line 98
static uint32_t ulRxTaskCycles=0u;
// ulSizeOfLoggingFile
// file ..\common\application_code\aws_demo_logging.c line 147
static size_t ulSizeOfLoggingFile=0ull;
// ulTaskSwitchedInTime
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 406
static uint32_t ulTaskSwitchedInTime=0ul;
// ulTotalRunTime
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 407
static uint32_t ulTotalRunTime=0ul;
// ulTxRxCycles
// file ..\..\..\common\tcp\aws_tcp_echo_client_single_task.c line 129
static uint32_t ulTxRxCycles[1ll]={ 0u };
// ulTxRxFailures
// file ..\..\..\common\tcp\aws_tcp_echo_client_single_task.c line 130
static uint32_t ulTxRxFailures[1ll]={ 0u };
// ulTxTaskCycles
// file ..\..\..\common\tcp\aws_tcp_echo_client_separate_tasks.c line 98
static uint32_t ulTxTaskCycles=0u;
// ulWinPCAPSendFailures
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 135
static volatile uint32_t ulWinPCAPSendFailures=0u;
// usPacketIdentifier
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 251
uint16_t usPacketIdentifier=0;
// usUsedStackSize
// file ..\..\..\common\tcp\aws_simple_tcp_echo_server.c line 88
static uint16_t usUsedStackSize=0;
// usUserNameLength
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 238
static const uint16_t usUserNameLength=(uint16_t)(sizeof(const char [52ll]) /*52ull*/  - 1ull);
// uxCurrentNumberOfTasks
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 382
static volatile UBaseType_t uxCurrentNumberOfTasks=0u;
// uxDeletedTasksWaitingCleanUp
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 365
static volatile UBaseType_t uxDeletedTasksWaitingCleanUp=0u;
// uxMinimumFreeNetworkBuffers
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\BufferManagement\BufferAllocation_2.c line 78
static size_t uxMinimumFreeNetworkBuffers;
// uxPendedTicks
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 387
static volatile UBaseType_t uxPendedTicks=0u;
// uxSchedulerSuspended
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 402
static volatile UBaseType_t uxSchedulerSuspended=0ul;
// uxTaskNumber
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 390
static UBaseType_t uxTaskNumber=0u;
// uxTopReadyPriority
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 385
static volatile UBaseType_t uxTopReadyPriority=0u;
// vTraceStopHookPtr
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 100
TRACE_STOP_HOOK vTraceStopHookPtr=((TRACE_STOP_HOOK)NULL);
// vWinPcapRecvThreadHandle
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 121
static HANDLE vWinPcapRecvThreadHandle=NULL;
// vWinPcapSendThreadHandle
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 122
static HANDLE vWinPcapSendThreadHandle=NULL;
// x509_crt_verify_strings
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 1519
static const struct x509_crt_verify_string x509_crt_verify_strings[21ll]={ { .code=0x1, .string="The certificate validity has expired" },
    { .code=0x2, .string="The certificate has been revoked (is on a CRL)" },
    { .code=0x4, .string="The certificate Common Name (CN) does not match with the expected CN" },
    { .code=0x8, .string="The certificate is not correctly signed by the trusted CA" },
    { .code=0x10, .string="The CRL is not correctly signed by the trusted CA" },
    { .code=0x20, .string="The CRL is expired" },
    { .code=0x40, .string="Certificate was missing" },
    { .code=0x80, .string="Certificate verification was skipped" },
    { .code=0x100, .string="Other reason (can be used by verify callback)" },
    { .code=0x200, .string="The certificate validity starts in the future" },
    { .code=0x400, .string="The CRL is from the future" },
    { .code=0x800, .string="Usage does not match the keyUsage extension" },
    { .code=0x1000, .string="Usage does not match the extendedKeyUsage extension" },
    { .code=0x2000, .string="Usage does not match the nsCertType extension" },
    { .code=0x4000, .string="The certificate is signed with an unacceptable hash." },
    { .code=0x8000, .string="The certificate is signed with an unacceptable PK alg (eg RSA vs ECDSA)." },
    { .code=0x10000, .string="The certificate is signed with an unacceptable key (eg bad curve, RSA too short)." },
    { .code=0x20000, .string="The CRL is signed with an unacceptable hash." },
    { .code=0x40000, .string="The CRL is signed with an unacceptable PK alg (eg RSA vs ECDSA)." },
    { .code=0x80000, .string="The CRL is signed with an unacceptable key (eg bad curve, RSA too short)." },
    { .code=0, .string=((const char *)NULL) } };
// xARPCache
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_ARP.c line 70
static ARPCacheRow_t xARPCache[6ll];
// xARPTimer
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 293
static IPTimer_t xARPTimer;
// xActiveTimerList1
// file ..\..\..\..\lib\FreeRTOS\timers.c line 131
static List_t xActiveTimerList1;
// xActiveTimerList2
// file ..\..\..\..\lib\FreeRTOS\timers.c line 132
static List_t xActiveTimerList2;
// xAppFirmwareVersion
// file ..\common\application_code\main.c line 60
const AppVersion32_t xAppFirmwareVersion={ .u={ .x={ .usBuild=0, .ucMinor=9, .ucMajor=0 } } };
// xBlockAllocatedBit
// file ..\..\..\..\lib\FreeRTOS\portable\MemMang\heap_4.c line 109
static size_t xBlockAllocatedBit=0ull;
// xBoundTCPSocketsList
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 163
List_t xBoundTCPSocketsList;
// xBoundUDPSocketsList
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 160
List_t xBoundUDPSocketsList;
// xBroadcastMACAddress
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 255
const MACAddress_t xBroadcastMACAddress={ .ucBytes={ 255, 255, 255, 255, 255, 255 } };
// xBufferAllocFixedSize
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\BufferManagement\BufferAllocation_2.c line 89
const BaseType_t xBufferAllocFixedSize=0;
// xClientHandle
// file ..\..\..\common\shadow\aws_shadow_lightbulb_on_off.c line 169
static ShadowClientHandle_t xClientHandle;
// xCommandQueue
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 253
static QueueHandle_t xCommandQueue=NULL;
// xConfigNextworkInterfaceToUse
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 118
static BaseType_t xConfigNextworkInterfaceToUse=2l;
// xDHCPData
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DHCP.c line 242
static DHCPData_t xDHCPData;
// xDHCPTimer
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 295
static IPTimer_t xDHCPTimer;
// xDNSCache
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DNS.c line 153
static DNSCacheRow_t xDNSCache[1ll];
// xDefaultAddressing
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 262
NetworkAddressingParameters_t xDefaultAddressing={ .ulDefaultIPAddress=0u, .ulNetMask=0u, .ulGatewayAddress=0u,
    .ulDNSServerAddress=0u, .ulBroadcastAddress=0u };
// xDefaultPartARPPacketHeader
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_ARP.c line 91
static const uint8_t xDefaultPartARPPacketHeader[38ll]={ 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 8, 6, 0, 1, 8, 0, 6, 4, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// xDefaultPartUDPPacketHeader
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_UDP_IP.c line 56
UDPPacketHeader_t xDefaultPartUDPPacketHeader={ .ucBytes={ 0, 0, 0, 0, 0, 0, 8, 0, 69, 0, 0, 0, 0, 0, 0, 0, 128, 17, 0, 0, 0, 0, 0, 0 } };
// xDelayedTaskList1
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 356
static List_t xDelayedTaskList1;
// xDelayedTaskList2
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 357
static List_t xDelayedTaskList2;
// xDirectPrint
// file ..\common\application_code\aws_demo_logging.c line 140
BaseType_t xDirectPrint=1;
// xDiskFileLoggingUsed
// file ..\common\application_code\aws_demo_logging.c line 125
BaseType_t xDiskFileLoggingUsed=0;
// xEchoMessageBuffer
// file ..\..\..\common\mqtt\aws_hello_world.c line 174
static MessageBufferHandle_t xEchoMessageBuffer=NULL;
// xFreeBuffersList
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\BufferManagement\BufferAllocation_2.c line 75
static List_t xFreeBuffersList;
// xFreeBytesRemaining
// file ..\..\..\..\lib\FreeRTOS\portable\MemMang\heap_4.c line 102
static size_t xFreeBytesRemaining=0ull;
// xHeapStructSize
// file ..\..\..\..\lib\FreeRTOS\portable\MemMang\heap_4.c line 95
static const size_t xHeapStructSize=sizeof(BlockLink_t) /*16ull*/  + (size_t)(8 - 1) & ~7ull;
// xIPTaskHandle
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 273
static TaskHandle_t xIPTaskHandle=NULL;
// xIPTaskInitialised
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 305
static BaseType_t xIPTaskInitialised=0;
// xIdleTaskHandle
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 392
static TaskHandle_t xIdleTaskHandle=NULL;
// xIdleTickCount
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 384
static volatile TickType_t xIdleTickCount=0u;
// xJobDocModel
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1127
static const JobParamDeterminer_t xJobDocModel[16ll];
// xLastGratuitousARPTime
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_ARP.c line 74
static TickType_t xLastGratuitousARPTime=0u;
// xLogStreamBuffer
// file ..\common\application_code\aws_demo_logging.c line 131
static StreamBuffer_t *xLogStreamBuffer=((const StreamBuffer_t *)NULL);
// xLogToFile
// file ..\common\application_code\main.c line 127
const BaseType_t xLogToFile=0;
// xLogToStdout
// file ..\common\application_code\main.c line 127
const BaseType_t xLogToStdout=1;
// xLogToUDP
// file ..\common\application_code\main.c line 127
const BaseType_t xLogToUDP=0;
// xMQTTClientHandle
// file ..\..\..\common\greengrass_connectivity\aws_greengrass_discovery_demo.c line 85
static MQTTAgentHandle_t xMQTTClientHandle;
// xMQTTConnections
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 247
static MQTTBrokerConnection_t xMQTTConnections[4ll];
// xMQTTHandle
// file ..\..\..\common\mqtt\aws_hello_world.c line 179
static MQTTAgentHandle_t xMQTTHandle=NULL;
// xMQTTTaskHandle
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 258
static TaskHandle_t xMQTTTaskHandle=NULL;
// xMaxCommandTime
// file ..\..\..\common\greengrass_connectivity\aws_greengrass_discovery_demo.c line 78
static const TickType_t xMaxCommandTime=(TickType_t)((20000ul * 1000u) / 1000u);
// xMaxCommandTime$link1
// file ..\..\..\common\mqtt\aws_subscribe_publish_loop.c line 212
static const TickType_t xMaxCommandTime$link1=(TickType_t)((1200000ul * 1000u) / 1000u);
// xMinimumEverFreeBytesRemaining
// file ..\..\..\..\lib\FreeRTOS\portable\MemMang\heap_4.c line 103
static size_t xMinimumEverFreeBytesRemaining=0ull;
// xNetworkAddressing
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 258
NetworkAddressingParameters_t xNetworkAddressing={ .ulDefaultIPAddress=0u, .ulNetMask=0u, .ulGatewayAddress=0u,
    .ulDNSServerAddress=0u, .ulBroadcastAddress=0u };
// xNetworkBufferDescriptors
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\BufferManagement\BufferAllocation_2.c line 85
static NetworkBufferDescriptor_t xNetworkBufferDescriptors[60ll];
// xNetworkBufferSemaphore
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\BufferManagement\BufferAllocation_2.c line 92
static SemaphoreHandle_t xNetworkBufferSemaphore=NULL;
// xNetworkDownEventPending
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 267
static BaseType_t xNetworkDownEventPending=0;
// xNetworkEventQueue
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 248
QueueHandle_t xNetworkEventQueue=NULL;
// xNetworkUp
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 283
static BaseType_t xNetworkUp=0;
// xNextTaskUnblockTime
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 391
static volatile TickType_t xNextTaskUnblockTime=0u;
// xNumOfOverflows
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 389
static volatile BaseType_t xNumOfOverflows=0;
// xOTA_EventFlags
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 347
EventGroupHandle_t xOTA_EventFlags=NULL;
// xOTA_MsgQ
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 358
static QueueHandle_t xOTA_MsgQ=NULL;
// xPendingReadyList
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 360
static List_t xPendingReadyList;
// xPortRunning
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 122
static BaseType_t xPortRunning=0;
// xPrintSocket
// file ..\common\application_code\aws_demo_logging.c line 150
Socket_t xPrintSocket=(void *)~0u;
// xPrintUDPAddress
// file ..\common\application_code\aws_demo_logging.c line 151
struct freertos_sockaddr xPrintUDPAddress;
// xProcessedTCPMessage
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 278
static BaseType_t xProcessedTCPMessage;
// xReceiveTimeOut
// file ..\..\..\common\tcp\aws_tcp_echo_client_separate_tasks.c line 94
static const TickType_t xReceiveTimeOut=(TickType_t)((500u * 1000u) / 1000u);
// xReceiveTimeOut$link1
// file ..\..\..\common\tcp\aws_tcp_echo_client_single_task.c line 125
static const TickType_t xReceiveTimeOut$link1=(TickType_t)((2000u * 1000u) / 1000u);
// xRecvBuffer
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 129
static StreamBuffer_t *xRecvBuffer=((const StreamBuffer_t *)NULL);
// xSchedulerRunning
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 386
static volatile BaseType_t xSchedulerRunning=0;
// xSegmentList
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 209
static List_t xSegmentList;
// xSendBuffer
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 128
static StreamBuffer_t *xSendBuffer=((const StreamBuffer_t *)NULL);
// xSendTimeOut
// file ..\..\..\common\tcp\aws_tcp_echo_client_separate_tasks.c line 95
static const TickType_t xSendTimeOut=(TickType_t)((2000u * 1000u) / 1000u);
// xSendTimeOut$link1
// file ..\..\..\common\tcp\aws_tcp_echo_client_single_task.c line 126
static const TickType_t xSendTimeOut$link1=(TickType_t)((2000u * 1000u) / 1000u);
// xShadowTaskParamBuffer
// file ..\..\..\common\shadow\aws_shadow_lightbulb_on_off.c line 171
static ShadowTaskParam_t xShadowTaskParamBuffer[4ll];
// xSocketPassingQueue
// file ..\..\..\common\tcp\aws_tcp_echo_client_separate_tasks.c line 102
static QueueHandle_t xSocketPassingQueue=NULL;
// xStart
// file ..\..\..\..\lib\FreeRTOS\portable\MemMang\heap_4.c line 98
static BlockLink_t xStart;
// xStaticQueue
// file ..\..\..\common\shadow\aws_shadow_lightbulb_on_off.c line 165
static StaticQueue_t xStaticQueue;
// xStdoutLoggingUsed
// file ..\common\application_code\aws_demo_logging.c line 124
BaseType_t xStdoutLoggingUsed=1;
// xSuspendedTaskList
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 371
static List_t xSuspendedTaskList;
// xSyncEventGroup
// file ..\..\..\common\tcp\aws_tcp_echo_client_separate_tasks.c line 106
static EventGroupHandle_t xSyncEventGroup=NULL;
// xTCPSegments
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 204
static TCPSegment_t *xTCPSegments=((TCPSegment_t *)NULL);
// xTCPTimer
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 298
static IPTimer_t xTCPTimer;
// xTCPWindowLoggingLevel
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 213
BaseType_t xTCPWindowLoggingLevel=0;
// xTasksWaitingTermination
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 364
static List_t xTasksWaitingTermination;
// xTickCount
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 383
static volatile TickType_t xTickCount=0u;
// xTimeBetweenPublish
// file ..\..\..\common\greengrass_connectivity\aws_greengrass_discovery_demo.c line 79
static const TickType_t xTimeBetweenPublish=(TickType_t)((1500ul * 1000u) / 1000u);
// xTimerQueue
// file ..\..\..\..\lib\FreeRTOS\timers.c line 137
static QueueHandle_t xTimerQueue=NULL;
// xTimerTaskHandle
// file ..\..\..\..\lib\FreeRTOS\timers.c line 138
static TaskHandle_t xTimerTaskHandle=NULL;
// xTraceRunning
// file ..\common\application_code\main.c line 148
static BaseType_t xTraceRunning=1;
// xUDPLoggingUsed
// file ..\common\application_code\aws_demo_logging.c line 126
BaseType_t xUDPLoggingUsed=0;
// xUpdateQueue
// file ..\..\..\common\shadow\aws_shadow_lightbulb_on_off.c line 164
static QueueHandle_t xUpdateQueue=NULL;
// xYieldPending
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 388
static volatile BaseType_t xYieldPending=0;

// App_OTACompleteCallback
// file ..\..\..\common\ota\aws_ota_update_demo.c line 143
static void App_OTACompleteCallback(OTA_ImageState_t eState)
{
  if((signed int)eState == 2)
    OTA_ActivateNewImage();

  else
    if(!((signed int)eState == 3))
    {
      if((signed int)eState == 1)
        OTA_SetImageState(/*enum*/eOTA_ImageState_Accepted);

    }

}

// BUFFERPOOL_GetFreeBuffer
// file ..\..\..\..\lib\bufferpool\aws_bufferpool_static_thread_safe.c line 133
uint8_t * BUFFERPOOL_GetFreeBuffer(uint32_t *pulBufferLength)
{
  BaseType_t x=0;
  uint8_t *pucFreeBuffer=((uint8_t *)NULL);
  if(!(*pulBufferLength >= 2177u))
  {
    x = 0;
    for( ; !(x >= 8); x = x + 1l)
    {
      vPortEnterCritical();
      if((signed int)((BufferMetadata_t *)((uint8_t *)(sizeof(BufferMetadata_t) * 8ul /*8ul*/  + (unsigned long int)ucBufferPool[(signed long long int)x] & 18446744073709551608ull) + -1ll))->ucBufferInUse == 0)
      {
        ((BufferMetadata_t *)((uint8_t *)((size_t)((uint8_t *)(ucBufferPool[(signed long long int)x] + (signed long long int)sizeof(BufferMetadata_t) /*1ll*/ ) + (signed long long int)(8 - 1)) & ~7ull) - (signed long long int)sizeof(BufferMetadata_t) /*1ll*/ ))->ucBufferInUse = 1;
        vPortExitCritical();
        *pulBufferLength = (uint32_t)(2048 + 128);
        pucFreeBuffer = (uint8_t *)((size_t)((uint8_t *)(ucBufferPool[(signed long long int)x] + (signed long long int)sizeof(BufferMetadata_t) /*1ll*/ ) + (signed long long int)(8 - 1)) & ~7ull);
        break;
      }

      else
        vPortExitCritical();
    }
  }

  return pucFreeBuffer;
}

// BUFFERPOOL_Init
// file ..\..\..\..\lib\bufferpool\aws_bufferpool_static_thread_safe.c line 117
extern BaseType_t BUFFERPOOL_Init(void)
{
  BaseType_t x=0;
  x = 0;
  for( ; !(x >= 8); x = x + 1l)
    ((BufferMetadata_t *)((uint8_t *)((size_t)((uint8_t *)(ucBufferPool[(signed long long int)x] + (signed long long int)sizeof(BufferMetadata_t) /*1ll*/ ) + (signed long long int)(8 - 1)) & ~7ull) - (signed long long int)sizeof(BufferMetadata_t) /*1ll*/ ))->ucBufferInUse = 0;
  return 1;
}

// BUFFERPOOL_ReturnBuffer
// file ..\..\..\..\lib\bufferpool\aws_bufferpool_static_thread_safe.c line 181
void BUFFERPOOL_ReturnBuffer(uint8_t * const pucBuffer)
{
  vPortEnterCritical();
  ((BufferMetadata_t *)(pucBuffer - (signed long long int)sizeof(BufferMetadata_t) /*1ll*/ ))->ucBufferInUse = 0;
  vPortExitCritical();
}

// CRYPTO_ConfigureHeap
// file ..\..\..\..\lib\crypto\aws_crypto.c line 144
void CRYPTO_ConfigureHeap(void)
{
  mbedtls_platform_set_calloc_free(prvCalloc, vPortFree);
}

// CRYPTO_SignatureVerificationFinal
// file ..\..\..\..\lib\crypto\aws_crypto.c line 225
BaseType_t CRYPTO_SignatureVerificationFinal(void *pvContext, char *pcSignerCertificate, size_t xSignerCertificateLength, uint8_t *pucSignature, size_t xSignatureLength)
{
  BaseType_t xResult=1;
  SignatureVerificationStatePtr_t pxCtx=(SignatureVerificationStatePtr_t)pvContext;
  uint8_t ucSHA1[20ll];
  uint8_t ucSHA256[32ll];
  uint8_t *pucHash=((uint8_t *)NULL);
  size_t xHashLength=0ull;
  if(pxCtx->xHashAlgorithm == 1)
  {
    mbedtls_sha1_finish_ret(&pxCtx->xSHA1Context, ucSHA1);
    pucHash = ucSHA1;
    xHashLength = 20ull;
  }

  else
  {
    mbedtls_sha256_finish_ret(&pxCtx->xSHA256Context, ucSHA256);
    pucHash = ucSHA256;
    xHashLength = 32ull;
  }
  xResult=prvVerifySignature(pcSignerCertificate, xSignerCertificateLength, pxCtx->xHashAlgorithm, pucHash, xHashLength, pucSignature, xSignatureLength);
  vPortFree((void *)pxCtx);
  return xResult;
}

// CRYPTO_SignatureVerificationStart
// file ..\..\..\..\lib\crypto\aws_crypto.c line 155
BaseType_t CRYPTO_SignatureVerificationStart(void **ppvContext, BaseType_t xAsymmetricAlgorithm, BaseType_t xHashAlgorithm)
{
  BaseType_t xResult=1;
  SignatureVerificationStatePtr_t pxCtx=((SignatureVerificationStatePtr_t)NULL);
  void *return_value_pvPortMalloc=pvPortMalloc(sizeof(struct SignatureVerificationState) /*208ull*/ );
  pxCtx = (SignatureVerificationStatePtr_t)return_value_pvPortMalloc;
  if(pxCtx == ((SignatureVerificationStatePtr_t)NULL))
    xResult = 0;

  if(xResult == 1)
  {
    *ppvContext = (void *)pxCtx;
    pxCtx->xAsymmetricAlgorithm = xAsymmetricAlgorithm;
    pxCtx->xHashAlgorithm = xHashAlgorithm;
    if(pxCtx->xHashAlgorithm == 1)
    {
      mbedtls_sha1_init(&pxCtx->xSHA1Context);
      mbedtls_sha1_starts_ret(&pxCtx->xSHA1Context);
    }

    else
    {
      mbedtls_sha256_init(&pxCtx->xSHA256Context);
      mbedtls_sha256_starts_ret(&pxCtx->xSHA256Context, 0);
    }
  }

  return xResult;
}

// CRYPTO_SignatureVerificationUpdate
// file ..\..\..\..\lib\crypto\aws_crypto.c line 203
void CRYPTO_SignatureVerificationUpdate(void *pvContext, uint8_t *pucData, size_t xDataLength)
{
  SignatureVerificationStatePtr_t pxCtx=(SignatureVerificationStatePtr_t)pvContext;
  if(pxCtx->xHashAlgorithm == 1)
    mbedtls_sha1_update_ret(&pxCtx->xSHA1Context, pucData, xDataLength);

  else
    mbedtls_sha256_update_ret(&pxCtx->xSHA256Context, pucData, xDataLength);
}

// C_CloseSession
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 656
extern CK_RV C_CloseSession(CK_SESSION_HANDLE xSession)
{
  CK_RV xResult=0x0ul;
  P11SessionPtr_t pxSession=prvSessionPointerFromHandle(xSession);
  if(!(pxSession == ((P11SessionPtr_t)NULL)))
  {
    if(!(pxSession->pxCurrentKey == ((P11KeyPtr_t)NULL)))
      prvFreeKey(pxSession->pxCurrentKey);

    if(!(pxSession->xPublicKey.pk_ctx == NULL))
      mbedtls_pk_free(&pxSession->xPublicKey);

    mbedtls_ctr_drbg_free(&pxSession->xMbedDrbgCtx);
    vPortFree((void *)pxSession);
  }

  else
    xResult = 0xB3ul;
  return xResult;
}

// C_CreateObject
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 693
extern CK_RV C_CreateObject(CK_SESSION_HANDLE xSession, CK_ATTRIBUTE_PTR pxTemplate, CK_ULONG ulCount, CK_OBJECT_HANDLE_PTR pxObject)
{
  CK_RV xResult=0x0ul;
  P11SessionPtr_t pxSession=prvSessionPointerFromHandle(xSession);
  void *pvContext=NULL;
  int32_t lMbedTLSParseResult=~0;
  if(pxTemplate == ((CK_ATTRIBUTE_PTR)NULL) || pxObject == ((CK_OBJECT_HANDLE_PTR)NULL) || !(ulCount >= 3u))
    xResult = 0x7ul;

  if(xResult == 0x0ul)
  {
    _Bool tmp_if_expr;
    if(!(pxTemplate->type == 0x0ul))
      tmp_if_expr = (_Bool)1;

    else
      tmp_if_expr = sizeof(CK_OBJECT_CLASS) /*4ull*/  != (unsigned long long int)(pxTemplate + 0ll)->ulValueLen ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr)
      xResult = 0x7ul;

  }

  signed int return_value_mbedtls_pk_parse_public_key;
  BaseType_t return_value_PKCS11_PAL_SaveFile$0;
  if(xResult == 0x0ul)
    switch(*((uint32_t *)(pxTemplate + 0ll)->pValue))
    {
      case 0x1ul:
      {
        if(!(ulCount == 3u))
        {
          xResult = 0x7ul;
          break;
        }

        if(!((pxTemplate + 1ll)->type == 0x11ul))
        {
          xResult = 0x7ul;
          break;
        }

        pvContext=pvPortMalloc(sizeof(mbedtls_x509_crt) /*552ull*/ );
        if(!(pvContext == NULL))
        {
          mbedtls_x509_crt_init((mbedtls_x509_crt *)pvContext);
          lMbedTLSParseResult=mbedtls_x509_crt_parse((mbedtls_x509_crt *)pvContext, (const unsigned char *)(pxTemplate + 1ll)->pValue, (size_t)(pxTemplate + 1ll)->ulValueLen);
          mbedtls_x509_crt_free((mbedtls_x509_crt *)pvContext);
          vPortFree(pvContext);
        }

        else
        {
          xResult = 0x2ul;
          break;
        }
        if(!(lMbedTLSParseResult == 0))
        {
          xResult = 0x7ul;
          break;
        }

        if(*((uint32_t *)(pxTemplate + 2ll)->pValue) == 1u)
        {
          BaseType_t return_value_PKCS11_PAL_SaveFile=PKCS11_PAL_SaveFile("FreeRTOS_P11_Certificate.dat", (uint8_t *)(pxTemplate + 1ll)->pValue, (pxTemplate + 1ll)->ulValueLen);
          if(return_value_PKCS11_PAL_SaveFile == 0)
          {
            xResult = 0x30ul;
            break;
          }

          else
            *pxObject = 3ul;
        }

        break;
      }
      case 0x2ul:
      {
        if(!(ulCount == 3u))
        {
          xResult = 0x7ul;
          break;
        }

        if(!((pxTemplate + 2ll)->type == 0x11ul))
        {
          xResult = 0x7ul;
          break;
        }

        if(!(pxSession->xPublicKey.pk_ctx == NULL))
          mbedtls_pk_free(&pxSession->xPublicKey);

        return_value_mbedtls_pk_parse_public_key=mbedtls_pk_parse_public_key(&pxSession->xPublicKey, (const unsigned char *)(pxTemplate + 2ll)->pValue, (size_t)(pxTemplate + 2ll)->ulValueLen);
        if(!(return_value_mbedtls_pk_parse_public_key == 0))
          xResult = 0x7ul;

        else
          *pxObject = 1ul;
        break;
      }
      case 0x3ul:
      {
        if(!(ulCount == 4u))
        {
          xResult = 0x7ul;
          break;
        }

        if(!((pxTemplate + 3ll)->type == 0x11ul))
        {
          xResult = 0x7ul;
          break;
        }

        pvContext=pvPortMalloc(sizeof(mbedtls_pk_context) /*16ull*/ );
        if(!(pvContext == NULL))
        {
          mbedtls_pk_init((mbedtls_pk_context *)pvContext);
          lMbedTLSParseResult=mbedtls_pk_parse_key((mbedtls_pk_context *)pvContext, (const unsigned char *)(pxTemplate + 3ll)->pValue, (size_t)(pxTemplate + 3ll)->ulValueLen, ((const unsigned char *)NULL), 0ull);
          mbedtls_pk_free((mbedtls_pk_context *)pvContext);
          vPortFree(pvContext);
        }

        else
        {
          xResult = 0x2ul;
          break;
        }
        if(!(lMbedTLSParseResult == 0))
        {
          xResult = 0x7ul;
          break;
        }

        return_value_PKCS11_PAL_SaveFile$0=PKCS11_PAL_SaveFile("FreeRTOS_P11_Key.dat", (uint8_t *)(pxTemplate + 3ll)->pValue, (pxTemplate + 3ll)->ulValueLen);
        if(return_value_PKCS11_PAL_SaveFile$0 == 0)
        {
          xResult = 0x30ul;
          break;
        }

        else
          *pxObject = 2ul;
        break;
      }
      default:
        xResult = 0x7ul;
    }

  return xResult;
}

// C_DestroyObject
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 901
extern CK_RV C_DestroyObject(CK_SESSION_HANDLE xSession, CK_OBJECT_HANDLE xObject)
{
  P11KeyPtr_t pxKey=(P11KeyPtr_t)xObject;
  (void)xSession;
  if(!(pxKey == ((P11KeyPtr_t)NULL)) && !(xObject == 1u) && !(xObject == 2u) && !(xObject == 3u))
    prvFreeKey(pxKey);

  return 0x0ul;
}

// C_DigestFinal
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 1285
extern CK_RV C_DigestFinal(CK_SESSION_HANDLE xSession, CK_BYTE_PTR pDigest, CK_ULONG_PTR pulDigestLen)
{
  CK_RV xResult=0x0ul;
  P11SessionPtr_t pxSession=prvSessionPointerFromHandle(xSession);
  if(pxSession == ((P11SessionPtr_t)NULL))
    xResult = 0xB3ul;

  else
    if(!(pxSession->xOperationInProgress == 0x250ul))
    {
      xResult = 0x91ul;
      pxSession->xOperationInProgress = 4294967295ul;
    }

  if(xResult == 0x0ul)
  {
    if(pDigest == ((CK_BYTE_PTR)NULL))
      *pulDigestLen = 32ul;

    else
      if(!(*pulDigestLen >= 32u))
        xResult = 0x150ul;

      else
      {
        signed int return_value_mbedtls_sha256_finish_ret=mbedtls_sha256_finish_ret(&pxSession->xSHA256Context, pDigest);
        if(!(return_value_mbedtls_sha256_finish_ret == 0))
          xResult = 0x6ul;

        pxSession->xOperationInProgress = 4294967295ul;
      }
  }

  return xResult;
}

// C_DigestInit
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 1221
extern CK_RV C_DigestInit(CK_SESSION_HANDLE xSession, CK_MECHANISM_PTR pMechanism)
{
  CK_RV xResult=0x0ul;
  P11SessionPtr_t pxSession=prvSessionPointerFromHandle(xSession);
  if(pxSession == ((P11SessionPtr_t)NULL))
    xResult = 0xB3ul;

  if(!(pMechanism->mechanism == 0x250ul))
    xResult = 0x70ul;

  if(xResult == 0x0ul)
  {
    mbedtls_sha256_init(&pxSession->xSHA256Context);
    signed int return_value_mbedtls_sha256_starts_ret=mbedtls_sha256_starts_ret(&pxSession->xSHA256Context, 0);
    if(!(return_value_mbedtls_sha256_starts_ret == 0))
      xResult = 0x6ul;

    else
      pxSession->xOperationInProgress = pMechanism->mechanism;
  }

  return xResult;
}

// C_DigestUpdate
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 1257
extern CK_RV C_DigestUpdate(CK_SESSION_HANDLE xSession, CK_BYTE_PTR pPart, CK_ULONG ulPartLen)
{
  CK_RV xResult=0x0ul;
  P11SessionPtr_t pxSession=prvSessionPointerFromHandle(xSession);
  if(pxSession == ((P11SessionPtr_t)NULL))
    xResult = 0xB3ul;

  else
    if(!(pxSession->xOperationInProgress == 0x250ul))
      xResult = 0x91ul;

  if(xResult == 0x0ul)
  {
    signed int return_value_mbedtls_sha256_update_ret=mbedtls_sha256_update_ret(&pxSession->xSHA256Context, pPart, (size_t)ulPartLen);
    if(!(return_value_mbedtls_sha256_update_ret == 0))
    {
      xResult = 0x6ul;
      pxSession->xOperationInProgress = 4294967295ul;
    }

  }

  return xResult;
}

// C_Finalize
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 491
extern CK_RV C_Finalize(CK_VOID_PTR pvReserved)
{
  CK_RV xResult=0x0ul;
  if(!(pvReserved == NULL))
    xResult = 0x7ul;

  return xResult;
}

// C_FindObjects
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 1105
extern CK_RV C_FindObjects(CK_SESSION_HANDLE xSession, CK_OBJECT_HANDLE_PTR pxObject, CK_ULONG ulMaxObjectCount, CK_ULONG_PTR pulObjectCount)
{
  CK_RV xResult=0x0ul;
  BaseType_t xDone=0;
  P11SessionPtr_t pxSession=prvSessionPointerFromHandle(xSession);
  if(pulObjectCount == ((CK_ULONG_PTR)NULL) || pxObject == ((CK_OBJECT_HANDLE_PTR)NULL))
  {
    xResult = 0x7ul;
    xDone = 1;
  }

  if(xDone == 0)
  {
    if(pxSession->xFindObjectInit == 0)
    {
      xResult = 0x91ul;
      xDone = 1;
    }

  }

  if(xDone == 0 && ulMaxObjectCount == 0u)
  {
    xResult = 0x7ul;
    xDone = 1;
  }

  if(xDone == 0)
  {
    if(pxSession->xFindObjectComplete == 1)
    {
      *pulObjectCount = 0ul;
      xResult = 0x0ul;
      xDone = 1;
    }

  }

  if(xDone == 0)
  {
    if(pxSession->pxCurrentKey == ((P11KeyPtr_t)NULL))
    {
      xResult=prvLoadAndInitializeDefaultCertificateAndKey(pxSession);
      if(!(xResult == 0x0ul))
        xDone = 1;

    }

  }

  if(xDone == 0)
  {
    switch(pxSession->xFindObjectClass)
    {
      case 0x3ul:
      {
        *pxObject = 2ul;
        *pulObjectCount = 1ul;
        break;
      }
      case 0x2ul:
      {
        *pxObject = 1ul;
        *pulObjectCount = 1ul;
        break;
      }
      case 0x1ul:
      {
        *pxObject = 3ul;
        *pulObjectCount = 1ul;
        break;
      }
      default:
      {
        *pxObject = 0ul;
        *pulObjectCount = 0ul;
      }
    }
    pxSession->xFindObjectComplete = 1;
  }

  return xResult;
}

// C_FindObjectsFinal
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 1194
extern CK_RV C_FindObjectsFinal(CK_SESSION_HANDLE xSession)
{
  CK_RV xResult=0x0ul;
  P11SessionPtr_t pxSession=prvSessionPointerFromHandle(xSession);
  if(pxSession->xFindObjectInit == 0)
    xResult = 0x91ul;

  else
  {
    pxSession->xFindObjectInit = 0;
    pxSession->xFindObjectComplete = 0;
    pxSession->xFindObjectClass = 0ul;
  }
  return xResult;
}

// C_FindObjectsInit
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 1070
extern CK_RV C_FindObjectsInit(CK_SESSION_HANDLE xSession, CK_ATTRIBUTE_PTR pxTemplate, CK_ULONG ulCount)
{
  P11SessionPtr_t pxSession=prvSessionPointerFromHandle(xSession);
  CK_RV xResult=0x0ul;
  (void)ulCount;
  if(pxTemplate == ((CK_ATTRIBUTE_PTR)NULL))
    xResult = 0x7ul;

  else
  {
    pxSession->xFindObjectInit = 1;
    pxSession->xFindObjectComplete = 0;
    memcpy((void *)&pxSession->xFindObjectClass, (pxTemplate + 0ll)->pValue, sizeof(CK_OBJECT_CLASS) /*4ull*/ );
  }
  return xResult;
}

// C_GenerateKeyPair
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 1493
extern CK_RV C_GenerateKeyPair(CK_SESSION_HANDLE xSession, CK_MECHANISM_PTR pxMechanism, CK_ATTRIBUTE_PTR pxPublicKeyTemplate, CK_ULONG ulPublicKeyAttributeCount, CK_ATTRIBUTE_PTR pxPrivateKeyTemplate, CK_ULONG ulPrivateKeyAttributeCount, CK_OBJECT_HANDLE_PTR pxPublicKey, CK_OBJECT_HANDLE_PTR pxPrivateKey)
{
  CK_RV xResult=0x0ul;
  P11SessionPtr_t pxSessionObj=prvSessionPointerFromHandle(xSession);
  P11KeyPtr_t pxNewKey=((P11KeyPtr_t)NULL);
  _Bool tmp_if_expr;
  if(!(pxMechanism->mechanism == 0x1040ul))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = 0x100ul != (pxPrivateKeyTemplate + 0ll)->type ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$0;
  if(tmp_if_expr)
    tmp_if_expr$0 = (_Bool)1;

  else
    tmp_if_expr$0 = 0x3ul != *((CK_ULONG *)(pxPrivateKeyTemplate + 0ll)->pValue) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$1;
  if(tmp_if_expr$0)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = 0x100ul != (pxPublicKeyTemplate + 0ll)->type ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = 0x3ul != *((CK_ULONG *)(pxPrivateKeyTemplate + 0ll)->pValue) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$2)
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = 0x180ul != (pxPublicKeyTemplate + 1ll)->type ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$4;
  signed int return_value_strcmp;
  if(tmp_if_expr$3)
    tmp_if_expr$4 = (_Bool)1;

  else
  {
    return_value_strcmp=strcmp("1.2.840.10045.3.1.7", (const char *)(pxPublicKeyTemplate + 1ll)->pValue);
    tmp_if_expr$4 = 0 != return_value_strcmp ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$4)
    xResult = 0x7ul;

  if(xResult == 0u)
  {
    void *return_value_pvPortMalloc=pvPortMalloc(sizeof(P11Key_t) /*680ull*/ );
    pxNewKey = (P11KeyPtr_t)return_value_pvPortMalloc;
    if(pxNewKey == ((P11KeyPtr_t)NULL))
      xResult = 0x2ul;

  }

  if(xResult == 0u)
  {
    memset((void *)pxNewKey, 0, sizeof(P11Key_t) /*680ull*/ );
    const mbedtls_pk_info_t *return_value_mbedtls_pk_info_from_type=mbedtls_pk_info_from_type(/*enum*/MBEDTLS_PK_ECDSA);
    signed int return_value_mbedtls_pk_setup=mbedtls_pk_setup(&pxNewKey->xMbedPkCtx, return_value_mbedtls_pk_info_from_type);
    xResult = (CK_RV)return_value_mbedtls_pk_setup;
  }

  if(xResult == 0u)
  {
    mbedtls_ecdsa_init((mbedtls_ecdsa_context *)pxNewKey->xMbedPkCtx.pk_ctx);
    signed int return_value_mbedtls_ecdsa_genkey=mbedtls_ecdsa_genkey((mbedtls_ecdsa_context *)pxNewKey->xMbedPkCtx.pk_ctx, /*enum*/MBEDTLS_ECP_DP_SECP256R1, mbedtls_ctr_drbg_random, (void *)&pxSessionObj->xMbedDrbgCtx);
    if(!(return_value_mbedtls_ecdsa_genkey == 0))
      xResult = 0x6ul;

  }

  if(xResult == 0u)
    xResult=prvSetupPkcs11SigningForMbedTls(pxSessionObj, pxNewKey);

  if(xResult == 0u)
  {
    if(!(pxSessionObj->pxCurrentKey == ((P11KeyPtr_t)NULL)))
      prvFreeKey(pxSessionObj->pxCurrentKey);

    pxSessionObj->pxCurrentKey = pxNewKey;
    *pxPrivateKey = (CK_OBJECT_HANDLE)pxNewKey;
    pxNewKey = ((P11KeyPtr_t)NULL);
  }

  if(!(pxNewKey == ((P11KeyPtr_t)NULL)))
  {
    mbedtls_pk_free(&pxNewKey->xMbedPkCtx);
    vPortFree((void *)pxNewKey);
  }

  return xResult;
}

// C_GenerateRandom
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 1588
extern CK_RV C_GenerateRandom(CK_SESSION_HANDLE xSession, CK_BYTE_PTR pucRandomData, CK_ULONG ulRandomLen)
{
  CK_RV xResult=0x0ul;
  P11SessionPtr_t pxSessionObj=prvSessionPointerFromHandle(xSession);
  if(pucRandomData == ((CK_BYTE_PTR)NULL) || ulRandomLen == 0u)
    xResult = 0x7ul;

  else
  {
    signed int return_value_mbedtls_ctr_drbg_random=mbedtls_ctr_drbg_random((void *)&pxSessionObj->xMbedDrbgCtx, pucRandomData, (size_t)ulRandomLen);
    if(!(return_value_mbedtls_ctr_drbg_random == 0))
      xResult = 0x6ul;

  }
  return xResult;
}

// C_GetAttributeValue
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 929
extern CK_RV C_GetAttributeValue(CK_SESSION_HANDLE xSession, CK_OBJECT_HANDLE xObject, CK_ATTRIBUTE_PTR pxTemplate, CK_ULONG ulCount)
{
  CK_RV xResult=0x0ul;
  P11SessionPtr_t pxSession=prvSessionPointerFromHandle(xSession);
  CK_VOID_PTR pvAttr=NULL;
  CK_ULONG ulAttrLength=0ul;
  mbedtls_pk_type_t xMbedPkType;
  CK_ULONG xP11KeyType;
  CK_ULONG iAttrib;
  CK_ULONG xKeyBitLen;
  size_t return_value_mbedtls_pk_get_bitlen;
  if(pxTemplate == ((CK_ATTRIBUTE_PTR)NULL))
    xResult = 0x7ul;

  else
  {
    iAttrib = 0ul;
    for( ; xResult == 0x0ul && !(iAttrib >= ulCount); iAttrib = iAttrib + 1ul)
    {
      switch((pxTemplate + (signed long long int)iAttrib)->type)
      {
        case 0x100ul:
        {
          xMbedPkType=mbedtls_pk_get_type(&pxSession->pxCurrentKey->xMbedPkCtx);
          switch((signed int)xMbedPkType)
          {
            case 1:

            case 5:

            case 6:
            {
              xP11KeyType = 0x0ul;
              break;
            }
            case 2:

            case 3:
            {
              xP11KeyType = 0x3ul;
              break;
            }
            case 4:
            {
              xP11KeyType = 0x3ul;
              break;
            }
            default:
              xResult = 0x13ul;
          }
          ulAttrLength = (CK_ULONG)sizeof(CK_ULONG) /*4ul*/ ;
          pvAttr = (CK_VOID_PTR)&xP11KeyType;
          break;
        }
        case 0x11ul:
        {
          switch(xObject)
          {
            case 3ul:
            {
              pvAttr = (CK_VOID_PTR)pxSession->pxCurrentKey->xMbedX509Cli.raw.p;
              ulAttrLength = (CK_ULONG)pxSession->pxCurrentKey->xMbedX509Cli.raw.len;
              break;
            }
            case 1ul:
            {
              pvAttr = (CK_VOID_PTR)&pxSession->xPublicKey;
              ulAttrLength = (CK_ULONG)sizeof(mbedtls_pk_context) /*16ul*/ ;
              break;
            }
            default:
              xResult = 0x7ul;
          }
          break;
        }
        case 0x121ul:

        case 0x133ul:
        {
          return_value_mbedtls_pk_get_bitlen=mbedtls_pk_get_bitlen(&pxSession->pxCurrentKey->xMbedPkCtx);
          xKeyBitLen = (CK_ULONG)return_value_mbedtls_pk_get_bitlen;
          ulAttrLength = (CK_ULONG)sizeof(CK_ULONG) /*4ul*/ ;
          pvAttr = (CK_VOID_PTR)&xKeyBitLen;
          break;
        }
        case 0x80000000ul:
        {
          ulAttrLength = (CK_ULONG)sizeof(mbedtls_pk_context) /*16ul*/ ;
          pvAttr = (CK_VOID_PTR)&pxSession->pxCurrentKey->xMbedPkCtx;
          break;
        }
        default:
          xResult = 0x12ul;
      }
      if(xResult == 0x0ul)
      {
        if(!((pxTemplate + (signed long long int)iAttrib)->pValue == NULL))
        {
          if(!((pxTemplate + (signed long long int)iAttrib)->ulValueLen >= ulAttrLength))
            xResult = 0x150ul;

          else
            memcpy((pxTemplate + (signed long long int)iAttrib)->pValue, pvAttr, (size_t)ulAttrLength);
        }

        (pxTemplate + (signed long long int)iAttrib)->ulValueLen = ulAttrLength;
      }

    }
  }
  return xResult;
}

// C_GetFunctionList
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 506
extern CK_RV C_GetFunctionList(CK_FUNCTION_LIST_PTR_PTR ppxFunctionList)
{
  CK_RV xResult=0x0ul;
  if(ppxFunctionList == ((CK_FUNCTION_LIST_PTR_PTR)NULL))
    xResult = 0x7ul;

  else
    *ppxFunctionList = &prvP11FunctionList;
  return xResult;
}

// C_GetSlotList
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 525
extern CK_RV C_GetSlotList(CK_BBOOL xTokenPresent, CK_SLOT_ID_PTR pxSlotList, CK_ULONG_PTR pulCount)
{
  CK_RV xResult=0x0ul;
  (void)xTokenPresent;
  if(pulCount == ((CK_ULONG_PTR)NULL))
    xResult = 0x7ul;

  else
    if(pxSlotList == ((CK_SLOT_ID_PTR)NULL))
      *pulCount = 1ul;

    else
      if(*pulCount == 0u)
        xResult = 0x150ul;

      else
      {
        pxSlotList[0ll] = 1ul;
        *pulCount = 1ul;
      }
  return xResult;
}

// C_Initialize
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 477
extern CK_RV C_Initialize(CK_VOID_PTR pvInitArgs)
{
  (void)pvInitArgs;
  CRYPTO_ConfigureHeap();
  return 0x0ul;
}

// C_OpenSession
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 560
extern CK_RV C_OpenSession(CK_SLOT_ID xSlotID, CK_FLAGS xFlags, CK_VOID_PTR pvApplication, CK_NOTIFY xNotify, CK_SESSION_HANDLE_PTR pxSession)
{
  CK_RV xResult=0x0ul;
  P11SessionPtr_t pxSessionObj=((P11SessionPtr_t)NULL);
  (void)xSlotID;
  (void)pvApplication;
  (void)xNotify;
  if(pxSession == ((CK_SESSION_HANDLE_PTR)NULL))
    xResult = 0x7ul;

  if((0x4ul & xFlags) == 0u)
    xResult = 0xB4ul;

  if(xResult == 0x0ul)
  {
    void *return_value_pvPortMalloc=pvPortMalloc(sizeof(P11Session_t) /*1424ull*/ );
    pxSessionObj = (P11SessionPtr_t)return_value_pvPortMalloc;
    if(pxSessionObj == ((P11SessionPtr_t)NULL))
      xResult = 0x2ul;

  }

  if(xResult == 0x0ul)
  {
    memset((void *)pxSessionObj, 0, sizeof(P11Session_t) /*1424ull*/ );
    mbedtls_entropy_init(&pxSessionObj->xMbedEntropyContext);
    mbedtls_ctr_drbg_init(&pxSessionObj->xMbedDrbgCtx);
    signed int return_value_mbedtls_ctr_drbg_seed=mbedtls_ctr_drbg_seed(&pxSessionObj->xMbedDrbgCtx, mbedtls_entropy_func, (void *)&pxSessionObj->xMbedEntropyContext, ((const unsigned char *)NULL), 0ull);
    if(!(return_value_mbedtls_ctr_drbg_seed == 0))
      xResult = 0x6ul;

  }

  if(xResult == 0x0ul)
  {
    pxSessionObj->ulState = 0u != (xFlags & 0x2ul) ? 2ul : 0ul;
    pxSessionObj->xOpened = 1;
    *pxSession = (CK_SESSION_HANDLE)pxSessionObj;
  }

  if(xResult == 0x0ul)
    pxSessionObj->xOperationInProgress = 4294967295ul;

  if(!(pxSessionObj == ((P11SessionPtr_t)NULL)) && !(xResult == 0x0ul))
    vPortFree((void *)pxSessionObj);

  return xResult;
}

// C_Sign
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 1354
extern CK_RV C_Sign(CK_SESSION_HANDLE xSession, CK_BYTE_PTR pucData, CK_ULONG ulDataLen, CK_BYTE_PTR pucSignature, CK_ULONG_PTR pulSignatureLen)
{
  CK_RV xResult=0x0ul;
  P11SessionPtr_t pxSessionObj=prvSessionPointerFromHandle(xSession);
  if(pulSignatureLen == ((CK_ULONG_PTR)NULL))
    xResult = 0x7ul;

  if(xResult == 0x0ul)
  {
    if(pucSignature == ((CK_BYTE_PTR)NULL))
      *pulSignatureLen = (CK_ULONG)(2048 / 8);

    else
    {
      if(xResult == 0x0ul)
      {
        if(!(ulDataLen == 32ul))
          xResult = 0x21ul;

      }

      if(xResult == 0x0ul)
      {
        signed int return_value=pxSessionObj->pxCurrentKey->pfnSavedMbedSign(pxSessionObj->pxCurrentKey->pvSavedMbedPkCtx, /*enum*/MBEDTLS_MD_SHA256, pucData, (size_t)ulDataLen, pucSignature, (size_t *)pulSignatureLen, mbedtls_ctr_drbg_random, (void *)&pxSessionObj->xMbedDrbgCtx);
        if(!(return_value == 0))
          xResult = 0x6ul;

      }

    }
  }

  return xResult;
}

// C_SignInit
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 1333
extern CK_RV C_SignInit(CK_SESSION_HANDLE xSession, CK_MECHANISM_PTR pxMechanism, CK_OBJECT_HANDLE xKey)
{
  CK_RV xResult=0x0ul;
  (void)xSession;
  (void)xKey;
  if(pxMechanism == ((CK_MECHANISM_PTR)NULL))
    xResult = 0x7ul;

  return xResult;
}

// C_Verify
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 1437
extern CK_RV C_Verify(CK_SESSION_HANDLE xSession, CK_BYTE_PTR pucData, CK_ULONG ulDataLen, CK_BYTE_PTR pucSignature, CK_ULONG ulSignatureLen)
{
  CK_RV xResult=0x0ul;
  P11SessionPtr_t pxSessionObj;
  if(pucData == ((CK_BYTE_PTR)NULL) || pucSignature == ((CK_BYTE_PTR)NULL))
    xResult = 0x7ul;

  else
  {
    pxSessionObj=prvSessionPointerFromHandle(xSession);
    if(!(pxSessionObj->xPublicKey.pk_ctx == NULL))
    {
      signed int return_value_mbedtls_pk_verify=mbedtls_pk_verify(&pxSessionObj->xPublicKey, /*enum*/MBEDTLS_MD_SHA256, pucData, (size_t)ulDataLen, pucSignature, (size_t)ulSignatureLen);
      if(!(return_value_mbedtls_pk_verify == 0))
        xResult = 0xC0ul;

    }

    else
    {
      signed int return_value=pxSessionObj->pxCurrentKey->xMbedPkInfo.verify_func(pxSessionObj->pxCurrentKey->pvSavedMbedPkCtx, /*enum*/MBEDTLS_MD_SHA256, pucData, (size_t)ulDataLen, pucSignature, (size_t)ulSignatureLen);
      if(!(return_value == 0))
        xResult = 0xC0ul;

    }
  }
  return xResult;
}

// C_VerifyInit
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 1415
extern CK_RV C_VerifyInit(CK_SESSION_HANDLE xSession, CK_MECHANISM_PTR pxMechanism, CK_OBJECT_HANDLE xKey)
{
  CK_RV xResult=0x0ul;
  (void)xSession;
  (void)xKey;
  if(pxMechanism == ((CK_MECHANISM_PTR)NULL))
    xResult = 0x7ul;

  return xResult;
}

// DEMO_RUNNER_RunDemos
// file ..\..\..\common\demo_runner\aws_demo_runner.c line 53
void DEMO_RUNNER_RunDemos(void)
{
  vStartMQTTEchoDemo();
}

// FreeRTOS_ClearARP
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_ARP.c line 618
void FreeRTOS_ClearARP(void)
{
  memset((void *)xARPCache, 0, sizeof(ARPCacheRow_t [6ll]) /*72ull*/ );
}

// FreeRTOS_GetAddressConfiguration
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 1024
void FreeRTOS_GetAddressConfiguration(uint32_t *pulIPAddress, uint32_t *pulNetMask, uint32_t *pulGatewayAddress, uint32_t *pulDNSServerAddress)
{
  if(!(pulIPAddress == ((uint32_t *)NULL)))
    *pulIPAddress = *((uint32_t *)&xDefaultPartUDPPacketHeader.ulWords[(signed long long int)(20ull / sizeof(uint32_t) /*4ull*/ )]);

  if(!(pulNetMask == ((uint32_t *)NULL)))
    *pulNetMask = xNetworkAddressing.ulNetMask;

  if(!(pulGatewayAddress == ((uint32_t *)NULL)))
    *pulGatewayAddress = xNetworkAddressing.ulGatewayAddress;

  if(!(pulDNSServerAddress == ((uint32_t *)NULL)))
    *pulDNSServerAddress = xNetworkAddressing.ulDNSServerAddress;

}

// FreeRTOS_GetDNSServerAddress
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 2215
uint32_t FreeRTOS_GetDNSServerAddress(void)
{
  return xNetworkAddressing.ulDNSServerAddress;
}

// FreeRTOS_GetGatewayAddress
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 2209
uint32_t FreeRTOS_GetGatewayAddress(void)
{
  return xNetworkAddressing.ulGatewayAddress;
}

// FreeRTOS_GetIPAddress
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 2195
uint32_t FreeRTOS_GetIPAddress(void)
{
  return *((uint32_t *)&xDefaultPartUDPPacketHeader.ulWords[(signed long long int)(20ull / sizeof(uint32_t) /*4ull*/ )]);
}

// FreeRTOS_GetLocalAddress
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 1825
size_t FreeRTOS_GetLocalAddress(Socket_t xSocket, struct freertos_sockaddr *pxAddress)
{
  FreeRTOS_Socket_t *pxSocket=(FreeRTOS_Socket_t *)xSocket;
  pxAddress->sin_addr = *((uint32_t *)&xDefaultPartUDPPacketHeader.ulWords[(signed long long int)(20ull / sizeof(uint32_t) /*4ull*/ )]);
  pxAddress->sin_port = (uint16_t)((signed int)pxSocket->usLocalPort << 8u | (signed int)pxSocket->usLocalPort >> 8u);
  return sizeof(struct freertos_sockaddr) /*8ull*/ ;
}

// FreeRTOS_GetMACAddress
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 2234
const uint8_t * FreeRTOS_GetMACAddress(void)
{
  return xDefaultPartUDPPacketHeader.ucBytes;
}

// FreeRTOS_GetNetmask
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 2221
uint32_t FreeRTOS_GetNetmask(void)
{
  return xNetworkAddressing.ulNetMask;
}

// FreeRTOS_GetRemoteAddress
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 3081
BaseType_t FreeRTOS_GetRemoteAddress(Socket_t xSocket, struct freertos_sockaddr *pxAddress)
{
  FreeRTOS_Socket_t *pxSocket=(FreeRTOS_Socket_t *)xSocket;
  BaseType_t xResult;
  if(!(pxSocket->ucProtocol == 6))
    xResult = -22;

  else
  {
    pxAddress->sin_addr = (uint32_t)((uint32_t)pxSocket->u.xTCP.ulRemoteIP << 24 | ((uint32_t)pxSocket->u.xTCP.ulRemoteIP & 0xFF00ul) << 8 | ((uint32_t)pxSocket->u.xTCP.ulRemoteIP & 0xFF0000ul) >> 8 | (uint32_t)pxSocket->u.xTCP.ulRemoteIP >> 24);
    pxAddress->sin_port = (uint16_t)((signed int)pxSocket->u.xTCP.usRemotePort << 8u | (signed int)pxSocket->u.xTCP.usRemotePort >> 8u);
    xResult = (BaseType_t)sizeof(struct freertos_sockaddr) /*8l*/ ;
  }
  return xResult;
}

// FreeRTOS_GetTCPStateName
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 3264
const char * FreeRTOS_GetTCPStateName(UBaseType_t ulState)
{
  if(ulState >= 13ul)
    ulState = (UBaseType_t)(BaseType_t)(sizeof(const char *[13ll]) /*104ull*/  / sizeof(const char *) /*8ull*/ ) - 1u;

  return pcStateNames[(signed long long int)ulState];
}

// FreeRTOS_GetUDPPayloadBuffer
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 788
void * FreeRTOS_GetUDPPayloadBuffer(size_t xRequestedSizeBytes, TickType_t xBlockTimeTicks)
{
  NetworkBufferDescriptor_t *pxNetworkBuffer;
  void *pvReturn;
  if(xBlockTimeTicks >= 5001u)
    xBlockTimeTicks = 5000u / (1000u / 1000u);

  pxNetworkBuffer=pxGetNetworkBufferWithDescriptor(sizeof(UDPPacket_t) /*42ull*/  + xRequestedSizeBytes, xBlockTimeTicks);
  if(!(pxNetworkBuffer == ((NetworkBufferDescriptor_t *)NULL)))
  {
    pxNetworkBuffer->xDataLength = sizeof(UDPPacket_t) /*42ull*/  + xRequestedSizeBytes;
    pvReturn = (void *)&pxNetworkBuffer->pucEthernetBuffer[(signed long long int)sizeof(UDPPacket_t) /*42ll*/ ];
  }

  else
    pvReturn = NULL;
  return (void *)pvReturn;
}

// FreeRTOS_IPInit
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 935
BaseType_t FreeRTOS_IPInit(const uint8_t *FreeRTOS_IPInit$$ucIPAddress, const uint8_t *FreeRTOS_IPInit$$ucNetMask, const uint8_t *FreeRTOS_IPInit$$ucGatewayAddress, const uint8_t *FreeRTOS_IPInit$$ucDNSServerAddress, const uint8_t *FreeRTOS_IPInit$$ucMACAddress)
{
  BaseType_t xReturn=0;
  BaseType_t return_value_xIPIsNetworkTaskReady=xIPIsNetworkTaskReady();
  if(!(return_value_xIPIsNetworkTaskReady == 0))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS-Plus-TCP\\source\\FreeRTOS_IP.c", 940u);

  if(!(xNetworkEventQueue == NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS-Plus-TCP\\source\\FreeRTOS_IP.c", 941u);

  if(!(xIPTaskHandle == NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS-Plus-TCP\\source\\FreeRTOS_IP.c", 942u);

  xNetworkEventQueue=xQueueGenericCreate((UBaseType_t)(60 + 5), (UBaseType_t)sizeof(IPStackEvent_t) /*16ul*/ , 0);
  if(xNetworkEventQueue == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS-Plus-TCP\\source\\FreeRTOS_IP.c", 953u);

  if(!(xNetworkEventQueue == NULL))
  {
    BaseType_t return_value_xNetworkBuffersInitialise=xNetworkBuffersInitialise();
    if(return_value_xNetworkBuffersInitialise == 1)
    {
      xNetworkAddressing.ulDefaultIPAddress = (uint32_t)FreeRTOS_IPInit$$ucIPAddress[3ll] << 24ul | (uint32_t)FreeRTOS_IPInit$$ucIPAddress[2ll] << 16ul | (uint32_t)FreeRTOS_IPInit$$ucIPAddress[1ll] << 8ul | (uint32_t)FreeRTOS_IPInit$$ucIPAddress[0ll];
      xNetworkAddressing.ulNetMask = (uint32_t)FreeRTOS_IPInit$$ucNetMask[3ll] << 24ul | (uint32_t)FreeRTOS_IPInit$$ucNetMask[2ll] << 16ul | (uint32_t)FreeRTOS_IPInit$$ucNetMask[1ll] << 8ul | (uint32_t)FreeRTOS_IPInit$$ucNetMask[0ll];
      xNetworkAddressing.ulGatewayAddress = (uint32_t)FreeRTOS_IPInit$$ucGatewayAddress[3ll] << 24ul | (uint32_t)FreeRTOS_IPInit$$ucGatewayAddress[2ll] << 16ul | (uint32_t)FreeRTOS_IPInit$$ucGatewayAddress[1ll] << 8ul | (uint32_t)FreeRTOS_IPInit$$ucGatewayAddress[0ll];
      xNetworkAddressing.ulDNSServerAddress = (uint32_t)FreeRTOS_IPInit$$ucDNSServerAddress[3ll] << 24ul | (uint32_t)FreeRTOS_IPInit$$ucDNSServerAddress[2ll] << 16ul | (uint32_t)FreeRTOS_IPInit$$ucDNSServerAddress[1ll] << 8ul | (uint32_t)FreeRTOS_IPInit$$ucDNSServerAddress[0ll];
      xNetworkAddressing.ulBroadcastAddress = xNetworkAddressing.ulDefaultIPAddress & xNetworkAddressing.ulNetMask | ~xNetworkAddressing.ulNetMask;
      memcpy((void *)&xDefaultAddressing, (const void *)&xNetworkAddressing, sizeof(NetworkAddressingParameters_t) /*20ull*/ );
      *((uint32_t *)&xDefaultPartUDPPacketHeader.ulWords[(signed long long int)(20ull / sizeof(uint32_t) /*4ull*/ )]) = 0x0ul;
      memcpy((void *)xDefaultPartUDPPacketHeader.ucBytes, (void *)FreeRTOS_IPInit$$ucMACAddress, 6ull);
      xReturn=vNetworkSocketsInit();
      if(xReturn == 1)
        xReturn=xTaskCreate(prvIPTask, "IP-task", (uint16_t)(60 * 5), NULL, (UBaseType_t)(7 - 2), &xIPTaskHandle);

    }

    else
    {
      while((_Bool)0)
        ;
      vQueueDelete(xNetworkEventQueue);
      xNetworkEventQueue = NULL;
    }
  }

  else
    while((_Bool)0)
      ;
  return xReturn;
}

// FreeRTOS_IsNetworkUp
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 2304
BaseType_t FreeRTOS_IsNetworkUp(void)
{
  return xNetworkUp;
}

// FreeRTOS_NetworkDown
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 746
void FreeRTOS_NetworkDown(void)
{
  const TickType_t xDontBlock=0u;
  static const IPStackEvent_t xNetworkDownEvent={ .eEventType=/*enum*/eNetworkDownEvent, .pvData=NULL };
  BaseType_t return_value_xSendEventStructToIPTask=xSendEventStructToIPTask(&xNetworkDownEvent, xDontBlock);
  if(!(return_value_xSendEventStructToIPTask == 1))
    xNetworkDownEventPending = 1;

  else
    xNetworkDownEventPending = 0;
}

// FreeRTOS_NetworkDownFromISR
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 767
BaseType_t FreeRTOS_NetworkDownFromISR(void)
{
  BaseType_t xHigherPriorityTaskWoken=0;
  static const IPStackEvent_t xNetworkDownEvent={ .eEventType=/*enum*/eNetworkDownEvent, .pvData=NULL };
  BaseType_t return_value_xQueueGenericSendFromISR=xQueueGenericSendFromISR(xNetworkEventQueue, (const void *)&xNetworkDownEvent, &xHigherPriorityTaskWoken, 0);
  if(!(return_value_xQueueGenericSendFromISR == 1))
    xNetworkDownEventPending = 1;

  else
    xNetworkDownEventPending = 0;
  return xHigherPriorityTaskWoken;
}

// FreeRTOS_OutputARPRequest
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_ARP.c line 556
void FreeRTOS_OutputARPRequest(uint32_t ulIPAddress)
{
  NetworkBufferDescriptor_t *pxNetworkBuffer=pxGetNetworkBufferWithDescriptor(sizeof(ARPPacket_t) /*42ull*/ , 0u);
  if(!(pxNetworkBuffer == ((NetworkBufferDescriptor_t *)NULL)))
  {
    pxNetworkBuffer->ulIPAddress = ulIPAddress;
    vARPGenerateRequestPacket(pxNetworkBuffer);
    xNetworkInterfaceOutput(pxNetworkBuffer, 1);
  }

}

// FreeRTOS_PrintARPCache
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_ARP.c line 626
void FreeRTOS_PrintARPCache(void)
{
  BaseType_t x;
  BaseType_t xCount=0;
  x = 0;
  for( ; !(x >= 6); x = x + 1l)
    if(!(xARPCache[(signed long long int)x].ulIPAddress == 0ul))
    {
      if((unsigned int)xARPCache[(signed long long int)x].ucAge >= 1u)
      {
        vLoggingPrintf("Arp %2ld: %3u - %16lxip : %02x:%02x:%02x : %02x:%02x:%02x\n", x, xARPCache[(signed long long int)x].ucAge, xARPCache[(signed long long int)x].ulIPAddress, xARPCache[(signed long long int)x].xMACAddress.ucBytes[0ll], xARPCache[(signed long long int)x].xMACAddress.ucBytes[1ll], xARPCache[(signed long long int)x].xMACAddress.ucBytes[2ll], xARPCache[(signed long long int)x].xMACAddress.ucBytes[3ll], xARPCache[(signed long long int)x].xMACAddress.ucBytes[4ll], xARPCache[(signed long long int)x].xMACAddress.ucBytes[5ll]);
        xCount = xCount + 1l;
      }

    }

  vLoggingPrintf("Arp has %ld entries\n", xCount);
}

// FreeRTOS_ReleaseUDPPayloadBuffer
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 925
void FreeRTOS_ReleaseUDPPayloadBuffer(void *pvBuffer)
{
  NetworkBufferDescriptor_t *return_value_pxUDPPayloadBuffer_to_NetworkBuffer=pxUDPPayloadBuffer_to_NetworkBuffer(pvBuffer);
  vReleaseNetworkBufferAndDescriptor(return_value_pxUDPPayloadBuffer_to_NetworkBuffer);
}

// FreeRTOS_SetAddressConfiguration
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 1050
void FreeRTOS_SetAddressConfiguration(const uint32_t *pulIPAddress, const uint32_t *pulNetMask, const uint32_t *pulGatewayAddress, const uint32_t *pulDNSServerAddress)
{
  if(!(pulIPAddress == ((const uint32_t *)NULL)))
    *((uint32_t *)&xDefaultPartUDPPacketHeader.ulWords[(signed long long int)(20ull / sizeof(uint32_t) /*4ull*/ )]) = *pulIPAddress;

  if(!(pulNetMask == ((const uint32_t *)NULL)))
    xNetworkAddressing.ulNetMask = *pulNetMask;

  if(!(pulGatewayAddress == ((const uint32_t *)NULL)))
    xNetworkAddressing.ulGatewayAddress = *pulGatewayAddress;

  if(!(pulDNSServerAddress == ((const uint32_t *)NULL)))
    xNetworkAddressing.ulDNSServerAddress = *pulDNSServerAddress;

}

// FreeRTOS_SetGatewayAddress
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 2246
void FreeRTOS_SetGatewayAddress(uint32_t ulGatewayAddress)
{
  xNetworkAddressing.ulGatewayAddress = ulGatewayAddress;
}

// FreeRTOS_SetIPAddress
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 2202
void FreeRTOS_SetIPAddress(uint32_t ulIPAddress)
{
  *((uint32_t *)&xDefaultPartUDPPacketHeader.ulWords[(signed long long int)(20ull / sizeof(uint32_t) /*4ull*/ )]) = ulIPAddress;
}

// FreeRTOS_SetNetmask
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 2240
void FreeRTOS_SetNetmask(uint32_t ulNetmask)
{
  xNetworkAddressing.ulNetMask = ulNetmask;
}

// FreeRTOS_UpdateMACAddress
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 2227
void FreeRTOS_UpdateMACAddress(const uint8_t *FreeRTOS_UpdateMACAddress$$ucMACAddress)
{
  memcpy((void *)xDefaultPartUDPPacketHeader.ucBytes, (void *)FreeRTOS_UpdateMACAddress$$ucMACAddress, 6ull);
}

// FreeRTOS_accept
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 2078
Socket_t FreeRTOS_accept(Socket_t xServerSocket, struct freertos_sockaddr *pxAddress, uint32_t *pxAddressLength)
{
  FreeRTOS_Socket_t *pxSocket=(FreeRTOS_Socket_t *)xServerSocket;
  FreeRTOS_Socket_t *pxClientSocket=((FreeRTOS_Socket_t *)NULL);
  TickType_t xRemainingTime;
  BaseType_t xTimed=0;
  BaseType_t xAsk=0;
  TimeOut_t xTimeOut;
  IPStackEvent_t xAskEvent;
  BaseType_t return_value_prvValidSocket=prvValidSocket(pxSocket, 6, 1);
  _Bool tmp_if_expr;
  if(return_value_prvValidSocket == 0)
    pxClientSocket = (FreeRTOS_Socket_t *)(void *)~0u;

  else
  {
    if((unsigned int)pxSocket->u.xTCP.bits.bReuseSocket == 0u)
      tmp_if_expr = (signed int)pxSocket->u.xTCP.ucTCPState != 1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr = (_Bool)0;
    if(tmp_if_expr)
      pxClientSocket = (FreeRTOS_Socket_t *)(void *)~0u;

    else
      while((_Bool)1)
      {
        vTaskSuspendAll();
        if((unsigned int)pxSocket->u.xTCP.bits.bReuseSocket == 0u)
          pxClientSocket = pxSocket->u.xTCP.pxPeerSocket;

        else
          pxClientSocket = pxSocket;
        if(!(pxClientSocket == ((FreeRTOS_Socket_t *)NULL)))
        {
          pxSocket->u.xTCP.pxPeerSocket = ((struct XSOCKET *)NULL);
          if(!((unsigned int)pxClientSocket->u.xTCP.bits.bPassAccept == 0u))
            pxClientSocket->u.xTCP.bits.bPassAccept = 0u;

          else
            pxClientSocket = ((FreeRTOS_Socket_t *)NULL);
        }

        xTaskResumeAll();
        if(!(pxClientSocket == ((FreeRTOS_Socket_t *)NULL)))
        {
          if(!(pxAddress == ((struct freertos_sockaddr *)NULL)))
          {
            pxAddress->sin_addr = (uint32_t)((uint32_t)pxClientSocket->u.xTCP.ulRemoteIP << 24 | ((uint32_t)pxClientSocket->u.xTCP.ulRemoteIP & 0xFF00ul) << 8 | ((uint32_t)pxClientSocket->u.xTCP.ulRemoteIP & 0xFF0000ul) >> 8 | (uint32_t)pxClientSocket->u.xTCP.ulRemoteIP >> 24);
            pxAddress->sin_port = (uint16_t)((signed int)pxClientSocket->u.xTCP.usRemotePort << 8u | (signed int)pxClientSocket->u.xTCP.usRemotePort >> 8u);
          }

          if(!(pxAddressLength == ((uint32_t *)NULL)))
            *pxAddressLength = (uint32_t)sizeof(struct freertos_sockaddr) /*8u*/ ;

          if((unsigned int)pxSocket->u.xTCP.bits.bReuseSocket == 0u)
            xAsk = 1;

        }

        if(!(xAsk == 0))
        {
          xAskEvent.eEventType = /*enum*/eTCPAcceptEvent;
          xAskEvent.pvData = (void *)pxSocket;
          xSendEventStructToIPTask(&xAskEvent, 0xFFFFFFFFul);
        }

        if(!(pxClientSocket == ((FreeRTOS_Socket_t *)NULL)))
          break;

        if(xTimed == 0)
        {
          xRemainingTime = pxSocket->xReceiveBlockTime;
          if(xRemainingTime == 0u)
            break;

          xTimed = 1;
          vTaskSetTimeOutState(&xTimeOut);
        }

        BaseType_t return_value_xTaskCheckForTimeOut=xTaskCheckForTimeOut(&xTimeOut, &xRemainingTime);
        if(!(return_value_xTaskCheckForTimeOut == 0))
          break;

        xEventGroupWaitBits(pxSocket->xEventGroup, 4u, 1, 0, xRemainingTime);
      }
  }
  return (Socket_t)pxClientSocket;
}

// FreeRTOS_bind
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 904
BaseType_t FreeRTOS_bind(Socket_t xSocket, struct freertos_sockaddr *pxAddress, uint32_t xAddressLength)
{
  IPStackEvent_t xBindEvent;
  FreeRTOS_Socket_t *pxSocket=(FreeRTOS_Socket_t *)xSocket;
  BaseType_t xReturn=0;
  (void)xAddressLength;
  if(pxSocket == ((FreeRTOS_Socket_t *)NULL) || pxSocket == (FreeRTOS_Socket_t *)4294967295u)
    xReturn = -22;

  else
    if(!(pxSocket->xBoundSocketListItem.pvContainer == NULL))
    {
      while((_Bool)0)
        ;
      xReturn = -22;
    }

    else
    {
      xBindEvent.eEventType = /*enum*/eSocketBindEvent;
      xBindEvent.pvData = (void *)xSocket;
      if(!(pxAddress == ((struct freertos_sockaddr *)NULL)))
        pxSocket->usLocalPort = (uint16_t)((signed int)pxAddress->sin_port << 8u | (signed int)pxAddress->sin_port >> 8u);

      else
        pxSocket->usLocalPort = 0;
      BaseType_t return_value_xSendEventStructToIPTask=xSendEventStructToIPTask(&xBindEvent, 0xFFFFFFFFul);
      if(return_value_xSendEventStructToIPTask == 0)
      {
        while((_Bool)0)
          ;
        xReturn = -140;
      }

      else
      {
        xEventGroupWaitBits(pxSocket->xEventGroup, 16u, 1, 0, 0xFFFFFFFFul);
        if(pxSocket->xBoundSocketListItem.pvContainer == NULL)
          xReturn = -22;

      }
    }
  return xReturn;
}

// FreeRTOS_closesocket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 1087
BaseType_t FreeRTOS_closesocket(Socket_t xSocket)
{
  BaseType_t xResult;
  IPStackEvent_t xCloseEvent;
  xCloseEvent.eEventType = /*enum*/eSocketCloseEvent;
  xCloseEvent.pvData = (void *)xSocket;
  if(xSocket == NULL || xSocket == (void *)4294967295u)
    xResult = 0;

  else
  {
    BaseType_t return_value_xSendEventStructToIPTask=xSendEventStructToIPTask(&xCloseEvent, 0u);
    if(return_value_xSendEventStructToIPTask == 0)
    {
      while((_Bool)0)
        ;
      xResult = -1;
    }

    else
      xResult = 1;
  }
  return xResult;
}

// FreeRTOS_connect
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 2001
BaseType_t FreeRTOS_connect(Socket_t xClientSocket, struct freertos_sockaddr *pxAddress, uint32_t xAddressLength)
{
  FreeRTOS_Socket_t *pxSocket=(FreeRTOS_Socket_t *)xClientSocket;
  TickType_t xRemainingTime;
  BaseType_t xTimed=0;
  BaseType_t xResult;
  TimeOut_t xTimeOut;
  (void)xAddressLength;
  xResult=prvTCPConnectStart(pxSocket, pxAddress);
  if(xResult == 0)
    while((_Bool)1)
    {
      if(xTimed == 0)
      {
        xRemainingTime = pxSocket->xReceiveBlockTime;
        if(xRemainingTime == 0u)
        {
          xResult = -11;
          break;
        }

        xTimed = 1;
        vTaskSetTimeOutState(&xTimeOut);
      }

      xResult=FreeRTOS_issocketconnected((Socket_t)pxSocket);
      if(!(xResult >= 0))
        break;

      if(xResult >= 1)
      {
        xResult = 0;
        break;
      }

      BaseType_t return_value_xTaskCheckForTimeOut=xTaskCheckForTimeOut(&xTimeOut, &xRemainingTime);
      if(!(return_value_xTaskCheckForTimeOut == 0l))
      {
        xResult = -116;
        break;
      }

      xEventGroupWaitBits(pxSocket->xEventGroup, 8u, 1, 0, xRemainingTime);
    }

  return xResult;
}

// FreeRTOS_connstatus
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 3268
BaseType_t FreeRTOS_connstatus(Socket_t xSocket)
{
  FreeRTOS_Socket_t *pxSocket=(FreeRTOS_Socket_t *)xSocket;
  BaseType_t xReturn;
  if(!(pxSocket->ucProtocol == 6))
    xReturn = -22;

  else
    xReturn = (BaseType_t)pxSocket->u.xTCP.ucTCPState;
  return xReturn;
}

// FreeRTOS_dnslookup
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DNS.c line 256
uint32_t FreeRTOS_dnslookup(const char *pcHostName)
{
  uint32_t ulIPAddress=0ul;
  prvProcessDNSCache(pcHostName, &ulIPAddress, 0u, 1);
  return ulIPAddress;
}

// FreeRTOS_get_rx_buf
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 2867
const struct xSTREAM_BUFFER$0 * FreeRTOS_get_rx_buf(Socket_t xSocket)
{
  FreeRTOS_Socket_t *pxSocket=(FreeRTOS_Socket_t *)xSocket;
  return pxSocket->u.xTCP.rxStream;
}

// FreeRTOS_get_tx_head
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 2417
uint8_t * FreeRTOS_get_tx_head(Socket_t xSocket, BaseType_t *pxLength)
{
  uint8_t *pucReturn;
  FreeRTOS_Socket_t *pxSocket=(FreeRTOS_Socket_t *)xSocket;
  const StreamBuffer_t *pxBuffer=pxSocket->u.xTCP.txStream;
  if(!(pxBuffer == ((const StreamBuffer_t *)NULL)))
  {
    BaseType_t xSpace;
    size_t return_value_uxStreamBufferGetSpace=uxStreamBufferGetSpace(pxBuffer);
    xSpace = (BaseType_t)return_value_uxStreamBufferGetSpace;
    BaseType_t xRemain=(BaseType_t)(pxBuffer->LENGTH - pxBuffer->uxHead);
    *pxLength=FreeRTOS_min_BaseType(xSpace, xRemain);
    pucReturn = pxBuffer->ucArray + (signed long long int)pxBuffer->uxHead;
  }

  else
  {
    *pxLength = 0;
    pucReturn = ((uint8_t *)NULL);
  }
  return pucReturn;
}

// FreeRTOS_gethostbyname
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DNS.c line 410
uint32_t FreeRTOS_gethostbyname(const char *pcHostName)
{
  uint32_t ulIPAddress=0ul;
  TickType_t xReadTimeOut_ms=1200u;
  TickType_t xIdentifier=0u;
  ulIPAddress=FreeRTOS_inet_addr(pcHostName);
  if(ulIPAddress == 0ul)
  {
    ulIPAddress=FreeRTOS_dnslookup(pcHostName);
    if(!(ulIPAddress == 0u))
      while((_Bool)0)
        ;

  }

  if(ulIPAddress == 0u)
  {
    uint32_t return_value_ulRand=ulRand();
    xIdentifier = (TickType_t)return_value_ulRand;
  }

  if(ulIPAddress == 0ul && !(xIdentifier == 0u))
    ulIPAddress=prvGetHostByName(pcHostName, xIdentifier, xReadTimeOut_ms);

  return ulIPAddress;
}

// FreeRTOS_inet_addr
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 1736
uint32_t FreeRTOS_inet_addr(const char *pcIPAddress)
{
  const uint32_t ulDecimalBase=10u;
  uint8_t ucOctet[4ll];
  const char *pcPointerOnEntering;
  uint32_t ulReturn=0ul;
  uint32_t ulValue;
  UBaseType_t uxOctetNumber;
  BaseType_t xResult=1;
  uxOctetNumber = 0u;
  for( ; !(uxOctetNumber >= 4u); uxOctetNumber = uxOctetNumber + 1ul)
  {
    ulValue = 0ul;
    pcPointerOnEntering = pcIPAddress;
    for( ; (signed int)*pcIPAddress >= 48; pcIPAddress = pcIPAddress + 1ll)
    {
      if((signed int)*pcIPAddress >= 58)
        break;

      ulValue = ulValue * ulDecimalBase;
      ulValue = ulValue + ((uint32_t)*pcIPAddress - 48u);
    }
    if(pcIPAddress == pcPointerOnEntering)
      xResult = 0;

    if(ulValue >= 256ul)
      xResult = 0;

    else
    {
      ucOctet[(signed long long int)uxOctetNumber] = (uint8_t)ulValue;
      if(!(uxOctetNumber >= 3u))
      {
        if(!((signed int)*pcIPAddress == 46))
          xResult = 0;

        else
          pcIPAddress = pcIPAddress + 1ll;
      }

    }
    if(xResult == 0)
      break;

  }
  if(!(*pcIPAddress == 0))
    xResult = 0;

  if(!(uxOctetNumber == 4u))
    xResult = 0;

  if(xResult == 1)
    ulReturn = (uint32_t)ucOctet[3ll] << 24ul | (uint32_t)ucOctet[2ll] << 16ul | (uint32_t)ucOctet[1ll] << 8ul | (uint32_t)ucOctet[0ll];

  return ulReturn;
}

// FreeRTOS_issocketconnected
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 3213
BaseType_t FreeRTOS_issocketconnected(Socket_t xSocket)
{
  FreeRTOS_Socket_t *pxSocket=(FreeRTOS_Socket_t *)xSocket;
  BaseType_t xReturn=0;
  if(!(pxSocket->ucProtocol == 6))
    xReturn = -22;

  else
    if((signed int)pxSocket->u.xTCP.ucTCPState >= 5)
    {
      if(!((signed int)pxSocket->u.xTCP.ucTCPState >= 8))
        xReturn = 1;

    }

  return xReturn;
}

// FreeRTOS_listen
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 2631
BaseType_t FreeRTOS_listen(Socket_t xSocket, BaseType_t xBacklog)
{
  FreeRTOS_Socket_t *pxSocket;
  BaseType_t xResult=0;
  pxSocket = (FreeRTOS_Socket_t *)xSocket;
  BaseType_t return_value_prvValidSocket=prvValidSocket(pxSocket, 6, 1);
  _Bool tmp_if_expr;
  if(return_value_prvValidSocket == 0)
    xResult = -95;

  else
  {
    if(!((signed int)pxSocket->u.xTCP.ucTCPState == 0))
      tmp_if_expr = (signed int)pxSocket->u.xTCP.ucTCPState != 8 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr = (_Bool)0;
    if(tmp_if_expr)
      xResult = -95;

    else
    {
      int32_t return_value_FreeRTOS_min_int32=FreeRTOS_min_int32(0xFFFF, (int32_t)xBacklog);
      pxSocket->u.xTCP.usBacklog = (uint16_t)return_value_FreeRTOS_min_int32;
      if(!(pxSocket->u.xTCP.bits.bReuseSocket == 0u))
      {
        if(!(pxSocket->u.xTCP.rxStream == ((const StreamBuffer_t *)NULL)))
          vStreamBufferClear(pxSocket->u.xTCP.rxStream);

        if(!(pxSocket->u.xTCP.txStream == ((const StreamBuffer_t *)NULL)))
          vStreamBufferClear(pxSocket->u.xTCP.txStream);

        memset((void *)pxSocket->u.xTCP.xPacket.u.ucLastPacket, 0, sizeof(uint8_t [70ll]) /*70ull*/ );
        memset((void *)&pxSocket->u.xTCP.xTCPWindow, 0, sizeof(TCPWindow_t) /*296ull*/ );
        memset((void *)&pxSocket->u.xTCP.bits, 0, sizeof(struct anonymous$104) /*4ull*/ );
        pxSocket->u.xTCP.bits.bReuseSocket = 1u;
      }

      vTCPStateChange(pxSocket, /*enum*/eTCP_LISTEN);
    }
  }
  return xResult;
}

// FreeRTOS_max_int32
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP.h line 182
static inline int32_t FreeRTOS_max_int32(int32_t a, int32_t b)
{
  return a >= b ? a : b;
}

// FreeRTOS_max_uint32
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP.h line 183
static inline uint32_t FreeRTOS_max_uint32(uint32_t a, uint32_t b)
{
  return a >= b ? a : b;
}

// FreeRTOS_maywrite
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 3117
BaseType_t FreeRTOS_maywrite(Socket_t xSocket)
{
  FreeRTOS_Socket_t *pxSocket=(FreeRTOS_Socket_t *)xSocket;
  BaseType_t xResult;
  if(!(pxSocket->ucProtocol == 6))
    xResult = -22;

  else
    if(!((signed int)pxSocket->u.xTCP.ucTCPState == 5))
    {
      _Bool tmp_if_expr;
      if(!((signed int)pxSocket->u.xTCP.ucTCPState >= 2))
        tmp_if_expr = (_Bool)1;

      else
        tmp_if_expr = (signed int)pxSocket->u.xTCP.ucTCPState > 5 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr)
        xResult = -1;

      else
        xResult = 0;
    }

    else
      if(pxSocket->u.xTCP.txStream == ((const StreamBuffer_t *)NULL))
        xResult = (BaseType_t)pxSocket->u.xTCP.uxTxStreamSize;

      else
      {
        size_t return_value_uxStreamBufferGetSpace=uxStreamBufferGetSpace(pxSocket->u.xTCP.txStream);
        xResult = (BaseType_t)return_value_uxStreamBufferGetSpace;
      }
  return xResult;
}

// FreeRTOS_min_BaseType
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP.h line 191
static inline BaseType_t FreeRTOS_min_BaseType(BaseType_t a, BaseType_t b)
{
  return a <= b ? a : b;
}

// FreeRTOS_min_int32
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP.h line 184
static inline int32_t FreeRTOS_min_int32(int32_t a, int32_t b)
{
  return a <= b ? a : b;
}

// FreeRTOS_min_int32$link1
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP.h line 184
static inline int32_t FreeRTOS_min_int32$link1(int32_t a$link1, int32_t b$link1)
{
  return a$link1 <= b$link1 ? a$link1 : b$link1;
}

// FreeRTOS_min_int32$link2
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP.h line 184
static inline int32_t FreeRTOS_min_int32$link2(int32_t a$link2, int32_t b$link2)
{
  return a$link2 <= b$link2 ? a$link2 : b$link2;
}

// FreeRTOS_min_uint32
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP.h line 185
static inline uint32_t FreeRTOS_min_uint32(uint32_t a, uint32_t b)
{
  return a <= b ? a : b;
}

// FreeRTOS_min_uint32$link1
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP.h line 185
static inline uint32_t FreeRTOS_min_uint32$link1(uint32_t a$link1, uint32_t b$link1)
{
  return a$link1 <= b$link1 ? a$link1 : b$link1;
}

// FreeRTOS_min_uint32$link2
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP.h line 185
static inline uint32_t FreeRTOS_min_uint32$link2(uint32_t a$link2, uint32_t b$link2)
{
  return a$link2 <= b$link2 ? a$link2 : b$link2;
}

// FreeRTOS_min_uint32$link3
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP.h line 185
static inline uint32_t FreeRTOS_min_uint32$link3(uint32_t a$link3, uint32_t b$link3)
{
  return a$link3 <= b$link3 ? a$link3 : b$link3;
}

// FreeRTOS_mss
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 3242
BaseType_t FreeRTOS_mss(Socket_t xSocket)
{
  FreeRTOS_Socket_t *pxSocket=(FreeRTOS_Socket_t *)xSocket;
  BaseType_t xReturn;
  if(!(pxSocket->ucProtocol == 6))
    xReturn = -22;

  else
    xReturn = (BaseType_t)pxSocket->u.xTCP.usCurMSS;
  return xReturn;
}

// FreeRTOS_netstat
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 3320
void FreeRTOS_netstat(void)
{
  IPStackEvent_t xAskEvent;
  xAskEvent.eEventType = /*enum*/eTCPNetStat;
  xAskEvent.pvData = NULL;
  xSendEventStructToIPTask(&xAskEvent, 1000u);
}

// FreeRTOS_recv
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 2206
BaseType_t FreeRTOS_recv(Socket_t xSocket, void *pvBuffer, size_t xBufferLength, BaseType_t xFlags)
{
  BaseType_t xByteCount;
  FreeRTOS_Socket_t *pxSocket=(FreeRTOS_Socket_t *)xSocket;
  TickType_t xRemainingTime;
  BaseType_t xTimed=0;
  TimeOut_t xTimeOut;
  EventBits_t xEventBits=0u;
  BaseType_t return_value_prvValidSocket=prvValidSocket(pxSocket, 6, 1);
  if(return_value_prvValidSocket == 0)
    xByteCount = -22;

  else
  {
    if(!(pxSocket->u.xTCP.rxStream == ((const StreamBuffer_t *)NULL)))
    {
      size_t return_value_uxStreamBufferGetSize=uxStreamBufferGetSize(pxSocket->u.xTCP.rxStream);
      xByteCount = (BaseType_t)return_value_uxStreamBufferGetSize;
    }

    else
      xByteCount = 0;
    while(xByteCount == 0)
      if((signed int)pxSocket->u.xTCP.ucTCPState == 0 || (signed int)pxSocket->u.xTCP.ucTCPState == 8 || (signed int)pxSocket->u.xTCP.ucTCPState == 9)
      {
        if(!((unsigned int)pxSocket->u.xTCP.bits.bMallocError == 0u))
          xByteCount = -12;

        else
          xByteCount = -128;
      }

      else
      {
        if(xTimed == 0)
        {
          xRemainingTime = pxSocket->xReceiveBlockTime;
          if(xRemainingTime == 0u)
            break;

          if(!((16 & xFlags) == 0))
            break;

          xTimed = 1;
          vTaskSetTimeOutState(&xTimeOut);
        }

        BaseType_t return_value_xTaskCheckForTimeOut=xTaskCheckForTimeOut(&xTimeOut, &xRemainingTime);
        if(!(return_value_xTaskCheckForTimeOut == 0))
          break;

        xEventBits=xEventGroupWaitBits(pxSocket->xEventGroup, (const EventBits_t)(1 | 32 | 64), 1, 0, xRemainingTime);
        (void)xEventBits;
        if(!(pxSocket->u.xTCP.rxStream == ((const StreamBuffer_t *)NULL)))
        {
          size_t return_value_uxStreamBufferGetSize$0=uxStreamBufferGetSize(pxSocket->u.xTCP.rxStream);
          xByteCount = (BaseType_t)return_value_uxStreamBufferGetSize$0;
        }

        else
          xByteCount = 0;
      }
    if(xByteCount >= 1)
    {
      if((1 & xFlags) == 0)
      {
        size_t return_value_uxStreamBufferGet=uxStreamBufferGet(pxSocket->u.xTCP.rxStream, 0ull, (uint8_t *)pvBuffer, (size_t)xBufferLength, (BaseType_t)((xFlags & 4) != 0));
        xByteCount = (BaseType_t)return_value_uxStreamBufferGet;
        if(!((unsigned int)pxSocket->u.xTCP.bits.bLowWater == 0u))
        {
          size_t uxFrontSpace=uxStreamBufferFrontSpace(pxSocket->u.xTCP.rxStream);
          if(uxFrontSpace >= pxSocket->u.xTCP.uxEnoughSpace)
          {
            pxSocket->u.xTCP.bits.bLowWater = 0u;
            pxSocket->u.xTCP.bits.bWinChange = 1u;
            pxSocket->u.xTCP.usTimeout = 1;
            xSendEventToIPTask(/*enum*/eTCPTimerEvent);
          }

        }

      }

      else
      {
        size_t return_value_uxStreamBufferGetPtr=uxStreamBufferGetPtr(pxSocket->u.xTCP.rxStream, (uint8_t **)pvBuffer);
        xByteCount = (BaseType_t)return_value_uxStreamBufferGetPtr;
      }
    }

  }
  return xByteCount;
}

// FreeRTOS_recvfrom
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 594
int32_t FreeRTOS_recvfrom(Socket_t xSocket, void *pvBuffer, size_t xBufferLength, BaseType_t xFlags, struct freertos_sockaddr *pxSourceAddress, uint32_t *pxSourceAddressLength)
{
  BaseType_t lPacketCount=0;
  NetworkBufferDescriptor_t *pxNetworkBuffer;
  FreeRTOS_Socket_t *pxSocket=(FreeRTOS_Socket_t *)xSocket;
  TickType_t xRemainingTime=0u;
  BaseType_t xTimed=0;
  TimeOut_t xTimeOut;
  int32_t lReturn;
  EventBits_t xEventBits=0u;
  BaseType_t return_value_prvValidSocket=prvValidSocket(pxSocket, 17, 1);
  if(return_value_prvValidSocket == 0)
    return -22;

  else
  {
    lPacketCount = (BaseType_t)(&pxSocket->u.xUDP.xWaitingPacketsList)->uxNumberOfItems;
    (void)pxSourceAddressLength;
    while(lPacketCount == 0)
    {
      if(xTimed == 0)
      {
        xRemainingTime = pxSocket->xReceiveBlockTime;
        if(xRemainingTime == 0u)
          break;

        if(!((16 & xFlags) == 0))
          break;

        xTimed = 1;
        vTaskSetTimeOutState(&xTimeOut);
      }

      xEventBits=xEventGroupWaitBits(pxSocket->xEventGroup, (const EventBits_t)(1 | 64), 1, 0, xRemainingTime);
      (void)xEventBits;
      lPacketCount = (BaseType_t)(&pxSocket->u.xUDP.xWaitingPacketsList)->uxNumberOfItems;
      if(!(lPacketCount == 0))
        break;

      BaseType_t return_value_xTaskCheckForTimeOut=xTaskCheckForTimeOut(&xTimeOut, &xRemainingTime);
      if(!(return_value_xTaskCheckForTimeOut == 0l))
        break;

    }
    if(!(lPacketCount == 0))
    {
      vPortEnterCritical();
      pxNetworkBuffer = (NetworkBufferDescriptor_t *)(&(&pxSocket->u.xUDP.xWaitingPacketsList)->xListEnd)->pxNext->pvOwner;
      if((4 & xFlags) == 0)
        uxListRemove(&pxNetworkBuffer->xBufferListItem);

      vPortExitCritical();
      lReturn = (int32_t)pxNetworkBuffer->xDataLength;
      if(!(pxSourceAddress == ((struct freertos_sockaddr *)NULL)))
      {
        pxSourceAddress->sin_port = pxNetworkBuffer->usPort;
        pxSourceAddress->sin_addr = pxNetworkBuffer->ulIPAddress;
      }

      if((1 & xFlags) == 0)
      {
        if(!((int32_t)xBufferLength >= lReturn))
          lReturn = (int32_t)xBufferLength;

        memcpy(pvBuffer, (void *)&pxNetworkBuffer->pucEthernetBuffer[(signed long long int)sizeof(UDPPacket_t) /*42ll*/ ], (size_t)lReturn);
        if((4 & xFlags) == 0)
          vReleaseNetworkBufferAndDescriptor(pxNetworkBuffer);

      }

      else
        *((void **)pvBuffer) = (void *)&pxNetworkBuffer->pucEthernetBuffer[(signed long long int)sizeof(UDPPacket_t) /*42ll*/ ];
    }

    else
      lReturn = -11;
    return lReturn;
  }
}

// FreeRTOS_round_up
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP.h line 186
static inline uint32_t FreeRTOS_round_up(uint32_t a, uint32_t d)
{
  return d * (((a + d) - 1u) / d);
}

// FreeRTOS_rx_size
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 3294
BaseType_t FreeRTOS_rx_size(Socket_t xSocket)
{
  FreeRTOS_Socket_t *pxSocket=(FreeRTOS_Socket_t *)xSocket;
  BaseType_t xReturn;
  if(!(pxSocket->ucProtocol == 6))
    xReturn = -22;

  else
    if(!(pxSocket->u.xTCP.rxStream == ((const StreamBuffer_t *)NULL)))
    {
      size_t return_value_uxStreamBufferGetSize=uxStreamBufferGetSize(pxSocket->u.xTCP.rxStream);
      xReturn = (BaseType_t)return_value_uxStreamBufferGetSize;
    }

    else
      xReturn = 0;
  return xReturn;
}

// FreeRTOS_send
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 2448
BaseType_t FreeRTOS_send(Socket_t xSocket, const void *pvBuffer, size_t uxDataLength, BaseType_t xFlags)
{
  BaseType_t xByteCount;
  BaseType_t xBytesLeft;
  FreeRTOS_Socket_t *pxSocket=(FreeRTOS_Socket_t *)xSocket;
  TickType_t xRemainingTime;
  BaseType_t xTimed=0;
  TimeOut_t xTimeOut;
  BaseType_t xCloseAfterSend;
  (void)xFlags;
  int32_t return_value_prvTCPSendCheck=prvTCPSendCheck(pxSocket, uxDataLength);
  xByteCount = (BaseType_t)return_value_prvTCPSendCheck;
  if(xByteCount >= 1)
  {
    xBytesLeft = (BaseType_t)uxDataLength;
    size_t return_value_uxStreamBufferGetSpace=uxStreamBufferGetSpace(pxSocket->u.xTCP.txStream);
    xByteCount = (BaseType_t)return_value_uxStreamBufferGetSpace;
    while(xBytesLeft >= 1)
    {
      if(xByteCount >= 1)
      {
        if(!(xBytesLeft >= xByteCount))
          xByteCount = xBytesLeft;

        if(xByteCount == xBytesLeft && !((unsigned int)pxSocket->u.xTCP.bits.bCloseAfterSend == 0u))
          xCloseAfterSend = 1;

        else
          xCloseAfterSend = 0;
        if(!(xCloseAfterSend == 0))
        {
          vTaskSuspendAll();
          pxSocket->u.xTCP.bits.bCloseRequested = 1u;
        }

        size_t return_value_uxStreamBufferAdd=uxStreamBufferAdd(pxSocket->u.xTCP.txStream, 0ull, (const uint8_t *)pvBuffer, (size_t)xByteCount);
        xByteCount = (BaseType_t)return_value_uxStreamBufferAdd;
        if(!(xCloseAfterSend == 0))
          xTaskResumeAll();

        pxSocket->u.xTCP.usTimeout = 1;
        BaseType_t return_value_xIsCallingFromIPTask=xIsCallingFromIPTask();
        if(return_value_xIsCallingFromIPTask == 0)
          xSendEventToIPTask(/*enum*/eTCPTimerEvent);

        xBytesLeft = xBytesLeft - xByteCount;
        if(xBytesLeft == 0)
          break;

        pvBuffer = (void *)((const uint8_t *)pvBuffer + (signed long long int)xByteCount);
      }

      if(xTimed == 0)
      {
        xRemainingTime = pxSocket->xSendBlockTime;
        if(xRemainingTime == 0u)
          break;

        if(!((16 & xFlags) == 0))
          break;

        xTimed = 1;
        vTaskSetTimeOutState(&xTimeOut);
      }

      else
      {
        BaseType_t return_value_xTaskCheckForTimeOut=xTaskCheckForTimeOut(&xTimeOut, &xRemainingTime);
        if(!(return_value_xTaskCheckForTimeOut == 0))
          break;

      }
      xEventGroupWaitBits(pxSocket->xEventGroup, (const EventBits_t)(2 | 32), 1, 0, xRemainingTime);
      size_t return_value_uxStreamBufferGetSpace$0=uxStreamBufferGetSpace(pxSocket->u.xTCP.txStream);
      xByteCount = (BaseType_t)return_value_uxStreamBufferGetSpace$0;
    }
    xByteCount = (BaseType_t)uxDataLength - xBytesLeft;
    if(xByteCount == 0)
    {
      if((signed int)pxSocket->u.xTCP.ucTCPState >= 6)
        xByteCount = (BaseType_t)-128;

      else
      {
        if(!((unsigned int)pxSocket->usLocalPort == 23u))
          while((_Bool)0)
            ;

        xByteCount = (BaseType_t)-28;
      }
    }

  }

  return xByteCount;
}

// FreeRTOS_sendto
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 759
int32_t FreeRTOS_sendto(Socket_t xSocket, const void *pvBuffer, size_t xTotalDataLength, BaseType_t xFlags, const struct freertos_sockaddr *pxDestinationAddress, uint32_t xDestinationAddressLength)
{
  NetworkBufferDescriptor_t *pxNetworkBuffer;
  IPStackEvent_t xStackTxEvent={ .eEventType=/*enum*/eStackTxEvent, .pvData=NULL };
  TimeOut_t xTimeOut;
  TickType_t xTicksToWait;
  int32_t lReturn=0;
  FreeRTOS_Socket_t *pxSocket=(FreeRTOS_Socket_t *)xSocket;
  (void)xDestinationAddressLength;
  if(pvBuffer == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS-Plus-TCP\\source\\FreeRTOS_Sockets.c", 774u);

  BaseType_t return_value_FreeRTOS_bind;
  if(!(xTotalDataLength >= 1173ull))
  {
    _Bool tmp_if_expr;
    if(!(pxSocket->xBoundSocketListItem.pvContainer == NULL))
      tmp_if_expr = (_Bool)1;

    else
    {
      return_value_FreeRTOS_bind=FreeRTOS_bind(xSocket, ((struct freertos_sockaddr *)NULL), 0u);
      tmp_if_expr = return_value_FreeRTOS_bind == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr)
    {
      xTicksToWait = pxSocket->xSendBlockTime;
      if(!((16 & xFlags) == 0))
        xTicksToWait = 0u;

      if((1 & xFlags) == 0)
      {
        vTaskSetTimeOutState(&xTimeOut);
        pxNetworkBuffer=pxGetNetworkBufferWithDescriptor(xTotalDataLength + sizeof(UDPPacket_t) /*42ull*/ , xTicksToWait);
        if(!(pxNetworkBuffer == ((NetworkBufferDescriptor_t *)NULL)))
        {
          memcpy((void *)&pxNetworkBuffer->pucEthernetBuffer[(signed long long int)sizeof(UDPPacket_t) /*42ll*/ ], (void *)pvBuffer, xTotalDataLength);
          BaseType_t return_value_xTaskCheckForTimeOut=xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait);
          if(return_value_xTaskCheckForTimeOut == 1)
            xTicksToWait = 0u;

        }

      }

      else
        pxNetworkBuffer=pxUDPPayloadBuffer_to_NetworkBuffer((void *)pvBuffer);
      if(!(pxNetworkBuffer == ((NetworkBufferDescriptor_t *)NULL)))
      {
        pxNetworkBuffer->xDataLength = xTotalDataLength;
        pxNetworkBuffer->usPort = pxDestinationAddress->sin_port;
        pxNetworkBuffer->usBoundPort = (uint16_t)(&pxSocket->xBoundSocketListItem)->xItemValue;
        pxNetworkBuffer->ulIPAddress = pxDestinationAddress->sin_addr;
        pxNetworkBuffer->pucEthernetBuffer[6ll] = pxSocket->ucSocketOptions;
        xStackTxEvent.pvData = (void *)pxNetworkBuffer;
        BaseType_t return_value_xSendEventStructToIPTask=xSendEventStructToIPTask(&xStackTxEvent, xTicksToWait);
        if(return_value_xSendEventStructToIPTask == 1)
          lReturn = (int32_t)xTotalDataLength;

        else
          if((1 & xFlags) == 0)
            vReleaseNetworkBufferAndDescriptor(pxNetworkBuffer);

      }

    }

  }

  return lReturn;
}

// FreeRTOS_setsockopt
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 1275
BaseType_t FreeRTOS_setsockopt(Socket_t xSocket, int32_t lLevel, int32_t lOptionName, const void *pvOptionValue, size_t xOptionLength)
{
  BaseType_t xReturn=-22;
  BaseType_t lOptionValue;
  FreeRTOS_Socket_t *pxSocket=(FreeRTOS_Socket_t *)xSocket;
  (void)lLevel;
  (void)xOptionLength;
  if(xSocket == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS-Plus-TCP\\source\\FreeRTOS_Sockets.c", 1289u);

  _Bool tmp_if_expr$0;
  BaseType_t return_value_FreeRTOS_tx_size;
  switch(lOptionName)
  {
    case 0:
    {
      pxSocket->xReceiveBlockTime = *((TickType_t *)pvOptionValue);
      xReturn = 0;
      break;
    }
    case 1:
    {
      pxSocket->xSendBlockTime = *((TickType_t *)pvOptionValue);
      if(pxSocket->ucProtocol == 17)
      {
        if(pxSocket->xSendBlockTime >= 5001u)
          pxSocket->xSendBlockTime = 5000u / (1000u / 1000u);

      }

      xReturn = 0;
      break;
    }
    case 2:
    {
      lOptionValue = (BaseType_t)pvOptionValue;
      if(lOptionValue == 0)
        pxSocket->ucSocketOptions = pxSocket->ucSocketOptions & (uint8_t)~2;

      else
        pxSocket->ucSocketOptions = pxSocket->ucSocketOptions | 2;
      xReturn = 0;
      break;
    }
    case 17:
    {
      pxSocket->pxUserWakeCallback = (SocketWakeupCallback_t)pvOptionValue;
      xReturn = 0;
      break;
    }
    case 4:

    case 5:
    {
      uint32_t ulNewValue;
      if(!(pxSocket->ucProtocol == 6))
      {
        while((_Bool)0)
          ;
        break;
      }

      _Bool tmp_if_expr;
      if(lOptionName == 4)
        tmp_if_expr = pxSocket->u.xTCP.txStream != ((const StreamBuffer_t *)NULL) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr = (_Bool)0;
      _Bool tmp_if_expr$1;
      if(tmp_if_expr)
        tmp_if_expr$1 = (_Bool)1;

      else
      {
        if(lOptionName == 5)
          tmp_if_expr$0 = pxSocket->u.xTCP.rxStream != ((const StreamBuffer_t *)NULL) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$0 = (_Bool)0;
        tmp_if_expr$1 = tmp_if_expr$0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$1)
      {
        while((_Bool)0)
          ;
        break;
      }

      ulNewValue = *((uint32_t *)pvOptionValue);
      if(lOptionName == 4)
      {
        ulNewValue=FreeRTOS_round_up(ulNewValue, (uint32_t)pxSocket->u.xTCP.usInitMSS);
        pxSocket->u.xTCP.uxTxStreamSize = (size_t)ulNewValue;
      }

      else
        pxSocket->u.xTCP.uxRxStreamSize = (size_t)ulNewValue;
      xReturn = 0;
      break;
    }
    case 13:
    {
      WinProperties_t *pxProps;
      if(!(pxSocket->ucProtocol == 6))
      {
        while((_Bool)0)
          ;
        break;
      }

      _Bool tmp_if_expr$2;
      if(!(pxSocket->u.xTCP.txStream == ((const StreamBuffer_t *)NULL)))
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = pxSocket->u.xTCP.rxStream != ((const StreamBuffer_t *)NULL) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
      {
        while((_Bool)0)
          ;
        break;
      }

      pxProps = (WinProperties_t *)pvOptionValue;
      FreeRTOS_setsockopt(xSocket, 0, 4, (const void *)&pxProps->lTxBufSize, sizeof(int32_t) /*4ull*/ );
      FreeRTOS_setsockopt(xSocket, 0, 5, (const void *)&pxProps->lRxBufSize, sizeof(int32_t) /*4ull*/ );
      pxSocket->u.xTCP.uxRxWinSize = (size_t)(uint32_t)pxProps->lRxWinSize;
      pxSocket->u.xTCP.uxTxWinSize = (size_t)(uint32_t)pxProps->lTxWinSize;
      if(!((unsigned int)pxSocket->u.xTCP.xTCPWindow.u.bits.bHasInit == 0u))
      {
        pxSocket->u.xTCP.xTCPWindow.xSize.ulRxWindowLength = (uint32_t)(pxSocket->u.xTCP.uxRxWinSize * (unsigned long long int)pxSocket->u.xTCP.usInitMSS);
        pxSocket->u.xTCP.xTCPWindow.xSize.ulTxWindowLength = (uint32_t)(pxSocket->u.xTCP.uxTxWinSize * (unsigned long long int)pxSocket->u.xTCP.usInitMSS);
      }

      xReturn = 0;
      break;
    }
    case 11:
    {
      if(!(pxSocket->ucProtocol == 6))
        break;

      if(!(*((BaseType_t *)pvOptionValue) == 0))
        pxSocket->u.xTCP.bits.bReuseSocket = 1u;

      else
        pxSocket->u.xTCP.bits.bReuseSocket = 0u;
      xReturn = 0;
      break;
    }
    case 12:
    {
      if(!(pxSocket->ucProtocol == 6))
        break;

      if(!(*((BaseType_t *)pvOptionValue) == 0))
        pxSocket->u.xTCP.bits.bCloseAfterSend = 1u;

      else
        pxSocket->u.xTCP.bits.bCloseAfterSend = 0u;
      xReturn = 0;
      break;
    }
    case 14:
    {
      if(!(pxSocket->ucProtocol == 6))
        break;

      if(!(*((BaseType_t *)pvOptionValue) == 0))
        pxSocket->u.xTCP.xTCPWindow.u.bits.bSendFullSize = 1u;

      else
        pxSocket->u.xTCP.xTCPWindow.u.bits.bSendFullSize = 0u;
      if((unsigned int)pxSocket->u.xTCP.xTCPWindow.u.bits.bSendFullSize == 0u)
      {
        if((signed int)pxSocket->u.xTCP.ucTCPState >= 5)
        {
          return_value_FreeRTOS_tx_size=FreeRTOS_tx_size((Socket_t)pxSocket);
          if(!(return_value_FreeRTOS_tx_size == 0))
          {
            pxSocket->u.xTCP.usTimeout = 1;
            xSendEventToIPTask(/*enum*/eTCPTimerEvent);
          }

        }

      }

      xReturn = 0;
      break;
    }
    case 15:
    {
      if(!(pxSocket->ucProtocol == 6))
        break;

      if(!(*((BaseType_t *)pvOptionValue) == 0))
        pxSocket->u.xTCP.bits.bRxStopped = 1u;

      else
        pxSocket->u.xTCP.bits.bRxStopped = 0u;
      pxSocket->u.xTCP.bits.bWinChange = 1u;
      pxSocket->u.xTCP.usTimeout = 1;
      xSendEventToIPTask(/*enum*/eTCPTimerEvent);
      xReturn = 0;
      break;
    }
    default:
      xReturn = -109;
  }
  return xReturn;
}

// FreeRTOS_shutdown
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 2690
BaseType_t FreeRTOS_shutdown(Socket_t xSocket, BaseType_t xHow)
{
  FreeRTOS_Socket_t *pxSocket=(FreeRTOS_Socket_t *)xSocket;
  BaseType_t xResult;
  BaseType_t return_value_prvValidSocket=prvValidSocket(pxSocket, 6, 1);
  if(return_value_prvValidSocket == 0)
    xResult = -95;

  else
    if(!((signed int)pxSocket->u.xTCP.ucTCPState == 5))
      xResult = -95;

    else
    {
      pxSocket->u.xTCP.bits.bUserShutdown = 1u;
      pxSocket->u.xTCP.usTimeout = 1;
      xSendEventToIPTask(/*enum*/eTCPTimerEvent);
      xResult = 0;
    }
  (void)xHow;
  return xResult;
}

// FreeRTOS_socket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 267
Socket_t FreeRTOS_socket(BaseType_t xDomain, BaseType_t xType, BaseType_t xProtocol)
{
  FreeRTOS_Socket_t *pxSocket;
  size_t uxSocketSize;
  EventGroupHandle_t xEventGroup;
  Socket_t xReturn;
  BaseType_t return_value_prvDetermineSocketSize=prvDetermineSocketSize(xDomain, xType, xProtocol, &uxSocketSize);
  if(return_value_prvDetermineSocketSize == 0)
    xReturn = (void *)~0u;

  else
  {
    void *return_value_pvPortMalloc=pvPortMalloc(uxSocketSize);
    pxSocket = (FreeRTOS_Socket_t *)return_value_pvPortMalloc;
    if(pxSocket == ((FreeRTOS_Socket_t *)NULL))
      pxSocket = (FreeRTOS_Socket_t *)(void *)~0u;

    else
    {
      xEventGroup=xEventGroupCreate();
      if(xEventGroup == NULL)
      {
        vPortFree((void *)pxSocket);
        pxSocket = (FreeRTOS_Socket_t *)(void *)~0u;
      }

      else
      {
        memset((void *)pxSocket, 0, uxSocketSize);
        pxSocket->xEventGroup = xEventGroup;
        if(xProtocol == 17)
          vListInitialise(&pxSocket->u.xUDP.xWaitingPacketsList);

        vListInitialiseItem(&pxSocket->xBoundSocketListItem);
        (&pxSocket->xBoundSocketListItem)->pvOwner = (void *)pxSocket;
        pxSocket->xReceiveBlockTime = 5000u;
        pxSocket->xSendBlockTime = 5000u;
        pxSocket->ucSocketOptions = 2;
        pxSocket->ucProtocol = (uint8_t)xProtocol;
        if(xProtocol == 6)
        {
          pxSocket->u.xTCP.usCurMSS = (uint16_t)((1200u - 20u) - 20u);
          pxSocket->u.xTCP.usInitMSS = pxSocket->u.xTCP.usCurMSS;
          pxSocket->u.xTCP.uxRxStreamSize = 10000ull;
          uint32_t return_value_FreeRTOS_round_up=FreeRTOS_round_up(10000u, (1200u - 20u) - 20u);
          pxSocket->u.xTCP.uxTxStreamSize = (size_t)return_value_FreeRTOS_round_up;
          uint32_t return_value_FreeRTOS_max_uint32=FreeRTOS_max_uint32(1ul, (uint32_t)(pxSocket->u.xTCP.uxRxStreamSize / 2ull) / ((1200u - 20u) - 20u));
          pxSocket->u.xTCP.uxRxWinSize = (size_t)return_value_FreeRTOS_max_uint32;
          uint32_t return_value_FreeRTOS_max_uint32$0=FreeRTOS_max_uint32(1ul, (uint32_t)(pxSocket->u.xTCP.uxTxStreamSize / 2ull) / ((1200u - 20u) - 20u));
          pxSocket->u.xTCP.uxTxWinSize = (size_t)return_value_FreeRTOS_max_uint32$0;
        }

      }
    }
    xReturn = (Socket_t)pxSocket;
  }
  (void)xDomain;
  return xReturn;
}

// FreeRTOS_tx_size
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 3183
BaseType_t FreeRTOS_tx_size(Socket_t xSocket)
{
  FreeRTOS_Socket_t *pxSocket=(FreeRTOS_Socket_t *)xSocket;
  BaseType_t xReturn;
  if(!(pxSocket->ucProtocol == 6))
    xReturn = -22;

  else
    if(!(pxSocket->u.xTCP.txStream == ((const StreamBuffer_t *)NULL)))
    {
      size_t return_value_uxStreamBufferGetSize=uxStreamBufferGetSize(pxSocket->u.xTCP.txStream);
      xReturn = (BaseType_t)return_value_uxStreamBufferGetSize;
    }

    else
      xReturn = 0;
  return xReturn;
}

// FreeRTOS_tx_space
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 3154
BaseType_t FreeRTOS_tx_space(Socket_t xSocket)
{
  FreeRTOS_Socket_t *pxSocket=(FreeRTOS_Socket_t *)xSocket;
  BaseType_t xReturn;
  if(!(pxSocket->ucProtocol == 6))
    xReturn = -22;

  else
    if(!(pxSocket->u.xTCP.txStream == ((const StreamBuffer_t *)NULL)))
    {
      size_t return_value_uxStreamBufferGetSpace=uxStreamBufferGetSpace(pxSocket->u.xTCP.txStream);
      xReturn = (BaseType_t)return_value_uxStreamBufferGetSpace;
    }

    else
      xReturn = (BaseType_t)pxSocket->u.xTCP.uxTxStreamSize;
  return xReturn;
}

// GGD_GetGGCIPandCertificate
// file ..\..\..\..\lib\greengrass\aws_greengrass_discovery.c line 159
BaseType_t GGD_GetGGCIPandCertificate(char *pcBuffer, const uint32_t ulBufferSize, GGD_HostAddressData_t *pxHostAddressData)
{
  Socket_t xSocket;
  uint32_t ulJSONFileSize=0u;
  BaseType_t xJSONFileRetrieveCompleted=0;
  uint32_t ulByteRead=0u;
  BaseType_t xStatus;
  if(pxHostAddressData == ((GGD_HostAddressData_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\greengrass\\aws_greengrass_discovery.c", 169u);

  if(pcBuffer == ((char *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\greengrass\\aws_greengrass_discovery.c", 170u);

  xStatus=GGD_JSONRequestStart(&xSocket);
  if(xStatus == 1)
    xStatus=GGD_JSONRequestGetSize(&xSocket, &ulJSONFileSize);

  if(xStatus == 1)
  {
    do
      xStatus=GGD_JSONRequestGetFile(&xSocket, &pcBuffer[(signed long long int)ulByteRead], ulBufferSize - ulByteRead, &ulByteRead, &xJSONFileRetrieveCompleted, ulJSONFileSize);
    while(xStatus == 1 && ulBufferSize + -ulByteRead >= 1u && !(xJSONFileRetrieveCompleted == 1));
    if(xJSONFileRetrieveCompleted == 0 && ulBufferSize == ulByteRead)
    {
      vLoggingPrintf("[ERROR] The supplied buffer is not large enough to hold the GreenGrass discovery document. \r\n");
      vLoggingPrintf("[ERROR] Consider increasing the size of the supplied buffer. \r\n");
    }

    if(!(xSocket == (Socket_t)4294967295u))
    {
      GGD_JSONRequestAbort(&xSocket);
      xStatus = 0;
    }

    if(!(xJSONFileRetrieveCompleted == 1))
      xStatus = 0;

  }

  if(xStatus == 1)
    xStatus=GGD_GetIPandCertificateFromJSON(pcBuffer, ulJSONFileSize, ((const HostParameters_t *)NULL), pxHostAddressData, 1);

  return xStatus;
}

// GGD_GetIPandCertificateFromJSON
// file ..\..\..\..\lib\greengrass\aws_greengrass_discovery.c line 445
BaseType_t GGD_GetIPandCertificateFromJSON(char *GGD_GetIPandCertificateFromJSON$$pcJSONFile, const uint32_t ulJSONFileSize, const HostParameters_t *pxHostParameters, GGD_HostAddressData_t *pxHostAddressData, const BaseType_t xAutoSelectFlag)
{
  Socket_t xSocket;
  BaseType_t xStatus;
  jsmn_parser xParser;
  jsmntok_t pxTok[128ll];
  int32_t lNbTokens;
  uint32_t ulTokenIndex=0u;
  uint8_t ucCurrentInterface=0;
  uint8_t ucTargetInterface=1;
  BaseType_t xFoundGGC=0;
  BaseType_t xIsIPValid;
  if(GGD_GetIPandCertificateFromJSON$$pcJSONFile == ((char *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\greengrass\\aws_greengrass_discovery.c", 461u);

  if(pxHostAddressData == ((GGD_HostAddressData_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\greengrass\\aws_greengrass_discovery.c", 462u);

  if(xAutoSelectFlag == 0)
  {
    if(pxHostParameters == ((const HostParameters_t *)NULL))
      vAssertCalled("..\\..\\..\\..\\lib\\greengrass\\aws_greengrass_discovery.c", 466u);

  }

  jsmn_init(&xParser);
  signed int return_value_jsmn_parse=jsmn_parse(&xParser, GGD_GetIPandCertificateFromJSON$$pcJSONFile, (size_t)ulJSONFileSize, pxTok, 128u);
  lNbTokens = (int32_t)return_value_jsmn_parse;
  if(!(lNbTokens >= 0))
  {
    vLoggingPrintf("JSON parsing: Failed to parse JSON\r\n");
    xStatus = 0;
  }

  else
    xStatus = 1;
  if(xStatus == 1)
  {
    BaseType_t return_value_prvGGDGetCertificate=prvGGDGetCertificate(GGD_GetIPandCertificateFromJSON$$pcJSONFile, pxHostParameters, xAutoSelectFlag, pxTok, (uint32_t)lNbTokens, pxHostAddressData);
    if(return_value_prvGGDGetCertificate == 0)
    {
      vLoggingPrintf("JSON parsing: Couldn't find certificate\r\n");
      xStatus = 0;
    }

  }

  if(xStatus == 1)
  {
    BaseType_t return_value_prvGGDGetCore=prvGGDGetCore(GGD_GetIPandCertificateFromJSON$$pcJSONFile, pxHostParameters, xAutoSelectFlag, pxTok, (uint32_t)lNbTokens, &ulTokenIndex);
    if(return_value_prvGGDGetCore == 0)
    {
      vLoggingPrintf("JSON parsing: Couldn't find Green Grass Core\r\n");
      xStatus = 0;
    }

  }

  BaseType_t return_value_prvGGDGetIPOnInterface$0;
  if(xStatus == 1)
  {
    if(xAutoSelectFlag == 0)
    {
      BaseType_t return_value_prvGGDGetIPOnInterface=prvGGDGetIPOnInterface(GGD_GetIPandCertificateFromJSON$$pcJSONFile, pxHostParameters->ucInterface, pxTok, (uint32_t)lNbTokens, pxHostAddressData, &ulTokenIndex, &ucCurrentInterface);
      if(return_value_prvGGDGetIPOnInterface == 0)
        vLoggingPrintf("GGC - Can't find interface\r\n");

      else
        xFoundGGC = 1;
    }

    else
      do
      {
        return_value_prvGGDGetIPOnInterface$0=prvGGDGetIPOnInterface(GGD_GetIPandCertificateFromJSON$$pcJSONFile, ucTargetInterface, pxTok, (uint32_t)lNbTokens, pxHostAddressData, &ulTokenIndex, &ucCurrentInterface);
        if(!(return_value_prvGGDGetIPOnInterface$0 == 1))
          break;

        size_t return_value_strlen=strlen(pxHostAddressData->pcHostAddress);
        xIsIPValid=prvIsIPvalid((const char *)pxHostAddressData->pcHostAddress, (uint32_t)return_value_strlen);
        if(xIsIPValid == 1)
        {
          BaseType_t return_value_GGD_SecureConnect_Connect=GGD_SecureConnect_Connect(pxHostAddressData, &xSocket, 5000u, 5000u);
          if(return_value_GGD_SecureConnect_Connect == 1)
          {
            xFoundGGC = 1;
            GGD_SecureConnect_Disconnect(&xSocket);
            break;
          }

        }

        ucTargetInterface = ucTargetInterface + 1;
      }
      while((_Bool)1);
    if(!(xFoundGGC == 1))
    {
      vLoggingPrintf("GGD - Can't connect to greengrass Core\r\n");
      xStatus = 0;
    }

  }

  return xStatus;
}

// GGD_JSONRequestAbort
// file ..\..\..\..\lib\greengrass\aws_greengrass_discovery.c line 433
void GGD_JSONRequestAbort(Socket_t *pxSocket)
{
  if(pxSocket == ((Socket_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\greengrass\\aws_greengrass_discovery.c", 435u);

  if(!(*pxSocket == (Socket_t)4294967295u))
    GGD_SecureConnect_Disconnect(pxSocket);

}

// GGD_JSONRequestGetFile
// file ..\..\..\..\lib\greengrass\aws_greengrass_discovery.c line 364
BaseType_t GGD_JSONRequestGetFile(Socket_t *pxSocket, char *pcBuffer, const uint32_t ulBufferSize, uint32_t *pulByteRead, BaseType_t *pxJSONFileRetrieveCompleted, const uint32_t pulJSONFileSize)
{
  BaseType_t xStatus;
  uint32_t ulDataSizeRead;
  if(pxSocket == ((Socket_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\greengrass\\aws_greengrass_discovery.c", 374u);

  if(pulByteRead == ((uint32_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\greengrass\\aws_greengrass_discovery.c", 375u);

  if(pxJSONFileRetrieveCompleted == ((BaseType_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\greengrass\\aws_greengrass_discovery.c", 376u);

  if(pcBuffer == ((char *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\greengrass\\aws_greengrass_discovery.c", 377u);

  *pxJSONFileRetrieveCompleted = 0;
  xStatus=GGD_SecureConnect_Read(pcBuffer, ulBufferSize, *pxSocket, &ulDataSizeRead);
  if(xStatus == 1)
  {
    *pulByteRead = *pulByteRead + ulDataSizeRead;
    if(!(4294967295u + pulJSONFileSize >= *pulByteRead))
    {
      vLoggingPrintf("JSON parsing - Received %ld, expected at most %ld \r\n", *pulByteRead, pulJSONFileSize - 1u);
      xStatus = 0;
    }

  }

  if(xStatus == 1)
  {
    if(!(*pulByteRead >= 4294967295u + pulJSONFileSize))
      *pxJSONFileRetrieveCompleted = 0;

    else
    {
      pcBuffer[(signed long long int)(pulJSONFileSize - 1u)] = 0;
      *pxJSONFileRetrieveCompleted = 1;
    }
  }

  if(xStatus == 0)
  {
    vLoggingPrintf("JSON parsing - JSON file retrieval failed\r\n");
    GGD_SecureConnect_Disconnect(pxSocket);
  }

  else
    if(*pxJSONFileRetrieveCompleted == 1)
      GGD_SecureConnect_Disconnect(pxSocket);

  return xStatus;
}

// GGD_JSONRequestGetSize
// file ..\..\..\..\lib\greengrass\aws_greengrass_discovery.c line 268
BaseType_t GGD_JSONRequestGetSize(Socket_t *pxSocket, uint32_t *pulJSONFileSize)
{
  BaseType_t xStatus=0;
  BaseType_t xReadStatus=0;
  char cBuffer[10ll];
  char cReadChar;
  uint32_t ulReadSize;
  uint8_t ucContentLengthIndex=0;
  uint8_t ucLengthStrIndex;
  if(pxSocket == ((Socket_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\greengrass\\aws_greengrass_discovery.c", 281u);

  if(pulJSONFileSize == ((uint32_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\greengrass\\aws_greengrass_discovery.c", 282u);

  memset((void *)cBuffer, 0, sizeof(char [10ll]) /*10ull*/ );
  do
  {
    xReadStatus=GGD_SecureConnect_Read(&cReadChar, 1u, *pxSocket, &ulReadSize);
    BaseType_t return_value_prvCheckForContentLengthString=prvCheckForContentLengthString(&ucContentLengthIndex, cReadChar);
    if(return_value_prvCheckForContentLengthString == 1)
    {
      xStatus = 1;
      break;
    }

  }
  while(xReadStatus == 1 && ulReadSize == 1u);
  if(xStatus == 1)
  {
    ucLengthStrIndex = 0;
    for( ; !((signed int)ucLengthStrIndex >= 10); ucLengthStrIndex = ucLengthStrIndex + 1)
    {
      xReadStatus=GGD_SecureConnect_Read(&cBuffer[(signed long long int)ucLengthStrIndex], 1u, *pxSocket, &ulReadSize);
      if(xReadStatus == 0 || !(ulReadSize == 1u))
      {
        vLoggingPrintf("JSON parsing could not get JSON file Size.\r\n");
        xStatus = 0;
        break;
      }

    }
  }

  if(xStatus == 1)
  {
    unsigned long int return_value_strtoul=strtoul(cBuffer, ((char **)NULL), 10);
    *pulJSONFileSize = (uint32_t)return_value_strtoul + 1u;
    xStatus = 0;
    do
    {
      xReadStatus=GGD_SecureConnect_Read(&cBuffer[3ll], 1u, *pxSocket, &ulReadSize);
      if((signed int)cBuffer[0ll] == 13)
      {
        if((signed int)cBuffer[1ll] == 10)
        {
          if((signed int)cBuffer[2ll] == 13)
          {
            if((signed int)cBuffer[3ll] == 10)
            {
              xStatus = 1;
              break;
            }

          }

        }

      }

      cBuffer[0ll] = cBuffer[1ll];
      cBuffer[1ll] = cBuffer[2ll];
      cBuffer[2ll] = cBuffer[3ll];
    }
    while(xReadStatus == 1 && ulReadSize == 1u);
  }

  if(xStatus == 0)
  {
    GGD_SecureConnect_Disconnect(pxSocket);
    vLoggingPrintf("JSON parsing failed\r\n");
  }

  return xStatus;
}

// GGD_JSONRequestStart
// file ..\..\..\..\lib\greengrass\aws_greengrass_discovery.c line 227
BaseType_t GGD_JSONRequestStart(Socket_t *pxSocket)
{
  GGD_HostAddressData_t xHostAddressData;
  BaseType_t xStatus;
  if(pxSocket == ((Socket_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\greengrass\\aws_greengrass_discovery.c", 232u);

  xHostAddressData.pcHostAddress = clientcredentialMQTT_BROKER_ENDPOINT;
  xHostAddressData.pcCertificate = ((char *)NULL);
  xHostAddressData.ulCertificateSize = 0u;
  xHostAddressData.usPort = 8443;
  xStatus=GGD_SecureConnect_Connect(&xHostAddressData, pxSocket, 5000u, 5000u);
  if(xStatus == 1)
  {
    xStatus=GGD_SecureConnect_Send("GET /greengrass/discover/thing/Paste AWS IoT Thing name here. HTTP/1.1\r\n\r\n", (uint32_t)sizeof(char [75ll]) /*75u*/  - 1u, *pxSocket);
    if(xStatus == 0)
    {
      GGD_SecureConnect_Disconnect(pxSocket);
      vLoggingPrintf("JSON request failed\r\n");
    }

  }

  else
    vLoggingPrintf("JSON request could not connect to end point\r\n");
  return xStatus;
}

// GGD_SecureConnect_Connect
// file ..\..\..\..\lib\greengrass\aws_helper_secure_connect.c line 58
BaseType_t GGD_SecureConnect_Connect(const GGD_HostAddressData_t *pxHostAddressData, Socket_t *pxSocket, uint32_t ulReceiveTimeOut, uint32_t ulSendTimeOut)
{
  const TickType_t GGD_SecureConnect_Connect$$1$$xReceiveTimeOut=(TickType_t)(((TickType_t)ulReceiveTimeOut * 1000u) / 1000u);
  const TickType_t GGD_SecureConnect_Connect$$1$$xSendTimeOut=(TickType_t)(((TickType_t)ulSendTimeOut * 1000u) / 1000u);
  SocketsSockaddr_t xServerAddress;
  size_t xURLLength;
  BaseType_t xIsIPAddress;
  BaseType_t xStatus;
  if(pxHostAddressData == ((const GGD_HostAddressData_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\greengrass\\aws_helper_secure_connect.c", 70u);

  if(pxSocket == ((Socket_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\greengrass\\aws_helper_secure_connect.c", 71u);

  xURLLength=strlen(pxHostAddressData->pcHostAddress);
  if(!(xURLLength >= 254ull))
  {
    *pxSocket=SOCKETS_Socket(2, 1, 6);
    if(*pxSocket == (Socket_t)4294967295u)
      xStatus = 0;

    else
      xStatus = 1;
    if(xStatus == 1)
    {
      uint32_t return_value_prvIsIPaddress=prvIsIPaddress(pxHostAddressData->pcHostAddress);
      if(return_value_prvIsIPaddress == 0u)
        xIsIPAddress = 0;

      else
        xIsIPAddress = 1;
      xServerAddress.ucLength = (uint8_t)sizeof(SocketsSockaddr_t) /*8*/ ;
      xServerAddress.usPort = (uint16_t)((signed int)pxHostAddressData->usPort << 8u | (signed int)pxHostAddressData->usPort >> 8u);
      xServerAddress.ulAddress=SOCKETS_GetHostByName(pxHostAddressData->pcHostAddress);
      xServerAddress.ucSocketDomain = 2;
      SOCKETS_SetSockOpt(*pxSocket, 0, 1, (const void *)&GGD_SecureConnect_Connect$$1$$xSendTimeOut, sizeof(const TickType_t) /*4ull*/ );
      SOCKETS_SetSockOpt(*pxSocket, 0, 0, (const void *)&GGD_SecureConnect_Connect$$1$$xReceiveTimeOut, sizeof(const TickType_t) /*4ull*/ );
      SOCKETS_SetSockOpt(*pxSocket, 0, 8, NULL, 0ull);
      if(!(pxHostAddressData->pcCertificate == ((char *)NULL)))
      {
        int32_t return_value_SOCKETS_SetSockOpt=SOCKETS_SetSockOpt(*pxSocket, 0, 7, (const void *)pxHostAddressData->pcCertificate, (size_t)pxHostAddressData->ulCertificateSize);
        if(!(return_value_SOCKETS_SetSockOpt == 0))
          xStatus = 0;

      }

      if(xIsIPAddress == 0)
      {
        int32_t return_value_SOCKETS_SetSockOpt$0=SOCKETS_SetSockOpt(*pxSocket, 0, 6, (const void *)pxHostAddressData->pcHostAddress, 1ull + xURLLength);
        if(!(return_value_SOCKETS_SetSockOpt$0 == 0))
          xStatus = 0;

      }

      if(xStatus == 1)
      {
        int32_t return_value_SOCKETS_Connect=SOCKETS_Connect(*pxSocket, &xServerAddress, (uint32_t)sizeof(SocketsSockaddr_t) /*8u*/ );
        if(!(return_value_SOCKETS_Connect == 0))
        {
          GGD_SecureConnect_Disconnect(pxSocket);
          xStatus = 0;
        }

      }

    }

  }

  else
  {
    vLoggingPrintf("Malformed URL\r\n");
    xStatus = 0;
  }
  return xStatus;
}

// GGD_SecureConnect_Disconnect
// file ..\..\..\..\lib\greengrass\aws_helper_secure_connect.c line 182
void GGD_SecureConnect_Disconnect(Socket_t *pxSocket)
{
  const TickType_t xShortDelay=(TickType_t)((10u * 1000u) / 1000u);
  TickType_t xTicksToWait=xShortDelay * 100u;
  TimeOut_t xTimeOut;
  char cBuf;
  if(pxSocket == ((Socket_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\greengrass\\aws_helper_secure_connect.c", 189u);

  if(*pxSocket == (Socket_t)4294967295u)
    vAssertCalled("..\\..\\..\\..\\lib\\greengrass\\aws_helper_secure_connect.c", 190u);

  vLoggingPrintf("About to close socket.\r\n");
  vTaskSetTimeOutState(&xTimeOut);
  SOCKETS_Shutdown(*pxSocket, 2u);
  int32_t return_value_SOCKETS_Recv;
  do
  {
    return_value_SOCKETS_Recv=SOCKETS_Recv(*pxSocket, (void *)&cBuf, sizeof(char) /*1ull*/ , 0u);
    if(!(return_value_SOCKETS_Recv >= 0))
      break;

    vTaskDelay(xShortDelay);
    BaseType_t return_value_xTaskCheckForTimeOut=xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait);
    if(!(return_value_xTaskCheckForTimeOut == 0))
      break;

  }
  while((_Bool)1);
  SOCKETS_Close(*pxSocket);
  *pxSocket = (Socket_t)~0u;
  vLoggingPrintf("Socket closed.\r\n");
  UBaseType_t return_value_uxTaskGetStackHighWaterMark=uxTaskGetStackHighWaterMark(NULL);
  vLoggingPrintf("Stack high watermark for discovery helper task: %u.\r\n", return_value_uxTaskGetStackHighWaterMark);
}

// GGD_SecureConnect_Read
// file ..\..\..\..\lib\greengrass\aws_helper_secure_connect.c line 285
BaseType_t GGD_SecureConnect_Read(char *pcBuffer, const uint32_t ulBufferSize, const Socket_t xSocket, uint32_t *pulDataRecvSize)
{
  int32_t lTmpStatus=0;
  BaseType_t xStatus=0;
  uint16_t usNbRetry;
  if(pulDataRecvSize == ((uint32_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\greengrass\\aws_helper_secure_connect.c", 294u);

  if(pcBuffer == ((char *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\greengrass\\aws_helper_secure_connect.c", 295u);

  usNbRetry = 0;
  for( ; !((signed int)usNbRetry >= 3); usNbRetry = usNbRetry + 1)
  {
    lTmpStatus=SOCKETS_Recv(xSocket, (void *)(unsigned char *)pcBuffer, (size_t)(uint32_t)ulBufferSize, 0u);
    if(!(lTmpStatus == 0))
    {
      if(!(lTmpStatus >= 0))
      {
        vLoggingPrintf("SecureConnect - recv error, %d\r\n", lTmpStatus);
        xStatus = 0;
      }

      else
        xStatus = 1;
      break;
    }

    else
      vLoggingPrintf("SecureConnect - recv Timeout\r\n");
  }
  if(usNbRetry == 3)
  {
    vLoggingPrintf("SecureConnect - recv number of Timeout exceeded\r\n");
    xStatus = 0;
  }

  *pulDataRecvSize = (uint32_t)lTmpStatus;
  return xStatus;
}

// GGD_SecureConnect_Send
// file ..\..\..\..\lib\greengrass\aws_helper_secure_connect.c line 230
BaseType_t GGD_SecureConnect_Send(const char *pcPayload, const uint32_t ulPayloadSize, const Socket_t xSocket)
{
  BaseType_t xStatus=0;
  uint32_t ulBytesSent=0u;
  int32_t lSendRetVal;
  if(pcPayload == ((const char *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\greengrass\\aws_helper_secure_connect.c", 238u);

  if(ulPayloadSize >= 1u)
  {
    while(!(ulBytesSent >= ulPayloadSize))
    {
      lSendRetVal=SOCKETS_Send(xSocket, (const void *)(const unsigned char *)&pcPayload[(signed long long int)ulBytesSent], (size_t)(ulPayloadSize - ulBytesSent), 0u);
      if(!(lSendRetVal >= 0))
        break;

      else
        ulBytesSent = ulBytesSent + (uint32_t)lSendRetVal;
    }
    if(ulBytesSent == ulPayloadSize)
      xStatus = 1;

    else
    {
      vLoggingPrintf("SecureConnect - error sending secure data to network\r\n");
      xStatus = 0;
    }
  }

  else
    xStatus = 1;
  return xStatus;
}

// Handle32ToHandle
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 304
inline void * Handle32ToHandle(const void * h)
{
  return (void *)(LONG_PTR)(signed long int)h;
}

// HandleToLong
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 167
inline signed long int HandleToLong(const void *h)
{
  return (signed long int)(LONG_PTR)h;
}

// HandleToULong
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 158
inline unsigned long int HandleToULong(const void *h)
{
  return (unsigned long int)(ULONG_PTR)h;
}

// IntToPtr
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 250
inline void * IntToPtr(const signed int i)
{
  return (void *)(INT_PTR)i;
}

// JSON_IsCStringEqual
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1147
uint8_t JSON_IsCStringEqual(const char *pcJSONString, uint32_t lLen, const char *pcCString)
{
  signed int return_value_strncmp=strncmp(pcJSONString, pcCString, (size_t)lLen);
  _Bool tmp_if_expr;
  if(return_value_strncmp == 0)
    tmp_if_expr = (signed int)pcCString[(signed long long int)lLen] == 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr = (_Bool)0;
  if(tmp_if_expr)
    return 1;

  else
    return 0;
}

// LongToHandle
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 186
inline void * LongToHandle(const signed long int h)
{
  return (void *)(INT_PTR)h;
}

// LongToPtr
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 270
inline void * LongToPtr(const signed long int l)
{
  return (void *)(LONG_PTR)l;
}

// MQTT_AGENT_Connect
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1931
MQTTAgentReturnCode_t MQTT_AGENT_Connect(MQTTAgentHandle_t MQTT_AGENT_Connect$$xMQTTHandle, const MQTTAgentConnectParams_t * const pxConnectParams, TickType_t xTimeoutTicks)
{
  MQTTEventData_t xEventData;
  MQTTAgentReturnCode_t xReturnCode;
  const UBaseType_t uxBrokerNumber=(UBaseType_t)((UBaseType_t)MQTT_AGENT_Connect$$xMQTTHandle - 1ul);
  xEventData.uxBrokerNumber = uxBrokerNumber;
  xEventData.xEventType = /*enum*/eMQTTConnectRequest;
  xEventData.xTicksToWait = xTimeoutTicks;
  xEventData.u.pxConnectParams = pxConnectParams;
  xReturnCode=prvSendCommandToMQTTTask(&xEventData);
  return xReturnCode;
}

// MQTT_AGENT_Create
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1889
MQTTAgentReturnCode_t MQTT_AGENT_Create(MQTTAgentHandle_t * const pxMQTTHandle)
{
  BaseType_t xBrokerNumber;
  UBaseType_t xEncodedBrokerNumber;
  MQTTAgentReturnCode_t xReturnCode=/*enum*/eMQTTAgentFailure;
  xBrokerNumber=prvGetFreeConnection();
  if(xBrokerNumber >= 0)
  {
    xEncodedBrokerNumber = (UBaseType_t)xBrokerNumber + 1ul;
    *pxMQTTHandle = (MQTTAgentHandle_t)xEncodedBrokerNumber;
    xReturnCode = /*enum*/eMQTTAgentSuccess;
  }

  else
    vLoggingPrintf("No free MQTTBrokerConnection_t struct available!.\r\n");
  return xReturnCode;
}

// MQTT_AGENT_Delete
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1920
MQTTAgentReturnCode_t MQTT_AGENT_Delete(MQTTAgentHandle_t MQTT_AGENT_Delete$$xMQTTHandle)
{
  const UBaseType_t uxBrokerNumber=(UBaseType_t)((UBaseType_t)MQTT_AGENT_Delete$$xMQTTHandle - 1ul);
  prvReturnConnection(uxBrokerNumber);
  return /*enum*/eMQTTAgentSuccess;
}

// MQTT_AGENT_Disconnect
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1954
MQTTAgentReturnCode_t MQTT_AGENT_Disconnect(MQTTAgentHandle_t MQTT_AGENT_Disconnect$$xMQTTHandle, TickType_t xTimeoutTicks)
{
  MQTTEventData_t xEventData;
  MQTTAgentReturnCode_t xReturnCode;
  xEventData.uxBrokerNumber = (UBaseType_t)((UBaseType_t)MQTT_AGENT_Disconnect$$xMQTTHandle - 1ul);
  xEventData.xEventType = /*enum*/eMQTTDisconnectRequest;
  xEventData.xTicksToWait = xTimeoutTicks;
  xReturnCode=prvSendCommandToMQTTTask(&xEventData);
  return xReturnCode;
}

// MQTT_AGENT_Init
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1809
extern BaseType_t MQTT_AGENT_Init(void)
{
  BaseType_t xReturnCode=1;
  UBaseType_t x;
  UBaseType_t y;
  if(xCommandQueue == NULL)
  {
    memset((void *)xMQTTConnections, 0x0, sizeof(MQTTBrokerConnection_t [4ll]) /*10784ull*/ );
    x = 0ul;
    for( ; !(x >= 4ul); x = x + 1ul)
    {
      xMQTTConnections[(signed long long int)x].xSocket = (Socket_t)~0u;
      xMQTTConnections[(signed long long int)x].pvUserData = NULL;
      xMQTTConnections[(signed long long int)x].pxCallback = ((MQTTAgentCallback_t)NULL);
      xMQTTConnections[(signed long long int)x].xConnectionInUse = 0;
      MQTTInitParams_t xInitParams;
      xInitParams.pvCallbackContext = (void *)x;
      xInitParams.pxCallback = prvMQTTEventCallback;
      xInitParams.pvSendContext = (void *)x;
      xInitParams.pxMQTTSendFxn = prvMQTTSendCallback;
      xInitParams.pxGetTicksFxn = prvMQTTGetTicks;
      xInitParams.xBufferPoolInterface.pxGetBufferFxn = BUFFERPOOL_GetFreeBuffer;
      xInitParams.xBufferPoolInterface.pxReturnBufferFxn = BUFFERPOOL_ReturnBuffer;
      MQTTReturnCode_t return_value_MQTT_Init=MQTT_Init(&xMQTTConnections[(signed long long int)x].xMQTTContext, &xInitParams);
      if(!((signed int)return_value_MQTT_Init == 0))
      {
        xReturnCode = 0;
        break;
      }

      y = 0ul;
      for( ; !(y >= 5ul); y = y + 1ul)
      {
        xMQTTConnections[(signed long long int)x].xWaitingTasks[(signed long long int)y].xTaskToNotify = NULL;
        xMQTTConnections[(signed long long int)x].xWaitingTasks[(signed long long int)y].ulMessageIdentifier = 0u;
      }
    }
    ulQueueMessageIdentifier = 0x10000ul;
    static StaticQueue_t MQTT_AGENT_Init$$1$$xStaticQueue;
    static uint8_t MQTT_AGENT_Init$$1$$ucQueueStorageArea[(signed long long int)(sizeof(MQTTEventData_t) * 20ul) /*960ll*/ ];
    xCommandQueue=xQueueGenericCreateStatic((UBaseType_t)(4 * 5), (const UBaseType_t)sizeof(MQTTEventData_t) /*48ul*/ , MQTT_AGENT_Init$$1$$ucQueueStorageArea, &MQTT_AGENT_Init$$1$$xStaticQueue, 0);
    if(xCommandQueue == NULL)
      vAssertCalled("..\\..\\..\\..\\lib\\mqtt\\aws_mqtt_agent.c", 1879u);

    static StaticTask_t xStaticTask;
    static StackType_t xStack[240ll];
    xMQTTTaskHandle=xTaskCreateStatic(prvMQTTTask, "MQTT", 60u * 4u, NULL, (UBaseType_t)(7 - 3), xStack, &xStaticTask);
    if(xMQTTTaskHandle == NULL)
      vAssertCalled("..\\..\\..\\..\\lib\\mqtt\\aws_mqtt_agent.c", 1882u);

  }

  return xReturnCode;
}

// MQTT_AGENT_Publish
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 2018
MQTTAgentReturnCode_t MQTT_AGENT_Publish(MQTTAgentHandle_t MQTT_AGENT_Publish$$xMQTTHandle, const MQTTAgentPublishParams_t * const pxPublishParams, TickType_t xTimeoutTicks)
{
  MQTTEventData_t xEventData;
  MQTTAgentReturnCode_t xReturnCode;
  xEventData.uxBrokerNumber = (UBaseType_t)((UBaseType_t)MQTT_AGENT_Publish$$xMQTTHandle - 1ul);
  xEventData.xEventType = /*enum*/eMQTTPublishRequest;
  xEventData.xTicksToWait = xTimeoutTicks;
  xEventData.u.pxPublishParams = pxPublishParams;
  xReturnCode=prvSendCommandToMQTTTask(&xEventData);
  return xReturnCode;
}

// MQTT_AGENT_ReturnBuffer
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 2040
MQTTAgentReturnCode_t MQTT_AGENT_ReturnBuffer(MQTTAgentHandle_t MQTT_AGENT_ReturnBuffer$$xMQTTHandle, MQTTBufferHandle_t xBufferHandle)
{
  (void)MQTT_AGENT_ReturnBuffer$$xMQTTHandle;
  BUFFERPOOL_ReturnBuffer((uint8_t *)xBufferHandle);
  return /*enum*/eMQTTAgentSuccess;
}

// MQTT_AGENT_Subscribe
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1974
MQTTAgentReturnCode_t MQTT_AGENT_Subscribe(MQTTAgentHandle_t MQTT_AGENT_Subscribe$$xMQTTHandle, const MQTTAgentSubscribeParams_t * const pxSubscribeParams, TickType_t xTimeoutTicks)
{
  MQTTEventData_t xEventData;
  MQTTAgentReturnCode_t xReturnCode;
  xEventData.uxBrokerNumber = (UBaseType_t)((UBaseType_t)MQTT_AGENT_Subscribe$$xMQTTHandle - 1ul);
  xEventData.xEventType = /*enum*/eMQTTSubscribeRequest;
  xEventData.xTicksToWait = xTimeoutTicks;
  xEventData.u.pxSubscribeParams = pxSubscribeParams;
  xReturnCode=prvSendCommandToMQTTTask(&xEventData);
  return xReturnCode;
}

// MQTT_AGENT_Unsubscribe
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1996
MQTTAgentReturnCode_t MQTT_AGENT_Unsubscribe(MQTTAgentHandle_t MQTT_AGENT_Unsubscribe$$xMQTTHandle, const MQTTAgentUnsubscribeParams_t * const pxUnsubscribeParams, TickType_t xTimeoutTicks)
{
  MQTTEventData_t xEventData;
  MQTTAgentReturnCode_t xReturnCode;
  xEventData.uxBrokerNumber = (UBaseType_t)((UBaseType_t)MQTT_AGENT_Unsubscribe$$xMQTTHandle - 1ul);
  xEventData.xEventType = /*enum*/eMQTTUnsubscribeRequest;
  xEventData.xTicksToWait = xTimeoutTicks;
  xEventData.u.pxUnsubscribeParams = pxUnsubscribeParams;
  xReturnCode=prvSendCommandToMQTTTask(&xEventData);
  return xReturnCode;
}

// MQTT_Connect
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 2477
MQTTReturnCode_t MQTT_Connect(MQTTContext_t *pxMQTTContext, const MQTTConnectParams_t * const pxConnectParams)
{
  uint8_t *pucNextByte;
  uint8_t *pucLastByteInBuffer;
  uint8_t ucRemainingLengthFieldBytes;
  uint32_t ulRemainingLength;
  uint32_t ulTotalMessageLength=0u;
  uint16_t usClientIdLength;
  uint16_t MQTT_Connect$$1$$usUserNameLength;
  MQTTBufferHandle_t xBuffer=NULL;
  MQTTReturnCode_t xReturnCode=/*enum*/eMQTTFailure;
  if(!((signed int)pxMQTTContext->xConnectionState == 0))
    xReturnCode = (MQTTReturnCode_t)((signed int)pxMQTTContext->xConnectionState == 2 ? 2 : 3);

  else
  {
    pxMQTTContext->ulKeepAliveActualIntervalTicks = pxConnectParams->ulKeepAliveActualIntervalTicks;
    pxMQTTContext->ulPingRequestTimeoutTicks = pxConnectParams->ulPingRequestTimeoutTicks;
    usClientIdLength = (uint16_t)((signed int)pxConnectParams->usClientIdLength + 2);
    signed int tmp_if_expr;
    if((signed int)pxConnectParams->usUserNameLength >= 1)
      tmp_if_expr = (signed int)pxConnectParams->usUserNameLength + 2;

    else
      tmp_if_expr = 0;
    MQTT_Connect$$1$$usUserNameLength = (uint16_t)tmp_if_expr;
    ulRemainingLength = (uint32_t)sizeof(const uint8_t [10ll]) /*10u*/  + (uint32_t)usClientIdLength + (uint32_t)MQTT_Connect$$1$$usUserNameLength;
    ucRemainingLengthFieldBytes=prvSizeOfRemainingLength(ulRemainingLength);
    if((signed int)ucRemainingLengthFieldBytes >= 1)
    {
      ulTotalMessageLength = 1u + (uint32_t)ucRemainingLengthFieldBytes + ulRemainingLength;
      xBuffer=prvGetFreeBuffer(pxMQTTContext, ulTotalMessageLength);
      if(xBuffer == NULL)
        xReturnCode = /*enum*/eMQTTNoFreeBuffer;

      else
      {
        Link_t *pxPrevLink=&pxMQTTContext->xTxBufferListHead;
        Link_t *pxNextLink=(&pxMQTTContext->xTxBufferListHead)->pxNext;
        (&((MQTTBufferMetadata_t *)xBuffer)->xLink)->pxNext = pxNextLink;
        pxNextLink->pxPrev = &((MQTTBufferMetadata_t *)xBuffer)->xLink;
        pxPrevLink->pxNext = &((MQTTBufferMetadata_t *)xBuffer)->xLink;
        (&((MQTTBufferMetadata_t *)xBuffer)->xLink)->pxPrev = pxPrevLink;
        memset((void *)(uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ), 0x0, (unsigned long long int)((MQTTBufferMetadata_t *)xBuffer)->ulBufferLength - sizeof(MQTTBufferMetadata_t) /*40ull*/ );
        ((MQTTBufferMetadata_t *)xBuffer)->xBufferState.xRecordedTickCount=prvGetCurrentTickCount(pxMQTTContext);
        ((MQTTBufferMetadata_t *)xBuffer)->xBufferState.ulTimeoutTicks = pxConnectParams->ulTimeoutTicks;
        ((uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[0ll] = (uint8_t)(1 << 4 | 0);
        pucNextByte = &((uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[1ll];
        pucLastByteInBuffer = &((uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)(((unsigned long long int)((MQTTBufferMetadata_t *)xBuffer)->ulBufferLength - sizeof(MQTTBufferMetadata_t) /*40ull*/ ) - 1ull)];
        ucRemainingLengthFieldBytes=prvEncodeRemainingLength(ulRemainingLength, pucNextByte, pucLastByteInBuffer);
        pucNextByte = &((uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)((2u + (uint32_t)ucRemainingLengthFieldBytes) - 1u)];
        static const uint8_t ucDefaultConnectVariableHeader[10ll]={ 0, 4, 77, 81, 84, 84, 4, (uint8_t)(1 << 1), 0, 0 };
        memcpy((void *)pucNextByte, (const void *)ucDefaultConnectVariableHeader, sizeof(const uint8_t [10ll]) /*10ull*/ );
        if((signed int)pxConnectParams->usUserNameLength >= 1)
          ((uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)((9u + (uint32_t)ucRemainingLengthFieldBytes) - 1u)] = ((uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)((9u + (uint32_t)ucRemainingLengthFieldBytes) - 1u)] | (uint8_t)(1 << 7);

        ((uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)((10u + (uint32_t)ucRemainingLengthFieldBytes) - 1u)] = (uint8_t)((signed int)pxConnectParams->usKeepAliveIntervlSeconds >> 8);
        ((uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)((11u + (uint32_t)ucRemainingLengthFieldBytes) - 1u)] = (uint8_t)pxConnectParams->usKeepAliveIntervlSeconds;
        pucNextByte = &((uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)((12u + (uint32_t)ucRemainingLengthFieldBytes) - 1u)];
        pucNextByte=prvWriteString(pucNextByte, pucLastByteInBuffer, pxConnectParams->pucClientId, pxConnectParams->usClientIdLength);
        if((signed int)pxConnectParams->usUserNameLength >= 1)
          pucNextByte=prvWriteString(pucNextByte, pucLastByteInBuffer, pxConnectParams->pucUserName, pxConnectParams->usUserNameLength);

        (void)pucNextByte;
        ((MQTTBufferMetadata_t *)xBuffer)->xBufferState.usPacketIdentifier = pxConnectParams->usPacketIdentifier;
        ((MQTTBufferMetadata_t *)xBuffer)->ulDataLength = ulTotalMessageLength;
        xReturnCode = /*enum*/eMQTTSuccess;
      }
    }

  }
  if((signed int)xReturnCode == 0)
    xReturnCode=prvSendData$link1(pxMQTTContext, (uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ), ((MQTTBufferMetadata_t *)xBuffer)->ulDataLength);

  if(!((signed int)xReturnCode == 0))
    prvReturnBuffer(pxMQTTContext, xBuffer);

  else
    pxMQTTContext->xConnectionState = /*enum*/eMQTTConnectionInProgress;
  return xReturnCode;
}

// MQTT_Disconnect
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 2638
MQTTReturnCode_t MQTT_Disconnect(MQTTContext_t *pxMQTTContext)
{
  MQTTReturnCode_t xReturnCode=/*enum*/eMQTTSuccess;
  MQTTEventCallbackParams_t xEventCallbackParams;
  _Bool tmp_if_expr;
  if((signed int)pxMQTTContext->xConnectionState == 2)
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = (signed int)pxMQTTContext->xConnectionState == 1 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
  {
    static const uint8_t ucDisconnectPacket[2ll]={ (const uint8_t)(14 << 4 | 0), 0 };
    MQTTReturnCode_t return_value_prvSendData=prvSendData$link1(pxMQTTContext, ucDisconnectPacket, (uint32_t)sizeof(const uint8_t [2ll]) /*2u*/ );
    if(!((signed int)return_value_prvSendData == 0))
      xReturnCode = /*enum*/eMQTTSendFailed;

    xEventCallbackParams.xEventType = /*enum*/eMQTTClientDisconnected;
    xEventCallbackParams.u.xDisconnectData.xDisconnectReason = /*enum*/eMQTTDisconnectReasonUserRequest;
    prvInvokeCallback(pxMQTTContext, &xEventCallbackParams);
  }

  prvResetMQTTContext(pxMQTTContext);
  return xReturnCode;
}

// MQTT_Init
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 2422
MQTTReturnCode_t MQTT_Init(MQTTContext_t *pxMQTTContext, const MQTTInitParams_t * const pxInitParams)
{
  uint32_t x;
  (&pxMQTTContext->xTxBufferListHead)->pxPrev = &pxMQTTContext->xTxBufferListHead;
  (&pxMQTTContext->xTxBufferListHead)->pxNext = &pxMQTTContext->xTxBufferListHead;
  prvResetRxMessageState(pxMQTTContext);
  pxMQTTContext->xConnectionState = /*enum*/eMQTTNotConnected;
  pxMQTTContext->pvCallbackContext = pxInitParams->pvCallbackContext;
  pxMQTTContext->pxCallback = pxInitParams->pxCallback;
  pxMQTTContext->pvSendContext = pxInitParams->pvSendContext;
  pxMQTTContext->pxMQTTSendFxn = pxInitParams->pxMQTTSendFxn;
  pxMQTTContext->pxGetTicksFxn = pxInitParams->pxGetTicksFxn;
  pxMQTTContext->xBufferPoolInterface = pxInitParams->xBufferPoolInterface;
  x = 0u;
  for( ; !(x >= 8u); x = x + 1u)
    pxMQTTContext->xSubscriptionManager.xSubscriptions[(signed long long int)x].xInUse = /*enum*/eMQTTFalse;
  pxMQTTContext->xSubscriptionManager.ulInUseSubscriptions = 0u;
  return /*enum*/eMQTTSuccess;
}

// MQTT_ParseReceivedData
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 3096
MQTTReturnCode_t MQTT_ParseReceivedData(MQTTContext_t *pxMQTTContext, const uint8_t *pucReceivedData, size_t xReceivedDataLength)
{
  MQTTReturnCode_t xReturnCode=/*enum*/eMQTTSuccess;
  MQTTEventCallbackParams_t xEventCallbackParams;
  size_t xProcessedBytes=0ull;
  size_t xExpectedBytes;
  size_t xUnprocessedBytes;
  _Bool tmp_if_expr$0;
  _Bool tmp_if_expr;
  while(!(xProcessedBytes >= xReceivedDataLength))
  {
    if((signed int)pxMQTTContext->xConnectionState == 0)
    {
      xReturnCode = /*enum*/eMQTTClientNotConnected;
      break;
    }

    if((signed int)pxMQTTContext->xRxMessageState.xRxNextByte == 0)
    {
      memcpy((void *)&pxMQTTContext->ucRxFixedHeaderBuffer[(signed long long int)pxMQTTContext->ulRxMessageReceivedLength], (const void *)&pucReceivedData[(signed long long int)xProcessedBytes], 1ull);
      xProcessedBytes = (size_t)((uint32_t)xProcessedBytes + 1u);
      pxMQTTContext->ulRxMessageReceivedLength = (uint32_t)pxMQTTContext->ulRxMessageReceivedLength + 1u;
      pxMQTTContext->xRxMessageState.xRxNextByte = /*enum*/eMQTTRxNextBytePacketLength;
    }

    else
      if((signed int)pxMQTTContext->xRxMessageState.xRxNextByte == 1)
      {
        memcpy((void *)&pxMQTTContext->ucRxFixedHeaderBuffer[(signed long long int)pxMQTTContext->ulRxMessageReceivedLength], (const void *)&pucReceivedData[(signed long long int)xProcessedBytes], 1ull);
        xProcessedBytes = (size_t)((uint32_t)xProcessedBytes + 1u);
        pxMQTTContext->ulRxMessageReceivedLength = (uint32_t)pxMQTTContext->ulRxMessageReceivedLength + 1u;
        if(!((128 & (signed int)pxMQTTContext->ucRxFixedHeaderBuffer[(signed long long int)(4294967295u + pxMQTTContext->ulRxMessageReceivedLength)]) == 0))
        {
          if(pxMQTTContext->ulRxMessageReceivedLength >= 5u)
          {
            prvResetMQTTContext(pxMQTTContext);
            xEventCallbackParams.xEventType = /*enum*/eMQTTClientDisconnected;
            xEventCallbackParams.u.xDisconnectData.xDisconnectReason = /*enum*/eMQTTDisconnectReasonMalformedPacket;
            prvInvokeCallback(pxMQTTContext, &xEventCallbackParams);
            xReturnCode = /*enum*/eMQTTMalformedPacketReceived;
            break;
          }

        }

        else
        {
          pxMQTTContext->xRxMessageState.ucRemaingingLengthFieldBytes=prvDecodeRemainingLength(&pxMQTTContext->ucRxFixedHeaderBuffer[1ll], &pxMQTTContext->xRxMessageState.ulTotalMessageLength);
          pxMQTTContext->xRxMessageState.ulTotalMessageLength = pxMQTTContext->xRxMessageState.ulTotalMessageLength + pxMQTTContext->ulRxMessageReceivedLength;
          if(pxMQTTContext->xRxMessageState.ulTotalMessageLength == pxMQTTContext->ulRxMessageReceivedLength)
          {
            prvProcessReceivedFixedHeaderOnlyMQTTPacket(pxMQTTContext);
            prvResetRxMessageState(pxMQTTContext);
          }

          else
          {
            pxMQTTContext->xRxBuffer=prvGetFreeBuffer(pxMQTTContext, pxMQTTContext->xRxMessageState.ulTotalMessageLength);
            if(!(pxMQTTContext->xRxBuffer == NULL))
            {
              memcpy((void *)(uint8_t *)((uint8_t *)pxMQTTContext->xRxBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ), (const void *)pxMQTTContext->ucRxFixedHeaderBuffer, (size_t)pxMQTTContext->ulRxMessageReceivedLength);
              ((MQTTBufferMetadata_t *)pxMQTTContext->xRxBuffer)->ulDataLength = pxMQTTContext->ulRxMessageReceivedLength;
              pxMQTTContext->xRxMessageState.xRxNextByte = /*enum*/eMQTTRxNextByteMessage;
              pxMQTTContext->xRxMessageState.xRxMessageAction = /*enum*/eMQTTRxMessageStore;
            }

            else
            {
              pxMQTTContext->xRxMessageState.xRxNextByte = /*enum*/eMQTTRxNextByteMessage;
              pxMQTTContext->xRxMessageState.xRxMessageAction = /*enum*/eMQTTRxMessageDrop;
              prvReturnBuffer(pxMQTTContext, pxMQTTContext->xRxBuffer);
              pxMQTTContext->xRxBuffer = NULL;
            }
          }
        }
      }

      else
      {
        if((signed int)pxMQTTContext->xRxMessageState.xRxNextByte == 2)
          tmp_if_expr$0 = (signed int)pxMQTTContext->xRxMessageState.xRxMessageAction == 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$0 = (_Bool)0;
        if(tmp_if_expr$0)
        {
          xExpectedBytes = (size_t)(pxMQTTContext->xRxMessageState.ulTotalMessageLength - ((MQTTBufferMetadata_t *)pxMQTTContext->xRxBuffer)->ulDataLength);
          xUnprocessedBytes = xReceivedDataLength - xProcessedBytes;
          if(!(xUnprocessedBytes >= xExpectedBytes))
          {
            memcpy((void *)&((uint8_t *)((uint8_t *)pxMQTTContext->xRxBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)((MQTTBufferMetadata_t *)pxMQTTContext->xRxBuffer)->ulDataLength], (const void *)&pucReceivedData[(signed long long int)xProcessedBytes], xUnprocessedBytes);
            xProcessedBytes = (size_t)((uint32_t)xProcessedBytes + (uint32_t)xUnprocessedBytes);
            ((MQTTBufferMetadata_t *)pxMQTTContext->xRxBuffer)->ulDataLength = (uint32_t)((MQTTBufferMetadata_t *)pxMQTTContext->xRxBuffer)->ulDataLength + (uint32_t)xUnprocessedBytes;
          }

          else
          {
            memcpy((void *)&((uint8_t *)((uint8_t *)pxMQTTContext->xRxBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)((MQTTBufferMetadata_t *)pxMQTTContext->xRxBuffer)->ulDataLength], (const void *)&pucReceivedData[(signed long long int)xProcessedBytes], xExpectedBytes);
            xProcessedBytes = (size_t)((uint32_t)xProcessedBytes + (uint32_t)xExpectedBytes);
            ((MQTTBufferMetadata_t *)pxMQTTContext->xRxBuffer)->ulDataLength = (uint32_t)((MQTTBufferMetadata_t *)pxMQTTContext->xRxBuffer)->ulDataLength + (uint32_t)xExpectedBytes;
            prvProcessReceivedMQTTPacket(pxMQTTContext);
            prvResetRxMessageState(pxMQTTContext);
          }
        }

        else
        {
          if((signed int)pxMQTTContext->xRxMessageState.xRxNextByte == 2)
            tmp_if_expr = (signed int)pxMQTTContext->xRxMessageState.xRxMessageAction == 1 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr = (_Bool)0;
          if(tmp_if_expr)
          {
            xExpectedBytes = (size_t)(pxMQTTContext->xRxMessageState.ulTotalMessageLength - pxMQTTContext->ulRxMessageReceivedLength);
            xUnprocessedBytes = xReceivedDataLength - xProcessedBytes;
            if(!(xUnprocessedBytes >= xExpectedBytes))
            {
              xProcessedBytes = xProcessedBytes + xUnprocessedBytes;
              pxMQTTContext->ulRxMessageReceivedLength = pxMQTTContext->ulRxMessageReceivedLength + (uint32_t)xUnprocessedBytes;
            }

            else
            {
              xProcessedBytes = xProcessedBytes + xExpectedBytes;
              pxMQTTContext->ulRxMessageReceivedLength = pxMQTTContext->ulRxMessageReceivedLength + (uint32_t)xExpectedBytes;
              xEventCallbackParams.xEventType = /*enum*/eMQTTPacketDropped;
              prvInvokeCallback(pxMQTTContext, &xEventCallbackParams);
              prvResetRxMessageState(pxMQTTContext);
            }
          }

        }
      }
  }
  return xReturnCode;
}

// MQTT_Periodic
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 3303
uint32_t MQTT_Periodic(MQTTContext_t *pxMQTTContext, uint64_t xCurrentTickCount)
{
  Link_t *pxLink;
  Link_t *pxTempLink;
  MQTTBufferHandle_t xBuffer;
  MQTTEventCallbackParams_t xEventCallbackParams;
  uint32_t ulNextTimeoutTicks=4294967295u;
  pxLink = (&pxMQTTContext->xTxBufferListHead)->pxNext;
  pxTempLink = pxLink->pxNext;
  for( ; !(pxLink == &pxMQTTContext->xTxBufferListHead); pxTempLink = pxLink->pxNext)
  {
    xBuffer = (MQTTBufferHandle_t)(MQTTBufferMetadata_t *)((uint8_t *)pxLink - (uint8_t *)&((MQTTBufferMetadata_t *)NULL)->xLink);
    MQTTBool_t return_value_prvIsTimeElapsed=prvIsTimeElapsed(&((MQTTBufferMetadata_t *)xBuffer)->xBufferState.xRecordedTickCount, xCurrentTickCount, &((MQTTBufferMetadata_t *)xBuffer)->xBufferState.ulTimeoutTicks);
    if((signed int)return_value_prvIsTimeElapsed == 1)
    {
      if(((uint8_t *)xBuffer)[(signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ] == 16)
      {
        prvResetMQTTContext(pxMQTTContext);
        xEventCallbackParams.xEventType = /*enum*/eMQTTClientDisconnected;
        xEventCallbackParams.u.xDisconnectData.xDisconnectReason = /*enum*/eMQTTDisconnectReasonConnectTimeout;
        prvInvokeCallback(pxMQTTContext, &xEventCallbackParams);
        break;
      }

      else
      {
        if(((uint8_t *)xBuffer)[(signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ] == 130)
          prvRemoveSubscriptionForSubscribeOrUnsubscribeBuffer(pxMQTTContext, xBuffer);

        xEventCallbackParams.xEventType = /*enum*/eMQTTTimeout;
        xEventCallbackParams.u.xTimeoutData.usPacketIdentifier = ((MQTTBufferMetadata_t *)xBuffer)->xBufferState.usPacketIdentifier;
        prvInvokeCallback(pxMQTTContext, &xEventCallbackParams);
        prvReturnBuffer(pxMQTTContext, xBuffer);
      }
    }

    else
    {
      uint32_t tmp_if_expr;
      if(!(ulNextTimeoutTicks >= ((MQTTBufferMetadata_t *)xBuffer)->xBufferState.ulTimeoutTicks))
        tmp_if_expr = ulNextTimeoutTicks;

      else
        tmp_if_expr = ((MQTTBufferMetadata_t *)xBuffer)->xBufferState.ulTimeoutTicks;
      ulNextTimeoutTicks = tmp_if_expr;
    }
    pxLink = pxTempLink;
  }
  if((signed int)pxMQTTContext->xConnectionState == 2)
  {
    MQTTBool_t return_value_prvIsTimeElapsed$0=prvIsTimeElapsed(&pxMQTTContext->xLastSentMessageTimestamp, xCurrentTickCount, &pxMQTTContext->ulNextPeriodicInvokeTicks);
    if((signed int)return_value_prvIsTimeElapsed$0 == 1)
    {
      if((signed int)pxMQTTContext->xWaitingForPingResp == 1)
      {
        xEventCallbackParams.xEventType = /*enum*/eMQTTPingTimeout;
        prvInvokeCallback(pxMQTTContext, &xEventCallbackParams);
        pxMQTTContext->xWaitingForPingResp = /*enum*/eMQTTFalse;
      }

      else
      {
        static const uint8_t ucPingReqPacket[2ll]={ (const uint8_t)(12 << 4 | 0), 0 };
        MQTTReturnCode_t return_value_prvSendData=prvSendData$link1(pxMQTTContext, ucPingReqPacket, (uint32_t)sizeof(const uint8_t [2ll]) /*2u*/ );
        if((signed int)return_value_prvSendData == 0)
        {
          pxMQTTContext->xLastSentMessageTimestamp=prvGetCurrentTickCount(pxMQTTContext);
          pxMQTTContext->ulNextPeriodicInvokeTicks = pxMQTTContext->ulPingRequestTimeoutTicks;
          pxMQTTContext->xWaitingForPingResp = /*enum*/eMQTTTrue;
        }

      }
    }

    uint32_t tmp_if_expr$0;
    if(!(ulNextTimeoutTicks >= pxMQTTContext->ulNextPeriodicInvokeTicks))
      tmp_if_expr$0 = ulNextTimeoutTicks;

    else
      tmp_if_expr$0 = pxMQTTContext->ulNextPeriodicInvokeTicks;
    ulNextTimeoutTicks = tmp_if_expr$0;
  }

  return ulNextTimeoutTicks;
}

// MQTT_Publish
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 2962
MQTTReturnCode_t MQTT_Publish(MQTTContext_t *pxMQTTContext, const MQTTPublishParams_t * const pxPublishParams)
{
  uint8_t *pucNextByte;
  uint8_t *pucLastByteInBuffer;
  uint8_t ucRemainingLengthFieldBytes;
  uint32_t ulRemainingLength;
  uint32_t ulTotalMessageLength;
  uint16_t usTopicLength;
  MQTTBufferHandle_t xBuffer=NULL;
  MQTTReturnCode_t xReturnCode=/*enum*/eMQTTFailure;
  if(!((signed int)pxMQTTContext->xConnectionState == 2))
    xReturnCode = /*enum*/eMQTTClientNotConnected;

  else
  {
    usTopicLength = (uint16_t)((signed int)pxPublishParams->usTopicLength + 2);
    ulRemainingLength = (uint32_t)usTopicLength + ((signed int)pxPublishParams->xQos == 0 ? 0u : 2u) + pxPublishParams->ulDataLength;
    ucRemainingLengthFieldBytes=prvSizeOfRemainingLength(ulRemainingLength);
    if((signed int)ucRemainingLengthFieldBytes >= 1)
    {
      ulTotalMessageLength = 1u + (uint32_t)ucRemainingLengthFieldBytes + ulRemainingLength;
      xBuffer=prvGetFreeBuffer(pxMQTTContext, ulTotalMessageLength);
      if(xBuffer == NULL)
        xReturnCode = /*enum*/eMQTTNoFreeBuffer;

      else
      {
        Link_t *pxPrevLink=&pxMQTTContext->xTxBufferListHead;
        Link_t *pxNextLink=(&pxMQTTContext->xTxBufferListHead)->pxNext;
        (&((MQTTBufferMetadata_t *)xBuffer)->xLink)->pxNext = pxNextLink;
        pxNextLink->pxPrev = &((MQTTBufferMetadata_t *)xBuffer)->xLink;
        pxPrevLink->pxNext = &((MQTTBufferMetadata_t *)xBuffer)->xLink;
        (&((MQTTBufferMetadata_t *)xBuffer)->xLink)->pxPrev = pxPrevLink;
        memset((void *)(uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ), 0x0, (unsigned long long int)((MQTTBufferMetadata_t *)xBuffer)->ulBufferLength - sizeof(MQTTBufferMetadata_t) /*40ull*/ );
        ((MQTTBufferMetadata_t *)xBuffer)->xBufferState.xRecordedTickCount=prvGetCurrentTickCount(pxMQTTContext);
        ((MQTTBufferMetadata_t *)xBuffer)->xBufferState.ulTimeoutTicks = pxPublishParams->ulTimeoutTicks;
        ((uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[0ll] = (uint8_t)(3 << 4);
        ((uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[0ll] = ((uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[0ll] | (uint8_t)((signed int)(uint8_t)pxPublishParams->xQos << 1);
        pucNextByte = &((uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[1ll];
        pucLastByteInBuffer = &((uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)(((unsigned long long int)((MQTTBufferMetadata_t *)xBuffer)->ulBufferLength - sizeof(MQTTBufferMetadata_t) /*40ull*/ ) - 1ull)];
        ucRemainingLengthFieldBytes=prvEncodeRemainingLength(ulRemainingLength, pucNextByte, pucLastByteInBuffer);
        pucNextByte = &((uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)((2u + (uint32_t)ucRemainingLengthFieldBytes) - 1u)];
        pucNextByte=prvWriteString(pucNextByte, pucLastByteInBuffer, pxPublishParams->pucTopic, pxPublishParams->usTopicLength);
        if(!((signed int)pxPublishParams->xQos == 0))
        {
          *pucNextByte = (uint8_t)((signed int)pxPublishParams->usPacketIdentifier >> 8);
          pucNextByte = pucNextByte + 1ll;
          *pucNextByte = (uint8_t)pxPublishParams->usPacketIdentifier;
          pucNextByte = pucNextByte + 1ll;
        }

        memcpy((void *)pucNextByte, pxPublishParams->pvData, (size_t)pxPublishParams->ulDataLength);
        ((MQTTBufferMetadata_t *)xBuffer)->xBufferState.usPacketIdentifier = pxPublishParams->usPacketIdentifier;
        ((MQTTBufferMetadata_t *)xBuffer)->ulDataLength = ulTotalMessageLength;
        xReturnCode = /*enum*/eMQTTSuccess;
      }
    }

  }
  if((signed int)xReturnCode == 0)
    xReturnCode=prvSendData$link1(pxMQTTContext, (uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ), ((MQTTBufferMetadata_t *)xBuffer)->ulDataLength);

  _Bool tmp_if_expr;
  if(!((signed int)xReturnCode == 0))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = (signed int)pxPublishParams->xQos == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    prvReturnBuffer(pxMQTTContext, xBuffer);

  return xReturnCode;
}

// MQTT_ReturnBuffer
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 3285
MQTTReturnCode_t MQTT_ReturnBuffer(MQTTContext_t *pxMQTTContext, MQTTBufferHandle_t xBufferHandle)
{
  prvReturnBuffer(pxMQTTContext, xBufferHandle);
  return /*enum*/eMQTTSuccess;
}

// MQTT_Subscribe
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 2681
MQTTReturnCode_t MQTT_Subscribe(MQTTContext_t *pxMQTTContext, const MQTTSubscribeParams_t * const pxSubscribeParams)
{
  uint8_t *pucNextByte;
  uint8_t *pucLastByteInBuffer;
  uint8_t ucRemainingLengthFieldBytes;
  uint32_t ulRemainingLength;
  uint32_t ulTotalMessageLength;
  uint16_t usTopicLength;
  MQTTBufferHandle_t xBuffer=NULL;
  MQTTReturnCode_t xReturnCode=/*enum*/eMQTTFailure;
  if(!((signed int)pxMQTTContext->xConnectionState == 2))
    xReturnCode = /*enum*/eMQTTClientNotConnected;

  else
  {
    MQTTBool_t return_value_prvStoreSubscription=prvStoreSubscription(pxMQTTContext, pxSubscribeParams->pucTopic, pxSubscribeParams->usTopicLength, pxSubscribeParams->pvPublishCallbackContext, pxSubscribeParams->pxPublishCallback);
    if((signed int)return_value_prvStoreSubscription == 0)
      xReturnCode = /*enum*/eMQTTSubscriptionManagerFull;

    else
    {
      usTopicLength = (uint16_t)((signed int)pxSubscribeParams->usTopicLength + 2);
      ulRemainingLength = 2u + (uint32_t)usTopicLength + 1u;
      ucRemainingLengthFieldBytes=prvSizeOfRemainingLength(ulRemainingLength);
      if((signed int)ucRemainingLengthFieldBytes >= 1)
      {
        ulTotalMessageLength = 1u + (uint32_t)ucRemainingLengthFieldBytes + ulRemainingLength;
        xBuffer=prvGetFreeBuffer(pxMQTTContext, ulTotalMessageLength);
        if(xBuffer == NULL)
          xReturnCode = /*enum*/eMQTTNoFreeBuffer;

        else
        {
          Link_t *pxPrevLink=&pxMQTTContext->xTxBufferListHead;
          Link_t *pxNextLink=(&pxMQTTContext->xTxBufferListHead)->pxNext;
          (&((MQTTBufferMetadata_t *)xBuffer)->xLink)->pxNext = pxNextLink;
          pxNextLink->pxPrev = &((MQTTBufferMetadata_t *)xBuffer)->xLink;
          pxPrevLink->pxNext = &((MQTTBufferMetadata_t *)xBuffer)->xLink;
          (&((MQTTBufferMetadata_t *)xBuffer)->xLink)->pxPrev = pxPrevLink;
          memset((void *)(uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ), 0x0, (unsigned long long int)((MQTTBufferMetadata_t *)xBuffer)->ulBufferLength - sizeof(MQTTBufferMetadata_t) /*40ull*/ );
          ((MQTTBufferMetadata_t *)xBuffer)->xBufferState.xRecordedTickCount=prvGetCurrentTickCount(pxMQTTContext);
          ((MQTTBufferMetadata_t *)xBuffer)->xBufferState.ulTimeoutTicks = pxSubscribeParams->ulTimeoutTicks;
          ((uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[0ll] = (uint8_t)(8 << 4 | 2);
          pucNextByte = &((uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[1ll];
          pucLastByteInBuffer = &((uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)(((unsigned long long int)((MQTTBufferMetadata_t *)xBuffer)->ulBufferLength - sizeof(MQTTBufferMetadata_t) /*40ull*/ ) - 1ull)];
          ucRemainingLengthFieldBytes=prvEncodeRemainingLength(ulRemainingLength, pucNextByte, pucLastByteInBuffer);
          ((uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)((2u + (uint32_t)ucRemainingLengthFieldBytes) - 1u)] = (uint8_t)((signed int)pxSubscribeParams->usPacketIdentifier >> 8);
          ((uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)((3u + (uint32_t)ucRemainingLengthFieldBytes) - 1u)] = (uint8_t)pxSubscribeParams->usPacketIdentifier;
          pucNextByte = &((uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)((4u + (uint32_t)ucRemainingLengthFieldBytes) - 1u)];
          pucNextByte=prvWriteString(pucNextByte, pucLastByteInBuffer, pxSubscribeParams->pucTopic, pxSubscribeParams->usTopicLength);
          *pucNextByte = (uint8_t)pxSubscribeParams->xQos;
          ((MQTTBufferMetadata_t *)xBuffer)->xBufferState.usPacketIdentifier = pxSubscribeParams->usPacketIdentifier;
          ((MQTTBufferMetadata_t *)xBuffer)->ulDataLength = ulTotalMessageLength;
          xReturnCode = /*enum*/eMQTTSuccess;
        }
      }

    }
  }
  if((signed int)xReturnCode == 0)
    xReturnCode=prvSendData$link1(pxMQTTContext, (uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ), ((MQTTBufferMetadata_t *)xBuffer)->ulDataLength);

  if(!((signed int)xReturnCode == 0))
  {
    prvReturnBuffer(pxMQTTContext, xBuffer);
    if(!((signed int)xReturnCode == 8))
      prvRemoveSubscription(pxMQTTContext, pxSubscribeParams->pucTopic, pxSubscribeParams->usTopicLength);

  }

  return xReturnCode;
}

// MQTT_Unsubscribe
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 2840
MQTTReturnCode_t MQTT_Unsubscribe(MQTTContext_t *pxMQTTContext, const MQTTUnsubscribeParams_t * const pxUnsubscribeParams)
{
  uint8_t *pucNextByte;
  uint8_t *pucLastByteInBuffer;
  uint8_t ucRemainingLengthFieldBytes;
  uint32_t ulRemainingLength;
  uint32_t ulTotalMessageLength;
  uint16_t usTopicLength;
  MQTTBufferHandle_t xBuffer=NULL;
  MQTTReturnCode_t xReturnCode=/*enum*/eMQTTFailure;
  if(!((signed int)pxMQTTContext->xConnectionState == 2))
    xReturnCode = /*enum*/eMQTTClientNotConnected;

  else
  {
    usTopicLength = (uint16_t)((signed int)pxUnsubscribeParams->usTopicLength + 2);
    ulRemainingLength = 2u + (uint32_t)usTopicLength;
    ucRemainingLengthFieldBytes=prvSizeOfRemainingLength(ulRemainingLength);
    if((signed int)ucRemainingLengthFieldBytes >= 1)
    {
      ulTotalMessageLength = 1u + (uint32_t)ucRemainingLengthFieldBytes + ulRemainingLength;
      xBuffer=prvGetFreeBuffer(pxMQTTContext, ulTotalMessageLength);
      if(xBuffer == NULL)
        xReturnCode = /*enum*/eMQTTNoFreeBuffer;

      else
      {
        Link_t *pxPrevLink=&pxMQTTContext->xTxBufferListHead;
        Link_t *pxNextLink=(&pxMQTTContext->xTxBufferListHead)->pxNext;
        (&((MQTTBufferMetadata_t *)xBuffer)->xLink)->pxNext = pxNextLink;
        pxNextLink->pxPrev = &((MQTTBufferMetadata_t *)xBuffer)->xLink;
        pxPrevLink->pxNext = &((MQTTBufferMetadata_t *)xBuffer)->xLink;
        (&((MQTTBufferMetadata_t *)xBuffer)->xLink)->pxPrev = pxPrevLink;
        memset((void *)(uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ), 0x0, (unsigned long long int)((MQTTBufferMetadata_t *)xBuffer)->ulBufferLength - sizeof(MQTTBufferMetadata_t) /*40ull*/ );
        ((MQTTBufferMetadata_t *)xBuffer)->xBufferState.xRecordedTickCount=prvGetCurrentTickCount(pxMQTTContext);
        ((MQTTBufferMetadata_t *)xBuffer)->xBufferState.ulTimeoutTicks = pxUnsubscribeParams->ulTimeoutTicks;
        ((uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[0ll] = (uint8_t)(10 << 4 | 2);
        pucNextByte = &((uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[1ll];
        pucLastByteInBuffer = &((uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)(((unsigned long long int)((MQTTBufferMetadata_t *)xBuffer)->ulBufferLength - sizeof(MQTTBufferMetadata_t) /*40ull*/ ) - 1ull)];
        ucRemainingLengthFieldBytes=prvEncodeRemainingLength(ulRemainingLength, pucNextByte, pucLastByteInBuffer);
        ((uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)((2u + (uint32_t)ucRemainingLengthFieldBytes) - 1u)] = (uint8_t)((signed int)pxUnsubscribeParams->usPacketIdentifier >> 8);
        ((uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)((3u + (uint32_t)ucRemainingLengthFieldBytes) - 1u)] = (uint8_t)pxUnsubscribeParams->usPacketIdentifier;
        pucNextByte = &((uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)((4u + (uint32_t)ucRemainingLengthFieldBytes) - 1u)];
        pucNextByte=prvWriteString(pucNextByte, pucLastByteInBuffer, pxUnsubscribeParams->pucTopic, pxUnsubscribeParams->usTopicLength);
        (void)pucNextByte;
        ((MQTTBufferMetadata_t *)xBuffer)->xBufferState.usPacketIdentifier = pxUnsubscribeParams->usPacketIdentifier;
        ((MQTTBufferMetadata_t *)xBuffer)->ulDataLength = ulTotalMessageLength;
        xReturnCode = /*enum*/eMQTTSuccess;
      }
    }

  }
  if((signed int)xReturnCode == 0)
    xReturnCode=prvSendData$link1(pxMQTTContext, (uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ), ((MQTTBufferMetadata_t *)xBuffer)->ulDataLength);

  if(!((signed int)xReturnCode == 0))
    prvReturnBuffer(pxMQTTContext, xBuffer);

  return xReturnCode;
}

// NtCurrentTeb
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\winnt.h line 19832
inline struct _TEB * NtCurrentTeb(void)
{
  DWORD return_value___readfsdword=__readfsdword(24ul);
  return (struct _TEB *)(ULONG_PTR)return_value___readfsdword;
}

// OTA_ActivateNewImage
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 540
OTA_Err_t OTA_ActivateNewImage(void)
{
  OTA_Err_t eErr=0u;
  uint8_t uErr;
  OTA_Err_t return_value_prvActivateNewImage=prvActivateNewImage();
  uErr = (uint8_t)return_value_prvActivateNewImage;
  if(!((signed int)uErr == 0))
    eErr = 67108864u;

  return eErr;
}

// OTA_AgentInit
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 384
OTA_State_t OTA_AgentInit(void *pvClient, pxOTACompleteCallback_t func, TickType_t xTicksToWait)
{
  uint32_t i;
  BaseType_t xReturn;
  pxOTAJobCompleteCallback = func;
  ulOTA_PacketsDropped = 0u;
  ulOTA_PacketsQueued = 0u;
  ulOTA_PacketsProcessed = 0u;
  vPortEnterCritical();
  TickType_t tmp_post;
  if((signed int)eOTA_AgentState == 0)
  {
    pvPubSubClient = pvClient;
    static StaticQueue_t OTA_AgentInit$$1$$xStaticQueue;
    static MQTTPublishData_t ucQueueData[6ll];
    xOTA_MsgQ=xQueueGenericCreateStatic(6ul, (const UBaseType_t)sizeof(MQTTPublishData_t) /*48ul*/ , (uint8_t *)ucQueueData, &OTA_AgentInit$$1$$xStaticQueue, 0);
    if(xOTA_MsgQ == NULL)
      vAssertCalled("..\\..\\..\\..\\lib\\ota\\aws_ota_agent.c", 409u);

    i = 0u;
    for( ; !(i >= 1u); i = i + 1u)
      astOTA_Files[(signed long long int)i].pacFilepath = ((uint8_t *)NULL);
    xReturn=xTaskCreate(prvOTAUpdateTask, "OTA Task", (const uint16_t)(7 * 60), NULL, 0u, ((TaskHandle_t * const )NULL));
    vPortExitCritical();
    if(xReturn == 1)
      do
      {
        tmp_post = xTicksToWait;
        xTicksToWait = xTicksToWait - 1u;
        if(!(tmp_post >= 1u))
          break;

        if((signed int)eOTA_AgentState == 1)
          break;

        vTaskDelay(1u);
      }
      while((_Bool)1);

  }

  else
    vPortExitCritical();
  return eOTA_AgentState;
}

// OTA_AgentShutdown
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 440
OTA_State_t OTA_AgentShutdown(TickType_t xTicksToWait)
{
  TickType_t tmp_post;
  if((signed int)eOTA_AgentState == 1)
  {
    xEventGroupSetBits(xOTA_EventFlags, 2u);
    do
    {
      tmp_post = xTicksToWait;
      xTicksToWait = xTicksToWait - 1u;
      if(!(tmp_post >= 1u))
        break;

      if((signed int)eOTA_AgentState == 0)
        break;

      vTaskDelay(1u);
    }
    while((_Bool)1);
  }

  return eOTA_AgentState;
}

// OTA_CBOR_Decode_GetStreamResponseMessage
// file ..\..\..\..\lib\ota\aws_ota_cbor.c line 57
BaseType_t OTA_CBOR_Decode_GetStreamResponseMessage(uint8_t *pucMessageBuffer, size_t xMessageSize, signed int *plFileId, signed int *plBlockId, signed int *plBlockSize, uint8_t **ppucPayload, size_t *pxPayloadSize)
{
  CborError xCborResult=/*enum*/CborNoError;
  CborParser xCborParser;
  CborValue xCborValue;
  CborValue xCborMap;
  xCborResult=cbor_parser_init(pucMessageBuffer, xMessageSize, 0, &xCborParser, &xCborMap);
  if((signed int)xCborResult == 0)
  {
    _Bool return_value_cbor_value_is_map=cbor_value_is_map(&xCborMap);
    if((signed int)return_value_cbor_value_is_map == 0)
      xCborResult = /*enum*/CborErrorIllegalType;

  }

  if((signed int)xCborResult == 0)
    xCborResult=cbor_value_map_find_value(&xCborMap, "f", &xCborValue);

  if((signed int)xCborResult == 0)
  {
    CborType return_value_cbor_value_get_type=cbor_value_get_type(&xCborValue);
    if(!((signed int)return_value_cbor_value_get_type == 0))
      xCborResult = /*enum*/CborErrorIllegalType;

  }

  if((signed int)xCborResult == 0)
    xCborResult=cbor_value_get_int(&xCborValue, plFileId);

  if((signed int)xCborResult == 0)
    xCborResult=cbor_value_map_find_value(&xCborMap, "i", &xCborValue);

  if((signed int)xCborResult == 0)
  {
    CborType return_value_cbor_value_get_type$0=cbor_value_get_type(&xCborValue);
    if(!((signed int)return_value_cbor_value_get_type$0 == 0))
      xCborResult = /*enum*/CborErrorIllegalType;

  }

  if((signed int)xCborResult == 0)
    xCborResult=cbor_value_get_int(&xCborValue, plBlockId);

  if((signed int)xCborResult == 0)
    xCborResult=cbor_value_map_find_value(&xCborMap, "l", &xCborValue);

  if((signed int)xCborResult == 0)
  {
    CborType return_value_cbor_value_get_type$1=cbor_value_get_type(&xCborValue);
    if(!((signed int)return_value_cbor_value_get_type$1 == 0))
      xCborResult = /*enum*/CborErrorIllegalType;

  }

  if((signed int)xCborResult == 0)
    xCborResult=cbor_value_get_int(&xCborValue, plBlockSize);

  if((signed int)xCborResult == 0)
    xCborResult=cbor_value_map_find_value(&xCborMap, "p", &xCborValue);

  if((signed int)xCborResult == 0)
  {
    CborType return_value_cbor_value_get_type$2=cbor_value_get_type(&xCborValue);
    if(!((signed int)return_value_cbor_value_get_type$2 == 64))
      xCborResult = /*enum*/CborErrorIllegalType;

  }

  if((signed int)xCborResult == 0)
    xCborResult=cbor_value_calculate_string_length(&xCborValue, pxPayloadSize);

  if((signed int)xCborResult == 0)
  {
    void *return_value_pvPortMalloc=pvPortMalloc(*pxPayloadSize);
    *ppucPayload = (uint8_t *)return_value_pvPortMalloc;
    if(*ppucPayload == ((uint8_t *)NULL))
      xCborResult = /*enum*/CborErrorOutOfMemory;

  }

  if((signed int)xCborResult == 0)
    xCborResult=cbor_value_copy_byte_string(&xCborValue, *ppucPayload, pxPayloadSize, ((CborValue *)NULL));

  return (BaseType_t)(0 == (signed int)xCborResult);
}

// OTA_CBOR_Encode_GetStreamRequestMessage
// file ..\..\..\..\lib\ota\aws_ota_cbor.c line 216
BaseType_t OTA_CBOR_Encode_GetStreamRequestMessage(uint8_t *pucMessageBuffer, size_t xMessageBufferSize, size_t *pxEncodedMessageSize, char *pcClientToken, signed int lFileId, signed int lBlockSize, signed int lBlockOffset, uint8_t *pucBlockBitmap, size_t xBlockBitmapSize)
{
  CborError xCborResult=/*enum*/CborNoError;
  CborEncoder xCborEncoder;
  CborEncoder xCborMapEncoder;
  cbor_encoder_init(&xCborEncoder, pucMessageBuffer, xMessageBufferSize, 0);
  xCborResult=cbor_encoder_create_map(&xCborEncoder, &xCborMapEncoder, 5ull);
  if((signed int)xCborResult == 0)
    xCborResult=cbor_encode_text_stringz(&xCborMapEncoder, "c");

  if((signed int)xCborResult == 0)
    xCborResult=cbor_encode_text_stringz(&xCborMapEncoder, pcClientToken);

  if((signed int)xCborResult == 0)
    xCborResult=cbor_encode_text_stringz(&xCborMapEncoder, "f");

  if((signed int)xCborResult == 0)
    xCborResult=cbor_encode_int(&xCborMapEncoder, (int64_t)lFileId);

  if((signed int)xCborResult == 0)
    xCborResult=cbor_encode_text_stringz(&xCborMapEncoder, "l");

  if((signed int)xCborResult == 0)
    xCborResult=cbor_encode_int(&xCborMapEncoder, (int64_t)lBlockSize);

  if((signed int)xCborResult == 0)
    xCborResult=cbor_encode_text_stringz(&xCborMapEncoder, "o");

  if((signed int)xCborResult == 0)
    xCborResult=cbor_encode_int(&xCborMapEncoder, (int64_t)lBlockOffset);

  if((signed int)xCborResult == 0)
    xCborResult=cbor_encode_text_stringz(&xCborMapEncoder, "b");

  if((signed int)xCborResult == 0)
    xCborResult=cbor_encode_byte_string(&xCborMapEncoder, pucBlockBitmap, xBlockBitmapSize);

  if((signed int)xCborResult == 0)
    xCborResult=cbor_encoder_close_container_checked(&xCborEncoder, &xCborMapEncoder);

  if((signed int)xCborResult == 0)
    *pxEncodedMessageSize=cbor_encoder_get_buffer_size(&xCborEncoder, pucMessageBuffer);

  return (BaseType_t)(0 == (signed int)xCborResult);
}

// OTA_CheckForUpdate
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 483
OTA_Err_t OTA_CheckForUpdate(void)
{
  MQTTAgentReturnCode_t eResult;
  uint32_t iLen;
  char acMsg[(signed long long int)(sizeof(char [31ll]) * 2ul + 1ul) /*63ll*/ ];
  static uint32_t ulReqCounter=0u;
  vLoggingPrintf("[OTA] Check For Update #%u\r\n", ulReqCounter);
  uint32_t tmp_post=ulReqCounter;
  ulReqCounter = ulReqCounter + 1u;
  iLen=rsprintf(acMsg, acOTA_GetNextJob_MsgTemplate, tmp_post, (const void *)"Paste AWS IoT Thing name here.");
  eResult=prvPublishMessage(pvPubSubClient, acOTA_GetNextJob_Topic, (uint16_t)(sizeof(const char [58ll]) /*58ull*/  - 1ull), acMsg, iLen, /*enum*/eMQTTQoS1);
  if(!((signed int)eResult == 0))
  {
    vLoggingPrintf("[OTA] Failed to publish Check For Update message.\r\n");
    return 100663296u;
  }

  else
    return 0u;
}

// OTA_GetAgentState
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 459
OTA_State_t OTA_GetAgentState(void)
{
  return eOTA_AgentState;
}

// OTA_GetImageState
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 558
OTA_ImageState_t OTA_GetImageState(void)
{
  return eOTA_FinalImageState;
}

// OTA_GetPacketsDropped
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 464
uint32_t OTA_GetPacketsDropped(void)
{
  return ulOTA_PacketsDropped;
}

// OTA_GetPacketsProcessed
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 474
uint32_t OTA_GetPacketsProcessed(void)
{
  return ulOTA_PacketsProcessed;
}

// OTA_GetPacketsQueued
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 469
uint32_t OTA_GetPacketsQueued(void)
{
  return ulOTA_PacketsQueued;
}

// OTA_SetImageState
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 566
OTA_Err_t OTA_SetImageState(OTA_ImageState_t eState)
{
  char acOTA_DynamicTopic[256ll];
  if((signed int)eState >= 1 && !((signed int)eState >= 5))
  {
    prvSetImageState(eState);
    eOTA_FinalImageState = eState;
    if(!(pacOTA_Singleton_ActiveJobName == ((uint8_t *)NULL)))
    {
      if((signed int)eState == 1)
        prvUpdateJobStatus(((OTA_FileContext_t *)NULL), acOTA_DynamicTopic, /*enum*/eJobStatus_InProgress, 2);

      else
      {
        if((signed int)eState == 2)
          prvUpdateJobStatus(((OTA_FileContext_t *)NULL), acOTA_DynamicTopic, /*enum*/eJobStatus_Succeeded, 3);

        else
          if((signed int)eState == 4)
            prvUpdateJobStatus(((OTA_FileContext_t *)NULL), acOTA_DynamicTopic, /*enum*/eJobStatus_Failed, 5);

          else
            prvUpdateJobStatus(((OTA_FileContext_t *)NULL), acOTA_DynamicTopic, /*enum*/eJobStatus_Failed, 4);
        vPortFree((void *)pacOTA_Singleton_ActiveJobName);
        pacOTA_Singleton_ActiveJobName = ((uint8_t *)NULL);
        bOTA_Singleton_SelfTestMode = 0;
      }
      return 0u;
    }

    else
      return 134217728u;
  }

  else
    return 117440512u;
}

// PKCS11_PAL_ReadFile
// file ..\..\..\..\lib\pkcs11\portable\pc\windows\aws_pkcs11_pal.c line 118
BaseType_t PKCS11_PAL_ReadFile(char *pcFileName, uint8_t **ppucData, uint32_t *pulDataSize)
{
  uint32_t ulStatus=0u;
  HANDLE hFile=(HANDLE)(LONG_PTR)-1;
  uint32_t ulSize=0u;
  hFile=CreateFileA(pcFileName, 0x80000000ul, 0ul, ((LPSECURITY_ATTRIBUTES)NULL), 3ul, 128ul, NULL);
  if((HANDLE)-1ll == hFile)
    ulStatus=GetLastError();

  if(ulStatus == 0u)
  {
    *pulDataSize=GetFileSize(hFile, (LPDWORD)&ulSize);
    void *return_value_pvPortMalloc=pvPortMalloc((size_t)*pulDataSize);
    *ppucData = (uint8_t *)return_value_pvPortMalloc;
    if(*ppucData == ((uint8_t *)NULL))
      ulStatus = 8u;

  }

  if(ulStatus == 0u)
  {
    BOOL return_value_ReadFile=ReadFile(hFile, (LPVOID)*ppucData, *pulDataSize, (LPDWORD)&ulSize, ((LPOVERLAPPED)NULL));
    if(return_value_ReadFile == 0)
      ulStatus=GetLastError();

  }

  if(ulStatus == 0u)
  {
    if(!(ulSize == *pulDataSize))
      ulStatus = 13u;

  }

  if(!((HANDLE)-1ll == hFile))
    CloseHandle(hFile);

  return (BaseType_t)(0u == ulStatus);
}

// PKCS11_PAL_ReleaseFileData
// file ..\..\..\..\lib\pkcs11\portable\pc\windows\aws_pkcs11_pal.c line 191
void PKCS11_PAL_ReleaseFileData(uint8_t *pucBuffer, uint32_t ulBufferSize)
{
  (void)ulBufferSize;
  vPortFree((void *)pucBuffer);
}

// PKCS11_PAL_SaveFile
// file ..\..\..\..\lib\pkcs11\portable\pc\windows\aws_pkcs11_pal.c line 62
BaseType_t PKCS11_PAL_SaveFile(char *pcFileName, uint8_t *pucData, uint32_t ulDataSize)
{
  uint32_t ulStatus=0u;
  HANDLE hFile=(HANDLE)(LONG_PTR)-1;
  DWORD lpNumberOfBytesWritten;
  hFile=CreateFileA(pcFileName, 1073741824ul, 0ul, ((LPSECURITY_ATTRIBUTES)NULL), 2ul, 128ul, NULL);
  if((HANDLE)-1ll == hFile)
    ulStatus=GetLastError();

  if(ulStatus == 0u)
  {
    BOOL return_value_WriteFile=WriteFile(hFile, (LPCVOID)pucData, ulDataSize, &lpNumberOfBytesWritten, ((LPOVERLAPPED)NULL));
    if(return_value_WriteFile == 0)
      ulStatus=GetLastError();

  }

  if(!((HANDLE)-1ll == hFile))
    CloseHandle(hFile);

  return (BaseType_t)(0u == ulStatus);
}

// Ptr32ToPtr
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 295
inline void * Ptr32ToPtr(const void * p)
{
  return (void *)(ULONG_PTR)(unsigned long int)p;
}

// PtrToInt
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 232
inline signed int PtrToInt(const void *p)
{
  return (signed int)(INT_PTR)p;
}

// PtrToLong
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 223
inline signed long int PtrToLong(const void *p)
{
  return (signed long int)(LONG_PTR)p;
}

// PtrToPtr32
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 313
inline void * PtrToPtr32(const void *p)
{
  return (void *)(unsigned long int)(ULONG_PTR)p;
}

// PtrToShort
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 241
inline signed short int PtrToShort(const void *p)
{
  return (signed short int)(signed long int)(LONG_PTR)p;
}

// PtrToUint
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 205
inline unsigned int PtrToUint(const void *p)
{
  return (unsigned int)(UINT_PTR)p;
}

// PtrToUlong
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 196
inline unsigned long int PtrToUlong(const void *p)
{
  return (unsigned long int)(ULONG_PTR)p;
}

// PtrToUshort
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 214
inline unsigned short int PtrToUshort(const void *p)
{
  return (unsigned short int)(unsigned long int)(ULONG_PTR)p;
}

// SHADOW_ClientConnect
// file ..\..\..\..\lib\shadow\aws_shadow.c line 1405
ShadowReturnCode_t SHADOW_ClientConnect(ShadowClientHandle_t xShadowClientHandle, MQTTAgentConnectParams_t * const pxConnectParams, TickType_t xTimeoutTicks)
{
  ShadowClient_t *pxShadowClient;
  ShadowReturnCode_t xReturn;
  MQTTAgentReturnCode_t xMQTTReturn;
  if(!((BaseType_t)xShadowClientHandle >= 0) || (BaseType_t)xShadowClientHandle >= 1)
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1414u);

  if(!(xShadowClientHandle == *((ShadowClientHandle_t *)pxConnectParams->pvUserData)))
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1415u);

  pxShadowClient = &pxShadowClients[(signed long long int)(BaseType_t)xShadowClientHandle];
  if(!(pxShadowClient->xInUse == 1))
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1418u);

  pxConnectParams->pxCallback = prvShadowMQTTCallback;
  xMQTTReturn=MQTT_AGENT_Connect(pxShadowClient->xMQTTClient, pxConnectParams, xTimeoutTicks);
  xReturn=prvConvertMQTTReturnCode(xMQTTReturn, xShadowClientHandle, "Connect");
  pxConnectParams->pxCallback = ((MQTTAgentCallback_t)NULL);
  return xReturn;
}

// SHADOW_ClientCreate
// file ..\..\..\..\lib\shadow\aws_shadow.c line 1351
ShadowReturnCode_t SHADOW_ClientCreate(ShadowClientHandle_t *pxShadowClientHandle, const ShadowCreateParams_t * const pxShadowCreateParams)
{
  ShadowClient_t *pxShadowClient;
  BaseType_t xShadowClientID;
  ShadowReturnCode_t xReturn=2;
  MQTTAgentReturnCode_t xMQTTReturn;
  if(pxShadowClientHandle == ((ShadowClientHandle_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1359u);

  if(pxShadowCreateParams == ((const ShadowCreateParams_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1360u);

  if(!((signed int)pxShadowCreateParams->xMQTTClientType == 1))
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1364u);

  xShadowClientID=prvGetFreeShadowClient();
  if(!(xShadowClientID >= 0))
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1367u);

  if(xShadowClientID >= 0)
  {
    pxShadowClient = &pxShadowClients[(signed long long int)xShadowClientID];
    xMQTTReturn=MQTT_AGENT_Create(&pxShadowClient->xMQTTClient);
    xReturn=prvConvertMQTTReturnCode(xMQTTReturn, (ShadowClientHandle_t)xShadowClientID, "Creation of dedicated MQTT client");
    if((signed int)xReturn == 0)
    {
      pxShadowClient->xCallbackSemaphore=xQueueGenericCreateStatic(1ul, 0ul, ((uint8_t *)NULL), &pxShadowClient->xCallbackSemaphoreBuffer, 3);
      pxShadowClient->xOperationMutex=xQueueCreateMutexStatic(1, &pxShadowClient->xOperationMutexBuffer);
      BaseType_t return_value_xQueueGenericSend=xQueueGenericSend((QueueHandle_t)pxShadowClient->xCallbackSemaphore, NULL, 0u, 0);
      if(!(return_value_xQueueGenericSend == 1))
        vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1385u);

      *pxShadowClientHandle = (ShadowClientHandle_t)xShadowClientID;
    }

    else
    {
      vLoggingPrintf("[Shadow Init] Failed to create dedicatedclient; deleting partially-initialized client.\r\n");
      xReturn=SHADOW_ClientDelete(*pxShadowClientHandle);
    }
  }

  return xReturn;
}

// SHADOW_ClientDelete
// file ..\..\..\..\lib\shadow\aws_shadow.c line 1464
ShadowReturnCode_t SHADOW_ClientDelete(ShadowClientHandle_t xShadowClientHandle)
{
  ShadowClient_t *pxShadowClient;
  ShadowReturnCode_t xReturn=2;
  MQTTAgentReturnCode_t xMQTTReturn;
  if(!((BaseType_t)xShadowClientHandle >= 0) || (BaseType_t)xShadowClientHandle >= 1)
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1471u);

  pxShadowClient = &pxShadowClients[(signed long long int)(BaseType_t)xShadowClientHandle];
  if(!(pxShadowClient->xInUse == 1))
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1474u);

  xMQTTReturn=MQTT_AGENT_Delete(pxShadowClient->xMQTTClient);
  xReturn=prvConvertMQTTReturnCode(xMQTTReturn, xShadowClientHandle, "MQTT Client delete");
  if((signed int)xReturn == 0)
  {
    vPortEnterCritical();
    memset((void *)pxShadowClient, 0, sizeof(ShadowClient_t) /*536ull*/ );
    vPortExitCritical();
  }

  return xReturn;
}

// SHADOW_ClientDisconnect
// file ..\..\..\..\lib\shadow\aws_shadow.c line 1437
ShadowReturnCode_t SHADOW_ClientDisconnect(ShadowClientHandle_t xShadowClientHandle)
{
  ShadowClient_t *pxShadowClient;
  MQTTAgentReturnCode_t xMQTTReturn;
  TickType_t xTimeoutTicks;
  ShadowReturnCode_t xReturn;
  if(!((BaseType_t)xShadowClientHandle >= 0) || (BaseType_t)xShadowClientHandle >= 1)
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1445u);

  pxShadowClient = &pxShadowClients[(signed long long int)(BaseType_t)xShadowClientHandle];
  if(!(pxShadowClient->xInUse == 1))
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1448u);

  xTimeoutTicks = (TickType_t)((5000ul * 1000u) / 1000u);
  xMQTTReturn=MQTT_AGENT_Disconnect(pxShadowClient->xMQTTClient, xTimeoutTicks);
  xReturn=prvConvertMQTTReturnCode(xMQTTReturn, xShadowClientHandle, "Disconnect");
  return xReturn;
}

// SHADOW_Delete
// file ..\..\..\..\lib\shadow\aws_shadow.c line 1561
ShadowReturnCode_t SHADOW_Delete(ShadowClientHandle_t xShadowClientHandle, ShadowOperationParams_t * const pxDeleteParams, TickType_t xTimeoutTicks)
{
  ShadowOperationCallParams_t xDeleteCallParams;
  ShadowReturnCode_t xStatus;
  if(!((BaseType_t)xShadowClientHandle >= 0) || (BaseType_t)xShadowClientHandle >= 1)
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1569u);

  if(pxDeleteParams == ((ShadowOperationParams_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1571u);

  if(pxDeleteParams->pcThingName == ((const char *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1572u);

  _Bool tmp_if_expr;
  if((signed int)pxDeleteParams->xQoS == 0)
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = (signed int)pxDeleteParams->xQoS == 1 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr)
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1574u);

  xDeleteCallParams.xShadowClientID = (BaseType_t)xShadowClientHandle;
  xDeleteCallParams.xOperationName = /*enum*/eShadowOperationDelete;
  xDeleteCallParams.pcOperationName = "delete";
  xDeleteCallParams.pcOperationTopic = "$aws/things/%s/shadow/delete";
  xDeleteCallParams.pcOperationAcceptedTopic = "$aws/things/%s/shadow/delete/accepted";
  xDeleteCallParams.pcOperationRejectedTopic = "$aws/things/%s/shadow/delete/rejected";
  xDeleteCallParams.pcPublishMessage = "";
  xDeleteCallParams.ulPublishMessageLength = 0u;
  xDeleteCallParams.pxOperationParams = (ShadowOperationParams_t *)pxDeleteParams;
  xDeleteCallParams.xTimeoutTicks = xTimeoutTicks;
  xStatus=prvShadowOperation(&xDeleteCallParams);
  return xStatus;
}

// SHADOW_Get
// file ..\..\..\..\lib\shadow\aws_shadow.c line 1528
ShadowReturnCode_t SHADOW_Get(ShadowClientHandle_t xShadowClientHandle, ShadowOperationParams_t * const pxGetParams, TickType_t xTimeoutTicks)
{
  ShadowOperationCallParams_t xGetCallParams;
  if(!((BaseType_t)xShadowClientHandle >= 0) || (BaseType_t)xShadowClientHandle >= 1)
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1535u);

  if(pxGetParams == ((ShadowOperationParams_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1537u);

  if(pxGetParams->pcThingName == ((const char *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1538u);

  _Bool tmp_if_expr;
  if((signed int)pxGetParams->xQoS == 0)
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = (signed int)pxGetParams->xQoS == 1 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr)
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1540u);

  xGetCallParams.xShadowClientID = (BaseType_t)xShadowClientHandle;
  xGetCallParams.xOperationName = /*enum*/eShadowOperationGet;
  xGetCallParams.pcOperationName = "get";
  xGetCallParams.pcOperationTopic = "$aws/things/%s/shadow/get";
  xGetCallParams.pcOperationAcceptedTopic = "$aws/things/%s/shadow/get/accepted";
  xGetCallParams.pcOperationRejectedTopic = "$aws/things/%s/shadow/get/rejected";
  xGetCallParams.pcPublishMessage = "";
  xGetCallParams.ulPublishMessageLength = 0u;
  xGetCallParams.pxOperationParams = pxGetParams;
  xGetCallParams.xTimeoutTicks = xTimeoutTicks;
  ShadowReturnCode_t return_value_prvShadowOperation=prvShadowOperation(&xGetCallParams);
  return return_value_prvShadowOperation;
}

// SHADOW_JSONDocClientTokenMatch
// file ..\..\..\..\lib\shadow\aws_shadow_json.c line 72
BaseType_t SHADOW_JSONDocClientTokenMatch(const char * const pcDoc1, uint32_t ulDoc1Length, const char * const pcDoc2, uint32_t ulDoc2Length)
{
  jsmntok_t pxJSMNTokens[64ll];
  BaseType_t xReturn=0;
  uint16_t usClientToken1Length;
  uint16_t usClientToken2Length;
  int16_t sNbTokens;
  char *pcClientToken1;
  char *pcClientToken2;
  sNbTokens=prvParseJSON(pcDoc1, ulDoc1Length, pxJSMNTokens);
  if((signed int)sNbTokens >= 1)
  {
    usClientToken1Length=prvGetJSONValue((const char **)&pcClientToken1, "clientToken", pcDoc1, (jsmntok_t *)pxJSMNTokens, sNbTokens);
    if((signed int)usClientToken1Length >= 1)
    {
      sNbTokens=prvParseJSON(pcDoc2, ulDoc2Length, pxJSMNTokens);
      if((signed int)sNbTokens >= 1)
      {
        usClientToken2Length=prvGetJSONValue((const char **)&pcClientToken2, "clientToken", pcDoc2, (jsmntok_t *)pxJSMNTokens, sNbTokens);
        if(usClientToken2Length == usClientToken1Length)
        {
          signed int return_value_strncmp=strncmp((const char *)pcClientToken1, (const char *)pcClientToken2, (size_t)usClientToken1Length);
          if(return_value_strncmp == 0)
            xReturn = 1;

        }

      }

    }

  }

  return xReturn;
}

// SHADOW_JSONGetErrorCodeAndMessage
// file ..\..\..\..\lib\shadow\aws_shadow_json.c line 128
int16_t SHADOW_JSONGetErrorCodeAndMessage(const char * const pcErrorJSON, uint32_t ulErrorJSONLength, char **ppcErrorMessage, uint16_t *pusErrorMessageLength)
{
  jsmntok_t pxJSMNTokens[64ll];
  char *pcErrorCode;
  int16_t sReturn=0;
  int16_t sTokensParsed=prvParseJSON(pcErrorJSON, ulErrorJSONLength, pxJSMNTokens);
  if((signed int)sTokensParsed >= 1)
  {
    uint16_t return_value_prvGetJSONValue=prvGetJSONValue((const char **)&pcErrorCode, "code", pcErrorJSON, pxJSMNTokens, sTokensParsed);
    sReturn = (int16_t)return_value_prvGetJSONValue;
    if((signed int)sReturn >= 1)
    {
      signed long int return_value_strtol=strtol(pcErrorCode, ((char **)NULL), 0);
      sReturn = (int16_t)return_value_strtol;
      if(!(ppcErrorMessage == ((char **)NULL)) && !(pusErrorMessageLength == ((uint16_t *)NULL)))
        *pusErrorMessageLength=prvGetJSONValue((const char **)ppcErrorMessage, "message", pcErrorJSON, pxJSMNTokens, sTokensParsed);

    }

  }

  else
    sReturn = sTokensParsed;
  return sReturn;
}

// SHADOW_RegisterCallbacks
// file ..\..\..\..\lib\shadow\aws_shadow.c line 1597
ShadowReturnCode_t SHADOW_RegisterCallbacks(ShadowClientHandle_t xShadowClientHandle, ShadowCallbackParams_t * const pxCallbackParams, TickType_t xTimeoutTicks)
{
  ShadowClient_t *pxShadowClient;
  CallbackCatalogEntry_t *pxCallbackCatalogEntry;
  ShadowReturnCode_t xReturn=2;
  BaseType_t xCallbackCatalogIndex;
  if(!((BaseType_t)xShadowClientHandle >= 0) || (BaseType_t)xShadowClientHandle >= 1)
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1607u);

  if(pxCallbackParams == ((ShadowCallbackParams_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1609u);

  if(pxCallbackParams->pcThingName == ((const char *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1610u);

  pxShadowClient = &pxShadowClients[(signed long long int)(BaseType_t)xShadowClientHandle];
  if(!(pxShadowClient->xInUse == 1))
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1613u);

  xCallbackCatalogIndex=prvGetCallbackCatalogEntry(pxShadowClient->pxCallbackCatalog, pxCallbackParams->pcThingName);
  if(!(xCallbackCatalogIndex >= 0))
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1617u);

  pxCallbackCatalogEntry = &pxShadowClient->pxCallbackCatalog[(signed long long int)xCallbackCatalogIndex];
  xReturn=prvRegisterCallback((BaseType_t)xShadowClientHandle, (const void **)&pxCallbackCatalogEntry->xCallbackInfo.xShadowUpdatedCallback, (const void **)&pxCallbackParams->xShadowUpdatedCallback, pxCallbackParams->pcThingName, (const uint8_t *)"$aws/things/%s/shadow/update/documents", xTimeoutTicks);
  if((signed int)xReturn == 0)
    xReturn=prvRegisterCallback((BaseType_t)xShadowClientHandle, (const void **)&pxCallbackCatalogEntry->xCallbackInfo.xShadowDeletedCallback, (const void **)&pxCallbackParams->xShadowDeletedCallback, pxCallbackParams->pcThingName, (const uint8_t *)"$aws/things/%s/shadow/delete/accepted", xTimeoutTicks);

  if((signed int)xReturn == 0)
    xReturn=prvRegisterCallback((BaseType_t)xShadowClientHandle, (const void **)&pxCallbackCatalogEntry->xCallbackInfo.xShadowDeltaCallback, (const void **)&pxCallbackParams->xShadowDeltaCallback, pxCallbackParams->pcThingName, (const uint8_t *)"$aws/things/%s/shadow/update/delta", xTimeoutTicks);

  if(pxCallbackCatalogEntry->xCallbackInfo.xShadowUpdatedCallback == ((ShadowUpdatedCallback_t)NULL))
  {
    if(pxCallbackCatalogEntry->xCallbackInfo.xShadowDeltaCallback == ((ShadowDeltaCallback_t)NULL))
    {
      if(pxCallbackCatalogEntry->xCallbackInfo.xShadowDeletedCallback == ((ShadowDeletedCallback_t)NULL))
      {
        vPortEnterCritical();
        memset((void *)pxCallbackCatalogEntry, 0, sizeof(CallbackCatalogEntry_t) /*40ull*/ );
        vPortExitCritical();
      }

    }

  }

  return xReturn;
}

// SHADOW_ReturnMQTTBuffer
// file ..\..\..\..\lib\shadow\aws_shadow.c line 1671
ShadowReturnCode_t SHADOW_ReturnMQTTBuffer(ShadowClientHandle_t xShadowClientHandle, MQTTBufferHandle_t xBufferHandle)
{
  ShadowClient_t *pxShadowClient;
  MQTTAgentReturnCode_t xMQTTReturn;
  ShadowReturnCode_t xReturn=2;
  if(!((BaseType_t)xShadowClientHandle >= 0) || (BaseType_t)xShadowClientHandle >= 1)
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1679u);

  pxShadowClient = &pxShadowClients[(signed long long int)(BaseType_t)xShadowClientHandle];
  if(!(pxShadowClient->xInUse == 1))
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1682u);

  xMQTTReturn=MQTT_AGENT_ReturnBuffer(pxShadowClient->xMQTTClient, xBufferHandle);
  xReturn=prvConvertMQTTReturnCode(xMQTTReturn, xShadowClientHandle, "Return MQTT buffer");
  return xReturn;
}

// SHADOW_Update
// file ..\..\..\..\lib\shadow\aws_shadow.c line 1494
ShadowReturnCode_t SHADOW_Update(ShadowClientHandle_t xShadowClientHandle, ShadowOperationParams_t * const pxUpdateParams, TickType_t xTimeoutTicks)
{
  ShadowOperationCallParams_t xUpdateCallParams;
  if(!((BaseType_t)xShadowClientHandle >= 0) || (BaseType_t)xShadowClientHandle >= 1)
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1501u);

  if(pxUpdateParams == ((ShadowOperationParams_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1503u);

  if(pxUpdateParams->pcThingName == ((const char *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1504u);

  if(pxUpdateParams->pcData == ((const char *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1505u);

  _Bool tmp_if_expr;
  if((signed int)pxUpdateParams->xQoS == 0)
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = (signed int)pxUpdateParams->xQoS == 1 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr)
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1507u);

  xUpdateCallParams.xShadowClientID = (BaseType_t)xShadowClientHandle;
  xUpdateCallParams.xOperationName = /*enum*/eShadowOperationUpdate;
  xUpdateCallParams.pcOperationName = "update";
  xUpdateCallParams.pcOperationTopic = "$aws/things/%s/shadow/update";
  xUpdateCallParams.pcOperationAcceptedTopic = "$aws/things/%s/shadow/update/accepted";
  xUpdateCallParams.pcOperationRejectedTopic = "$aws/things/%s/shadow/update/rejected";
  xUpdateCallParams.pcPublishMessage = pxUpdateParams->pcData;
  xUpdateCallParams.ulPublishMessageLength = pxUpdateParams->ulDataLength;
  xUpdateCallParams.pxOperationParams = (ShadowOperationParams_t *)pxUpdateParams;
  xUpdateCallParams.xTimeoutTicks = xTimeoutTicks;
  ShadowReturnCode_t return_value_prvShadowOperation=prvShadowOperation(&xUpdateCallParams);
  return return_value_prvShadowOperation;
}

// SOCKETS_Close
// file ..\..\..\..\lib\secure_sockets\portable\freertos_plus_tcp\aws_secure_sockets.c line 88
int32_t SOCKETS_Close(Socket_t xSocket)
{
  SSOCKETContextPtr_t pxContext=(SSOCKETContextPtr_t)xSocket;
  uint32_t ulProtocol;
  int32_t lReturn;
  if(!(xSocket == (Socket_t)4294967295u) && !(pxContext == ((SSOCKETContextPtr_t)NULL)))
  {
    if(!(pxContext->pcDestination == ((char *)NULL)))
      vPortFree((void *)pxContext->pcDestination);

    if(!(pxContext->pcServerCertificate == ((char *)NULL)))
      vPortFree((void *)pxContext->pcServerCertificate);

    if(!(pxContext->ppcAlpnProtocols == ((char **)NULL)))
    {
      ulProtocol = 0u;
      for( ; !(ulProtocol >= pxContext->ulAlpnProtocolsCount); ulProtocol = ulProtocol + 1u)
        if(!(pxContext->ppcAlpnProtocols[(signed long long int)ulProtocol] == ((char *)NULL)))
          vPortFree((void *)pxContext->ppcAlpnProtocols[(signed long long int)ulProtocol]);

      vPortFree((void *)pxContext->ppcAlpnProtocols);
    }

    if(pxContext->xRequireTLS == 1)
      TLS_Cleanup(pxContext->pvTLSContext);

    FreeRTOS_closesocket(pxContext->xSocket);
    vPortFree((void *)pxContext);
    lReturn = 0;
  }

  else
    lReturn = -22;
  return lReturn;
}

// SOCKETS_Connect
// file ..\..\..\..\lib\secure_sockets\portable\freertos_plus_tcp\aws_secure_sockets.c line 146
int32_t SOCKETS_Connect(Socket_t xSocket, SocketsSockaddr_t *pxAddress, uint32_t xAddressLength)
{
  int32_t lStatus=0;
  SSOCKETContextPtr_t pxContext=(SSOCKETContextPtr_t)xSocket;
  TLSParams_t xTLSParams={ .ulSize=0u, .pcDestination=((const char *)NULL), .pcServerCertificate=((const char *)NULL),
    .ulServerCertificateLength=0u,
    .ppcAlpnProtocols=((const char **)NULL), .ulAlpnProtocolsCount=0u,
    .pxNetworkRecv=((NetworkRecv_t)NULL), .pxNetworkSend=((NetworkSend_t)NULL),
    .pvCallerContext=NULL };
  struct freertos_sockaddr xTempAddress={ .sin_len=0, .sin_family=0, .sin_port=0, .sin_addr=0u };
  if(!(pxContext == (SSOCKETContextPtr_t)4294967295u) && !(pxAddress == ((SocketsSockaddr_t *)NULL)))
  {
    pxContext->xConnectAttempted = 1;
    xTempAddress.sin_addr = pxAddress->ulAddress;
    xTempAddress.sin_family = pxAddress->ucSocketDomain;
    xTempAddress.sin_len = (uint8_t)sizeof(struct freertos_sockaddr) /*8*/ ;
    xTempAddress.sin_port = pxAddress->usPort;
    lStatus=FreeRTOS_connect(pxContext->xSocket, &xTempAddress, xAddressLength);
    if(lStatus == 0)
    {
      if(pxContext->xRequireTLS == 1)
      {
        xTLSParams.ulSize = (uint32_t)sizeof(TLSParams_t) /*72u*/ ;
        xTLSParams.pcDestination = pxContext->pcDestination;
        xTLSParams.pcServerCertificate = pxContext->pcServerCertificate;
        xTLSParams.ulServerCertificateLength = pxContext->ulServerCertificateLength;
        xTLSParams.ppcAlpnProtocols = (const char **)pxContext->ppcAlpnProtocols;
        xTLSParams.ulAlpnProtocolsCount = pxContext->ulAlpnProtocolsCount;
        xTLSParams.pvCallerContext = (void *)pxContext;
        xTLSParams.pxNetworkRecv = prvNetworkRecv;
        xTLSParams.pxNetworkSend = prvNetworkSend;
        lStatus=TLS_Init(&pxContext->pvTLSContext, &xTLSParams);
        if(lStatus == 0)
          lStatus=TLS_Connect(pxContext->pvTLSContext);

      }

    }

  }

  else
    lStatus = -1;
  return lStatus;
}

// SOCKETS_GetHostByName
// file ..\..\..\..\lib\secure_sockets\portable\freertos_plus_tcp\aws_secure_sockets.c line 197
uint32_t SOCKETS_GetHostByName(const char *pcHostName)
{
  uint32_t return_value_FreeRTOS_gethostbyname=FreeRTOS_gethostbyname(pcHostName);
  return return_value_FreeRTOS_gethostbyname;
}

// SOCKETS_Init
// file ..\..\..\..\lib\secure_sockets\portable\freertos_plus_tcp\aws_secure_sockets.c line 518
extern BaseType_t SOCKETS_Init(void)
{
  return 1;
}

// SOCKETS_Recv
// file ..\..\..\..\lib\secure_sockets\portable\freertos_plus_tcp\aws_secure_sockets.c line 203
int32_t SOCKETS_Recv(Socket_t xSocket, void *pvBuffer, size_t xBufferLength, uint32_t ulFlags)
{
  int32_t lStatus=-1;
  SSOCKETContextPtr_t pxContext=(SSOCKETContextPtr_t)xSocket;
  if(!(pvBuffer == NULL) && !(xSocket == (Socket_t)4294967295u))
  {
    pxContext->xRecvFlags = (BaseType_t)ulFlags;
    if(pxContext->xRequireTLS == 1)
      lStatus=TLS_Recv(pxContext->pvTLSContext, (unsigned char *)pvBuffer, xBufferLength);

    else
      lStatus=prvNetworkRecv((void *)pxContext, (unsigned char *)pvBuffer, xBufferLength);
  }

  else
    lStatus = -22;
  return lStatus;
}

// SOCKETS_Send
// file ..\..\..\..\lib\secure_sockets\portable\freertos_plus_tcp\aws_secure_sockets.c line 236
int32_t SOCKETS_Send(Socket_t xSocket, const void *pvBuffer, size_t xDataLength, uint32_t ulFlags)
{
  int32_t lStatus=-1;
  SSOCKETContextPtr_t pxContext=(SSOCKETContextPtr_t)xSocket;
  if(!(pvBuffer == NULL) && !(xSocket == (Socket_t)4294967295u))
  {
    pxContext->xSendFlags = (BaseType_t)ulFlags;
    if(pxContext->xRequireTLS == 1)
      lStatus=TLS_Send(pxContext->pvTLSContext, (const unsigned char *)pvBuffer, xDataLength);

    else
      lStatus=prvNetworkSend((void *)pxContext, (const unsigned char *)pvBuffer, xDataLength);
  }

  else
    lStatus = -22;
  return lStatus;
}

// SOCKETS_SetSockOpt
// file ..\..\..\..\lib\secure_sockets\portable\freertos_plus_tcp\aws_secure_sockets.c line 269
int32_t SOCKETS_SetSockOpt(Socket_t xSocket, int32_t lLevel, int32_t lOptionName, const void *pvOptionValue, size_t xOptionLength)
{
  int32_t lStatus=0;
  TickType_t xTimeout;
  SSOCKETContextPtr_t pxContext=(SSOCKETContextPtr_t)xSocket;
  char **ppcAlpnIn=(char **)pvOptionValue;
  size_t xLength=0ull;
  uint32_t ulProtocol;
  void *return_value_pvPortMalloc;
  void *return_value_pvPortMalloc$0;
  void *return_value_pvPortMalloc$1;
  if(!(xSocket == NULL) && !(xSocket == (Socket_t)4294967295u))
    switch(lOptionName)
    {
      case 6:
      {
        if(pxContext->xConnectAttempted == 1)
          lStatus = -127;

        else
        {
          return_value_pvPortMalloc=pvPortMalloc(1ull + xOptionLength);
          pxContext->pcDestination = (char *)return_value_pvPortMalloc;
          if(pxContext->pcDestination == ((char *)NULL))
            lStatus = -12;

          else
          {
            memcpy((void *)pxContext->pcDestination, pvOptionValue, xOptionLength);
            pxContext->pcDestination[(signed long long int)xOptionLength] = 0;
          }
        }
        break;
      }
      case 7:
      {
        if(pxContext->xConnectAttempted == 1)
          lStatus = -127;

        else
        {
          return_value_pvPortMalloc$0=pvPortMalloc(xOptionLength);
          pxContext->pcServerCertificate = (char *)return_value_pvPortMalloc$0;
          if(pxContext->pcServerCertificate == ((char *)NULL))
            lStatus = -12;

          else
          {
            memcpy((void *)pxContext->pcServerCertificate, pvOptionValue, xOptionLength);
            pxContext->ulServerCertificateLength = (uint32_t)xOptionLength;
          }
        }
        break;
      }
      case 8:
      {
        if(pxContext->xConnectAttempted == 1)
          lStatus = -127;

        else
          pxContext->xRequireTLS = 1;
        break;
      }
      case 10:
      {
        if(pxContext->xConnectAttempted == 1)
        {
          lStatus = -127;
          break;
        }

        pxContext->ulAlpnProtocolsCount = (uint32_t)(1ull + xOptionLength);
        return_value_pvPortMalloc$1=pvPortMalloc((unsigned long long int)pxContext->ulAlpnProtocolsCount * sizeof(char *) /*8ull*/ );
        pxContext->ppcAlpnProtocols = (char **)return_value_pvPortMalloc$1;
        if(pxContext->ppcAlpnProtocols == ((char **)NULL))
          lStatus = -12;

        else
          memset((void *)pxContext->ppcAlpnProtocols, 0, (unsigned long long int)pxContext->ulAlpnProtocolsCount * sizeof(char *) /*8ull*/ );
        ulProtocol = 0u;
        for( ; lStatus == 0 && !(ulProtocol >= 4294967295u + pxContext->ulAlpnProtocolsCount); ulProtocol = ulProtocol + 1u)
        {
          xLength=strlen(ppcAlpnIn[(signed long long int)ulProtocol]);
          void *return_value_pvPortMalloc$2=pvPortMalloc(1ull + xLength);
          pxContext->ppcAlpnProtocols[(signed long long int)ulProtocol] = (char *)return_value_pvPortMalloc$2;
          if(pxContext->ppcAlpnProtocols[(signed long long int)ulProtocol] == ((char *)NULL))
            lStatus = -12;

          else
          {
            memcpy((void *)pxContext->ppcAlpnProtocols[(signed long long int)ulProtocol], (const void *)ppcAlpnIn[(signed long long int)ulProtocol], xLength);
            pxContext->ppcAlpnProtocols[(signed long long int)ulProtocol][(signed long long int)xLength] = 0;
          }
        }
        break;
      }
      case 9:
      {
        xTimeout = 0u;
        if(pxContext->xConnectAttempted == 1)
        {
          lStatus=FreeRTOS_setsockopt(pxContext->xSocket, lLevel, 0, (const void *)&xTimeout, sizeof(TickType_t) /*4ull*/ );
          if(lStatus == 0)
            lStatus=FreeRTOS_setsockopt(pxContext->xSocket, lLevel, 1, (const void *)&xTimeout, sizeof(TickType_t) /*4ull*/ );

        }

        else
          lStatus = -127;
        break;
      }
      case 0:

      case 1:
      {
        xTimeout = *((const TickType_t *)pvOptionValue);
        if(xTimeout == 0u)
          xTimeout = 0xFFFFFFFFul;

        lStatus=FreeRTOS_setsockopt(pxContext->xSocket, lLevel, lOptionName, (const void *)&xTimeout, xOptionLength);
        break;
      }
      default:
        lStatus=FreeRTOS_setsockopt(pxContext->xSocket, lLevel, lOptionName, pvOptionValue, xOptionLength);
    }

  else
    lStatus = -22;
  return lStatus;
}

// SOCKETS_Shutdown
// file ..\..\..\..\lib\secure_sockets\portable\freertos_plus_tcp\aws_secure_sockets.c line 460
int32_t SOCKETS_Shutdown(Socket_t xSocket, uint32_t ulHow)
{
  int32_t lReturn;
  SSOCKETContextPtr_t pxContext=(SSOCKETContextPtr_t)xSocket;
  if(!(xSocket == NULL) && !(xSocket == (Socket_t)4294967295u))
    lReturn=FreeRTOS_shutdown(pxContext->xSocket, (BaseType_t)ulHow);

  else
    lReturn = -22;
  return lReturn;
}

// SOCKETS_Socket
// file ..\..\..\..\lib\secure_sockets\portable\freertos_plus_tcp\aws_secure_sockets.c line 479
Socket_t SOCKETS_Socket(int32_t lDomain, int32_t lType, int32_t lProtocol)
{
  SSOCKETContextPtr_t pxContext=((SSOCKETContextPtr_t)NULL);
  Socket_t xSocket;
  if(!(lDomain == 2))
    vAssertCalled("..\\..\\..\\..\\lib\\secure_sockets\\portable\\freertos_plus_tcp\\aws_secure_sockets.c", 487u);

  if(!(lType == 1))
    vAssertCalled("..\\..\\..\\..\\lib\\secure_sockets\\portable\\freertos_plus_tcp\\aws_secure_sockets.c", 488u);

  if(!(lProtocol == 6))
    vAssertCalled("..\\..\\..\\..\\lib\\secure_sockets\\portable\\freertos_plus_tcp\\aws_secure_sockets.c", 489u);

  xSocket=FreeRTOS_socket(lDomain, lType, lProtocol);
  if(!(xSocket == (void *)4294967295u))
  {
    void *return_value_pvPortMalloc=pvPortMalloc(sizeof(SSOCKETContext_t) /*72ull*/ );
    pxContext = (SSOCKETContextPtr_t)return_value_pvPortMalloc;
    if(pxContext == ((SSOCKETContextPtr_t)NULL))
    {
      FreeRTOS_closesocket(xSocket);
      pxContext = (SSOCKETContextPtr_t)(Socket_t)~0u;
    }

    else
    {
      memset((void *)pxContext, 0, sizeof(SSOCKETContext_t) /*72ull*/ );
      pxContext->xSocket = xSocket;
    }
  }

  else
    pxContext = (SSOCKETContextPtr_t)(Socket_t)~0u;
  return (Socket_t)pxContext;
}

// SYSTEM_Init
// file ..\..\..\..\lib\utils\aws_system_init.c line 38
BaseType_t SYSTEM_Init()
{
  BaseType_t xResult=1;
  xResult=BUFFERPOOL_Init();
  if(xResult == 1)
    xResult=MQTT_AGENT_Init();

  if(xResult == 1)
    xResult=SOCKETS_Init();

  return xResult;
}

// TLS_Cleanup
// file ..\..\..\..\lib\tls\aws_tls.c line 710
void TLS_Cleanup(void *pvContext)
{
  TLSContext_t *pCtx=(TLSContext_t *)pvContext;
  if(!(pCtx == ((TLSContext_t *)NULL)))
  {
    if(pCtx->xMbedInitialized == 1)
      prvFreeContext(pCtx);

    vPortFree((void *)pCtx);
  }

}

// TLS_Connect
// file ..\..\..\..\lib\tls\aws_tls.c line 485
BaseType_t TLS_Connect(void *pvContext)
{
  BaseType_t xResult=0;
  TLSContext_t *pCtx=(TLSContext_t *)pvContext;
  CRYPTO_ConfigureHeap();
  mbedtls_ssl_init(&pCtx->mbedSslCtx);
  mbedtls_ssl_config_init(&pCtx->mbedSslConfig);
  mbedtls_x509_crt_init(&pCtx->mbedX509CA);
  if(!(pCtx->pcServerCertificate == ((const char *)NULL)))
    xResult=mbedtls_x509_crt_parse(&pCtx->mbedX509CA, (const unsigned char *)pCtx->pcServerCertificate, (size_t)pCtx->ulServerCertificateLength);

  else
  {
    xResult=mbedtls_x509_crt_parse(&pCtx->mbedX509CA, (const unsigned char *)tlsVERISIGN_ROOT_CERTIFICATE_PEM, (size_t)tlsVERISIGN_ROOT_CERTIFICATE_LENGTH);
    if(xResult == 0)
      xResult=mbedtls_x509_crt_parse(&pCtx->mbedX509CA, (const unsigned char *)tlsATS1_ROOT_CERTIFICATE_PEM, (size_t)tlsATS1_ROOT_CERTIFICATE_LENGTH);

  }
  if(xResult == 0)
    xResult=mbedtls_ssl_config_defaults(&pCtx->mbedSslConfig, 0, 0, 0);

  if(xResult == 0)
  {
    mbedtls_ssl_conf_verify(&pCtx->mbedSslConfig, prvCheckCertificate, (void *)pCtx);
    mbedtls_ssl_conf_authmode(&pCtx->mbedSslConfig, 2);
    mbedtls_ssl_conf_rng(&pCtx->mbedSslConfig, prvGenerateRandomBytes, (void *)pCtx);
    mbedtls_ssl_conf_ca_chain(&pCtx->mbedSslConfig, &pCtx->mbedX509CA, ((mbedtls_x509_crl *)NULL));
    xResult=prvInitializeClientCredential(pCtx);
  }

  if(xResult == 0)
  {
    if(!(pCtx->ppcAlpnProtocols == ((const char **)NULL)))
      xResult=mbedtls_ssl_conf_alpn_protocols(&pCtx->mbedSslConfig, pCtx->ppcAlpnProtocols);

  }

  if(xResult == 0)
    xResult=mbedtls_ssl_setup(&pCtx->mbedSslCtx, &pCtx->mbedSslConfig);

  if(xResult == 0)
  {
    if(!(pCtx->pcDestination == ((const char *)NULL)))
      xResult=mbedtls_ssl_set_hostname(&pCtx->mbedSslCtx, pCtx->pcDestination);

  }

  if(xResult == 0)
  {
    mbedtls_ssl_set_bio(&pCtx->mbedSslCtx, (void *)pCtx, prvNetworkSend$link1, prvNetworkRecv$link1, ((mbedtls_ssl_recv_timeout_t (*))NULL));
    do
    {
      xResult=mbedtls_ssl_handshake(&pCtx->mbedSslCtx);
      if(xResult == 0)
        break;

      if(!(xResult == -26880) && !(xResult == -26752))
      {
        prvFreeContext(pCtx);
        break;
      }

    }
    while((_Bool)1);
  }

  if(xResult == 0)
    pCtx->xMbedInitialized = 1;

  mbedtls_x509_crt_free(&pCtx->mbedX509CA);
  mbedtls_x509_crt_free(&pCtx->mbedX509Cli);
  return xResult;
}

// TLS_Init
// file ..\..\..\..\lib\tls\aws_tls.c line 432
BaseType_t TLS_Init(void **ppvContext, TLSParams_t *pxParams)
{
  BaseType_t xResult=0;
  TLSContext_t *pCtx=((TLSContext_t *)NULL);
  void *return_value_pvPortMalloc=pvPortMalloc(sizeof(TLSContext_t) /*1760ull*/ );
  pCtx = (TLSContext_t *)return_value_pvPortMalloc;
  if(!(pCtx == ((TLSContext_t *)NULL)))
  {
    memset((void *)pCtx, 0, sizeof(TLSContext_t) /*1760ull*/ );
    *ppvContext = (void *)pCtx;
    pCtx->pcDestination = pxParams->pcDestination;
    pCtx->pcServerCertificate = pxParams->pcServerCertificate;
    pCtx->ulServerCertificateLength = pxParams->ulServerCertificateLength;
    pCtx->ppcAlpnProtocols = pxParams->ppcAlpnProtocols;
    pCtx->ulAlpnProtocolsCount = pxParams->ulAlpnProtocolsCount;
    pCtx->pxNetworkRecv = pxParams->pxNetworkRecv;
    pCtx->pxNetworkSend = pxParams->pxNetworkSend;
    pCtx->pvCallerContext = pxParams->pvCallerContext;
  }

  else
    xResult = 2l;
  return xResult;
}

// TLS_Recv
// file ..\..\..\..\lib\tls\aws_tls.c line 616
BaseType_t TLS_Recv(void *pvContext, unsigned char *pucReadBuffer, size_t xReadLength)
{
  BaseType_t xResult=0;
  TLSContext_t *pCtx=(TLSContext_t *)pvContext;
  size_t xRead=0ull;
  if(!(pCtx == ((TLSContext_t *)NULL)))
  {
    if(pCtx->xMbedInitialized == 1)
      while(!(xRead >= xReadLength))
      {
        xResult=mbedtls_ssl_read(&pCtx->mbedSslCtx, pucReadBuffer + (signed long long int)xRead, xReadLength - xRead);
        if(xResult >= 1)
          xRead = xRead + (size_t)xResult;

        else
          if(xResult == 0)
            break;

          else
            if(!(xResult == -26880))
            {
              prvFreeContext(pCtx);
              break;
            }

      }

  }

  if(xResult >= 0)
    xResult = (BaseType_t)xRead;

  return xResult;
}

// TLS_Send
// file ..\..\..\..\lib\tls\aws_tls.c line 663
BaseType_t TLS_Send(void *pvContext, const unsigned char *pucMsg, size_t xMsgLength)
{
  BaseType_t xResult=0;
  TLSContext_t *pCtx=(TLSContext_t *)pvContext;
  size_t xWritten=0ull;
  if(!(pCtx == ((TLSContext_t *)NULL)))
  {
    if(pCtx->xMbedInitialized == 1)
      while(!(xWritten >= xMsgLength))
      {
        xResult=mbedtls_ssl_write(&pCtx->mbedSslCtx, pucMsg + (signed long long int)xWritten, xMsgLength - xWritten);
        if(xResult >= 1)
          xWritten = xWritten + (size_t)xResult;

        else
          if(xResult == 0)
            break;

          else
            if(!(xResult == -26752))
            {
              prvFreeContext(pCtx);
              break;
            }

      }

  }

  if(xResult >= 0)
    xResult = (BaseType_t)xWritten;

  return xResult;
}

// UIntToPtr
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 260
inline void * UIntToPtr(const unsigned int ui)
{
  return (void *)(UINT_PTR)ui;
}

// ULongToHandle
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 176
inline void * ULongToHandle(const unsigned long int h)
{
  return (void *)(UINT_PTR)h;
}

// ULongToPtr
// file C:\Program Files (x86)\Windows Kits\8.1\Include\shared\basetsd.h line 280
inline void * ULongToPtr(const unsigned long int ul)
{
  return (void *)(ULONG_PTR)ul;
}

// WspiapiClone
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\wspiapi.h line 405
inline signed int WspiapiClone(WORD wPort, struct addrinfo *ptResult)
{
  struct addrinfo *ptNext=((struct addrinfo *)NULL);
  struct addrinfo *ptNew=((struct addrinfo *)NULL);
  ptNext = ptResult;
  while(!(ptNext == ((struct addrinfo *)NULL)))
  {
    ptNew=WspiapiNewAddrInfo(2, ptNext->ai_protocol, wPort, ((struct sockaddr_in *)ptNext->ai_addr)->sin_addr.S_un.S_addr);
    if(ptNew == ((struct addrinfo *)NULL))
      break;

    ptNew->ai_next = ptNext->ai_next;
    ptNext->ai_next = ptNew;
    ptNext = ptNew->ai_next;
  }
  if(!(ptNext == ((struct addrinfo *)NULL)))
    return 8l;

  else
    return 0;
}

// WspiapiFreeAddrInfo
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\wspiapi.h line 1054
inline void WspiapiFreeAddrInfo(struct addrinfo *ai)
{
  FARPROC return_value_WspiapiLoad;
  static WSPIAPI_PFREEADDRINFO pfFreeAddrInfo=((WSPIAPI_PFREEADDRINFO)NULL);
  if(pfFreeAddrInfo == ((WSPIAPI_PFREEADDRINFO)NULL))
  {
    return_value_WspiapiLoad=WspiapiLoad(2);
    pfFreeAddrInfo = (WSPIAPI_PFREEADDRINFO)return_value_WspiapiLoad;
  }

  pfFreeAddrInfo(ai);
}

// WspiapiGetAddrInfo
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\wspiapi.h line 1007
inline signed int WspiapiGetAddrInfo(const char *nodename, const char *servname, const struct addrinfo *hints, struct addrinfo **res)
{
  signed int iError;
  FARPROC return_value_WspiapiLoad;
  static WSPIAPI_PGETADDRINFO pfGetAddrInfo=((WSPIAPI_PGETADDRINFO)NULL);
  if(pfGetAddrInfo == ((WSPIAPI_PGETADDRINFO)NULL))
  {
    return_value_WspiapiLoad=WspiapiLoad(0);
    pfGetAddrInfo = (WSPIAPI_PGETADDRINFO)return_value_WspiapiLoad;
  }

  iError=pfGetAddrInfo(nodename, servname, hints, res);
  WSASetLastError(iError);
  return iError;
}

// WspiapiGetNameInfo
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\wspiapi.h line 1029
inline signed int WspiapiGetNameInfo(const struct sockaddr *sa, socklen_t salen, char *host, size_t hostlen, char *serv, size_t servlen, signed int flags)
{
  signed int iError;
  FARPROC return_value_WspiapiLoad;
  static WSPIAPI_PGETNAMEINFO pfGetNameInfo=((WSPIAPI_PGETNAMEINFO)NULL);
  if(pfGetNameInfo == ((WSPIAPI_PGETNAMEINFO)NULL))
  {
    return_value_WspiapiLoad=WspiapiLoad(1);
    pfGetNameInfo = (WSPIAPI_PGETNAMEINFO)return_value_WspiapiLoad;
  }

  iError=pfGetNameInfo(sa, salen, host, hostlen, serv, servlen, flags);
  WSASetLastError(iError);
  return iError;
}

// WspiapiLegacyFreeAddrInfo
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\wspiapi.h line 455
inline void WspiapiLegacyFreeAddrInfo(struct addrinfo *ptHead)
{
  struct addrinfo *ptNext=ptHead;
  for( ; !(ptNext == ((struct addrinfo *)NULL)); ptNext = ptHead)
  {
    if(!(ptNext->ai_canonname == ((char *)NULL)))
      free((void *)ptNext->ai_canonname);

    if(!(ptNext->ai_addr == ((struct sockaddr *)NULL)))
      free((void *)ptNext->ai_addr);

    ptHead = ptNext->ai_next;
    free((void *)ptNext);
  }
}

// WspiapiLegacyGetAddrInfo
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\wspiapi.h line 488
inline signed int WspiapiLegacyGetAddrInfo(const char *pszNodeName, const char *pszServiceName, const struct addrinfo *ptHints, struct addrinfo **pptResult)
{
  signed int iError=0;
  signed int iFlags=0;
  signed int iFamily=0;
  signed int iSocketType=0;
  signed int iProtocol=0;
  WORD wPort=0;
  DWORD dwAddress=0ul;
  struct servent *ptService=((struct servent *)NULL);
  char *pc=((char *)NULL);
  BOOL bClone=0;
  WORD wTcpPort=0;
  WORD wUdpPort=0;
  *pptResult = ((struct addrinfo *)NULL);
  BOOL return_value_WspiapiParseV4Address;
  if(pszNodeName == ((const char *)NULL) && pszServiceName == ((const char *)NULL))
    return 11001l;

  else
  {
    if(!(ptHints == ((const struct addrinfo *)NULL)))
    {
      _Bool tmp_if_expr;
      if(!(ptHints->ai_addrlen == 0ull))
        tmp_if_expr = (_Bool)1;

      else
        tmp_if_expr = ptHints->ai_canonname != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$0;
      if(tmp_if_expr)
        tmp_if_expr$0 = (_Bool)1;

      else
        tmp_if_expr$0 = ptHints->ai_addr != ((struct sockaddr *)NULL) ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$1;
      if(tmp_if_expr$0)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = ptHints->ai_next != ((struct addrinfo *)NULL) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
        return 11003l;

      iFlags = ptHints->ai_flags;
      if(pszNodeName == ((const char *)NULL) && !((0x2 & iFlags) == 0))
        return 10022l;

      iFamily = ptHints->ai_family;
      if(!(iFamily == 0) && !(iFamily == 2))
        return 10047l;

      iSocketType = ptHints->ai_socktype;
      if(!(iSocketType == 0) && !(iSocketType == 1) && !(iSocketType == 2) && !(iSocketType == 3))
        return 10044l;

      iProtocol = ptHints->ai_protocol;
    }

    if(!(pszServiceName == ((const char *)NULL)))
    {
      unsigned long int return_value_strtoul=strtoul(pszServiceName, &pc, 10);
      wPort = (WORD)return_value_strtoul;
      if((signed int)*pc == 0)
      {
        wUdpPort=htons(wPort);
        wTcpPort = wUdpPort;
        wPort = wTcpPort;
        if(iSocketType == 0)
        {
          bClone = 1;
          iSocketType = 1;
        }

      }

      else
      {
        if(iSocketType == 0 || iSocketType == 2)
        {
          ptService=getservbyname(pszServiceName, "udp");
          if(!(ptService == ((struct servent *)NULL)))
          {
            wUdpPort = (WORD)ptService->s_port;
            wPort = wUdpPort;
          }

        }

        if(iSocketType == 0 || iSocketType == 1)
        {
          ptService=getservbyname(pszServiceName, "tcp");
          if(!(ptService == ((struct servent *)NULL)))
          {
            wTcpPort = (WORD)ptService->s_port;
            wPort = wTcpPort;
          }

        }

        if((signed int)wPort == 0)
          return iSocketType != 0 ? 10109l : 11001l;

        if(iSocketType == 0)
        {
          iSocketType = wTcpPort != 0 ? 1 : 2;
          bClone = (BOOL)(wTcpPort != 0 && wUdpPort != 0);
        }

      }
    }

    _Bool tmp_if_expr$2;
    if(pszNodeName == ((const char *)NULL))
      tmp_if_expr$2 = (_Bool)1;

    else
    {
      return_value_WspiapiParseV4Address=WspiapiParseV4Address(pszNodeName, &dwAddress);
      tmp_if_expr$2 = return_value_WspiapiParseV4Address != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$2)
    {
      if(pszNodeName == ((const char *)NULL))
        dwAddress=htonl((iFlags & 0x1) != 0 ? 0ul : 2130706433u);

      *pptResult=WspiapiNewAddrInfo(iSocketType, iProtocol, wPort, dwAddress);
      if(*pptResult == ((struct addrinfo *)NULL))
        iError = 8l;

      if(iError == 0 && !(pszNodeName == ((const char *)NULL)))
      {
        (*pptResult)->ai_flags = (*pptResult)->ai_flags | 0x4;
        if(!((0x2 & iFlags) == 0))
        {
          char *return_value_inet_ntoa=inet_ntoa(*((struct in_addr *)&dwAddress));
          (*pptResult)->ai_canonname=WspiapiStrdup(return_value_inet_ntoa);
          if((*pptResult)->ai_canonname == ((char *)NULL))
            iError = 8l;

        }

      }

    }

    else
      if(!((0x4 & iFlags) == 0))
        iError = 11001l;

      else
        iError=WspiapiLookupNode(pszNodeName, iSocketType, iProtocol, wPort, iFlags & 0x2, pptResult);
    if(iError == 0 && !(bClone == 0))
      iError=WspiapiClone(wUdpPort, *pptResult);

    if(!(iError == 0))
    {
      WspiapiLegacyFreeAddrInfo(*pptResult);
      *pptResult = ((struct addrinfo *)NULL);
    }

    return iError;
  }
}

// WspiapiLegacyGetNameInfo
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\wspiapi.h line 707
inline signed int WspiapiLegacyGetNameInfo(const struct sockaddr *ptSocketAddress, socklen_t tSocketLength, char *pszNodeName, size_t tNodeLength, char *pszServiceName, size_t tServiceLength, signed int iFlags)
{
  struct servent *ptService;
  WORD wPort;
  char szBuffer[6ll]={ '6', '5', '5', '3', '5', 0 };
  char *pszService=szBuffer;
  struct hostent *ptHost;
  struct in_addr tAddress;
  char *pszNode=((char *)NULL);
  char *pc=((char *)NULL);
  if(ptSocketAddress == ((const struct sockaddr *)NULL) || !((unsigned long long int)tSocketLength >= sizeof(struct sockaddr) /*16ull*/ ))
    return 11003l;

  else
    if(!((signed int)ptSocketAddress->sa_family == 2))
      return 10047l;

    else
      if(!((unsigned long long int)tSocketLength >= sizeof(struct sockaddr_in) /*16ull*/ ))
        return 11003l;

      else
        if((pszNodeName == ((char *)NULL) || tNodeLength == 0ull) && (pszServiceName == ((char *)NULL) || tServiceLength == 0ull))
          return 11001l;

        else
          if(!((0x2 & iFlags) == 0) && !((0x4 & iFlags) == 0))
            return 10022l;

          else
          {
            if(!(pszServiceName == ((char *)NULL)) && !(tServiceLength == 0ull))
            {
              wPort = ((struct sockaddr_in *)ptSocketAddress)->sin_port;
              if(!((0x8 & iFlags) == 0))
              {
                u_short return_value_ntohs=ntohs(wPort);
                sprintf_s(szBuffer, sizeof(char [6ll]) /*6ull*/  / sizeof(char) /*1ull*/ , "%u", return_value_ntohs);
              }

              else
              {
                ptService=getservbyport((signed int)wPort, (iFlags & 0x10) != 0 ? "udp" : ((char *)NULL));
                _Bool tmp_if_expr;
                if(!(ptService == ((struct servent *)NULL)))
                  tmp_if_expr = ptService->s_name != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr = (_Bool)0;
                if(tmp_if_expr)
                  pszService = ptService->s_name;

                else
                {
                  u_short return_value_ntohs$0=ntohs(wPort);
                  sprintf_s(szBuffer, sizeof(char [6ll]) /*6ull*/  / sizeof(char) /*1ull*/ , "%u", return_value_ntohs$0);
                }
              }
              size_t return_value_strlen=strlen(pszService);
              if(!(return_value_strlen >= tServiceLength))
                strcpy_s(pszServiceName, tServiceLength, pszService);

              else
                return 11003l;
            }

            if(!(pszNodeName == ((char *)NULL)) && !(tNodeLength == 0ull))
            {
              tAddress = ((struct sockaddr_in *)ptSocketAddress)->sin_addr;
              if(!((0x2 & iFlags) == 0))
                pszNode=inet_ntoa(tAddress);

              else
              {
                ptHost=gethostbyaddr((char *)&tAddress, (signed int)sizeof(struct in_addr) /*4*/ , 2);
                _Bool tmp_if_expr$0;
                if(!(ptHost == ((struct hostent *)NULL)))
                  tmp_if_expr$0 = ptHost->h_name != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$0 = (_Bool)0;
                if(tmp_if_expr$0)
                {
                  pszNode = ptHost->h_name;
                  if(!((0x1 & iFlags) == 0))
                  {
                    pc=strchr(pszNode, 46);
                    if(!(pc == ((char *)NULL)))
                      *pc = 0;

                  }

                }

                else
                  if(!((0x4 & iFlags) == 0))
                  {
                    signed int return_value_WSAGetLastError=WSAGetLastError();
                    switch(return_value_WSAGetLastError)
                    {
                      case 11001l:
                        return 11001l;
                      case 11002l:
                        return 11002l;
                      case 11003l:
                        return 11003l;
                      default:
                        return 11001l;
                    }
                  }

                  else
                    pszNode=inet_ntoa(tAddress);
              }
              size_t return_value_strlen$0=strlen(pszNode);
              if(!(return_value_strlen$0 >= tNodeLength))
                strcpy_s(pszNodeName, tNodeLength, pszNode);

              else
                return 11003l;
            }

            return 0;
          }
}

// WspiapiLoad
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\wspiapi.h line 881
inline FARPROC WspiapiLoad(WORD wFunction)
{
  HMODULE hLibrary=((HMODULE)NULL);
  WSPIAPI_FUNCTION rgtLocal[3ll]={ { .pszName="getaddrinfo", .pfAddress=(FARPROC)WspiapiLegacyGetAddrInfo },
    { .pszName="getnameinfo", .pfAddress=(FARPROC)WspiapiLegacyGetNameInfo },
    { .pszName="freeaddrinfo", .pfAddress=(FARPROC)WspiapiLegacyFreeAddrInfo } };
  FARPROC fScratch=((FARPROC)NULL);
  signed int i=0;
  static WSPIAPI_FUNCTION rgtGlobal[3ll]={ { .pszName="getaddrinfo", .pfAddress=(FARPROC)WspiapiLegacyGetAddrInfo },
    { .pszName="getnameinfo", .pfAddress=(FARPROC)WspiapiLegacyGetNameInfo },
    { .pszName="freeaddrinfo", .pfAddress=(FARPROC)WspiapiLegacyFreeAddrInfo } };
  static BOOL bInitialized=0;
  if(!(bInitialized == 0))
    return rgtGlobal[(signed long long int)wFunction].pfAddress;

  else
  {
    {
      CHAR SystemDir[261ll];
      CHAR Path[268ll];
      UINT return_value_GetSystemDirectoryA=GetSystemDirectoryA(SystemDir, 260u);
      if(!(return_value_GetSystemDirectoryA == 0u))
      {
        strcpy_s(Path, sizeof(CHAR [268ll]) /*268ull*/  / sizeof(CHAR) /*1ull*/ , SystemDir);
        strcat_s(Path, sizeof(CHAR [268ll]) /*268ull*/  / sizeof(CHAR) /*1ull*/ , "\\ws2_32");
        hLibrary=LoadLibraryA(Path);
        if(!(hLibrary == ((HMODULE)NULL)))
        {
          fScratch=GetProcAddress(hLibrary, "getaddrinfo");
          if(fScratch == ((FARPROC)NULL))
          {
            FreeLibrary(hLibrary);
            hLibrary = ((HMODULE)NULL);
          }

        }

        if(hLibrary == ((HMODULE)NULL))
        {
          strcpy_s(Path, sizeof(CHAR [268ll]) /*268ull*/  / sizeof(CHAR) /*1ull*/ , SystemDir);
          strcat_s(Path, sizeof(CHAR [268ll]) /*268ull*/  / sizeof(CHAR) /*1ull*/ , "\\wship6");
          hLibrary=LoadLibraryA(Path);
          if(!(hLibrary == ((HMODULE)NULL)))
          {
            fScratch=GetProcAddress(hLibrary, "getaddrinfo");
            if(fScratch == ((FARPROC)NULL))
            {
              FreeLibrary(hLibrary);
              hLibrary = ((HMODULE)NULL);
            }

          }

          goto __CPROVER_DUMP_L9;
        }

      }

    }

  __CPROVER_DUMP_L9:
    ;
    if(!(hLibrary == ((HMODULE)NULL)))
    {
      i = 0;
      static const signed int iNumGlobal=(const signed int)(sizeof(WSPIAPI_FUNCTION [3ll]) /*48ull*/  / sizeof(WSPIAPI_FUNCTION) /*16ull*/ );
      for( ; !(i >= iNumGlobal); i = i + 1)
      {
        rgtLocal[(signed long long int)i].pfAddress=GetProcAddress(hLibrary, rgtLocal[(signed long long int)i].pszName);
        if(rgtLocal[(signed long long int)i].pfAddress == ((FARPROC)NULL))
        {
          FreeLibrary(hLibrary);
          hLibrary = ((HMODULE)NULL);
          break;
        }

      }
      if(!(hLibrary == ((HMODULE)NULL)))
      {
        i = 0;
        for( ; !(i >= iNumGlobal); i = i + 1)
          rgtGlobal[(signed long long int)i].pfAddress = rgtLocal[(signed long long int)i].pfAddress;
      }

    }

    bInitialized = 1;
    return rgtGlobal[(signed long long int)wFunction].pfAddress;
  }
}

// WspiapiLookupNode
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\wspiapi.h line 321
inline signed int WspiapiLookupNode(const char *pszNodeName, signed int iSocketType, signed int iProtocol, WORD wPort, BOOL bAI_CANONNAME, struct addrinfo **pptResult)
{
  signed int iError=0;
  signed int iAliasCount=0;
  char szFQDN1[1025ll]={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  char szFQDN2[1025ll]={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  char *pszName=szFQDN1;
  char *pszAlias=szFQDN2;
  char *pszScratch=((char *)NULL);
  strncpy_s(pszName, 1025ull, pszNodeName, (rsize_t)(1025 - 1));
  signed int return_value_strcmp;
  while((_Bool)1)
  {
    iError=WspiapiQueryDNS(pszNodeName, iSocketType, iProtocol, wPort, pszAlias, pptResult);
    if(!(iError == 0))
      break;

    if(!(*pptResult == ((struct addrinfo *)NULL)))
      break;

    size_t return_value_strlen=strlen(pszAlias);
    _Bool tmp_if_expr;
    if(return_value_strlen == 0ull)
      tmp_if_expr = (_Bool)1;

    else
    {
      return_value_strcmp=strcmp(pszName, pszAlias);
      tmp_if_expr = !(return_value_strcmp != 0) ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr$0;
    if(tmp_if_expr)
      tmp_if_expr$0 = (_Bool)1;

    else
    {
      iAliasCount = iAliasCount + 1;
      tmp_if_expr$0 = iAliasCount == 16 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$0)
    {
      iError = 11003l;
      break;
    }

    pszScratch = pszName;
    pszName = pszAlias;
    pszAlias = pszScratch;
  }
  if(iError == 0 && !(bAI_CANONNAME == 0))
  {
    (*pptResult)->ai_canonname=WspiapiStrdup(pszAlias);
    if((*pptResult)->ai_canonname == ((char *)NULL))
      iError = 8l;

  }

  return iError;
}

// WspiapiNewAddrInfo
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\wspiapi.h line 185
inline struct addrinfo * WspiapiNewAddrInfo(signed int iSocketType, signed int iProtocol, WORD wPort, DWORD dwAddress)
{
  struct addrinfo *ptNew;
  struct sockaddr_in *ptAddress;
  void *return_value_calloc=calloc(1ull, sizeof(struct addrinfo) /*48ull*/ );
  ptNew = (struct addrinfo *)return_value_calloc;
  if(ptNew == ((struct addrinfo *)NULL))
    return ((struct addrinfo *)NULL);

  else
  {
    void *return_value_calloc$0=calloc(1ull, sizeof(struct sockaddr_in) /*16ull*/ );
    ptAddress = (struct sockaddr_in *)return_value_calloc$0;
    if(ptAddress == ((struct sockaddr_in *)NULL))
    {
      free((void *)ptNew);
      return ((struct addrinfo *)NULL);
    }

    else
    {
      ptAddress->sin_family = 2;
      ptAddress->sin_port = wPort;
      ptAddress->sin_addr.S_un.S_addr = dwAddress;
      ptNew->ai_family = 2;
      ptNew->ai_socktype = iSocketType;
      ptNew->ai_protocol = iProtocol;
      ptNew->ai_addrlen = sizeof(struct sockaddr_in) /*16ull*/ ;
      ptNew->ai_addr = (struct sockaddr *)ptAddress;
      return ptNew;
    }
  }
}

// WspiapiParseV4Address
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\wspiapi.h line 140
inline BOOL WspiapiParseV4Address(const char *pszAddress, PDWORD pdwAddress)
{
  DWORD dwAddress=0ul;
  const char *pcNext=((const char *)NULL);
  signed int iCount=0;
  pcNext = pszAddress;
  for( ; !((signed int)*pcNext == 0); pcNext = pcNext + 1ll)
    if((signed int)*pcNext == 46)
      iCount = iCount + 1;

  if(!(iCount == 3))
    return 0;

  else
  {
    dwAddress=inet_addr(pszAddress);
    if(dwAddress == 0xFFFFFFFFu)
      return 0;

    else
    {
      *pdwAddress = dwAddress;
      return 1;
    }
  }
}

// WspiapiQueryDNS
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\wspiapi.h line 242
inline signed int WspiapiQueryDNS(const char *pszNodeName, signed int iSocketType, signed int iProtocol, WORD wPort, char *pszAlias, struct addrinfo **pptResult)
{
  struct addrinfo **pptNext=pptResult;
  struct hostent *ptHost=((struct hostent *)NULL);
  char **ppAddresses;
  *pptNext = ((struct addrinfo *)NULL);
  pszAlias[0ll] = 0;
  ptHost=gethostbyname(pszNodeName);
  if(!(ptHost == ((struct hostent *)NULL)))
  {
    if((signed int)ptHost->h_addrtype == 2)
    {
      if((unsigned long long int)ptHost->h_length == sizeof(struct in_addr) /*4ull*/ )
      {
        ppAddresses = ptHost->h_addr_list;
        for( ; !(*ppAddresses == ((char *)NULL)); ppAddresses = ppAddresses + 1ll)
        {
          *pptNext=WspiapiNewAddrInfo(iSocketType, iProtocol, wPort, ((struct in_addr *)*ppAddresses)->S_un.S_addr);
          if(*pptNext == ((struct addrinfo *)NULL))
            return 8l;

          pptNext = &(*pptNext)->ai_next;
        }
      }

    }

    strncpy_s(pszAlias, 1025ull, ptHost->h_name, (rsize_t)(1025 - 1));
    return 0;
  }

  else
  {
    signed int return_value_WSAGetLastError=WSAGetLastError();
    switch(return_value_WSAGetLastError)
    {
      case 11001l:
        return 11001l;
      case 11002l:
        return 11002l;
      case 11003l:
        return 11003l;
      case 11004l:
        return 11001l;
      default:
        return 11001l;
    }
  }
}

// WspiapiStrdup
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\wspiapi.h line 103
inline char * WspiapiStrdup(const char *pszString)
{
  char *pszMemory;
  size_t cchMemory;
  if(pszString == ((const char *)NULL))
    return ((char *)NULL);

  else
  {
    size_t return_value_strlen=strlen(pszString);
    cchMemory = return_value_strlen + 1ull;
    void *return_value_calloc=calloc(1ull, cchMemory);
    pszMemory = (char *)return_value_calloc;
    if(pszMemory == ((char *)NULL))
      return ((char *)NULL);

    else
    {
      strcpy_s(pszMemory, cchMemory, pszString);
      return pszMemory;
    }
  }
}

// _MallocaComputeSize
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\malloc.h line 100
inline size_t _MallocaComputeSize(size_t _Size)
{
  size_t _MarkedSize=_Size + 16ull;
  return _MarkedSize > _Size ? _MarkedSize : 0ull;
}

// _MarkAllocaS
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\malloc.h line 90
inline void * _MarkAllocaS(void *_Ptr, unsigned int _Marker)
{
  if(!(_Ptr == NULL))
  {
    *((unsigned int *)_Ptr) = _Marker;
    _Ptr = (void *)((char *)_Ptr + 16ll);
  }

  return _Ptr;
}

// __acrt_get_locale_data_prefix
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\ctype.h line 144
inline __crt_locale_data_public * __acrt_get_locale_data_prefix(const volatile void * const _LocalePointers)
{
  const _locale_t _TypedLocalePointers=(_locale_t)_LocalePointers;
  return (__crt_locale_data_public *)_TypedLocalePointers->locinfo;
}

// __local_stdio_printf_options
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_stdio_config.h line 72
inline unsigned long long int * __local_stdio_printf_options(void)
{
  static unsigned long long int _OptionsStorage;
  return &_OptionsStorage;
}

// __local_stdio_scanf_options
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_stdio_config.h line 81
inline unsigned long long int * __local_stdio_scanf_options(void)
{
  static unsigned long long int _OptionsStorage;
  return &_OptionsStorage;
}


// __vswprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1205
inline signed int __vswprintf_l(wchar_t * const _Buffer, const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  signed int return_value__vswprintf_l=_vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
  return return_value__vswprintf_l;
}

// _cbor_value_copy_string
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 1064
CborError _cbor_value_copy_string(const CborValue *value, void *buffer, size_t *buflen, CborValue *next)
{
  _Bool copied_all;
  CborError err=iterate_string_chunks(value, (char *)buffer, buflen, &copied_all, next, buffer != NULL ? iterate_memcpy : iterate_noop);
  return (CborError)(err != /*enum*/CborNoError ? (signed int)err : (copied_all != (_Bool)0 ? 0 : -2147483648));
}

// _cbor_value_decode_int64_internal
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 300
uint64_t _cbor_value_decode_int64_internal(const CborValue *value)
{
  _Bool tmp_if_expr;
  if(!((1 & (signed int)value->flags) == 0))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = (signed int)value->type == 250 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$0;
  if(tmp_if_expr)
    tmp_if_expr$0 = (_Bool)1;

  else
    tmp_if_expr$0 = (signed int)value->type == 251 ? (_Bool)1 : (_Bool)0;
  /* assertion value->flags & CborIteratorFlag_IntegerValueTooLarge || value->type == CborFloatType || value->type == CborDoubleType */
  assert(tmp_if_expr$0);
  _Bool tmp_if_expr$1;
  if((31 & (signed int)*value->ptr) == 26)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = ((signed int)*value->ptr & 31) == 27 ? (_Bool)1 : (_Bool)0;
  /* assertion (*value->ptr & SmallValueMask) == Value32Bit || (*value->ptr & SmallValueMask) == Value64Bit */
  assert(tmp_if_expr$1);
  uint32_t return_value_get32;
  if((1 & (signed int)*value->ptr) == 0)
  {
    return_value_get32=get32$link1(value->ptr + 1ll);
    return (uint64_t)return_value_get32;
  }

  else
  {
    /* assertion (*value->ptr & SmallValueMask) == Value64Bit */
    assert(((signed int)*value->ptr & 31) == 27);
    uint64_t return_value_get64=get64$link1(value->ptr + 1ll);
    return return_value_get64;
  }
}

// _cbor_value_dup_string
// file ..\..\..\..\lib\third_party\tinycbor\cborparser_dup_string.c line 92
CborError _cbor_value_dup_string(const CborValue *value, void **buffer, size_t *buflen, CborValue *next)
{
  /* assertion buffer */
  assert(buffer != ((void **)NULL));
  /* assertion buflen */
  assert(buflen != ((size_t *)NULL));
  *buflen = 18446744073709551615ull;
  CborError err=_cbor_value_copy_string(value, NULL, buflen, ((CborValue *)NULL));
  if(!(err == /*enum*/CborNoError))
    return err;

  else
  {
    *buflen = *buflen + 1ull;
    *buffer=malloc(*buflen);
    if(*buffer == NULL)
      return /*enum*/CborErrorOutOfMemory;

    else
    {
      err=_cbor_value_copy_string(value, *buffer, buflen, next);
      if(!(err == /*enum*/CborNoError))
      {
        free(*buffer);
        return err;
      }

      else
        return /*enum*/CborNoError;
    }
  }
}

// _cbor_value_extract_int64_helper
// file ..\..\..\..\lib\third_party\tinycbor\cbor.h line 260
static inline uint64_t _cbor_value_extract_int64_helper(const CborValue *value)
{
  uint64_t tmp_if_expr;
  uint64_t return_value__cbor_value_decode_int64_internal;
  if(!((1 & (signed int)value->flags) == 0))
  {
    return_value__cbor_value_decode_int64_internal=_cbor_value_decode_int64_internal(value);
    tmp_if_expr = return_value__cbor_value_decode_int64_internal;
  }

  else
    tmp_if_expr = (unsigned long long int)value->extra;
  return tmp_if_expr;
}

// _cbor_value_extract_int64_helper$link1
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 260
static inline uint64_t _cbor_value_extract_int64_helper$link1(const CborValue *value$link1)
{
  uint64_t tmp_if_expr$link1;
  uint64_t return_value__cbor_value_decode_int64_internal$link1;
  if(!((1 & (signed int)value$link1->flags) == 0))
  {
    return_value__cbor_value_decode_int64_internal$link1=_cbor_value_decode_int64_internal(value$link1);
    tmp_if_expr$link1 = return_value__cbor_value_decode_int64_internal$link1;
  }

  else
    tmp_if_expr$link1 = (unsigned long long int)value$link1->extra;
  return tmp_if_expr$link1;
}

// _cbor_value_extract_int64_helper$link2
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 260
static inline uint64_t _cbor_value_extract_int64_helper$link2(const CborValue *value$link2)
{
  uint64_t tmp_if_expr$link2;
  uint64_t return_value__cbor_value_decode_int64_internal$link2;
  if(!((1 & (signed int)value$link2->flags) == 0))
  {
    return_value__cbor_value_decode_int64_internal$link2=_cbor_value_decode_int64_internal(value$link2);
    tmp_if_expr$link2 = return_value__cbor_value_decode_int64_internal$link2;
  }

  else
    tmp_if_expr$link2 = (unsigned long long int)value$link2->extra;
  return tmp_if_expr$link2;
}

// _chgsignl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 794
inline double _chgsignl(double _X)
{
  double return_value__chgsign=_chgsign((double)_X);
  return return_value__chgsign;
}

// _chvalidchk_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\ctype.h line 154
inline signed int _chvalidchk_l(const signed int _C, const signed int _Mask, const _locale_t _Locale)
{
  signed int return_value__chvalidator_l=_chvalidator_l(_Locale, _C, _Mask);
  return return_value__chvalidator_l;
}

// _copysignl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 801
inline double _copysignl(double _Number, double _Sign)
{
  double return_value__copysign=_copysign((double)_Number, (double)_Sign);
  return return_value__copysign;
}


// _hypotl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 855
inline double _hypotl(double _X, double _Y)
{
  double return_value__hypot=_hypot((double)_X, (double)_Y);
  return return_value__hypot;
}

// _ischartype_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\ctype.h line 175
inline signed int _ischartype_l(const signed int _C, const signed int _Mask, const _locale_t _Locale)
{
  __crt_locale_data_public *return_value___acrt_get_locale_data_prefix;
  if(!(_Locale == ((const _locale_t)NULL)))
  {
    return_value___acrt_get_locale_data_prefix=__acrt_get_locale_data_prefix((const volatile void *)_Locale);
    if(return_value___acrt_get_locale_data_prefix->_locale_mb_cur_max >= 2)
    {
      signed int return_value__isctype_l=_isctype_l(_C, _Mask, _Locale);
      return return_value__isctype_l;
    }

  }

  signed int return_value__chvalidchk_l=_chvalidchk_l(_C, _Mask, _Locale);
  return return_value__chvalidchk_l;
}


// _vcprintf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 86
inline signed int _vcprintf(const char * const _Format, va_list _ArgList)
{
  signed int return_value__vcprintf_l=_vcprintf_l(_Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vcprintf_l;
}

// _vcprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 70
inline signed int _vcprintf_l(const char * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  unsigned long long int *return_value___local_stdio_printf_options=__local_stdio_printf_options();
  signed int return_value___conio_common_vcprintf=__conio_common_vcprintf(*return_value___local_stdio_printf_options, _Format, _Locale, _ArgList);
  return return_value___conio_common_vcprintf;
}

// _vcprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 144
inline signed int _vcprintf_p(const char * const _Format, va_list _ArgList)
{
  signed int return_value__vcprintf_p_l=_vcprintf_p_l(_Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vcprintf_p_l;
}

// _vcprintf_p_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 128
inline signed int _vcprintf_p_l(const char * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  unsigned long long int *return_value___local_stdio_printf_options=__local_stdio_printf_options();
  signed int return_value___conio_common_vcprintf_p=__conio_common_vcprintf_p(*return_value___local_stdio_printf_options, _Format, _Locale, _ArgList);
  return return_value___conio_common_vcprintf_p;
}

// _vcprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 115
inline signed int _vcprintf_s(const char * const _Format, va_list _ArgList)
{
  signed int return_value__vcprintf_s_l=_vcprintf_s_l(_Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vcprintf_s_l;
}

// _vcprintf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 99
inline signed int _vcprintf_s_l(const char * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  unsigned long long int *return_value___local_stdio_printf_options=__local_stdio_printf_options();
  signed int return_value___conio_common_vcprintf_s=__conio_common_vcprintf_s(*return_value___local_stdio_printf_options, _Format, _Locale, _ArgList);
  return return_value___conio_common_vcprintf_s;
}

// _vcscanf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 292
inline signed int _vcscanf(const char * const _Format, va_list _ArgList)
{
  signed int return_value__vcscanf_l=_vcscanf_l(_Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vcscanf_l;
}

// _vcscanf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 276
inline signed int _vcscanf_l(const char * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  unsigned long long int *return_value___local_stdio_scanf_options=__local_stdio_scanf_options();
  signed int return_value___conio_common_vcscanf=__conio_common_vcscanf(*return_value___local_stdio_scanf_options, _Format, _Locale, _ArgList);
  return return_value___conio_common_vcscanf;
}

// _vcscanf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 324
inline signed int _vcscanf_s(const char * const _Format, va_list _ArgList)
{
  signed int return_value__vcscanf_s_l=_vcscanf_s_l(_Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vcscanf_s_l;
}

// _vcscanf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 308
inline signed int _vcscanf_s_l(const char * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  unsigned long long int *return_value___local_stdio_scanf_options=__local_stdio_scanf_options();
  signed int return_value___conio_common_vcscanf=__conio_common_vcscanf(*return_value___local_stdio_scanf_options | 1ull << 0, _Format, _Locale, _ArgList);
  return return_value___conio_common_vcscanf;
}

// _vcwprintf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 100
inline signed int _vcwprintf(const wchar_t * const _Format, va_list _ArgList)
{
  signed int return_value__vcwprintf_l=_vcwprintf_l(_Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vcwprintf_l;
}

// _vcwprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 86
inline signed int _vcwprintf_l(const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  unsigned long long int *return_value___local_stdio_printf_options=__local_stdio_printf_options();
  signed int return_value___conio_common_vcwprintf=__conio_common_vcwprintf(*return_value___local_stdio_printf_options, _Format, _Locale, _ArgList);
  return return_value___conio_common_vcwprintf;
}

// _vcwprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 154
inline signed int _vcwprintf_p(const wchar_t * const _Format, va_list _ArgList)
{
  signed int return_value__vcwprintf_p_l=_vcwprintf_p_l(_Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vcwprintf_p_l;
}

// _vcwprintf_p_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 140
inline signed int _vcwprintf_p_l(const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  unsigned long long int *return_value___local_stdio_printf_options=__local_stdio_printf_options();
  signed int return_value___conio_common_vcwprintf_p=__conio_common_vcwprintf_p(*return_value___local_stdio_printf_options, _Format, _Locale, _ArgList);
  return return_value___conio_common_vcwprintf_p;
}

// _vcwprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 127
inline signed int _vcwprintf_s(const wchar_t * const _Format, va_list _ArgList)
{
  signed int return_value__vcwprintf_s_l=_vcwprintf_s_l(_Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vcwprintf_s_l;
}

// _vcwprintf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 113
inline signed int _vcwprintf_s_l(const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  unsigned long long int *return_value___local_stdio_printf_options=__local_stdio_printf_options();
  signed int return_value___conio_common_vcwprintf_s=__conio_common_vcwprintf_s(*return_value___local_stdio_printf_options, _Format, _Locale, _ArgList);
  return return_value___conio_common_vcwprintf_s;
}

// _vcwscanf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 303
inline signed int _vcwscanf(const wchar_t * const _Format, va_list _ArgList)
{
  signed int return_value__vcwscanf_l=_vcwscanf_l(_Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vcwscanf_l;
}

// _vcwscanf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 287
inline signed int _vcwscanf_l(const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  unsigned long long int *return_value___local_stdio_scanf_options=__local_stdio_scanf_options();
  signed int return_value___conio_common_vcwscanf=__conio_common_vcwscanf(*return_value___local_stdio_scanf_options, _Format, _Locale, _ArgList);
  return return_value___conio_common_vcwscanf;
}

// _vcwscanf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 335
inline signed int _vcwscanf_s(const wchar_t * const _Format, va_list _ArgList)
{
  signed int return_value__vcwscanf_s_l=_vcwscanf_s_l(_Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vcwscanf_s_l;
}

// _vcwscanf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wconio.h line 319
inline signed int _vcwscanf_s_l(const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  unsigned long long int *return_value___local_stdio_scanf_options=__local_stdio_scanf_options();
  signed int return_value___conio_common_vcwscanf=__conio_common_vcwscanf(*return_value___local_stdio_scanf_options | 1ull << 0, _Format, _Locale, _ArgList);
  return return_value___conio_common_vcwscanf;
}

// _vfprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 629
inline signed int _vfprintf_l(FILE * const _Stream, const char * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  unsigned long long int *return_value___local_stdio_printf_options=__local_stdio_printf_options();
  signed int return_value___stdio_common_vfprintf=__stdio_common_vfprintf(*return_value___local_stdio_printf_options, _Stream, _Format, _Locale, _ArgList);
  return return_value___stdio_common_vfprintf;
}

// _vfprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 706
inline signed int _vfprintf_p(FILE * const _Stream, const char * const _Format, va_list _ArgList)
{
  signed int return_value__vfprintf_p_l=_vfprintf_p_l(_Stream, _Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vfprintf_p_l;
}

// _vfprintf_p_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 691
inline signed int _vfprintf_p_l(FILE * const _Stream, const char * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  unsigned long long int *return_value___local_stdio_printf_options=__local_stdio_printf_options();
  signed int return_value___stdio_common_vfprintf_p=__stdio_common_vfprintf_p(*return_value___local_stdio_printf_options, _Stream, _Format, _Locale, _ArgList);
  return return_value___stdio_common_vfprintf_p;
}

// _vfprintf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 658
inline signed int _vfprintf_s_l(FILE * const _Stream, const char * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  unsigned long long int *return_value___local_stdio_printf_options=__local_stdio_printf_options();
  signed int return_value___stdio_common_vfprintf_s=__stdio_common_vfprintf_s(*return_value___local_stdio_printf_options, _Stream, _Format, _Locale, _ArgList);
  return return_value___stdio_common_vfprintf_s;
}

// _vfscanf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1049
inline signed int _vfscanf_l(FILE * const _Stream, const char * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  unsigned long long int *return_value___local_stdio_scanf_options=__local_stdio_scanf_options();
  signed int return_value___stdio_common_vfscanf=__stdio_common_vfscanf(*return_value___local_stdio_scanf_options, _Stream, _Format, _Locale, _ArgList);
  return return_value___stdio_common_vfscanf;
}

// _vfscanf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1080
inline signed int _vfscanf_s_l(FILE * const _Stream, const char * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  unsigned long long int *return_value___local_stdio_scanf_options=__local_stdio_scanf_options();
  signed int return_value___stdio_common_vfscanf=__stdio_common_vfscanf(*return_value___local_stdio_scanf_options | 1ull << 0, _Stream, _Format, _Locale, _ArgList);
  return return_value___stdio_common_vfscanf;
}

// _vfwprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 294
inline signed int _vfwprintf_l(FILE * const _Stream, const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  unsigned long long int *return_value___local_stdio_printf_options=__local_stdio_printf_options();
  signed int return_value___stdio_common_vfwprintf=__stdio_common_vfwprintf(*return_value___local_stdio_printf_options, _Stream, _Format, _Locale, _ArgList);
  return return_value___stdio_common_vfwprintf;
}

// _vfwprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 371
inline signed int _vfwprintf_p(FILE * const _Stream, const wchar_t * const _Format, va_list _ArgList)
{
  signed int return_value__vfwprintf_p_l=_vfwprintf_p_l(_Stream, _Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vfwprintf_p_l;
}

// _vfwprintf_p_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 356
inline signed int _vfwprintf_p_l(FILE * const _Stream, const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  unsigned long long int *return_value___local_stdio_printf_options=__local_stdio_printf_options();
  signed int return_value___stdio_common_vfwprintf_p=__stdio_common_vfwprintf_p(*return_value___local_stdio_printf_options, _Stream, _Format, _Locale, _ArgList);
  return return_value___stdio_common_vfwprintf_p;
}

// _vfwprintf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 323
inline signed int _vfwprintf_s_l(FILE * const _Stream, const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  unsigned long long int *return_value___local_stdio_printf_options=__local_stdio_printf_options();
  signed int return_value___stdio_common_vfwprintf_s=__stdio_common_vfwprintf_s(*return_value___local_stdio_printf_options, _Stream, _Format, _Locale, _ArgList);
  return return_value___stdio_common_vfwprintf_s;
}

// _vfwscanf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 709
inline signed int _vfwscanf_l(FILE * const _Stream, const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  unsigned long long int *return_value___local_stdio_scanf_options=__local_stdio_scanf_options();
  signed int return_value___stdio_common_vfwscanf=__stdio_common_vfwscanf(*return_value___local_stdio_scanf_options, _Stream, _Format, _Locale, _ArgList);
  return return_value___stdio_common_vfwscanf;
}

// _vfwscanf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 740
inline signed int _vfwscanf_s_l(FILE * const _Stream, const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  unsigned long long int *return_value___local_stdio_scanf_options=__local_stdio_scanf_options();
  signed int return_value___stdio_common_vfwscanf=__stdio_common_vfwscanf(*return_value___local_stdio_scanf_options | 1ull << 0, _Stream, _Format, _Locale, _ArgList);
  return return_value___stdio_common_vfwscanf;
}

// _vprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 720
inline signed int _vprintf_l(const char * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  FILE *return_value___acrt_iob_func=__acrt_iob_func(1u);
  signed int return_value__vfprintf_l=_vfprintf_l(return_value___acrt_iob_func, _Format, _Locale, _ArgList);
  return return_value__vfprintf_l;
}

// _vprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 792
inline signed int _vprintf_p(const char * const _Format, va_list _ArgList)
{
  FILE *return_value___acrt_iob_func=__acrt_iob_func(1u);
  signed int return_value__vfprintf_p_l=_vfprintf_p_l(return_value___acrt_iob_func, _Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vfprintf_p_l;
}

// _vprintf_p_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 778
inline signed int _vprintf_p_l(const char * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  FILE *return_value___acrt_iob_func=__acrt_iob_func(1u);
  signed int return_value__vfprintf_p_l=_vfprintf_p_l(return_value___acrt_iob_func, _Format, _Locale, _ArgList);
  return return_value__vfprintf_p_l;
}

// _vprintf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 747
inline signed int _vprintf_s_l(const char * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  FILE *return_value___acrt_iob_func=__acrt_iob_func(1u);
  signed int return_value__vfprintf_s_l=_vfprintf_s_l(return_value___acrt_iob_func, _Format, _Locale, _ArgList);
  return return_value__vfprintf_s_l;
}

// _vscanf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1116
inline signed int _vscanf_l(const char * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  FILE *return_value___acrt_iob_func=__acrt_iob_func(0u);
  signed int return_value__vfscanf_l=_vfscanf_l(return_value___acrt_iob_func, _Format, _Locale, _ArgList);
  return return_value__vfscanf_l;
}

// _vscanf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1143
inline signed int _vscanf_s_l(const char * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  FILE *return_value___acrt_iob_func=__acrt_iob_func(0u);
  signed int return_value__vfscanf_s_l=_vfscanf_s_l(return_value___acrt_iob_func, _Format, _Locale, _ArgList);
  return return_value__vfscanf_s_l;
}

// _vscprintf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1664
inline signed int _vscprintf(const char * const _Format, va_list _ArgList)
{
  signed int return_value__vscprintf_l=_vscprintf_l(_Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vscprintf_l;
}

// _vscprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1646
inline signed int _vscprintf_l(const char * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  signed int _Result;
  unsigned long long int *return_value___local_stdio_printf_options=__local_stdio_printf_options();
  _Result=__stdio_common_vsprintf(*return_value___local_stdio_printf_options | 1ull << 1, ((char *)NULL), 0ull, _Format, _Locale, _ArgList);
  return _Result < 0 ? -1 : _Result;
}

// _vscprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1695
inline signed int _vscprintf_p(const char * const _Format, va_list _ArgList)
{
  signed int return_value__vscprintf_p_l=_vscprintf_p_l(_Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vscprintf_p_l;
}

// _vscprintf_p_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1677
inline signed int _vscprintf_p_l(const char * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  signed int _Result;
  unsigned long long int *return_value___local_stdio_printf_options=__local_stdio_printf_options();
  _Result=__stdio_common_vsprintf_p(*return_value___local_stdio_printf_options | 1ull << 1, ((char *)NULL), 0ull, _Format, _Locale, _ArgList);
  return _Result < 0 ? -1 : _Result;
}

// _vscwprintf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1356
inline signed int _vscwprintf(const wchar_t * const _Format, va_list _ArgList)
{
  signed int return_value__vscwprintf_l=_vscwprintf_l(_Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vscwprintf_l;
}

// _vscwprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1337
inline signed int _vscwprintf_l(const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  signed int _Result;
  unsigned long long int *return_value___local_stdio_printf_options=__local_stdio_printf_options();
  _Result=__stdio_common_vswprintf(*return_value___local_stdio_printf_options | 1ull << 1, ((wchar_t *)NULL), 0ull, _Format, _Locale, _ArgList);
  return _Result < 0 ? -1 : _Result;
}

// _vscwprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1389
inline signed int _vscwprintf_p(const wchar_t * const _Format, va_list _ArgList)
{
  signed int return_value__vscwprintf_p_l=_vscwprintf_p_l(_Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vscwprintf_p_l;
}

// _vscwprintf_p_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1370
inline signed int _vscwprintf_p_l(const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  signed int _Result;
  unsigned long long int *return_value___local_stdio_printf_options=__local_stdio_printf_options();
  _Result=__stdio_common_vswprintf_p(*return_value___local_stdio_printf_options | 1ull << 1, ((wchar_t *)NULL), 0ull, _Format, _Locale, _ArgList);
  return _Result < 0 ? -1 : _Result;
}

// _vsnprintf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1396
inline signed int _vsnprintf(char * const _Buffer, const size_t _BufferCount, const char * const _Format, va_list _ArgList)
{
  signed int return_value__vsnprintf_l=_vsnprintf_l(_Buffer, _BufferCount, _Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vsnprintf_l;
}

// _vsnprintf_c
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1729
inline signed int _vsnprintf_c(char * const _Buffer, const size_t _BufferCount, const char * const _Format, va_list _ArgList)
{
  signed int return_value__vsnprintf_c_l=_vsnprintf_c_l(_Buffer, _BufferCount, _Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vsnprintf_c_l;
}

// _vsnprintf_c_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1708
inline signed int _vsnprintf_c_l(char * const _Buffer, const size_t _BufferCount, const char * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  signed int _Result;
  unsigned long long int *return_value___local_stdio_printf_options=__local_stdio_printf_options();
  _Result=__stdio_common_vsprintf(*return_value___local_stdio_printf_options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
  return _Result < 0 ? -1 : _Result;
}

// _vsnprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1375
inline signed int _vsnprintf_l(char * const _Buffer, const size_t _BufferCount, const char * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  signed int _Result;
  unsigned long long int *return_value___local_stdio_printf_options=__local_stdio_printf_options();
  _Result=__stdio_common_vsprintf(*return_value___local_stdio_printf_options | 1ull << 0, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
  return _Result < 0 ? -1 : _Result;
}

// _vsnprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1591
inline signed int _vsnprintf_s(char * const _Buffer, const size_t _BufferCount, const size_t _MaxCount, const char * const _Format, va_list _ArgList)
{
  signed int return_value__vsnprintf_s_l=_vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vsnprintf_s_l;
}

// _vsnprintf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1569
inline signed int _vsnprintf_s_l(char * const _Buffer, const size_t _BufferCount, const size_t _MaxCount, const char * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  signed int _Result;
  unsigned long long int *return_value___local_stdio_printf_options=__local_stdio_printf_options();
  _Result=__stdio_common_vsnprintf_s(*return_value___local_stdio_printf_options, _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
  return _Result < 0 ? -1 : _Result;
}

// _vsnwprintf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1120
inline signed int _vsnwprintf(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, va_list _ArgList)
{
  signed int return_value__vsnwprintf_l=_vsnwprintf_l(_Buffer, _BufferCount, _Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vsnwprintf_l;
}

// _vsnwprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1046
inline signed int _vsnwprintf_l(wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  signed int _Result;
  unsigned long long int *return_value___local_stdio_printf_options=__local_stdio_printf_options();
  _Result=__stdio_common_vswprintf(*return_value___local_stdio_printf_options | 1ull << 0, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
  return _Result < 0 ? -1 : _Result;
}

// _vsnwprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1092
inline signed int _vsnwprintf_s(wchar_t * const _Buffer, const size_t _BufferCount, const size_t _MaxCount, const wchar_t * const _Format, va_list _ArgList)
{
  signed int return_value__vsnwprintf_s_l=_vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vsnwprintf_s_l;
}

// _vsnwprintf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1070
inline signed int _vsnwprintf_s_l(wchar_t * const _Buffer, const size_t _BufferCount, const size_t _MaxCount, const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  signed int _Result;
  unsigned long long int *return_value___local_stdio_printf_options=__local_stdio_printf_options();
  _Result=__stdio_common_vsnwprintf_s(*return_value___local_stdio_printf_options, _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
  return _Result < 0 ? -1 : _Result;
}

// _vsnwscanf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1979
inline signed int _vsnwscanf_l(const wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  unsigned long long int *return_value___local_stdio_scanf_options=__local_stdio_scanf_options();
  signed int return_value___stdio_common_vswscanf=__stdio_common_vswscanf(*return_value___local_stdio_scanf_options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
  return return_value___stdio_common_vswscanf;
}

// _vsnwscanf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1998
inline signed int _vsnwscanf_s_l(const wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  unsigned long long int *return_value___local_stdio_scanf_options=__local_stdio_scanf_options();
  signed int return_value___stdio_common_vswscanf=__stdio_common_vswscanf(*return_value___local_stdio_scanf_options | 1ull << 0, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
  return return_value___stdio_common_vswscanf;
}

// _vsprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1446
inline signed int _vsprintf_l(char * const _Buffer, const char * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  signed int return_value__vsnprintf_l=_vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
  return return_value__vsnprintf_l;
}

// _vsprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1553
inline signed int _vsprintf_p(char * const _Buffer, const size_t _BufferCount, const char * const _Format, va_list _ArgList)
{
  signed int return_value__vsprintf_p_l=_vsprintf_p_l(_Buffer, _BufferCount, _Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vsprintf_p_l;
}

// _vsprintf_p_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1532
inline signed int _vsprintf_p_l(char * const _Buffer, const size_t _BufferCount, const char * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  signed int _Result;
  unsigned long long int *return_value___local_stdio_printf_options=__local_stdio_printf_options();
  _Result=__stdio_common_vsprintf_p(*return_value___local_stdio_printf_options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
  return _Result < 0 ? -1 : _Result;
}

// _vsprintf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1483
inline signed int _vsprintf_s_l(char * const _Buffer, const size_t _BufferCount, const char * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  signed int _Result;
  unsigned long long int *return_value___local_stdio_printf_options=__local_stdio_printf_options();
  _Result=__stdio_common_vsprintf_s(*return_value___local_stdio_printf_options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
  return _Result < 0 ? -1 : _Result;
}

// _vsscanf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 2157
inline signed int _vsscanf_l(const char * const _Buffer, const char * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  unsigned long long int *return_value___local_stdio_scanf_options=__local_stdio_scanf_options();
  signed int return_value___stdio_common_vsscanf=__stdio_common_vsscanf(*return_value___local_stdio_scanf_options, _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
  return return_value___stdio_common_vsscanf;
}

// _vsscanf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 2188
inline signed int _vsscanf_s_l(const char * const _Buffer, const char * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  unsigned long long int *return_value___local_stdio_scanf_options=__local_stdio_scanf_options();
  signed int return_value___stdio_common_vsscanf=__stdio_common_vsscanf(*return_value___local_stdio_scanf_options | 1ull << 0, _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
  return return_value___stdio_common_vsscanf;
}

// _vswprintf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1221
inline signed int _vswprintf(wchar_t * const _Buffer, const wchar_t * const _Format, va_list _ArgList)
{
  signed int return_value__vswprintf_l=_vswprintf_l(_Buffer, (size_t)-1, _Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vswprintf_l;
}

// _vswprintf_c
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1169
inline signed int _vswprintf_c(wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, va_list _ArgList)
{
  signed int return_value__vswprintf_c_l=_vswprintf_c_l(_Buffer, _BufferCount, _Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vswprintf_c_l;
}

// _vswprintf_c_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1148
inline signed int _vswprintf_c_l(wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  signed int _Result;
  unsigned long long int *return_value___local_stdio_printf_options=__local_stdio_printf_options();
  _Result=__stdio_common_vswprintf(*return_value___local_stdio_printf_options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
  return _Result < 0 ? -1 : _Result;
}

// _vswprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1185
inline signed int _vswprintf_l(wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  signed int return_value__vswprintf_c_l=_vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
  return return_value__vswprintf_c_l;
}

// _vswprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1321
inline signed int _vswprintf_p(wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, va_list _ArgList)
{
  signed int return_value__vswprintf_p_l=_vswprintf_p_l(_Buffer, _BufferCount, _Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vswprintf_p_l;
}

// _vswprintf_p_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1300
inline signed int _vswprintf_p_l(wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  signed int _Result;
  unsigned long long int *return_value___local_stdio_printf_options=__local_stdio_printf_options();
  _Result=__stdio_common_vswprintf_p(*return_value___local_stdio_printf_options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
  return _Result < 0 ? -1 : _Result;
}

// _vswprintf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1252
inline signed int _vswprintf_s_l(wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  signed int _Result;
  unsigned long long int *return_value___local_stdio_printf_options=__local_stdio_printf_options();
  _Result=__stdio_common_vswprintf_s(*return_value___local_stdio_printf_options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
  return _Result < 0 ? -1 : _Result;
}

// _vswscanf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1901
inline signed int _vswscanf_l(const wchar_t * const _Buffer, const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  unsigned long long int *return_value___local_stdio_scanf_options=__local_stdio_scanf_options();
  signed int return_value___stdio_common_vswscanf=__stdio_common_vswscanf(*return_value___local_stdio_scanf_options, _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
  return return_value___stdio_common_vswscanf;
}

// _vswscanf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1934
inline signed int _vswscanf_s_l(const wchar_t * const _Buffer, const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  unsigned long long int *return_value___local_stdio_scanf_options=__local_stdio_scanf_options();
  signed int return_value___stdio_common_vswscanf=__stdio_common_vswscanf(*return_value___local_stdio_scanf_options | 1ull << 0, _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
  return return_value___stdio_common_vswscanf;
}

// _vwprintf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 385
inline signed int _vwprintf_l(const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  FILE *return_value___acrt_iob_func=__acrt_iob_func(1u);
  signed int return_value__vfwprintf_l=_vfwprintf_l(return_value___acrt_iob_func, _Format, _Locale, _ArgList);
  return return_value__vfwprintf_l;
}

// _vwprintf_p
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 457
inline signed int _vwprintf_p(const wchar_t * const _Format, va_list _ArgList)
{
  FILE *return_value___acrt_iob_func=__acrt_iob_func(1u);
  signed int return_value__vfwprintf_p_l=_vfwprintf_p_l(return_value___acrt_iob_func, _Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vfwprintf_p_l;
}

// _vwprintf_p_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 443
inline signed int _vwprintf_p_l(const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  FILE *return_value___acrt_iob_func=__acrt_iob_func(1u);
  signed int return_value__vfwprintf_p_l=_vfwprintf_p_l(return_value___acrt_iob_func, _Format, _Locale, _ArgList);
  return return_value__vfwprintf_p_l;
}

// _vwprintf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 412
inline signed int _vwprintf_s_l(const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  FILE *return_value___acrt_iob_func=__acrt_iob_func(1u);
  signed int return_value__vfwprintf_s_l=_vfwprintf_s_l(return_value___acrt_iob_func, _Format, _Locale, _ArgList);
  return return_value__vfwprintf_s_l;
}

// _vwscanf_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 774
inline signed int _vwscanf_l(const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  FILE *return_value___acrt_iob_func=__acrt_iob_func(0u);
  signed int return_value__vfwscanf_l=_vfwscanf_l(return_value___acrt_iob_func, _Format, _Locale, _ArgList);
  return return_value__vfwscanf_l;
}

// _vwscanf_s_l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 801
inline signed int _vwscanf_s_l(const wchar_t * const _Format, const _locale_t _Locale, va_list _ArgList)
{
  FILE *return_value___acrt_iob_func=__acrt_iob_func(0u);
  signed int return_value__vfwscanf_s_l=_vfwscanf_s_l(return_value___acrt_iob_func, _Format, _Locale, _ArgList);
  return return_value__vfwscanf_s_l;
}

// acosl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 763
/*inline double acosl(double _X)*/
/*{*/
  /*double return_value_acos=acos((double)_X);*/
  /*return return_value_acos;*/
/*}*/

// add32
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp_curves.c line 965
static inline void add32(uint32_t *dst, uint32_t src, signed char *carry)
{
  *dst = *dst + src;
  *carry = *carry + (signed char)(*dst < src);
}

// add_check_overflow
// file d:\tuttle\freertos\lib\third_party\tinycbor\compilersupport_p.h line 190
static inline _Bool add_check_overflow(size_t v1, size_t v2, size_t *r)
{
  *r = v1 + v2;
  return v1 > v1 + v2;
}

// add_one_and_zeros_padding
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 509
static void add_one_and_zeros_padding(unsigned char *output, size_t output_len, size_t data_len)
{
  size_t padding_len=output_len - data_len;
  unsigned char i=0;
  output[(signed long long int)data_len] = 128;
  i = 1;
  for( ; !((unsigned long long int)i >= padding_len); i = i + 1)
    output[(signed long long int)(data_len + (unsigned long long int)i)] = 0;
}

// add_pkcs_padding
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 469
static void add_pkcs_padding(unsigned char *output, size_t output_len, size_t data_len)
{
  size_t padding_len=output_len - data_len;
  unsigned char i=0;
  for( ; !((unsigned long long int)i >= padding_len); i = i + 1)
    output[(signed long long int)(data_len + (unsigned long long int)i)] = (unsigned char)padding_len;
}

// add_zeros_and_len_padding
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 548
static void add_zeros_and_len_padding(unsigned char *output, size_t output_len, size_t data_len)
{
  size_t padding_len=output_len - data_len;
  unsigned char i=0;
  i = 1;
  for( ; !((unsigned long long int)i >= padding_len); i = i + 1)
    output[(signed long long int)((data_len + (unsigned long long int)i) - 1ull)] = 0;
  output[(signed long long int)(output_len - 1ull)] = (unsigned char)padding_len;
}

// add_zeros_padding
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 588
static void add_zeros_padding(unsigned char *output, size_t output_len, size_t data_len)
{
  size_t i=data_len;
  for( ; !(i >= output_len); i = i + 1ull)
    output[(signed long long int)i] = 0;
}

// advance_internal
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 275
static CborError advance_internal(CborValue *it)
{
  uint64_t length;
  CborError err=extract_number$link1(&it->ptr, it->parser->end, &length);
  /* assertion err == CborNoError */
  assert((signed int)err == 0);
  _Bool tmp_if_expr;
  if((signed int)it->type == 64)
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = (signed int)it->type == 96 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
  {
    /* assertion length == (size_t)length */
    assert(length == (size_t)length);
    /* assertion (it->flags & CborIteratorFlag_UnknownLength) == 0 */
    assert(((signed int)it->flags & 4) == 0);
    it->ptr = it->ptr + (signed long long int)length;
  }

  CborError return_value_preparse_next_value=preparse_next_value(it);
  return return_value_preparse_next_value;
}

// advance_ptr
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 247
static inline void advance_ptr(CborEncoder *encoder, size_t n)
{
  if(!(encoder->end == ((const uint8_t *)NULL)))
    encoder->data.ptr = encoder->data.ptr + (signed long long int)n;

  else
    encoder->data.bytes_needed = encoder->data.bytes_needed + (ptrdiff_t)n;
}

// advance_recursive
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 403
static CborError advance_recursive(CborValue *it, signed int nestingLevel)
{
  _Bool return_value_is_fixed_type=is_fixed_type(it->type);
  CborError return_value_advance_internal;
  _Bool return_value_cbor_value_at_end;
  if(!(return_value_is_fixed_type == (_Bool)0))
  {
    return_value_advance_internal=advance_internal(it);
    return return_value_advance_internal;
  }

  else
  {
    _Bool return_value_cbor_value_is_container=cbor_value_is_container(it);
    if(return_value_cbor_value_is_container == (_Bool)0)
    {
      size_t len=18446744073709551615ull;
      CborError return_value__cbor_value_copy_string=_cbor_value_copy_string(it, NULL, &len, it);
      return return_value__cbor_value_copy_string;
    }

    else
      if(nestingLevel == 1024)
        return /*enum*/CborErrorNestingTooDeep;

      else
      {
        CborError err;
        CborValue recursed;
        err=cbor_value_enter_container(it, &recursed);
        if(!(err == /*enum*/CborNoError))
          return err;

        else
        {
          do
          {
            return_value_cbor_value_at_end=cbor_value_at_end(&recursed);
            if(return_value_cbor_value_at_end != (_Bool)0)
              break;

            err=advance_recursive(&recursed, nestingLevel + 1);
            if(!(err == /*enum*/CborNoError))
              return err;

          }
          while((_Bool)1);
          CborError return_value_cbor_value_leave_container=cbor_value_leave_container(it, &recursed);
          return return_value_cbor_value_leave_container;
        }
      }
  }
}

// aes_crypt_cbc_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 123
static signed int aes_crypt_cbc_wrap(void *ctx, mbedtls_operation_t operation, size_t length, unsigned char *aes_crypt_cbc_wrap$$iv, const unsigned char *input, unsigned char *output)
{
  signed int return_value_mbedtls_aes_crypt_cbc=mbedtls_aes_crypt_cbc((mbedtls_aes_context *)ctx, (signed int)operation, length, aes_crypt_cbc_wrap$$iv, input, output);
  return return_value_mbedtls_aes_crypt_cbc;
}

// aes_crypt_cfb128_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 132
static signed int aes_crypt_cfb128_wrap(void *ctx, mbedtls_operation_t operation, size_t length, size_t *iv_off, unsigned char *aes_crypt_cfb128_wrap$$iv, const unsigned char *input, unsigned char *output)
{
  signed int return_value_mbedtls_aes_crypt_cfb128=mbedtls_aes_crypt_cfb128((mbedtls_aes_context *)ctx, (signed int)operation, length, iv_off, aes_crypt_cfb128_wrap$$iv, input, output);
  return return_value_mbedtls_aes_crypt_cfb128;
}

// aes_crypt_ctr_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 142
static signed int aes_crypt_ctr_wrap(void *ctx, size_t length, size_t *nc_off, unsigned char *nonce_counter, unsigned char *stream_block, const unsigned char *input, unsigned char *output)
{
  signed int return_value_mbedtls_aes_crypt_ctr=mbedtls_aes_crypt_ctr((mbedtls_aes_context *)ctx, length, nc_off, nonce_counter, stream_block, input, output);
  return return_value_mbedtls_aes_crypt_ctr;
}

// aes_crypt_ecb_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 116
static signed int aes_crypt_ecb_wrap(void *ctx, mbedtls_operation_t operation, const unsigned char *input, unsigned char *output)
{
  signed int return_value_mbedtls_aes_crypt_ecb=mbedtls_aes_crypt_ecb((mbedtls_aes_context *)ctx, (signed int)operation, input, output);
  return return_value_mbedtls_aes_crypt_ecb;
}

// aes_ctx_alloc
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 163
static void * aes_ctx_alloc(void)
{
  mbedtls_aes_context *aes;
  void *return_value=mbedtls_calloc(1ull, sizeof(mbedtls_aes_context) /*288ull*/ );
  aes = (mbedtls_aes_context *)return_value;
  if(aes == ((mbedtls_aes_context *)NULL))
    return NULL;

  else
  {
    mbedtls_aes_init(aes);
    return (void *)aes;
  }
}

// aes_ctx_free
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 175
static void aes_ctx_free(void *ctx)
{
  mbedtls_aes_free((mbedtls_aes_context *)ctx);
  mbedtls_free(ctx);
}

// aes_setkey_dec_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 151
static signed int aes_setkey_dec_wrap(void *ctx, const unsigned char *aes_setkey_dec_wrap$$key, unsigned int key_bitlen)
{
  signed int return_value_mbedtls_aes_setkey_dec=mbedtls_aes_setkey_dec((mbedtls_aes_context *)ctx, aes_setkey_dec_wrap$$key, key_bitlen);
  return return_value_mbedtls_aes_setkey_dec;
}

// aes_setkey_enc_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 157
static signed int aes_setkey_enc_wrap(void *ctx, const unsigned char *aes_setkey_enc_wrap$$key, unsigned int key_bitlen)
{
  signed int return_value_mbedtls_aes_setkey_enc=mbedtls_aes_setkey_enc((mbedtls_aes_context *)ctx, aes_setkey_enc_wrap$$key, key_bitlen);
  return return_value_mbedtls_aes_setkey_enc;
}

// append_byte_to_buffer
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 273
static inline CborError append_byte_to_buffer(CborEncoder *encoder, uint8_t byte)
{
  CborError return_value_append_to_buffer=append_to_buffer(encoder, (const void *)&byte, 1ull);
  return return_value_append_to_buffer;
}

// append_to_buffer
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 255
static inline CborError append_to_buffer(CborEncoder *encoder, const void *data, size_t len)
{
  _Bool return_value_would_overflow=would_overflow(encoder, len);
  if(!(return_value_would_overflow == (_Bool)0))
  {
    if(!(encoder->end == ((const uint8_t *)NULL)))
    {
      len = len - (size_t)(encoder->end - encoder->data.ptr);
      encoder->end = ((const uint8_t *)NULL);
      encoder->data.bytes_needed = 0ll;
    }

    advance_ptr(encoder, len);
    return /*enum*/CborErrorOutOfMemory;
  }

  else
  {
    memcpy((void *)encoder->data.ptr, data, len);
    encoder->data.ptr = encoder->data.ptr + (signed long long int)len;
    return /*enum*/CborNoError;
  }
}

// asinl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 770
/*inline double asinl(double _X)*/
/*{*/
  /*double return_value_asin=asin((double)_X);*/
  /*return return_value_asin;*/
/*}*/

// atan2l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 775
/*inline double atan2l(double _Y, double _X)*/
/*{*/
  /*double return_value_atan2=atan2((double)_Y, (double)_X);*/
  /*return return_value_atan2;*/
/*}*/

// atanl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 782
/*inline double atanl(double _X)*/
/*{*/
  /*double return_value_atan=atan((double)_X);*/
  /*return return_value_atan;*/
/*}*/

// bMayConnect
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 1919
static BaseType_t bMayConnect(FreeRTOS_Socket_t *pxSocket)
{
  switch((signed int)pxSocket->u.xTCP.ucTCPState)
  {
    case 0:

    case 8:
      return 0;
    case 2:
      return -119;
    default:
      return -11;
  }
}

// block_cipher_df
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 146
static signed int block_cipher_df(unsigned char *output, const unsigned char *data, size_t data_len)
{
  unsigned char buf[416ll];
  unsigned char tmp[48ll];
  unsigned char block_cipher_df$$1$$key[32ll];
  unsigned char chain[16ll];
  unsigned char *p;
  unsigned char *block_cipher_df$$1$$iv;
  mbedtls_aes_context aes_ctx;
  signed int ret=0;
  signed int i;
  signed int j;
  size_t buf_len;
  size_t use_len;
  if(data_len >= 385ull)
    return -0x38;

  else
  {
    memset((void *)buf, 0, (size_t)(384 + 16 + 16));
    mbedtls_aes_init(&aes_ctx);
    p = buf + 16ll;
    unsigned char *tmp_post=p;
    p = p + 1ll;
    *tmp_post = (unsigned char)(data_len >> 24 & 255ull);
    unsigned char *tmp_post$0=p;
    p = p + 1ll;
    *tmp_post$0 = (unsigned char)(data_len >> 16 & 255ull);
    unsigned char *tmp_post$1=p;
    p = p + 1ll;
    *tmp_post$1 = (unsigned char)(data_len >> 8 & 255ull);
    unsigned char *tmp_post$2=p;
    p = p + 1ll;
    *tmp_post$2 = (unsigned char)(data_len & 255ull);
    p = p + 3ll;
    unsigned char *tmp_post$3=p;
    p = p + 1ll;
    *tmp_post$3 = (unsigned char)(32 + 16);
    memcpy((void *)p, (const void *)data, data_len);
    p[(signed long long int)data_len] = 128;
    buf_len = (unsigned long long int)(16 + 8) + data_len + 1ull;
    i = 0;
    for( ; !(i >= 32); i = i + 1)
      block_cipher_df$$1$$key[(signed long long int)i] = (unsigned char)i;
    ret=mbedtls_aes_setkey_enc(&aes_ctx, block_cipher_df$$1$$key, (unsigned int)(32 * 8));
    if(ret == 0)
    {
      j = 0;
      for( ; !(j >= 48); j = j + 16)
      {
        p = buf;
        memset((void *)chain, 0, 16ull);
        use_len = buf_len;
        while(use_len >= 1ull)
        {
          i = 0;
          for( ; !(i >= 16); i = i + 1)
            chain[(signed long long int)i] = chain[(signed long long int)i] ^ p[(signed long long int)i];
          p = p + 16ll;
          use_len = use_len - (use_len >= 16ull ? 16ull : use_len);
          ret=mbedtls_aes_crypt_ecb(&aes_ctx, 1, chain, chain);
          if(!(ret == 0))
            goto exit;

        }
        memcpy((void *)(tmp + (signed long long int)j), (const void *)chain, 16ull);
        buf[3ll] = buf[3ll] + 1;
      }
      ret=mbedtls_aes_setkey_enc(&aes_ctx, tmp, (unsigned int)(32 * 8));
      if(ret == 0)
      {
        block_cipher_df$$1$$iv = tmp + 32ll;
        p = output;
        j = 0;
        for( ; !(j >= 48); j = j + 16)
        {
          ret=mbedtls_aes_crypt_ecb(&aes_ctx, 1, block_cipher_df$$1$$iv, block_cipher_df$$1$$iv);
          if(!(ret == 0))
            goto exit;

          memcpy((void *)p, (const void *)block_cipher_df$$1$$iv, 16ull);
          p = p + 16ll;
        }
      }

    }


  exit:
    ;
    mbedtls_aes_free(&aes_ctx);
    mbedtls_zeroize$link4((void *)buf, sizeof(unsigned char [416ll]) /*416ull*/ );
    mbedtls_zeroize$link4((void *)tmp, sizeof(unsigned char [48ll]) /*48ull*/ );
    mbedtls_zeroize$link4((void *)block_cipher_df$$1$$key, sizeof(unsigned char [32ll]) /*32ull*/ );
    mbedtls_zeroize$link4((void *)chain, sizeof(unsigned char [16ll]) /*16ull*/ );
    if(!(ret == 0))
      mbedtls_zeroize$link4((void *)output, (size_t)(32 + 16));

    return ret;
  }
}

// cbor_encode_byte_string
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 432
CborError cbor_encode_byte_string(CborEncoder *encoder, const uint8_t *string, size_t length)
{
  CborError return_value_encode_string=encode_string(encoder, length, (uint8_t)(2 << 5), (const void *)string);
  return return_value_encode_string;
}

// cbor_encode_floating_point
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 378
CborError cbor_encode_floating_point(CborEncoder *encoder, CborType fpType, const void *value)
{
  uint8_t buf[9ll];
  /* assertion fpType == CborHalfFloatType || fpType == CborFloatType || fpType == CborDoubleType */
  assert((signed int)fpType == 249 || (signed int)fpType == 250 || (signed int)fpType == 251);
  buf[0ll] = (uint8_t)fpType;
  unsigned int size=2u << (signed int)fpType - 249;
  if(size == 8u)
    put64((void *)(buf + 1ll), *((const uint64_t *)value));

  else
    if(size == 4u)
      put32((void *)(buf + 1ll), *((const uint32_t *)value));

    else
      put16((void *)(buf + 1ll), *((const uint16_t *)value));
  encoder->added = encoder->added + 1ull;
  CborError return_value_append_to_buffer=append_to_buffer(encoder, (const void *)buf, (size_t)(size + 1u));
  return return_value_append_to_buffer;
}

// cbor_encode_int
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 341
CborError cbor_encode_int(CborEncoder *encoder, int64_t value)
{
  uint64_t ui=(uint64_t)(value >> 63);
  uint8_t majorType=(uint8_t)(ui & 32ull);
  ui = ui ^ (uint64_t)value;
  CborError return_value_encode_number=encode_number(encoder, ui, majorType);
  return return_value_encode_number;
}

// cbor_encode_negative_int
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 330
CborError cbor_encode_negative_int(CborEncoder *encoder, uint64_t absolute_value)
{
  CborError return_value_encode_number=encode_number(encoder, absolute_value, (uint8_t)(1 << 5));
  return return_value_encode_number;
}

// cbor_encode_simple_value
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 357
CborError cbor_encode_simple_value(CborEncoder *encoder, uint8_t value)
{
  if((signed int)value >= 25 && !((signed int)value >= 32))
    return /*enum*/CborErrorIllegalSimpleType;

  else
  {
    CborError return_value_encode_number=encode_number(encoder, (uint64_t)value, (uint8_t)(7 << 5));
    return return_value_encode_number;
  }
}

// cbor_encode_tag
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 400
CborError cbor_encode_tag(CborEncoder *encoder, CborTag cbor_encode_tag$$tag)
{
  CborError return_value_encode_number_no_update=encode_number_no_update(encoder, cbor_encode_tag$$tag, (uint8_t)(6 << 5));
  return return_value_encode_number_no_update;
}

// cbor_encode_text_string
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 443
CborError cbor_encode_text_string(CborEncoder *encoder, const char *string, size_t length)
{
  CborError return_value_encode_string=encode_string(encoder, length, (uint8_t)(3 << 5), (const void *)string);
  return return_value_encode_string;
}

// cbor_encode_text_stringz
// file ..\..\..\..\lib\third_party\tinycbor\cbor.h line 184
static inline CborError cbor_encode_text_stringz(CborEncoder *encoder, const char *string)
{
  size_t return_value_strlen=strlen(string);
  CborError return_value_cbor_encode_text_string=cbor_encode_text_string(encoder, string, return_value_strlen);
  return return_value_cbor_encode_text_string;
}

// cbor_encode_uint
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 319
CborError cbor_encode_uint(CborEncoder *encoder, uint64_t value)
{
  CborError return_value_encode_number=encode_number(encoder, value, (uint8_t)(0 << 5));
  return return_value_encode_number;
}

// cbor_encoder_close_container
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 528
CborError cbor_encoder_close_container(CborEncoder *encoder, const CborEncoder *containerEncoder)
{
  if(!(encoder->end == ((const uint8_t *)NULL)))
    encoder->data.ptr = containerEncoder->data.ptr;

  else
    encoder->data.bytes_needed = containerEncoder->data.bytes_needed;
  encoder->end = containerEncoder->end;
  CborError return_value_append_byte_to_buffer;
  if(!((4 & containerEncoder->flags) == 0))
  {
    return_value_append_byte_to_buffer=append_byte_to_buffer(encoder, 255);
    return return_value_append_byte_to_buffer;
  }

  else
    return /*enum*/CborNoError;
}

// cbor_encoder_close_container_checked
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder_close_container_checked.c line 60
CborError cbor_encoder_close_container_checked(CborEncoder *encoder, const CborEncoder *containerEncoder)
{
  const uint8_t *ptr=encoder->data.ptr;
  CborError err=cbor_encoder_close_container(encoder, containerEncoder);
  _Bool tmp_if_expr;
  if(!((4 & containerEncoder->flags) == 0))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = encoder->end == ((const uint8_t *)NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return err;

  else
  {
    uint64_t actually_added;
    err=extract_number(&ptr, encoder->data.ptr, &actually_added);
    if(!(err == /*enum*/CborNoError))
      return err;

    else
    {
      if(!((32 & containerEncoder->flags) == 0))
      {
        if(actually_added >= 9223372036854775808ull)
          return /*enum*/CborErrorDataTooLarge;

        actually_added = actually_added * 2ull;
      }

      signed int tmp_if_expr$0;
      if(actually_added == containerEncoder->added)
        tmp_if_expr$0 = 0;

      else
        tmp_if_expr$0 = actually_added < containerEncoder->added ? 768 : 769;
      return (CborError)tmp_if_expr$0;
    }
  }
}

// cbor_encoder_create_array
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 486
CborError cbor_encoder_create_array(CborEncoder *encoder, CborEncoder *arrayEncoder, size_t length)
{
  CborError return_value_create_container=create_container(encoder, arrayEncoder, length, (uint8_t)(4 << 5));
  return return_value_create_container;
}

// cbor_encoder_create_map
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 509
CborError cbor_encoder_create_map(CborEncoder *encoder, CborEncoder *mapEncoder, size_t length)
{
  if(length >= 9223372036854775808ull && !(length == CborIndefiniteLength))
    return /*enum*/CborErrorDataTooLarge;

  else
  {
    CborError return_value_create_container=create_container(encoder, mapEncoder, length, (uint8_t)(5 << 5));
    return return_value_create_container;
  }
}

// cbor_encoder_get_buffer_size
// file ..\..\..\..\lib\third_party\tinycbor\cbor.h line 208
static inline size_t cbor_encoder_get_buffer_size(const CborEncoder *encoder, const uint8_t *buffer)
{
  return (size_t)(encoder->data.ptr - buffer);
}

// cbor_encoder_init
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 202
void cbor_encoder_init(CborEncoder *encoder, uint8_t *buffer, size_t size, signed int flags)
{
  encoder->data.ptr = buffer;
  encoder->end = buffer + (signed long long int)size;
  encoder->added = 0ull;
  encoder->flags = flags;
}

// cbor_error_string
// file ..\..\..\..\lib\third_party\tinycbor\cborerrorstrings.c line 80
const char * cbor_error_string(CborError error)
{
  switch((signed int)error)
  {
    case 0:
      return "";
    case 1:
      return "unknown error";
    case -2147483648:
      return "out of memory/need more memory";
    case 2:
      return "unknown length (attempted to get the length of a map/array/string of indeterminate length";
    case 3:
      return "attempted to advance past EOF";
    case 4:
      return "I/O error";
    case 256:
      return "garbage after the end of the content";
    case 257:
      return "unexpected end of data";
    case 258:
      return "unexpected 'break' byte";
    case 259:
      return "illegal byte (encodes future extension type)";
    case 260:
      return "mismatched string type in chunked string";
    case 261:
      return "illegal initial byte (encodes unspecified additional information)";
    case 262:
      return "illegal encoding of simple type smaller than 32";
    case 512:
      return "unknown simple type";
    case 513:
      return "unknown tag";
    case 514:
      return "inappropriate tag for type";
    case 515:
      return "duplicate keys in object";
    case 516:
      return "invalid UTF-8 content in string";
    case 768:
      return "too many items added to encoder";
    case 769:
      return "too few items added to encoder";
    case 1024:
      return "internal error: data too large";
    case 1025:
      return "internal error: too many nested containers found in recursive function";
    case 1026:
      return "unsupported type";
    case 1027:
      return "conversion to JSON failed: key in object is an array or map";
    case 1028:
      return "conversion to JSON failed: key in object is not a string";
    case 1029:
      return "conversion to JSON failed: open_memstream unavailable";
    case -1:
      return "internal error";
    default:
    {
      const char *return_value_cbor_error_string=cbor_error_string(/*enum*/CborUnknownError);
      return return_value_cbor_error_string;
    }
  }
}

// cbor_parser_init
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 325
CborError cbor_parser_init(const uint8_t *buffer, size_t size, signed int flags, CborParser *parser, CborValue *it)
{
  memset((void *)parser, 0, sizeof(CborParser) /*16ull*/ );
  parser->end = buffer + (signed long long int)size;
  parser->flags = flags;
  it->parser = parser;
  it->ptr = buffer;
  it->remaining = 1u;
  CborError return_value_preparse_value=preparse_value(it);
  return return_value_preparse_value;
}

// cbor_value_advance
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 442
CborError cbor_value_advance(CborValue *it)
{
  /* assertion it->type != CborInvalidType */
  assert((signed int)it->type != 255);
  if(it->remaining == 0u)
    return /*enum*/CborErrorAdvancePastEOF;

  else
  {
    CborError return_value_advance_recursive=advance_recursive(it, 0);
    return return_value_advance_recursive;
  }
}

// cbor_value_advance_fixed
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 394
CborError cbor_value_advance_fixed(CborValue *it)
{
  /* assertion it->type != CborInvalidType */
  assert((signed int)it->type != 255);
  _Bool return_value_is_fixed_type=is_fixed_type(it->type);
  /* assertion is_fixed_type(it->type) */
  assert(return_value_is_fixed_type != (_Bool)0);
  if(it->remaining == 0u)
    return /*enum*/CborErrorAdvancePastEOF;

  else
  {
    CborError return_value_advance_internal=advance_internal(it);
    return return_value_advance_internal;
  }
}

// cbor_value_at_end
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 248
static inline _Bool cbor_value_at_end(const CborValue *it)
{
  return it->remaining == 0u;
}

// cbor_value_at_end$link1
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 248
static inline _Bool cbor_value_at_end$link1(const CborValue *it$link1)
{
  return it$link1->remaining == 0u;
}

// cbor_value_calculate_string_length
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 893
CborError cbor_value_calculate_string_length(const CborValue *value, size_t *len)
{
  *len = 18446744073709551615ull;
  CborError return_value__cbor_value_copy_string=_cbor_value_copy_string(value, NULL, len, ((CborValue *)NULL));
  return return_value__cbor_value_copy_string;
}

// cbor_value_copy_byte_string
// file ..\..\..\..\lib\third_party\tinycbor\cbor.h line 385
static inline CborError cbor_value_copy_byte_string(const CborValue *value, uint8_t *buffer, size_t *buflen, CborValue *next)
{
  _Bool return_value_cbor_value_is_byte_string=cbor_value_is_byte_string(value);
  /* assertion cbor_value_is_byte_string(value) */
  assert(return_value_cbor_value_is_byte_string != (_Bool)0);
  CborError return_value__cbor_value_copy_string=_cbor_value_copy_string(value, (void *)buffer, buflen, next);
  return return_value__cbor_value_copy_string;
}

// cbor_value_dup_byte_string
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 398
static inline CborError cbor_value_dup_byte_string(const CborValue *value, uint8_t **buffer, size_t *buflen, CborValue *next)
{
  _Bool return_value_cbor_value_is_byte_string=cbor_value_is_byte_string$link2(value);
  /* assertion cbor_value_is_byte_string(value) */
  assert(return_value_cbor_value_is_byte_string != (_Bool)0);
  CborError return_value__cbor_value_dup_string=_cbor_value_dup_string(value, (void **)buffer, buflen, next);
  return return_value__cbor_value_dup_string;
}

// cbor_value_dup_text_string
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 392
static inline CborError cbor_value_dup_text_string(const CborValue *value, char **buffer, size_t *buflen, CborValue *next)
{
  _Bool return_value_cbor_value_is_text_string=cbor_value_is_text_string$link1(value);
  /* assertion cbor_value_is_text_string(value) */
  assert(return_value_cbor_value_is_text_string != (_Bool)0);
  CborError return_value__cbor_value_dup_string=_cbor_value_dup_string(value, (void **)buffer, buflen, next);
  return return_value__cbor_value_dup_string;
}

// cbor_value_enter_container
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 505
CborError cbor_value_enter_container(const CborValue *it, CborValue *recursed)
{
  CborError err;
  _Bool return_value_cbor_value_is_container=cbor_value_is_container(it);
  /* assertion cbor_value_is_container(it) */
  assert(return_value_cbor_value_is_container != (_Bool)0);
  *recursed = *it;
  CborError return_value_preparse_value;
  if(!((4 & (signed int)it->flags) == 0))
  {
    recursed->remaining = 4294967295u;
    recursed->ptr = recursed->ptr + 1ll;
    err=preparse_value(recursed);
    if(!((signed int)err == 258))
      return err;

    recursed->ptr = recursed->ptr + 1ll;
  }

  else
  {
    uint64_t len;
    err=extract_number$link1(&recursed->ptr, recursed->parser->end, &len);
    /* assertion err == CborNoError */
    assert((signed int)err == 0);
    recursed->remaining = (uint32_t)len;
    if(len == 4294967295ull || !((unsigned long long int)recursed->remaining == len))
    {
      recursed->ptr = it->ptr;
      return /*enum*/CborErrorDataTooLarge;
    }

    if((signed int)recursed->type == 160)
    {
      if(recursed->remaining >= 2147483648u)
      {
        recursed->ptr = it->ptr;
        return /*enum*/CborErrorDataTooLarge;
      }

      recursed->remaining = recursed->remaining * 2u;
    }

    if(!(len == 0ull))
    {
      return_value_preparse_value=preparse_value(recursed);
      return return_value_preparse_value;
    }

  }
  recursed->type = 255;
  recursed->remaining = 0u;
  return /*enum*/CborNoError;
}

// cbor_value_get_boolean
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 280
static inline CborError cbor_value_get_boolean(const CborValue *value, _Bool *result)
{
  _Bool return_value_cbor_value_is_boolean=cbor_value_is_boolean(value);
  /* assertion cbor_value_is_boolean(value) */
  assert(return_value_cbor_value_is_boolean != (_Bool)0);
  *result = !(!(value->extra != 0));
  return /*enum*/CborNoError;
}

// cbor_value_get_double
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 459
static inline CborError cbor_value_get_double(const CborValue *value, double *result)
{
  _Bool return_value_cbor_value_is_double=cbor_value_is_double(value);
  /* assertion cbor_value_is_double(value) */
  assert(return_value_cbor_value_is_double != (_Bool)0);
  /* assertion value->flags & CborIteratorFlag_IntegerValueTooLarge */
  assert(((signed int)value->flags & 1) != 0);
  uint64_t data=_cbor_value_decode_int64_internal(value);
  memcpy((void *)result, (const void *)&data, sizeof(double) /*8ull*/ );
  return /*enum*/CborNoError;
}

// cbor_value_get_float
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 448
static inline CborError cbor_value_get_float(const CborValue *value, float *result)
{
  _Bool return_value_cbor_value_is_float=cbor_value_is_float(value);
  /* assertion cbor_value_is_float(value) */
  assert(return_value_cbor_value_is_float != (_Bool)0);
  /* assertion value->flags & CborIteratorFlag_IntegerValueTooLarge */
  assert(((signed int)value->flags & 1) != 0);
  uint32_t data;
  uint64_t return_value__cbor_value_decode_int64_internal=_cbor_value_decode_int64_internal(value);
  data = (uint32_t)return_value__cbor_value_decode_int64_internal;
  memcpy((void *)result, (const void *)&data, sizeof(float) /*4ull*/ );
  return /*enum*/CborNoError;
}

// cbor_value_get_half_float
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 1290
CborError cbor_value_get_half_float(const CborValue *value, void *result)
{
  _Bool return_value_cbor_value_is_half_float=cbor_value_is_half_float(value);
  /* assertion cbor_value_is_half_float(value) */
  assert(return_value_cbor_value_is_half_float != (_Bool)0);
  uint16_t v=get16$link1(value->ptr + 1ll);
  memcpy(result, (const void *)&v, sizeof(uint16_t) /*2ull*/ );
  return /*enum*/CborNoError;
}

// cbor_value_get_int
// file ..\..\..\..\lib\third_party\tinycbor\cbor.h line 328
static inline CborError cbor_value_get_int(const CborValue *value, signed int *result)
{
  _Bool return_value_cbor_value_is_integer=cbor_value_is_integer(value);
  /* assertion cbor_value_is_integer(value) */
  assert(return_value_cbor_value_is_integer != (_Bool)0);
  uint64_t return_value__cbor_value_extract_int64_helper=_cbor_value_extract_int64_helper(value);
  *result = (signed int)return_value__cbor_value_extract_int64_helper;
  if(!((2 & (signed int)value->flags) == 0))
    *result = -(*result) - 1;

  return /*enum*/CborNoError;
}

// cbor_value_get_int64_checked
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 744
CborError cbor_value_get_int64_checked(const CborValue *value, int64_t *result)
{
  _Bool return_value_cbor_value_is_integer=cbor_value_is_integer$link1(value);
  /* assertion cbor_value_is_integer(value) */
  assert(return_value_cbor_value_is_integer != (_Bool)0);
  uint64_t v=_cbor_value_extract_int64_helper$link1(value);
  if(v >= 9223372036854775808ull)
    return /*enum*/CborErrorDataTooLarge;

  else
  {
    *result = (int64_t)v;
    if(!((2 & (signed int)value->flags) == 0))
      *result = -(*result) - 1ll;

    return /*enum*/CborNoError;
  }
}

// cbor_value_get_int_checked
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 783
CborError cbor_value_get_int_checked(const CborValue *value, signed int *result)
{
  _Bool return_value_cbor_value_is_integer=cbor_value_is_integer$link1(value);
  /* assertion cbor_value_is_integer(value) */
  assert(return_value_cbor_value_is_integer != (_Bool)0);
  uint64_t v=_cbor_value_extract_int64_helper$link1(value);
  if(!((2 & (signed int)value->flags) == 0))
  {
    if(v >= 2147483648ull)
      return /*enum*/CborErrorDataTooLarge;

    *result = (signed int)v;
    *result = -(*result) - 1;
  }

  else
  {
    if(v >= 2147483648ull)
      return /*enum*/CborErrorDataTooLarge;

    *result = (signed int)v;
  }
  return /*enum*/CborNoError;
}

// cbor_value_get_raw_integer
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 305
static inline CborError cbor_value_get_raw_integer(const CborValue *value, uint64_t *result)
{
  _Bool return_value_cbor_value_is_integer=cbor_value_is_integer$link2(value);
  /* assertion cbor_value_is_integer(value) */
  assert(return_value_cbor_value_is_integer != (_Bool)0);
  *result=_cbor_value_extract_int64_helper$link2(value);
  return /*enum*/CborNoError;
}

// cbor_value_get_simple_type
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 290
static inline CborError cbor_value_get_simple_type(const CborValue *value, uint8_t *result)
{
  _Bool return_value_cbor_value_is_simple_type=cbor_value_is_simple_type(value);
  /* assertion cbor_value_is_simple_type(value) */
  assert(return_value_cbor_value_is_simple_type != (_Bool)0);
  *result = (uint8_t)value->extra;
  return /*enum*/CborNoError;
}

// cbor_value_get_tag
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 346
static inline CborError cbor_value_get_tag(const CborValue *value, CborTag *result)
{
  _Bool return_value_cbor_value_is_tag=cbor_value_is_tag$link1(value);
  /* assertion cbor_value_is_tag(value) */
  assert(return_value_cbor_value_is_tag != (_Bool)0);
  *result=_cbor_value_extract_int64_helper$link2(value);
  return /*enum*/CborNoError;
}

// cbor_value_get_type
// file ..\..\..\..\lib\third_party\tinycbor\cbor.h line 268
static inline CborType cbor_value_get_type(const CborValue *value)
{
  return (CborType)value->type;
}

// cbor_value_get_type$link1
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 268
static inline CborType cbor_value_get_type$link1(const CborValue *value$link1)
{
  return (CborType)value$link1->type;
}

// cbor_value_is_boolean
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 278
static inline _Bool cbor_value_is_boolean(const CborValue *value)
{
  return (signed int)value->type == 245;
}

// cbor_value_is_byte_string
// file ..\..\..\..\lib\third_party\tinycbor\cbor.h line 355
static inline _Bool cbor_value_is_byte_string(const CborValue *value)
{
  return (signed int)value->type == 64;
}

// cbor_value_is_byte_string$link1
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 355
static inline _Bool cbor_value_is_byte_string$link1(const CborValue *value$link1)
{
  return (signed int)value$link1->type == 64;
}

// cbor_value_is_byte_string$link2
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 355
static inline _Bool cbor_value_is_byte_string$link2(const CborValue *value$link2)
{
  return (signed int)value$link2->type == 64;
}

// cbor_value_is_container
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 254
static inline _Bool cbor_value_is_container(const CborValue *it)
{
  _Bool tmp_if_expr;
  if((signed int)it->type == 128)
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = (signed int)it->type == 160 ? (_Bool)1 : (_Bool)0;
  return tmp_if_expr;
}

// cbor_value_is_double
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 457
static inline _Bool cbor_value_is_double(const CborValue *value)
{
  return (signed int)value->type == 251;
}

// cbor_value_is_float
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 446
static inline _Bool cbor_value_is_float(const CborValue *value)
{
  return (signed int)value->type == 250;
}

// cbor_value_is_half_float
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 442
static inline _Bool cbor_value_is_half_float(const CborValue *value)
{
  return (signed int)value->type == 249;
}

// cbor_value_is_integer
// file ..\..\..\..\lib\third_party\tinycbor\cbor.h line 298
static inline _Bool cbor_value_is_integer(const CborValue *value)
{
  return (signed int)value->type == 0;
}

// cbor_value_is_integer$link1
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 298
static inline _Bool cbor_value_is_integer$link1(const CborValue *value$link1)
{
  return (signed int)value$link1->type == 0;
}

// cbor_value_is_integer$link2
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 298
static inline _Bool cbor_value_is_integer$link2(const CborValue *value$link2)
{
  return (signed int)value$link2->type == 0;
}

// cbor_value_is_length_known
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 340
static inline _Bool cbor_value_is_length_known(const CborValue *value)
{
  return ((signed int)value->flags & 4) == 0;
}

// cbor_value_is_length_known$link1
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 340
static inline _Bool cbor_value_is_length_known$link1(const CborValue *value$link1)
{
  return ((signed int)value$link1->flags & 4) == 0;
}

// cbor_value_is_map
// file ..\..\..\..\lib\third_party\tinycbor\cbor.h line 412
static inline _Bool cbor_value_is_map(const CborValue *value)
{
  return (signed int)value->type == 160;
}

// cbor_value_is_map$link1
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 412
static inline _Bool cbor_value_is_map$link1(const CborValue *value$link1)
{
  return (signed int)value$link1->type == 160;
}

// cbor_value_is_simple_type
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 288
static inline _Bool cbor_value_is_simple_type(const CborValue *value)
{
  return (signed int)value->type == 224;
}

// cbor_value_is_tag
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 344
static inline _Bool cbor_value_is_tag(const CborValue *value)
{
  return (signed int)value->type == 192;
}

// cbor_value_is_tag$link1
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 344
static inline _Bool cbor_value_is_tag$link1(const CborValue *value$link1)
{
  return (signed int)value$link1->type == 192;
}

// cbor_value_is_text_string
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 357
static inline _Bool cbor_value_is_text_string(const CborValue *value)
{
  return (signed int)value->type == 96;
}

// cbor_value_is_text_string$link1
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 357
static inline _Bool cbor_value_is_text_string$link1(const CborValue *value$link1)
{
  return (signed int)value$link1->type == 96;
}

// cbor_value_is_unsigned_integer
// file d:\tuttle\freertos\lib\third_party\tinycbor\cbor.h line 300
static inline _Bool cbor_value_is_unsigned_integer(const CborValue *value)
{
  _Bool return_value_cbor_value_is_integer=cbor_value_is_integer$link2(value);
  _Bool tmp_if_expr;
  if(!(return_value_cbor_value_is_integer == (_Bool)0))
    tmp_if_expr = ((signed int)value->flags & 2) == 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr = (_Bool)0;
  return tmp_if_expr;
}

// cbor_value_leave_container
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 562
CborError cbor_value_leave_container(CborValue *it, const CborValue *recursed)
{
  _Bool return_value_cbor_value_is_container=cbor_value_is_container(it);
  /* assertion cbor_value_is_container(it) */
  assert(return_value_cbor_value_is_container != (_Bool)0);
  /* assertion recursed->type == CborInvalidType */
  assert((signed int)recursed->type == 255);
  it->ptr = recursed->ptr;
  CborError return_value_preparse_next_value=preparse_next_value(it);
  return return_value_preparse_next_value;
}

// cbor_value_map_find_value
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 1179
CborError cbor_value_map_find_value(const CborValue *map, const char *string, CborValue *element)
{
  _Bool return_value_cbor_value_is_map=cbor_value_is_map$link1(map);
  /* assertion cbor_value_is_map(map) */
  assert(return_value_cbor_value_is_map != (_Bool)0);
  size_t len=strlen(string);
  CborError err=cbor_value_enter_container(map, element);
  _Bool return_value_cbor_value_at_end;
  CborError return_value_preparse_value;
  if(err == /*enum*/CborNoError)
  {
    do
    {
      return_value_cbor_value_at_end=cbor_value_at_end(element);
      if(return_value_cbor_value_at_end != (_Bool)0)
        break;

      err=cbor_value_skip_tag(element);
      if(err != /*enum*/CborNoError)
        goto error;

      _Bool return_value_cbor_value_is_text_string=cbor_value_is_text_string(element);
      if(!(return_value_cbor_value_is_text_string == (_Bool)0))
      {
        _Bool equals;
        size_t dummyLen=len;
        err=iterate_string_chunks(element, (char *)(uintptr_t)string, &dummyLen, &equals, element, iterate_memcmp);
        if(!(err == /*enum*/CborNoError))
          goto error;

        if(!(equals == (_Bool)0))
        {
          return_value_preparse_value=preparse_value(element);
          return return_value_preparse_value;
        }

      }

      else
      {
        err=cbor_value_advance(element);
        if(err != /*enum*/CborNoError)
          goto error;

      }
      err=cbor_value_skip_tag(element);
      if(!(err == /*enum*/CborNoError))
        goto error;

      err=cbor_value_advance(element);
      if(!(err == /*enum*/CborNoError))
        goto error;

    }
    while((_Bool)1);
    element->type = 255;
    return /*enum*/CborNoError;
  }

  else
  {

  error:
    ;
    element->type = 255;
    return err;
  }
}

// cbor_value_skip_tag
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 478
CborError cbor_value_skip_tag(CborValue *it)
{
  _Bool return_value_cbor_value_is_tag;
  do
  {
    return_value_cbor_value_is_tag=cbor_value_is_tag(it);
    if(return_value_cbor_value_is_tag == (_Bool)0)
      break;

    CborError err=cbor_value_advance_fixed(it);
    if(!(err == /*enum*/CborNoError))
      return err;

  }
  while((_Bool)1);
  return /*enum*/CborNoError;
}

// cbor_value_text_string_equals
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 1092
CborError cbor_value_text_string_equals(const CborValue *value, const char *string, _Bool *result)
{
  CborValue copy=*value;
  CborError err=cbor_value_skip_tag(&copy);
  if(!(err == /*enum*/CborNoError))
    return err;

  else
  {
    _Bool return_value_cbor_value_is_text_string=cbor_value_is_text_string(&copy);
    if(return_value_cbor_value_is_text_string == (_Bool)0)
    {
      *result = (_Bool)0;
      return /*enum*/CborNoError;
    }

    else
    {
      size_t len=strlen(string);
      CborError return_value_iterate_string_chunks=iterate_string_chunks(&copy, (char *)(uintptr_t)string, &len, result, ((CborValue *)NULL), iterate_memcmp);
      return return_value_iterate_string_chunks;
    }
  }
}

// cbor_value_to_pretty_advance
// file ..\..\..\..\lib\third_party\tinycbor\cborpretty.c line 466
CborError cbor_value_to_pretty_advance(FILE *out, CborValue *value)
{
  CborError return_value_value_to_pretty=value_to_pretty(out, value);
  return return_value_value_to_pretty;
}

// ceill
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 789
/*inline double ceill(double _X)*/
/*{*/
  /*double return_value_ceil=ceil((double)_X);*/
  /*return return_value_ceil;*/
/*}*/

// container_to_pretty
// file ..\..\..\..\lib\third_party\tinycbor\cborpretty.c line 242
static CborError container_to_pretty(FILE *out, CborValue *it, CborType containerType)
{
  const char *comma="";
  _Bool return_value_cbor_value_at_end;
  do
  {
    return_value_cbor_value_at_end=cbor_value_at_end$link1(it);
    if(return_value_cbor_value_at_end != (_Bool)0)
      break;

    signed int return_value_fprintf=fprintf(out, "%s", comma);
    if(!(return_value_fprintf >= 0))
      return /*enum*/CborErrorIO;

    comma = ", ";
    CborError err=value_to_pretty(out, it);
    if(!(err == /*enum*/CborNoError))
      return err;

    if(!((signed int)containerType == 128))
    {
      signed int return_value_fprintf$0=fprintf(out, ": ");
      if(!(return_value_fprintf$0 >= 0))
        return /*enum*/CborErrorIO;

      err=value_to_pretty(out, it);
      if(!(err == /*enum*/CborNoError))
        return err;

    }

  }
  while((_Bool)1);
  return /*enum*/CborNoError;
}

// coshl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 806
/*inline double coshl(double _X)*/
/*{*/
  /*double return_value_cosh=cosh((double)_X);*/
  /*return return_value_cosh;*/
/*}*/

// cosl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 811
/*inline double cosl(double _X)*/
/*{*/
  /*double return_value_cos=cos((double)_X);*/
  /*return return_value_cos;*/
/*}*/

// cprintf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 471

// create_container
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 451
static CborError create_container(CborEncoder *encoder, CborEncoder *container, size_t length, uint8_t shiftedMajorType)
{
  CborError err;
  container->data.ptr = encoder->data.ptr;
  container->end = encoder->end;
  encoder->added = encoder->added + 1ull;
  container->added = 0ull;
  (void)sizeof(char [1ll]) /*1ull*/ ;
  (void)sizeof(char [1ll]) /*1ull*/ ;
  container->flags = (signed int)shiftedMajorType & 32;
  if(length == CborIndefiniteLength)
  {
    container->flags = container->flags | 4;
    err=append_byte_to_buffer(container, (uint8_t)((signed int)shiftedMajorType + 31));
  }

  else
    err=encode_number_no_update(container, length, shiftedMajorType);
  return err;
}

// cscanf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\conio.h line 488

// ctr_drbg_self_test_entropy
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 581
static signed int ctr_drbg_self_test_entropy(void *data, unsigned char *buf, size_t len)
{
  const unsigned char *p=(const unsigned char *)data;
  memcpy((void *)buf, (const void *)(p + (signed long long int)test_offset), len);
  test_offset = test_offset + len;
  return 0;
}

// ctr_drbg_update_internal
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 263
static signed int ctr_drbg_update_internal(mbedtls_ctr_drbg_context *ctx, const unsigned char *data)
{
  unsigned char tmp[48ll];
  unsigned char *p=tmp;
  signed int i;
  signed int j;
  signed int ret=0;
  memset((void *)tmp, 0, (size_t)(32 + 16));
  j = 0;
  for( ; !(j >= 48); j = j + 16)
  {
    i = 16;
    for( ; i >= 1; i = i - 1)
    {
      ctx->counter[(signed long long int)(i - 1)] = ctx->counter[(signed long long int)(i - 1)] + 1;
      if(!((signed int)ctx->counter[(signed long long int)(-1 + i)] == 0))
        break;

    }
    ret=mbedtls_aes_crypt_ecb(&ctx->aes_ctx, 1, ctx->counter, p);
    if(!(ret == 0))
      return ret;

    p = p + 16ll;
  }
  i = 0;
  for( ; !(i >= 48); i = i + 1)
    tmp[(signed long long int)i] = tmp[(signed long long int)i] ^ data[(signed long long int)i];
  ret=mbedtls_aes_setkey_enc(&ctx->aes_ctx, tmp, (unsigned int)(32 * 8));
  if(!(ret == 0))
    return ret;

  else
  {
    memcpy((void *)ctx->counter, (const void *)(tmp + 32ll), 16ull);
    return 0;
  }
}

// decode_half
// file d:\tuttle\freertos\lib\third_party\tinycbor\math_support_p.h line 31
static inline double decode_half(unsigned short int half)
{
  signed int decode_half$$1$$exp=(signed int)half >> 10 & 0x1F;
  signed int mant=(signed int)half & 0x3FF;
  double val;
  if(decode_half$$1$$exp == 0)
    val=ldexp((double)mant, -24);

  else
    if(!(decode_half$$1$$exp == 31))
      val=ldexp((double)(mant + 1024), decode_half$$1$$exp - 25);

    else
      val = (double)(mant == 0 ? (float)(1.000000e+300 * 1.000000e+300) : (float)((float)(1.000000e+300 * 1.000000e+300) * 0.0f));
  return ((signed int)half & 0x8000) != 0 ? -val : val;
}

// derive_mpi
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdsa.c line 49
static signed int derive_mpi(const mbedtls_ecp_group *grp, mbedtls_mpi *x, const unsigned char *buf, size_t blen)
{
  signed int ret;
  size_t n_size=(grp->nbits + 7ull) / 8ull;
  size_t use_size=blen > n_size ? n_size : blen;
  do
  {
    ret=mbedtls_mpi_read_binary(x, buf, use_size);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  if(!(grp->nbits >= 8ull * use_size))
    do
    {
      ret=mbedtls_mpi_shift_r(x, use_size * 8ull - grp->nbits);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);

  signed int return_value_mbedtls_mpi_cmp_mpi=mbedtls_mpi_cmp_mpi(x, &grp->N);
  if(return_value_mbedtls_mpi_cmp_mpi >= 0)
    do
    {
      ret=mbedtls_mpi_sub_mpi(x, x, &grp->N);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);


cleanup:
  ;
  return ret;
}

// eARPGetCacheEntry
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_ARP.c line 371
eARPLookupResult_t eARPGetCacheEntry(uint32_t *pulIPAddress, MACAddress_t * const pxMACAddress)
{
  eARPLookupResult_t eReturn;
  uint32_t ulAddressToLookup;
  _Bool tmp_if_expr;
  if(*pulIPAddress == 0xFFFFFFFFul)
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = *pulIPAddress == xNetworkAddressing.ulBroadcastAddress ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
  {
    memcpy((void *)pxMACAddress->ucBytes, (const void *)xBroadcastMACAddress.ucBytes, sizeof(MACAddress_t) /*6ull*/ );
    eReturn = /*enum*/eARPCacheHit;
  }

  else
    if(xDefaultPartUDPPacketHeader.ulWords[5ll] == 0ul)
      eReturn = /*enum*/eCantSendPacket;

    else
    {
      eReturn = /*enum*/eARPCacheMiss;
      if(!((*pulIPAddress & xNetworkAddressing.ulNetMask) == (xDefaultPartUDPPacketHeader.ulWords[5ll] & xNetworkAddressing.ulNetMask)))
      {
        if(!(xNetworkAddressing.ulGatewayAddress == 0u))
          ulAddressToLookup = xNetworkAddressing.ulGatewayAddress;

        else
          ulAddressToLookup = *pulIPAddress;
      }

      else
        ulAddressToLookup = *pulIPAddress;
      if((signed int)eReturn == 0)
      {
        if(ulAddressToLookup == 0ul)
          eReturn = /*enum*/eCantSendPacket;

        else
        {
          eReturn=prvCacheLookup(ulAddressToLookup, pxMACAddress);
          if((signed int)eReturn == 0)
            *pulIPAddress = ulAddressToLookup;

        }
      }

    }
  return eReturn;
}

// eARPProcessPacket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_ARP.c line 108
eFrameProcessingResult_t eARPProcessPacket(ARPPacket_t * const pxARPFrame)
{
  eFrameProcessingResult_t eReturn=/*enum*/eReleaseBuffer;
  ARPHeader_t *pxARPHeader;
  uint32_t ulTargetProtocolAddress;
  uint32_t ulSenderProtocolAddress;
  pxARPHeader = &pxARPFrame->xARPHeader;
  memcpy((void *)&ulSenderProtocolAddress, (void *)pxARPHeader->ucSenderProtocolAddress, sizeof(uint32_t) /*4ull*/ );
  ulTargetProtocolAddress = pxARPHeader->ulTargetProtocolAddress;
  if(!(xDefaultPartUDPPacketHeader.ulWords[5ll] == 0ul))
    switch((signed int)pxARPHeader->usOperation)
    {
      case 256:
      {
        if(ulTargetProtocolAddress == xDefaultPartUDPPacketHeader.ulWords[5ll])
        {
          vARPRefreshCacheEntry(&pxARPHeader->xSenderHardwareAddress, ulSenderProtocolAddress);
          pxARPHeader->usOperation = 512;
          if(ulTargetProtocolAddress == ulSenderProtocolAddress)
          {
            memcpy((void *)pxARPFrame->xEthernetHeader.xSourceAddress.ucBytes, (const void *)xBroadcastMACAddress.ucBytes, sizeof(const MACAddress_t) /*6ull*/ );
            memset((void *)pxARPHeader->xTargetHardwareAddress.ucBytes, 0, sizeof(MACAddress_t) /*6ull*/ );
            pxARPHeader->ulTargetProtocolAddress = 0ul;
          }

          else
          {
            memcpy((void *)pxARPHeader->xTargetHardwareAddress.ucBytes, (const void *)pxARPHeader->xSenderHardwareAddress.ucBytes, sizeof(MACAddress_t) /*6ull*/ );
            pxARPHeader->ulTargetProtocolAddress = ulSenderProtocolAddress;
          }
          memcpy((void *)pxARPHeader->xSenderHardwareAddress.ucBytes, (void *)xDefaultPartUDPPacketHeader.ucBytes, sizeof(MACAddress_t) /*6ull*/ );
          memcpy((void *)pxARPHeader->ucSenderProtocolAddress, (void *)(uint32_t *)&xDefaultPartUDPPacketHeader.ulWords[(signed long long int)(20ull / sizeof(uint32_t) /*4ull*/ )], sizeof(uint8_t [4ll]) /*4ull*/ );
          eReturn = /*enum*/eReturnEthernetFrame;
        }

        break;
      }
      case 512:
      {
        vARPRefreshCacheEntry(&pxARPHeader->xSenderHardwareAddress, ulSenderProtocolAddress);
        break;
      }
      default:
        ;
    }

  return eReturn;
}

// eConsiderFrameForProcessing
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 1217
eFrameProcessingResult_t eConsiderFrameForProcessing(const uint8_t * const pucEthernetBuffer)
{
  eFrameProcessingResult_t eReturn;
  const EthernetHeader_t *pxEthernetHeader=(const EthernetHeader_t *)pucEthernetBuffer;
  signed int return_value_memcmp$0=memcmp((void *)xDefaultPartUDPPacketHeader.ucBytes, (void *)&pxEthernetHeader->xDestinationAddress, sizeof(MACAddress_t) /*6ull*/ );
  signed int return_value_memcmp;
  if(return_value_memcmp$0 == 0)
    eReturn = /*enum*/eProcessBuffer;

  else
  {
    return_value_memcmp=memcmp((void *)xBroadcastMACAddress.ucBytes, (void *)pxEthernetHeader->xDestinationAddress.ucBytes, sizeof(MACAddress_t) /*6ull*/ );
    if(return_value_memcmp == 0)
      eReturn = /*enum*/eProcessBuffer;

    else
      eReturn = /*enum*/eReleaseBuffer;
  }
  uint16_t usFrameType;
  if((signed int)eReturn == 1)
  {
    usFrameType = pxEthernetHeader->usFrameType;
    usFrameType = (uint16_t)((signed int)usFrameType << 8u | (signed int)usFrameType >> 8u);
    if(!((unsigned int)usFrameType >= 1537u))
      eReturn = /*enum*/eReleaseBuffer;

  }

  return eReturn;
}

// eTaskGetState
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 1344
eTaskState eTaskGetState(TaskHandle_t xTask)
{
  eTaskState eReturn;
  List_t *pxStateList;
  const TCB_t * const pxTCB=(TCB_t *)xTask;
  if(pxTCB == ((const TCB_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 1350u);

  if(pxTCB == pxCurrentTCB)
    eReturn = /*enum*/eRunning;

  else
  {
    vPortEnterCritical();
    pxStateList = (List_t *)(&pxTCB->xStateListItem)->pvContainer;
    vPortExitCritical();
    if(pxStateList == pxDelayedTaskList || pxStateList == pxOverflowDelayedTaskList)
      eReturn = /*enum*/eBlocked;

    else
      if(pxStateList == &xSuspendedTaskList)
      {
        if(pxTCB->xEventListItem.pvContainer == NULL)
          eReturn = /*enum*/eSuspended;

        else
          eReturn = /*enum*/eBlocked;
      }

      else
        if(pxStateList == &xTasksWaitingTermination || pxStateList == ((List_t *)NULL))
          eReturn = /*enum*/eDeleted;

        else
          eReturn = /*enum*/eReady;
  }
  return eReturn;
}

// ecdsa_alloc_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 375
static void * ecdsa_alloc_wrap(void)
{
  void *ctx=mbedtls_calloc(1ull, sizeof(mbedtls_ecdsa_context) /*344ull*/ );
  if(!(ctx == NULL))
    mbedtls_ecdsa_init((mbedtls_ecdsa_context *)ctx);

  return ctx;
}

// ecdsa_can_do
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 345
static signed int ecdsa_can_do(mbedtls_pk_type_t type)
{
  return (signed int)((signed int)type == 4);
}

// ecdsa_free_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 385
static void ecdsa_free_wrap(void *ctx)
{
  mbedtls_ecdsa_free((mbedtls_ecdsa_context *)ctx);
  mbedtls_free(ctx);
}

// ecdsa_sign_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 366
static signed int ecdsa_sign_wrap(void *ctx, mbedtls_md_type_t md_alg, const unsigned char *hash, size_t hash_len, unsigned char *sig, size_t *sig_len, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
  signed int return_value_mbedtls_ecdsa_write_signature=mbedtls_ecdsa_write_signature((mbedtls_ecdsa_context *)ctx, md_alg, hash, hash_len, sig, sig_len, f_rng, p_rng);
  return return_value_mbedtls_ecdsa_write_signature;
}

// ecdsa_signature_to_asn1
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdsa.c line 292
static signed int ecdsa_signature_to_asn1(const mbedtls_mpi *r, const mbedtls_mpi *s, unsigned char *sig, size_t *slen)
{
  signed int ret;
  unsigned char buf[141ll];
  unsigned char *p=buf + (signed long long int)sizeof(unsigned char [141ll]) /*141ll*/ ;
  size_t len=0ull;
  do
  {
    ret=mbedtls_asn1_write_mpi(&p, buf, s);
    if(!(ret >= 0))
      return ret;

    else
      len = len + (size_t)ret;
  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_asn1_write_mpi(&p, buf, r);
    if(!(ret >= 0))
      return ret;

    else
      len = len + (size_t)ret;
  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_asn1_write_len(&p, buf, len);
    if(!(ret >= 0))
      return ret;

    else
      len = len + (size_t)ret;
  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_asn1_write_tag(&p, buf, (unsigned char)(0x20 | 0x10));
    if(!(ret >= 0))
      return ret;

    else
      len = len + (size_t)ret;
  }
  while((_Bool)0);
  memcpy((void *)sig, (const void *)p, len);
  *slen = len;
  return 0;
}

// ecdsa_verify_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 350
static signed int ecdsa_verify_wrap(void *ctx, mbedtls_md_type_t md_alg, const unsigned char *hash, size_t hash_len, const unsigned char *sig, size_t sig_len)
{
  signed int ret;
  (void)md_alg;
  ret=mbedtls_ecdsa_read_signature((mbedtls_ecdsa_context *)ctx, hash, hash_len, sig, sig_len);
  if(ret == -19456)
    return -0x3900;

  else
    return ret;
}

// eckey_alloc_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 276
static void * eckey_alloc_wrap(void)
{
  void *ctx=mbedtls_calloc(1ull, sizeof(mbedtls_ecp_keypair) /*344ull*/ );
  if(!(ctx == NULL))
    mbedtls_ecp_keypair_init((mbedtls_ecp_keypair *)ctx);

  return ctx;
}

// eckey_can_do
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 209
static signed int eckey_can_do(mbedtls_pk_type_t type)
{
  return (signed int)((signed int)type == 2 || (signed int)type == 3 || (signed int)type == 4);
}

// eckey_check_pair
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 270
static signed int eckey_check_pair(const void *pub, const void *prv)
{
  signed int return_value_mbedtls_ecp_check_pub_priv=mbedtls_ecp_check_pub_priv((const mbedtls_ecp_keypair *)pub, (const mbedtls_ecp_keypair *)prv);
  return return_value_mbedtls_ecp_check_pub_priv;
}

// eckey_debug
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 292
static void eckey_debug(const void *ctx, mbedtls_pk_debug_item *items)
{
  items->type = /*enum*/MBEDTLS_PK_DEBUG_ECP;
  items->name = "eckey.Q";
  items->value = (void *)&((mbedtls_ecp_keypair *)ctx)->Q;
}

// eckey_free_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 286
static void eckey_free_wrap(void *ctx)
{
  mbedtls_ecp_keypair_free((mbedtls_ecp_keypair *)ctx);
  mbedtls_free(ctx);
}

// eckey_get_bitlen
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 216
static size_t eckey_get_bitlen(const void *ctx)
{
  return ((mbedtls_ecp_keypair *)ctx)->grp.pbits;
}

// eckey_sign_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 249
static signed int eckey_sign_wrap(void *ctx, mbedtls_md_type_t md_alg, const unsigned char *hash, size_t hash_len, unsigned char *sig, size_t *sig_len, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
  signed int ret;
  mbedtls_ecdsa_context ecdsa;
  mbedtls_ecdsa_init(&ecdsa);
  ret=mbedtls_ecdsa_from_keypair(&ecdsa, (const mbedtls_ecp_keypair *)ctx);
  if(ret == 0)
    ret=ecdsa_sign_wrap((void *)&ecdsa, md_alg, hash, hash_len, sig, sig_len, f_rng, p_rng);

  mbedtls_ecdsa_free(&ecdsa);
  return ret;
}

// eckey_verify_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 232
static signed int eckey_verify_wrap(void *ctx, mbedtls_md_type_t md_alg, const unsigned char *hash, size_t hash_len, const unsigned char *sig, size_t sig_len)
{
  signed int ret;
  mbedtls_ecdsa_context ecdsa;
  mbedtls_ecdsa_init(&ecdsa);
  ret=mbedtls_ecdsa_from_keypair(&ecdsa, (const mbedtls_ecp_keypair *)ctx);
  if(ret == 0)
    ret=ecdsa_verify_wrap((void *)&ecdsa, md_alg, hash, hash_len, sig, sig_len);

  mbedtls_ecdsa_free(&ecdsa);
  return ret;
}

// eckeydh_can_do
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 322
static signed int eckeydh_can_do(mbedtls_pk_type_t type)
{
  return (signed int)((signed int)type == 2 || (signed int)type == 3);
}

// ecp_add_mixed
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 1023
static signed int ecp_add_mixed(const mbedtls_ecp_group *grp, mbedtls_ecp_point *R, const mbedtls_ecp_point *P, const mbedtls_ecp_point *Q)
{
  signed int ret;
  mbedtls_mpi T1;
  mbedtls_mpi T2;
  mbedtls_mpi T3;
  mbedtls_mpi T4;
  mbedtls_mpi X;
  mbedtls_mpi Y;
  mbedtls_mpi Z;
  add_count = add_count + 1ul;
  signed int return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(&P->Z, 0ll);
  signed int return_value_mbedtls_ecp_copy;
  signed int return_value_mbedtls_mpi_cmp_int$0;
  signed int return_value_mbedtls_ecp_copy$0;
  signed int return_value_mbedtls_mpi_cmp_int$1;
  signed int return_value_mbedtls_mpi_cmp_int$2;
  signed int return_value_mbedtls_mpi_cmp_int$3;
  signed int return_value_mbedtls_mpi_cmp_mpi;
  signed int return_value_mbedtls_mpi_cmp_int$6;
  signed int return_value_mbedtls_mpi_cmp_int$7;
  signed int return_value_mbedtls_mpi_cmp_int$8;
  signed int return_value_mbedtls_mpi_cmp_int$9;
  if(return_value_mbedtls_mpi_cmp_int == 0)
  {
    return_value_mbedtls_ecp_copy=mbedtls_ecp_copy(R, Q);
    return return_value_mbedtls_ecp_copy;
  }

  else
  {
    if(!(Q->Z.p == ((mbedtls_mpi_uint *)NULL)))
    {
      return_value_mbedtls_mpi_cmp_int$0=mbedtls_mpi_cmp_int(&Q->Z, 0ll);
      if(return_value_mbedtls_mpi_cmp_int$0 == 0)
      {
        return_value_mbedtls_ecp_copy$0=mbedtls_ecp_copy(R, P);
        return return_value_mbedtls_ecp_copy$0;
      }

    }

    if(!(Q->Z.p == ((mbedtls_mpi_uint *)NULL)))
    {
      return_value_mbedtls_mpi_cmp_int$1=mbedtls_mpi_cmp_int(&Q->Z, 1ll);
      if(!(return_value_mbedtls_mpi_cmp_int$1 == 0))
        return -0x4F80;

    }

    mbedtls_mpi_init(&T1);
    mbedtls_mpi_init(&T2);
    mbedtls_mpi_init(&T3);
    mbedtls_mpi_init(&T4);
    mbedtls_mpi_init(&X);
    mbedtls_mpi_init(&Y);
    mbedtls_mpi_init(&Z);
    do
    {
      ret=mbedtls_mpi_mul_mpi(&T1, &P->Z, &P->Z);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L7:
      ;
      ret=ecp_modp(&T1, grp);
      if(!(ret == 0))
        goto cleanup;

      mul_count = mul_count + 1ul;
    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_mul_mpi(&T2, &T1, &P->Z);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L9:
      ;
      ret=ecp_modp(&T2, grp);
      if(!(ret == 0))
        goto cleanup;

      mul_count = mul_count + 1ul;
    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_mul_mpi(&T1, &T1, &Q->X);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L11:
      ;
      ret=ecp_modp(&T1, grp);
      if(!(ret == 0))
        goto cleanup;

      mul_count = mul_count + 1ul;
    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_mul_mpi(&T2, &T2, &Q->Y);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L13:
      ;
      ret=ecp_modp(&T2, grp);
      if(!(ret == 0))
        goto cleanup;

      mul_count = mul_count + 1ul;
    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_sub_mpi(&T1, &T1, &P->X);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    while(!(T1.s >= 0))
    {
      return_value_mbedtls_mpi_cmp_int$2=mbedtls_mpi_cmp_int(&T1, 0ll);
      if(return_value_mbedtls_mpi_cmp_int$2 == 0)
        break;

      do
      {
        ret=mbedtls_mpi_add_mpi(&T1, &T1, &grp->P);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
    }
    do
    {
      ret=mbedtls_mpi_sub_mpi(&T2, &T2, &P->Y);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    while(!(T2.s >= 0))
    {
      return_value_mbedtls_mpi_cmp_int$3=mbedtls_mpi_cmp_int(&T2, 0ll);
      if(return_value_mbedtls_mpi_cmp_int$3 == 0)
        break;

      do
      {
        ret=mbedtls_mpi_add_mpi(&T2, &T2, &grp->P);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
    }
    signed int return_value_mbedtls_mpi_cmp_int$5=mbedtls_mpi_cmp_int(&T1, 0ll);
    if(return_value_mbedtls_mpi_cmp_int$5 == 0)
    {
      signed int return_value_mbedtls_mpi_cmp_int$4=mbedtls_mpi_cmp_int(&T2, 0ll);
      if(return_value_mbedtls_mpi_cmp_int$4 == 0)
      {
        ret=ecp_double_jac(grp, R, P);
        goto cleanup;
      }

      else
      {
        ret=mbedtls_ecp_set_zero(R);
        goto cleanup;
      }
    }

    do
    {
      ret=mbedtls_mpi_mul_mpi(&Z, &P->Z, &T1);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L28:
      ;
      ret=ecp_modp(&Z, grp);
      if(!(ret == 0))
        goto cleanup;

      mul_count = mul_count + 1ul;
    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_mul_mpi(&T3, &T1, &T1);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L30:
      ;
      ret=ecp_modp(&T3, grp);
      if(!(ret == 0))
        goto cleanup;

      mul_count = mul_count + 1ul;
    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_mul_mpi(&T4, &T3, &T1);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L32:
      ;
      ret=ecp_modp(&T4, grp);
      if(!(ret == 0))
        goto cleanup;

      mul_count = mul_count + 1ul;
    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_mul_mpi(&T3, &T3, &P->X);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L34:
      ;
      ret=ecp_modp(&T3, grp);
      if(!(ret == 0))
        goto cleanup;

      mul_count = mul_count + 1ul;
    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_mul_int(&T1, &T3, 2ull);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      return_value_mbedtls_mpi_cmp_mpi=mbedtls_mpi_cmp_mpi(&T1, &grp->P);
      if(!(return_value_mbedtls_mpi_cmp_mpi >= 0))
        break;

      do
      {
        ret=mbedtls_mpi_sub_abs(&T1, &T1, &grp->P);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
    }
    while((_Bool)1);
    do
    {
      ret=mbedtls_mpi_mul_mpi(&X, &T2, &T2);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L40:
      ;
      ret=ecp_modp(&X, grp);
      if(!(ret == 0))
        goto cleanup;

      mul_count = mul_count + 1ul;
    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_sub_mpi(&X, &X, &T1);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    while(!(X.s >= 0))
    {
      return_value_mbedtls_mpi_cmp_int$6=mbedtls_mpi_cmp_int(&X, 0ll);
      if(return_value_mbedtls_mpi_cmp_int$6 == 0)
        break;

      do
      {
        ret=mbedtls_mpi_add_mpi(&X, &X, &grp->P);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
    }
    do
    {
      ret=mbedtls_mpi_sub_mpi(&X, &X, &T4);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    while(!(X.s >= 0))
    {
      return_value_mbedtls_mpi_cmp_int$7=mbedtls_mpi_cmp_int(&X, 0ll);
      if(return_value_mbedtls_mpi_cmp_int$7 == 0)
        break;

      do
      {
        ret=mbedtls_mpi_add_mpi(&X, &X, &grp->P);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
    }
    do
    {
      ret=mbedtls_mpi_sub_mpi(&T3, &T3, &X);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    while(!(T3.s >= 0))
    {
      return_value_mbedtls_mpi_cmp_int$8=mbedtls_mpi_cmp_int(&T3, 0ll);
      if(return_value_mbedtls_mpi_cmp_int$8 == 0)
        break;

      do
      {
        ret=mbedtls_mpi_add_mpi(&T3, &T3, &grp->P);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
    }
    do
    {
      ret=mbedtls_mpi_mul_mpi(&T3, &T3, &T2);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L57:
      ;
      ret=ecp_modp(&T3, grp);
      if(!(ret == 0))
        goto cleanup;

      mul_count = mul_count + 1ul;
    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_mul_mpi(&T4, &T4, &P->Y);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L59:
      ;
      ret=ecp_modp(&T4, grp);
      if(!(ret == 0))
        goto cleanup;

      mul_count = mul_count + 1ul;
    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_sub_mpi(&Y, &T3, &T4);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    while(!(Y.s >= 0))
    {
      return_value_mbedtls_mpi_cmp_int$9=mbedtls_mpi_cmp_int(&Y, 0ll);
      if(return_value_mbedtls_mpi_cmp_int$9 == 0)
        break;

      do
      {
        ret=mbedtls_mpi_add_mpi(&Y, &Y, &grp->P);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
    }
    do
    {
      ret=mbedtls_mpi_copy(&R->X, &X);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_copy(&R->Y, &Y);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_copy(&R->Z, &Z);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);

  cleanup:
    ;
    mbedtls_mpi_free(&T1);
    mbedtls_mpi_free(&T2);
    mbedtls_mpi_free(&T3);
    mbedtls_mpi_free(&T4);
    mbedtls_mpi_free(&X);
    mbedtls_mpi_free(&Y);
    mbedtls_mpi_free(&Z);
    return ret;
  }
}

// ecp_check_pubkey_sw
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 1728
static signed int ecp_check_pubkey_sw(const mbedtls_ecp_group *grp, const mbedtls_ecp_point *ecp_check_pubkey_sw$$pt)
{
  signed int ret;
  mbedtls_mpi YY;
  mbedtls_mpi RHS;
  signed int return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(&ecp_check_pubkey_sw$$pt->X, 0ll);
  _Bool tmp_if_expr;
  signed int return_value_mbedtls_mpi_cmp_int$0;
  if(!(return_value_mbedtls_mpi_cmp_int >= 0))
    tmp_if_expr = (_Bool)1;

  else
  {
    return_value_mbedtls_mpi_cmp_int$0=mbedtls_mpi_cmp_int(&ecp_check_pubkey_sw$$pt->Y, 0ll);
    tmp_if_expr = return_value_mbedtls_mpi_cmp_int$0 < 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$0;
  signed int return_value_mbedtls_mpi_cmp_mpi;
  if(tmp_if_expr)
    tmp_if_expr$0 = (_Bool)1;

  else
  {
    return_value_mbedtls_mpi_cmp_mpi=mbedtls_mpi_cmp_mpi(&ecp_check_pubkey_sw$$pt->X, &grp->P);
    tmp_if_expr$0 = return_value_mbedtls_mpi_cmp_mpi >= 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$1;
  signed int return_value_mbedtls_mpi_cmp_mpi$0;
  if(tmp_if_expr$0)
    tmp_if_expr$1 = (_Bool)1;

  else
  {
    return_value_mbedtls_mpi_cmp_mpi$0=mbedtls_mpi_cmp_mpi(&ecp_check_pubkey_sw$$pt->Y, &grp->P);
    tmp_if_expr$1 = return_value_mbedtls_mpi_cmp_mpi$0 >= 0 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_mbedtls_mpi_cmp_int$1;
  signed int return_value_mbedtls_mpi_cmp_mpi$1;
  signed int return_value_mbedtls_mpi_cmp_mpi$2;
  if(tmp_if_expr$1)
    return -0x4C80;

  else
  {
    mbedtls_mpi_init(&YY);
    mbedtls_mpi_init(&RHS);
    do
    {
      ret=mbedtls_mpi_mul_mpi(&YY, &ecp_check_pubkey_sw$$pt->Y, &ecp_check_pubkey_sw$$pt->Y);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L9:
      ;
      ret=ecp_modp(&YY, grp);
      if(!(ret == 0))
        goto cleanup;

      mul_count = mul_count + 1ul;
    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_mul_mpi(&RHS, &ecp_check_pubkey_sw$$pt->X, &ecp_check_pubkey_sw$$pt->X);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L11:
      ;
      ret=ecp_modp(&RHS, grp);
      if(!(ret == 0))
        goto cleanup;

      mul_count = mul_count + 1ul;
    }
    while((_Bool)0);
    if(grp->A.p == ((mbedtls_mpi_uint *)NULL))
    {
      do
      {
        ret=mbedtls_mpi_sub_int(&RHS, &RHS, 3ll);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      while(!(RHS.s >= 0))
      {
        return_value_mbedtls_mpi_cmp_int$1=mbedtls_mpi_cmp_int(&RHS, 0ll);
        if(return_value_mbedtls_mpi_cmp_int$1 == 0)
          break;

        do
        {
          ret=mbedtls_mpi_add_mpi(&RHS, &RHS, &grp->P);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
      }
    }

    else
    {
      do
      {
        ret=mbedtls_mpi_add_mpi(&RHS, &RHS, &grp->A);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        return_value_mbedtls_mpi_cmp_mpi$1=mbedtls_mpi_cmp_mpi(&RHS, &grp->P);
        if(!(return_value_mbedtls_mpi_cmp_mpi$1 >= 0))
          break;

        do
        {
          ret=mbedtls_mpi_sub_abs(&RHS, &RHS, &grp->P);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
      }
      while((_Bool)1);
    }
    do
    {
      ret=mbedtls_mpi_mul_mpi(&RHS, &RHS, &ecp_check_pubkey_sw$$pt->X);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L23:
      ;
      ret=ecp_modp(&RHS, grp);
      if(!(ret == 0))
        goto cleanup;

      mul_count = mul_count + 1ul;
    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_add_mpi(&RHS, &RHS, &grp->B);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      return_value_mbedtls_mpi_cmp_mpi$2=mbedtls_mpi_cmp_mpi(&RHS, &grp->P);
      if(!(return_value_mbedtls_mpi_cmp_mpi$2 >= 0))
        break;

      do
      {
        ret=mbedtls_mpi_sub_abs(&RHS, &RHS, &grp->P);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
    }
    while((_Bool)1);
    signed int return_value_mbedtls_mpi_cmp_mpi$3=mbedtls_mpi_cmp_mpi(&YY, &RHS);
    if(!(return_value_mbedtls_mpi_cmp_mpi$3 == 0))
      ret = -0x4C80;


  cleanup:
    ;
    mbedtls_mpi_free(&YY);
    mbedtls_mpi_free(&RHS);
    return ret;
  }
}

// ecp_comb_fixed
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 1193
static void ecp_comb_fixed(unsigned char *x, size_t d, unsigned char w, const mbedtls_mpi *m)
{
  size_t i;
  size_t j;
  unsigned char c;
  unsigned char cc;
  unsigned char adjust;
  memset((void *)x, 0, d + 1ull);
  i = 0ull;
  signed int return_value_mbedtls_mpi_get_bit;
  for( ; !(i >= d); i = i + 1ull)
  {
    j = 0ull;
    for( ; !(j >= (unsigned long long int)w); j = j + 1ull)
    {
      return_value_mbedtls_mpi_get_bit=mbedtls_mpi_get_bit(m, i + d * j);
      x[(signed long long int)i] = x[(signed long long int)i] | (unsigned char)(return_value_mbedtls_mpi_get_bit << j);
    }
  }
  c = 0;
  i = 1ull;
  for( ; d >= i; i = i + 1ull)
  {
    cc = (unsigned char)((signed int)x[(signed long long int)i] & (signed int)c);
    x[(signed long long int)i] = (unsigned char)((signed int)x[(signed long long int)i] ^ (signed int)c);
    c = cc;
    adjust = (unsigned char)(1 - ((signed int)x[(signed long long int)i] & 0x1));
    c = c | (unsigned char)((signed int)x[(signed long long int)i] & (signed int)x[(signed long long int)(i - 1ull)] * (signed int)adjust);
    x[(signed long long int)i] = (unsigned char)((signed int)x[(signed long long int)i] ^ (signed int)x[(signed long long int)(i - 1ull)] * (signed int)adjust);
    x[(signed long long int)(i - 1ull)] = x[(signed long long int)(i - 1ull)] | (unsigned char)((signed int)adjust << 7);
  }
}

// ecp_double_jac
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 925
static signed int ecp_double_jac(const mbedtls_ecp_group *grp, mbedtls_ecp_point *R, const mbedtls_ecp_point *P)
{
  signed int ret;
  mbedtls_mpi M;
  mbedtls_mpi S;
  mbedtls_mpi T;
  mbedtls_mpi U;
  dbl_count = dbl_count + 1ul;
  mbedtls_mpi_init(&M);
  mbedtls_mpi_init(&S);
  mbedtls_mpi_init(&T);
  mbedtls_mpi_init(&U);
  signed int return_value_mbedtls_mpi_cmp_mpi;
  signed int return_value_mbedtls_mpi_cmp_int;
  signed int return_value_mbedtls_mpi_cmp_mpi$0;
  signed int return_value_mbedtls_mpi_cmp_mpi$1;
  signed int return_value_mbedtls_mpi_cmp_mpi$2;
  if(grp->A.p == ((mbedtls_mpi_uint *)NULL))
  {
    do
    {
      ret=mbedtls_mpi_mul_mpi(&S, &P->Z, &P->Z);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L2:
      ;
      ret=ecp_modp(&S, grp);
      if(!(ret == 0))
        goto cleanup;

      mul_count = mul_count + 1ul;
    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_add_mpi(&T, &P->X, &S);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      return_value_mbedtls_mpi_cmp_mpi=mbedtls_mpi_cmp_mpi(&T, &grp->P);
      if(!(return_value_mbedtls_mpi_cmp_mpi >= 0))
        break;

      do
      {
        ret=mbedtls_mpi_sub_abs(&T, &T, &grp->P);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
    }
    while((_Bool)1);
    do
    {
      ret=mbedtls_mpi_sub_mpi(&U, &P->X, &S);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    while(!(U.s >= 0))
    {
      return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(&U, 0ll);
      if(return_value_mbedtls_mpi_cmp_int == 0)
        break;

      do
      {
        ret=mbedtls_mpi_add_mpi(&U, &U, &grp->P);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
    }
    do
    {
      ret=mbedtls_mpi_mul_mpi(&S, &T, &U);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L13:
      ;
      ret=ecp_modp(&S, grp);
      if(!(ret == 0))
        goto cleanup;

      mul_count = mul_count + 1ul;
    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_mul_int(&M, &S, 3ull);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      return_value_mbedtls_mpi_cmp_mpi$0=mbedtls_mpi_cmp_mpi(&M, &grp->P);
      if(!(return_value_mbedtls_mpi_cmp_mpi$0 >= 0))
        break;

      do
      {
        ret=mbedtls_mpi_sub_abs(&M, &M, &grp->P);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
    }
    while((_Bool)1);
  }

  else
  {
    do
    {
      ret=mbedtls_mpi_mul_mpi(&S, &P->X, &P->X);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L19:
      ;
      ret=ecp_modp(&S, grp);
      if(!(ret == 0))
        goto cleanup;

      mul_count = mul_count + 1ul;
    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_mul_int(&M, &S, 3ull);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      return_value_mbedtls_mpi_cmp_mpi$1=mbedtls_mpi_cmp_mpi(&M, &grp->P);
      if(!(return_value_mbedtls_mpi_cmp_mpi$1 >= 0))
        break;

      do
      {
        ret=mbedtls_mpi_sub_abs(&M, &M, &grp->P);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
    }
    while((_Bool)1);
    signed int return_value_mbedtls_mpi_cmp_int$0=mbedtls_mpi_cmp_int(&grp->A, 0ll);
    if(!(return_value_mbedtls_mpi_cmp_int$0 == 0))
    {
      do
      {
        ret=mbedtls_mpi_mul_mpi(&S, &P->Z, &P->Z);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {

      __CPROVER_DUMP_L25:
        ;
        ret=ecp_modp(&S, grp);
        if(!(ret == 0))
          goto cleanup;

        mul_count = mul_count + 1ul;
      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_mul_mpi(&T, &S, &S);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {

      __CPROVER_DUMP_L27:
        ;
        ret=ecp_modp(&T, grp);
        if(!(ret == 0))
          goto cleanup;

        mul_count = mul_count + 1ul;
      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_mul_mpi(&S, &T, &grp->A);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {

      __CPROVER_DUMP_L29:
        ;
        ret=ecp_modp(&S, grp);
        if(!(ret == 0))
          goto cleanup;

        mul_count = mul_count + 1ul;
      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_add_mpi(&M, &M, &S);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        return_value_mbedtls_mpi_cmp_mpi$2=mbedtls_mpi_cmp_mpi(&M, &grp->P);
        if(!(return_value_mbedtls_mpi_cmp_mpi$2 >= 0))
          break;

        do
        {
          ret=mbedtls_mpi_sub_abs(&M, &M, &grp->P);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
      }
      while((_Bool)1);
    }

  }
  do
  {
    ret=mbedtls_mpi_mul_mpi(&T, &P->Y, &P->Y);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {

  __CPROVER_DUMP_L37:
    ;
    ret=ecp_modp(&T, grp);
    if(!(ret == 0))
      goto cleanup;

    mul_count = mul_count + 1ul;
  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_shift_l(&T, 1ull);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  signed int return_value_mbedtls_mpi_cmp_mpi$3;
  do
  {
    return_value_mbedtls_mpi_cmp_mpi$3=mbedtls_mpi_cmp_mpi(&T, &grp->P);
    if(!(return_value_mbedtls_mpi_cmp_mpi$3 >= 0))
      break;

    do
    {
      ret=mbedtls_mpi_sub_abs(&T, &T, &grp->P);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
  }
  while((_Bool)1);
  do
  {
    ret=mbedtls_mpi_mul_mpi(&S, &P->X, &T);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {

  __CPROVER_DUMP_L43:
    ;
    ret=ecp_modp(&S, grp);
    if(!(ret == 0))
      goto cleanup;

    mul_count = mul_count + 1ul;
  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_shift_l(&S, 1ull);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  signed int return_value_mbedtls_mpi_cmp_mpi$4;
  do
  {
    return_value_mbedtls_mpi_cmp_mpi$4=mbedtls_mpi_cmp_mpi(&S, &grp->P);
    if(!(return_value_mbedtls_mpi_cmp_mpi$4 >= 0))
      break;

    do
    {
      ret=mbedtls_mpi_sub_abs(&S, &S, &grp->P);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
  }
  while((_Bool)1);
  do
  {
    ret=mbedtls_mpi_mul_mpi(&U, &T, &T);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {

  __CPROVER_DUMP_L49:
    ;
    ret=ecp_modp(&U, grp);
    if(!(ret == 0))
      goto cleanup;

    mul_count = mul_count + 1ul;
  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_shift_l(&U, 1ull);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  signed int return_value_mbedtls_mpi_cmp_mpi$5;
  do
  {
    return_value_mbedtls_mpi_cmp_mpi$5=mbedtls_mpi_cmp_mpi(&U, &grp->P);
    if(!(return_value_mbedtls_mpi_cmp_mpi$5 >= 0))
      break;

    do
    {
      ret=mbedtls_mpi_sub_abs(&U, &U, &grp->P);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
  }
  while((_Bool)1);
  do
  {
    ret=mbedtls_mpi_mul_mpi(&T, &M, &M);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {

  __CPROVER_DUMP_L55:
    ;
    ret=ecp_modp(&T, grp);
    if(!(ret == 0))
      goto cleanup;

    mul_count = mul_count + 1ul;
  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_sub_mpi(&T, &T, &S);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  signed int return_value_mbedtls_mpi_cmp_int$1;
  while(!(T.s >= 0))
  {
    return_value_mbedtls_mpi_cmp_int$1=mbedtls_mpi_cmp_int(&T, 0ll);
    if(return_value_mbedtls_mpi_cmp_int$1 == 0)
      break;

    do
    {
      ret=mbedtls_mpi_add_mpi(&T, &T, &grp->P);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
  }
  do
  {
    ret=mbedtls_mpi_sub_mpi(&T, &T, &S);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  signed int return_value_mbedtls_mpi_cmp_int$2;
  while(!(T.s >= 0))
  {
    return_value_mbedtls_mpi_cmp_int$2=mbedtls_mpi_cmp_int(&T, 0ll);
    if(return_value_mbedtls_mpi_cmp_int$2 == 0)
      break;

    do
    {
      ret=mbedtls_mpi_add_mpi(&T, &T, &grp->P);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
  }
  do
  {
    ret=mbedtls_mpi_sub_mpi(&S, &S, &T);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  signed int return_value_mbedtls_mpi_cmp_int$3;
  while(!(S.s >= 0))
  {
    return_value_mbedtls_mpi_cmp_int$3=mbedtls_mpi_cmp_int(&S, 0ll);
    if(return_value_mbedtls_mpi_cmp_int$3 == 0)
      break;

    do
    {
      ret=mbedtls_mpi_add_mpi(&S, &S, &grp->P);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
  }
  do
  {
    ret=mbedtls_mpi_mul_mpi(&S, &S, &M);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {

  __CPROVER_DUMP_L72:
    ;
    ret=ecp_modp(&S, grp);
    if(!(ret == 0))
      goto cleanup;

    mul_count = mul_count + 1ul;
  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_sub_mpi(&S, &S, &U);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  signed int return_value_mbedtls_mpi_cmp_int$4;
  while(!(S.s >= 0))
  {
    return_value_mbedtls_mpi_cmp_int$4=mbedtls_mpi_cmp_int(&S, 0ll);
    if(return_value_mbedtls_mpi_cmp_int$4 == 0)
      break;

    do
    {
      ret=mbedtls_mpi_add_mpi(&S, &S, &grp->P);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
  }
  do
  {
    ret=mbedtls_mpi_mul_mpi(&U, &P->Y, &P->Z);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {

  __CPROVER_DUMP_L79:
    ;
    ret=ecp_modp(&U, grp);
    if(!(ret == 0))
      goto cleanup;

    mul_count = mul_count + 1ul;
  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_shift_l(&U, 1ull);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  signed int return_value_mbedtls_mpi_cmp_mpi$6;
  do
  {
    return_value_mbedtls_mpi_cmp_mpi$6=mbedtls_mpi_cmp_mpi(&U, &grp->P);
    if(!(return_value_mbedtls_mpi_cmp_mpi$6 >= 0))
      break;

    do
    {
      ret=mbedtls_mpi_sub_abs(&U, &U, &grp->P);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
  }
  while((_Bool)1);
  do
  {
    ret=mbedtls_mpi_copy(&R->X, &T);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_copy(&R->Y, &S);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_copy(&R->Z, &U);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);

cleanup:
  ;
  mbedtls_mpi_free(&M);
  mbedtls_mpi_free(&S);
  mbedtls_mpi_free(&T);
  mbedtls_mpi_free(&U);
  return ret;
}

// ecp_get_type
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 264
static inline ecp_curve_type ecp_get_type(const mbedtls_ecp_group *grp)
{
  if(grp->G.X.p == ((mbedtls_mpi_uint *)NULL))
    return /*enum*/ECP_TYPE_NONE;

  else
    if(grp->G.Y.p == ((mbedtls_mpi_uint *)NULL))
      return /*enum*/ECP_TYPE_MONTGOMERY;

    else
      return /*enum*/ECP_TYPE_SHORT_WEIERSTRASS;
}

// ecp_group_load
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp_curves.c line 577
static signed int ecp_group_load(mbedtls_ecp_group *grp, const mbedtls_mpi_uint *p, size_t plen, const mbedtls_mpi_uint *a, size_t alen, const mbedtls_mpi_uint *b, size_t blen, const mbedtls_mpi_uint *gx, size_t gxlen, const mbedtls_mpi_uint *gy, size_t gylen, const mbedtls_mpi_uint *n, size_t nlen)
{
  ecp_mpi_load(&grp->P, p, plen);
  if(!(a == ((const mbedtls_mpi_uint *)NULL)))
    ecp_mpi_load(&grp->A, a, alen);

  ecp_mpi_load(&grp->B, b, blen);
  ecp_mpi_load(&grp->N, n, nlen);
  ecp_mpi_load(&grp->G.X, gx, gxlen);
  ecp_mpi_load(&grp->G.Y, gy, gylen);
  ecp_mpi_set1(&grp->G.Z);
  grp->pbits=mbedtls_mpi_bitlen(&grp->P);
  grp->nbits=mbedtls_mpi_bitlen(&grp->N);
  grp->h = 1u;
  return 0;
}

// ecp_mod_p256
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp_curves.c line 1066
static signed int ecp_mod_p256(mbedtls_mpi *N)
{
  signed int ret;
  signed char c=0;
  signed char cc;
  uint32_t cur;
  size_t i=0ull;
  size_t bits=256ull;
  mbedtls_mpi C;
  mbedtls_mpi_uint Cp[5ll];
  C.s = 1;
  C.n = (unsigned long long int)(256 / 8) / sizeof(mbedtls_mpi_uint) /*8ull*/  + 1ull;
  C.p = Cp;
  memset((void *)Cp, 0, C.n * sizeof(mbedtls_mpi_uint) /*8ull*/ );
  do
  {
    ret=mbedtls_mpi_grow(N, (unsigned long long int)((256 * 2) / 8) / sizeof(mbedtls_mpi_uint) /*8ull*/ );
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  uint32_t tmp_if_expr;
  if(!(i % 2ull == 0ull))
    tmp_if_expr = (uint32_t)(N->p[(signed long long int)(i / 2ull)] >> 32);

  else
    tmp_if_expr = (uint32_t)N->p[(signed long long int)(i / 2ull)];
  cur = tmp_if_expr;
  uint32_t tmp_if_expr$0;
  tmp_if_expr$0 = (uint32_t)N->p[(signed long long int)(8 / 2)];
  add32(&cur, tmp_if_expr$0, &c);
  uint32_t tmp_if_expr$1;
  tmp_if_expr$1 = (uint32_t)(N->p[(signed long long int)(9 / 2)] >> 32);
  add32(&cur, tmp_if_expr$1, &c);
  uint32_t tmp_if_expr$2;
  tmp_if_expr$2 = (uint32_t)(N->p[(signed long long int)(11 / 2)] >> 32);
  sub32(&cur, tmp_if_expr$2, &c);
  uint32_t tmp_if_expr$3;
  tmp_if_expr$3 = (uint32_t)N->p[(signed long long int)(12 / 2)];
  sub32(&cur, tmp_if_expr$3, &c);
  uint32_t tmp_if_expr$4;
  tmp_if_expr$4 = (uint32_t)(N->p[(signed long long int)(13 / 2)] >> 32);
  sub32(&cur, tmp_if_expr$4, &c);
  uint32_t tmp_if_expr$5;
  tmp_if_expr$5 = (uint32_t)N->p[(signed long long int)(14 / 2)];
  sub32(&cur, tmp_if_expr$5, &c);
  if(!(i % 2ull == 0ull))
  {
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] & 4294967295ull;
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] | (mbedtls_mpi_uint)cur << 32;
  }

  else
  {
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] & 0xFFFFFFFF00000000ull;
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] | (mbedtls_mpi_uint)cur;
  }
  i = i + 1ull;
  uint32_t tmp_if_expr$6;
  if(!(i % 2ull == 0ull))
    tmp_if_expr$6 = (uint32_t)(N->p[(signed long long int)(i / 2ull)] >> 32);

  else
    tmp_if_expr$6 = (uint32_t)N->p[(signed long long int)(i / 2ull)];
  cur = tmp_if_expr$6;
  cc = c;
  c = 0;
  if(!((signed int)cc >= 0))
    sub32(&cur, (uint32_t)-((signed int)cc), &c);

  else
    add32(&cur, (uint32_t)cc, &c);
  uint32_t tmp_if_expr$7;
  tmp_if_expr$7 = (uint32_t)(N->p[(signed long long int)(9 / 2)] >> 32);
  add32(&cur, tmp_if_expr$7, &c);
  uint32_t tmp_if_expr$8;
  tmp_if_expr$8 = (uint32_t)N->p[(signed long long int)(10 / 2)];
  add32(&cur, tmp_if_expr$8, &c);
  uint32_t tmp_if_expr$9;
  tmp_if_expr$9 = (uint32_t)N->p[(signed long long int)(12 / 2)];
  sub32(&cur, tmp_if_expr$9, &c);
  uint32_t tmp_if_expr$10;
  tmp_if_expr$10 = (uint32_t)(N->p[(signed long long int)(13 / 2)] >> 32);
  sub32(&cur, tmp_if_expr$10, &c);
  uint32_t tmp_if_expr$11;
  tmp_if_expr$11 = (uint32_t)N->p[(signed long long int)(14 / 2)];
  sub32(&cur, tmp_if_expr$11, &c);
  uint32_t tmp_if_expr$12;
  tmp_if_expr$12 = (uint32_t)(N->p[(signed long long int)(15 / 2)] >> 32);
  sub32(&cur, tmp_if_expr$12, &c);
  if(!(i % 2ull == 0ull))
  {
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] & 4294967295ull;
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] | (mbedtls_mpi_uint)cur << 32;
  }

  else
  {
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] & 0xFFFFFFFF00000000ull;
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] | (mbedtls_mpi_uint)cur;
  }
  i = i + 1ull;
  uint32_t tmp_if_expr$13;
  if(!(i % 2ull == 0ull))
    tmp_if_expr$13 = (uint32_t)(N->p[(signed long long int)(i / 2ull)] >> 32);

  else
    tmp_if_expr$13 = (uint32_t)N->p[(signed long long int)(i / 2ull)];
  cur = tmp_if_expr$13;
  cc = c;
  c = 0;
  if(!((signed int)cc >= 0))
    sub32(&cur, (uint32_t)-((signed int)cc), &c);

  else
    add32(&cur, (uint32_t)cc, &c);
  uint32_t tmp_if_expr$14;
  tmp_if_expr$14 = (uint32_t)N->p[(signed long long int)(10 / 2)];
  add32(&cur, tmp_if_expr$14, &c);
  uint32_t tmp_if_expr$15;
  tmp_if_expr$15 = (uint32_t)(N->p[(signed long long int)(11 / 2)] >> 32);
  add32(&cur, tmp_if_expr$15, &c);
  uint32_t tmp_if_expr$16;
  tmp_if_expr$16 = (uint32_t)(N->p[(signed long long int)(13 / 2)] >> 32);
  sub32(&cur, tmp_if_expr$16, &c);
  uint32_t tmp_if_expr$17;
  tmp_if_expr$17 = (uint32_t)N->p[(signed long long int)(14 / 2)];
  sub32(&cur, tmp_if_expr$17, &c);
  uint32_t tmp_if_expr$18;
  tmp_if_expr$18 = (uint32_t)(N->p[(signed long long int)(15 / 2)] >> 32);
  sub32(&cur, tmp_if_expr$18, &c);
  if(!(i % 2ull == 0ull))
  {
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] & 4294967295ull;
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] | (mbedtls_mpi_uint)cur << 32;
  }

  else
  {
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] & 0xFFFFFFFF00000000ull;
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] | (mbedtls_mpi_uint)cur;
  }
  i = i + 1ull;
  uint32_t tmp_if_expr$19;
  if(!(i % 2ull == 0ull))
    tmp_if_expr$19 = (uint32_t)(N->p[(signed long long int)(i / 2ull)] >> 32);

  else
    tmp_if_expr$19 = (uint32_t)N->p[(signed long long int)(i / 2ull)];
  cur = tmp_if_expr$19;
  cc = c;
  c = 0;
  if(!((signed int)cc >= 0))
    sub32(&cur, (uint32_t)-((signed int)cc), &c);

  else
    add32(&cur, (uint32_t)cc, &c);
  uint32_t tmp_if_expr$20;
  tmp_if_expr$20 = (uint32_t)(N->p[(signed long long int)(11 / 2)] >> 32);
  add32(&cur, tmp_if_expr$20, &c);
  uint32_t tmp_if_expr$21;
  tmp_if_expr$21 = (uint32_t)(N->p[(signed long long int)(11 / 2)] >> 32);
  add32(&cur, tmp_if_expr$21, &c);
  uint32_t tmp_if_expr$22;
  tmp_if_expr$22 = (uint32_t)N->p[(signed long long int)(12 / 2)];
  add32(&cur, tmp_if_expr$22, &c);
  uint32_t tmp_if_expr$23;
  tmp_if_expr$23 = (uint32_t)N->p[(signed long long int)(12 / 2)];
  add32(&cur, tmp_if_expr$23, &c);
  uint32_t tmp_if_expr$24;
  tmp_if_expr$24 = (uint32_t)(N->p[(signed long long int)(13 / 2)] >> 32);
  add32(&cur, tmp_if_expr$24, &c);
  uint32_t tmp_if_expr$25;
  tmp_if_expr$25 = (uint32_t)(N->p[(signed long long int)(15 / 2)] >> 32);
  sub32(&cur, tmp_if_expr$25, &c);
  uint32_t tmp_if_expr$26;
  tmp_if_expr$26 = (uint32_t)N->p[(signed long long int)(8 / 2)];
  sub32(&cur, tmp_if_expr$26, &c);
  uint32_t tmp_if_expr$27;
  tmp_if_expr$27 = (uint32_t)(N->p[(signed long long int)(9 / 2)] >> 32);
  sub32(&cur, tmp_if_expr$27, &c);
  if(!(i % 2ull == 0ull))
  {
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] & 4294967295ull;
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] | (mbedtls_mpi_uint)cur << 32;
  }

  else
  {
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] & 0xFFFFFFFF00000000ull;
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] | (mbedtls_mpi_uint)cur;
  }
  i = i + 1ull;
  uint32_t tmp_if_expr$28;
  if(!(i % 2ull == 0ull))
    tmp_if_expr$28 = (uint32_t)(N->p[(signed long long int)(i / 2ull)] >> 32);

  else
    tmp_if_expr$28 = (uint32_t)N->p[(signed long long int)(i / 2ull)];
  cur = tmp_if_expr$28;
  cc = c;
  c = 0;
  if(!((signed int)cc >= 0))
    sub32(&cur, (uint32_t)-((signed int)cc), &c);

  else
    add32(&cur, (uint32_t)cc, &c);
  uint32_t tmp_if_expr$29;
  tmp_if_expr$29 = (uint32_t)N->p[(signed long long int)(12 / 2)];
  add32(&cur, tmp_if_expr$29, &c);
  uint32_t tmp_if_expr$30;
  tmp_if_expr$30 = (uint32_t)N->p[(signed long long int)(12 / 2)];
  add32(&cur, tmp_if_expr$30, &c);
  uint32_t tmp_if_expr$31;
  tmp_if_expr$31 = (uint32_t)(N->p[(signed long long int)(13 / 2)] >> 32);
  add32(&cur, tmp_if_expr$31, &c);
  uint32_t tmp_if_expr$32;
  tmp_if_expr$32 = (uint32_t)(N->p[(signed long long int)(13 / 2)] >> 32);
  add32(&cur, tmp_if_expr$32, &c);
  uint32_t tmp_if_expr$33;
  tmp_if_expr$33 = (uint32_t)N->p[(signed long long int)(14 / 2)];
  add32(&cur, tmp_if_expr$33, &c);
  uint32_t tmp_if_expr$34;
  tmp_if_expr$34 = (uint32_t)(N->p[(signed long long int)(9 / 2)] >> 32);
  sub32(&cur, tmp_if_expr$34, &c);
  uint32_t tmp_if_expr$35;
  tmp_if_expr$35 = (uint32_t)N->p[(signed long long int)(10 / 2)];
  sub32(&cur, tmp_if_expr$35, &c);
  if(!(i % 2ull == 0ull))
  {
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] & 4294967295ull;
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] | (mbedtls_mpi_uint)cur << 32;
  }

  else
  {
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] & 0xFFFFFFFF00000000ull;
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] | (mbedtls_mpi_uint)cur;
  }
  i = i + 1ull;
  uint32_t tmp_if_expr$36;
  if(!(i % 2ull == 0ull))
    tmp_if_expr$36 = (uint32_t)(N->p[(signed long long int)(i / 2ull)] >> 32);

  else
    tmp_if_expr$36 = (uint32_t)N->p[(signed long long int)(i / 2ull)];
  cur = tmp_if_expr$36;
  cc = c;
  c = 0;
  if(!((signed int)cc >= 0))
    sub32(&cur, (uint32_t)-((signed int)cc), &c);

  else
    add32(&cur, (uint32_t)cc, &c);
  uint32_t tmp_if_expr$37;
  tmp_if_expr$37 = (uint32_t)(N->p[(signed long long int)(13 / 2)] >> 32);
  add32(&cur, tmp_if_expr$37, &c);
  uint32_t tmp_if_expr$38;
  tmp_if_expr$38 = (uint32_t)(N->p[(signed long long int)(13 / 2)] >> 32);
  add32(&cur, tmp_if_expr$38, &c);
  uint32_t tmp_if_expr$39;
  tmp_if_expr$39 = (uint32_t)N->p[(signed long long int)(14 / 2)];
  add32(&cur, tmp_if_expr$39, &c);
  uint32_t tmp_if_expr$40;
  tmp_if_expr$40 = (uint32_t)N->p[(signed long long int)(14 / 2)];
  add32(&cur, tmp_if_expr$40, &c);
  uint32_t tmp_if_expr$41;
  tmp_if_expr$41 = (uint32_t)(N->p[(signed long long int)(15 / 2)] >> 32);
  add32(&cur, tmp_if_expr$41, &c);
  uint32_t tmp_if_expr$42;
  tmp_if_expr$42 = (uint32_t)N->p[(signed long long int)(10 / 2)];
  sub32(&cur, tmp_if_expr$42, &c);
  uint32_t tmp_if_expr$43;
  tmp_if_expr$43 = (uint32_t)(N->p[(signed long long int)(11 / 2)] >> 32);
  sub32(&cur, tmp_if_expr$43, &c);
  if(!(i % 2ull == 0ull))
  {
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] & 4294967295ull;
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] | (mbedtls_mpi_uint)cur << 32;
  }

  else
  {
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] & 0xFFFFFFFF00000000ull;
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] | (mbedtls_mpi_uint)cur;
  }
  i = i + 1ull;
  uint32_t tmp_if_expr$44;
  if(!(i % 2ull == 0ull))
    tmp_if_expr$44 = (uint32_t)(N->p[(signed long long int)(i / 2ull)] >> 32);

  else
    tmp_if_expr$44 = (uint32_t)N->p[(signed long long int)(i / 2ull)];
  cur = tmp_if_expr$44;
  cc = c;
  c = 0;
  if(!((signed int)cc >= 0))
    sub32(&cur, (uint32_t)-((signed int)cc), &c);

  else
    add32(&cur, (uint32_t)cc, &c);
  uint32_t tmp_if_expr$45;
  tmp_if_expr$45 = (uint32_t)N->p[(signed long long int)(14 / 2)];
  add32(&cur, tmp_if_expr$45, &c);
  uint32_t tmp_if_expr$46;
  tmp_if_expr$46 = (uint32_t)N->p[(signed long long int)(14 / 2)];
  add32(&cur, tmp_if_expr$46, &c);
  uint32_t tmp_if_expr$47;
  tmp_if_expr$47 = (uint32_t)(N->p[(signed long long int)(15 / 2)] >> 32);
  add32(&cur, tmp_if_expr$47, &c);
  uint32_t tmp_if_expr$48;
  tmp_if_expr$48 = (uint32_t)(N->p[(signed long long int)(15 / 2)] >> 32);
  add32(&cur, tmp_if_expr$48, &c);
  uint32_t tmp_if_expr$49;
  tmp_if_expr$49 = (uint32_t)N->p[(signed long long int)(14 / 2)];
  add32(&cur, tmp_if_expr$49, &c);
  uint32_t tmp_if_expr$50;
  tmp_if_expr$50 = (uint32_t)(N->p[(signed long long int)(13 / 2)] >> 32);
  add32(&cur, tmp_if_expr$50, &c);
  uint32_t tmp_if_expr$51;
  tmp_if_expr$51 = (uint32_t)N->p[(signed long long int)(8 / 2)];
  sub32(&cur, tmp_if_expr$51, &c);
  uint32_t tmp_if_expr$52;
  tmp_if_expr$52 = (uint32_t)(N->p[(signed long long int)(9 / 2)] >> 32);
  sub32(&cur, tmp_if_expr$52, &c);
  if(!(i % 2ull == 0ull))
  {
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] & 4294967295ull;
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] | (mbedtls_mpi_uint)cur << 32;
  }

  else
  {
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] & 0xFFFFFFFF00000000ull;
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] | (mbedtls_mpi_uint)cur;
  }
  i = i + 1ull;
  uint32_t tmp_if_expr$53;
  if(!(i % 2ull == 0ull))
    tmp_if_expr$53 = (uint32_t)(N->p[(signed long long int)(i / 2ull)] >> 32);

  else
    tmp_if_expr$53 = (uint32_t)N->p[(signed long long int)(i / 2ull)];
  cur = tmp_if_expr$53;
  cc = c;
  c = 0;
  if(!((signed int)cc >= 0))
    sub32(&cur, (uint32_t)-((signed int)cc), &c);

  else
    add32(&cur, (uint32_t)cc, &c);
  uint32_t tmp_if_expr$54;
  tmp_if_expr$54 = (uint32_t)(N->p[(signed long long int)(15 / 2)] >> 32);
  add32(&cur, tmp_if_expr$54, &c);
  uint32_t tmp_if_expr$55;
  tmp_if_expr$55 = (uint32_t)(N->p[(signed long long int)(15 / 2)] >> 32);
  add32(&cur, tmp_if_expr$55, &c);
  uint32_t tmp_if_expr$56;
  tmp_if_expr$56 = (uint32_t)(N->p[(signed long long int)(15 / 2)] >> 32);
  add32(&cur, tmp_if_expr$56, &c);
  uint32_t tmp_if_expr$57;
  tmp_if_expr$57 = (uint32_t)N->p[(signed long long int)(8 / 2)];
  add32(&cur, tmp_if_expr$57, &c);
  uint32_t tmp_if_expr$58;
  tmp_if_expr$58 = (uint32_t)N->p[(signed long long int)(10 / 2)];
  sub32(&cur, tmp_if_expr$58, &c);
  uint32_t tmp_if_expr$59;
  tmp_if_expr$59 = (uint32_t)(N->p[(signed long long int)(11 / 2)] >> 32);
  sub32(&cur, tmp_if_expr$59, &c);
  uint32_t tmp_if_expr$60;
  tmp_if_expr$60 = (uint32_t)N->p[(signed long long int)(12 / 2)];
  sub32(&cur, tmp_if_expr$60, &c);
  uint32_t tmp_if_expr$61;
  tmp_if_expr$61 = (uint32_t)(N->p[(signed long long int)(13 / 2)] >> 32);
  sub32(&cur, tmp_if_expr$61, &c);
  if(!(i % 2ull == 0ull))
  {
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] & 4294967295ull;
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] | (mbedtls_mpi_uint)cur << 32;
  }

  else
  {
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] & 0xFFFFFFFF00000000ull;
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] | (mbedtls_mpi_uint)cur;
  }
  i = i + 1ull;
  cur = (uint32_t)((signed int)c > 0 ? (signed int)c : 0);
  if(!(i % 2ull == 0ull))
  {
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] & 4294967295ull;
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] | (mbedtls_mpi_uint)cur << 32;
  }

  else
  {
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] & 0xFFFFFFFF00000000ull;
    N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] | (mbedtls_mpi_uint)cur;
  }
  cur = 0u;
  do
  {
    i = i + 1ull;
    if(i >= 2ull * N->n)
      break;

    if(!(i % 2ull == 0ull))
    {
      N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] & 4294967295ull;
      N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] | (mbedtls_mpi_uint)cur << 32;
    }

    else
    {
      N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] & 0xFFFFFFFF00000000ull;
      N->p[(signed long long int)(i / 2ull)] = N->p[(signed long long int)(i / 2ull)] | (mbedtls_mpi_uint)cur;
    }
  }
  while((_Bool)1);
  if(!((signed int)c >= 0))
    fix_negative(N, c, &C, bits);


cleanup:
  ;
  return ret;
}

// ecp_modp
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 670
static signed int ecp_modp(mbedtls_mpi *N, const mbedtls_ecp_group *grp)
{
  signed int ret;
  signed int return_value_mbedtls_mpi_mod_mpi;
  signed int return_value_mbedtls_mpi_cmp_int;
  size_t return_value_mbedtls_mpi_bitlen;
  signed int return_value_mbedtls_mpi_cmp_int$0;
  signed int return_value_mbedtls_mpi_cmp_mpi;
  if(grp->modp == ((signed int (*)(mbedtls_mpi *))NULL))
  {
    return_value_mbedtls_mpi_mod_mpi=mbedtls_mpi_mod_mpi(N, N, &grp->P);
    return return_value_mbedtls_mpi_mod_mpi;
  }

  else
  {
    _Bool tmp_if_expr;
    if(!(N->s >= 0))
    {
      return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(N, 0ll);
      tmp_if_expr = return_value_mbedtls_mpi_cmp_int != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr = (_Bool)0;
    _Bool tmp_if_expr$0;
    if(tmp_if_expr)
      tmp_if_expr$0 = (_Bool)1;

    else
    {
      return_value_mbedtls_mpi_bitlen=mbedtls_mpi_bitlen(N);
      tmp_if_expr$0 = return_value_mbedtls_mpi_bitlen > 2ull * grp->pbits ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$0)
      return -0x4F80;

    else
    {
      ret=grp->modp(N);
      if(ret == 0)
      {
        if(!(N->s >= 0))
        {
          return_value_mbedtls_mpi_cmp_int$0=mbedtls_mpi_cmp_int(N, 0ll);
          if(!(return_value_mbedtls_mpi_cmp_int$0 == 0))
            ret=mbedtls_mpi_add_mpi(N, N, &grp->P);

        }

        return_value_mbedtls_mpi_cmp_mpi=mbedtls_mpi_cmp_mpi(N, &grp->P);
        if(return_value_mbedtls_mpi_cmp_mpi >= 0)
          ret=mbedtls_mpi_sub_abs(N, N, &grp->P);

      }


    cleanup:
      ;
      return ret;
    }
  }
}

// ecp_mpi_load
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp_curves.c line 556
static inline void ecp_mpi_load(mbedtls_mpi *X, const mbedtls_mpi_uint *p, size_t len)
{
  X->s = 1;
  X->n = len / sizeof(mbedtls_mpi_uint) /*8ull*/ ;
  X->p = (mbedtls_mpi_uint *)p;
}

// ecp_mpi_set1
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp_curves.c line 566
static inline void ecp_mpi_set1(mbedtls_mpi *X)
{
  X->s = 1;
  X->n = 1ull;
  static mbedtls_mpi_uint one[1ll]={ 1ull };
  X->p = one;
}

// ecp_mul_comb
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 1353
static signed int ecp_mul_comb(mbedtls_ecp_group *grp, mbedtls_ecp_point *R, const mbedtls_mpi *m, const mbedtls_ecp_point *P, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
  signed int ret;
  unsigned char w;
  unsigned char m_is_odd;
  unsigned char p_eq_g;
  unsigned char pre_len;
  unsigned char i;
  size_t d;
  unsigned char k[262ll];
  mbedtls_ecp_point *T;
  mbedtls_mpi M;
  mbedtls_mpi mm;
  mbedtls_mpi_init(&M);
  mbedtls_mpi_init(&mm);
  signed int return_value_mbedtls_mpi_get_bit=mbedtls_mpi_get_bit(&grp->N, 0ull);
  signed int return_value_mbedtls_mpi_cmp_mpi$0;
  if(!(return_value_mbedtls_mpi_get_bit == 1))
    return -0x4F80;

  else
  {
    w = (unsigned char)(grp->nbits >= 384ull ? 5 : 4);
    signed int return_value_mbedtls_mpi_cmp_mpi=mbedtls_mpi_cmp_mpi(&P->Y, &grp->G.Y);
    _Bool tmp_if_expr;
    if(return_value_mbedtls_mpi_cmp_mpi == 0)
    {
      return_value_mbedtls_mpi_cmp_mpi$0=mbedtls_mpi_cmp_mpi(&P->X, &grp->G.X);
      tmp_if_expr = return_value_mbedtls_mpi_cmp_mpi$0 == 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr = (_Bool)0;
    p_eq_g = (unsigned char)tmp_if_expr;
    if(!(p_eq_g == 0))
      w = w + 1;

    if((signed int)w >= 7)
      w = 6;

    if((unsigned long long int)w >= grp->nbits)
      w = 2;

    pre_len = (unsigned char)(1u << (signed int)w - 1);
    d = ((grp->nbits + (unsigned long long int)w) - 1ull) / (unsigned long long int)w;
    mbedtls_ecp_point *tmp_if_expr$0;
    if(!(p_eq_g == 0))
      tmp_if_expr$0 = grp->T;

    else
      tmp_if_expr$0 = ((mbedtls_ecp_point *)NULL);
    T = tmp_if_expr$0;
    if(T == ((mbedtls_ecp_point *)NULL))
    {
      void *return_value=mbedtls_calloc((size_t)pre_len, sizeof(mbedtls_ecp_point) /*72ull*/ );
      T = (mbedtls_ecp_point *)return_value;
      if(T == ((mbedtls_ecp_point *)NULL))
        ret = -0x4D80;

      ret=ecp_precompute_comb(grp, T, P, w, d);
      if(!(p_eq_g == 0))
      {
        grp->T = T;
        grp->T_size = (size_t)pre_len;
      }

    }

    signed int return_value_mbedtls_mpi_get_bit$0=mbedtls_mpi_get_bit(m, 0ull);
    m_is_odd = (unsigned char)(return_value_mbedtls_mpi_get_bit$0 == 1);
    do
    {
      ret=mbedtls_mpi_copy(&M, m);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_sub_mpi(&mm, &grp->N, m);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_safe_cond_assign(&M, &mm, (unsigned char)!(m_is_odd != 0));
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    ecp_comb_fixed(k, d, w, &M);
    do
    {
      ret=ecp_mul_comb_core(grp, R, T, pre_len, k, d, f_rng, p_rng);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=ecp_safe_invert_jac(grp, R, (unsigned char)!(m_is_odd != 0));
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=ecp_normalize_jac(grp, R);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);

  cleanup:
    ;
    if(p_eq_g == 0 && !(T == ((mbedtls_ecp_point *)NULL)))
    {
      i = 0;
      for( ; !((signed int)i >= (signed int)pre_len); i = i + 1)
        mbedtls_ecp_point_free(&T[(signed long long int)i]);
      mbedtls_free((void *)T);
    }

    mbedtls_mpi_free(&M);
    mbedtls_mpi_free(&mm);
    if(!(ret == 0))
      mbedtls_ecp_point_free(R);

    return ret;
  }
}

// ecp_mul_comb_core
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 1316
static signed int ecp_mul_comb_core(const mbedtls_ecp_group *grp, mbedtls_ecp_point *R, const mbedtls_ecp_point *T, unsigned char t_len, const unsigned char *x, size_t d, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
  signed int ret;
  mbedtls_ecp_point Txi;
  size_t i;
  mbedtls_ecp_point_init(&Txi);
  i = d;
  do
  {
    ret=ecp_select_comb(grp, R, T, t_len, x[(signed long long int)i]);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_lset(&R->Z, 1ll);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  if(!(f_rng == ((signed int (*)(void *, unsigned char *, size_t))NULL)))
    do
    {
      ret=ecp_randomize_jac(grp, R, f_rng, p_rng);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);

  size_t tmp_post;
  do
  {
    tmp_post = i;
    i = i - 1ull;
    if(tmp_post == 0ull)
      break;

    do
    {
      ret=ecp_double_jac(grp, R, R);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=ecp_select_comb(grp, &Txi, T, t_len, x[(signed long long int)i]);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=ecp_add_mixed(grp, R, R, &Txi);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
  }
  while((_Bool)1);

cleanup:
  ;
  mbedtls_ecp_point_free(&Txi);
  return ret;
}

// ecp_normalize_jac
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 750
static signed int ecp_normalize_jac(const mbedtls_ecp_group *grp, mbedtls_ecp_point *ecp_normalize_jac$$pt)
{
  signed int ret;
  mbedtls_mpi Zi;
  mbedtls_mpi ZZi;
  signed int return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(&ecp_normalize_jac$$pt->Z, 0ll);
  if(return_value_mbedtls_mpi_cmp_int == 0)
    return 0;

  else
  {
    mbedtls_mpi_init(&Zi);
    mbedtls_mpi_init(&ZZi);
    do
    {
      ret=mbedtls_mpi_inv_mod(&Zi, &ecp_normalize_jac$$pt->Z, &grp->P);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_mul_mpi(&ZZi, &Zi, &Zi);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L4:
      ;
      ret=ecp_modp(&ZZi, grp);
      if(!(ret == 0))
        goto cleanup;

      mul_count = mul_count + 1ul;
    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_mul_mpi(&ecp_normalize_jac$$pt->X, &ecp_normalize_jac$$pt->X, &ZZi);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L6:
      ;
      ret=ecp_modp(&ecp_normalize_jac$$pt->X, grp);
      if(!(ret == 0))
        goto cleanup;

      mul_count = mul_count + 1ul;
    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_mul_mpi(&ecp_normalize_jac$$pt->Y, &ecp_normalize_jac$$pt->Y, &ZZi);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L8:
      ;
      ret=ecp_modp(&ecp_normalize_jac$$pt->Y, grp);
      if(!(ret == 0))
        goto cleanup;

      mul_count = mul_count + 1ul;
    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_mul_mpi(&ecp_normalize_jac$$pt->Y, &ecp_normalize_jac$$pt->Y, &Zi);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L10:
      ;
      ret=ecp_modp(&ecp_normalize_jac$$pt->Y, grp);
      if(!(ret == 0))
        goto cleanup;

      mul_count = mul_count + 1ul;
    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_lset(&ecp_normalize_jac$$pt->Z, 1ll);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);

  cleanup:
    ;
    mbedtls_mpi_free(&Zi);
    mbedtls_mpi_free(&ZZi);
    return ret;
  }
}

// ecp_normalize_jac_many
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 802
static signed int ecp_normalize_jac_many(const mbedtls_ecp_group *grp, mbedtls_ecp_point **T, size_t t_len)
{
  signed int ret;
  size_t i;
  mbedtls_mpi *c;
  mbedtls_mpi u;
  mbedtls_mpi Zi;
  mbedtls_mpi ZZi;
  signed int return_value_ecp_normalize_jac;
  if(!(t_len >= 2ull))
  {
    return_value_ecp_normalize_jac=ecp_normalize_jac(grp, *T);
    return return_value_ecp_normalize_jac;
  }

  else
  {
    void *return_value=mbedtls_calloc(t_len, sizeof(mbedtls_mpi) /*24ull*/ );
    c = (mbedtls_mpi *)return_value;
    if(c == ((mbedtls_mpi *)NULL))
      return -0x4D80;

    else
    {
      mbedtls_mpi_init(&u);
      mbedtls_mpi_init(&Zi);
      mbedtls_mpi_init(&ZZi);
      ret=mbedtls_mpi_copy(&c[0ll], &T[0ll]->Z);
      if(ret == 0)
      {
        i = 1ull;
        if(!(i >= t_len))
        {
          ret=mbedtls_mpi_mul_mpi(&c[(signed long long int)i], &c[(signed long long int)(i - 1ull)], &T[(signed long long int)i]->Z);
          ret=ecp_modp(&c[(signed long long int)i], grp);
          mul_count = mul_count + 1ul;
          i = i + 1ull;
        }

        ret=mbedtls_mpi_inv_mod(&u, &c[(signed long long int)(t_len - 1ull)], &grp->P);
        if(ret == 0)
        {
          i = t_len - 1ull;
          if(i == 0ull)
            ret=mbedtls_mpi_copy(&Zi, &u);

          else
          {
            ret=mbedtls_mpi_mul_mpi(&Zi, &u, &c[(signed long long int)(i - 1ull)]);
            ret=ecp_modp(&Zi, grp);
            mul_count = mul_count + 1ul;
            ret=mbedtls_mpi_mul_mpi(&u, &u, &T[(signed long long int)i]->Z);
            ret=ecp_modp(&u, grp);
            mul_count = mul_count + 1ul;
          }
          ret=mbedtls_mpi_mul_mpi(&ZZi, &Zi, &Zi);
          ret=ecp_modp(&ZZi, grp);
          mul_count = mul_count + 1ul;
          ret=mbedtls_mpi_mul_mpi(&T[(signed long long int)i]->X, &T[(signed long long int)i]->X, &ZZi);
          ret=ecp_modp(&T[(signed long long int)i]->X, grp);
          mul_count = mul_count + 1ul;
          ret=mbedtls_mpi_mul_mpi(&T[(signed long long int)i]->Y, &T[(signed long long int)i]->Y, &ZZi);
          ret=ecp_modp(&T[(signed long long int)i]->Y, grp);
          mul_count = mul_count + 1ul;
          ret=mbedtls_mpi_mul_mpi(&T[(signed long long int)i]->Y, &T[(signed long long int)i]->Y, &Zi);
          ret=ecp_modp(&T[(signed long long int)i]->Y, grp);
          mul_count = mul_count + 1ul;
          ret=mbedtls_mpi_shrink(&T[(signed long long int)i]->X, grp->P.n);
          ret=mbedtls_mpi_shrink(&T[(signed long long int)i]->Y, grp->P.n);
          mbedtls_mpi_free(&T[(signed long long int)i]->Z);
          if(!(i == 0ull))
            i = i - 1ull;

        }

      }


    cleanup:
      ;
      mbedtls_mpi_free(&u);
      mbedtls_mpi_free(&Zi);
      mbedtls_mpi_free(&ZZi);
      i = 0ull;
      if(!(i >= t_len))
      {
        mbedtls_mpi_free(&c[(signed long long int)i]);
        i = i + 1ull;
      }

      mbedtls_free((void *)c);
      return ret;
    }
  }
}

// ecp_precompute_comb
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 1233
static signed int ecp_precompute_comb(const mbedtls_ecp_group *grp, mbedtls_ecp_point *T, const mbedtls_ecp_point *P, unsigned char w, size_t d)
{
  signed int ret;
  unsigned char i;
  unsigned char k;
  size_t j;
  mbedtls_ecp_point *cur;
  mbedtls_ecp_point *TT[31ll];
  do
  {
    ret=mbedtls_ecp_copy(&T[0ll], P);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  k = 0;
  i = 1;
  for( ; !((unsigned int)i >= 1u << -1 + (signed int)w); i = i << 1)
  {
    cur = T + (signed long long int)i;
    do
    {
      ret=mbedtls_ecp_copy(cur, T + (signed long long int)((signed int)i >> 1));
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    j = 0ull;
    for( ; !(j >= d); j = j + 1ull)
      do
      {
        ret=ecp_double_jac(grp, cur, cur);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
    unsigned char tmp_post=k;
    k = k + 1;
    TT[(signed long long int)tmp_post] = cur;
  }
  do
  {
    ret=ecp_normalize_jac_many(grp, TT, (size_t)k);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  k = 0;
  i = 1;
  size_t tmp_post$0;
  for( ; !((unsigned int)i >= 1u << -1 + (signed int)w); i = i << 1)
  {
    j = (size_t)i;
    do
    {
      tmp_post$0 = j;
      j = j - 1ull;
      if(tmp_post$0 == 0ull)
        break;

      do
      {
        ret=ecp_add_mixed(grp, &T[(signed long long int)((unsigned long long int)i + j)], &T[(signed long long int)j], &T[(signed long long int)i]);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      unsigned char tmp_post$1=k;
      k = k + 1;
      TT[(signed long long int)tmp_post$1] = &T[(signed long long int)((unsigned long long int)i + j)];
    }
    while((_Bool)1);
  }
  do
  {
    ret=ecp_normalize_jac_many(grp, TT, (size_t)k);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);

cleanup:
  ;
  return ret;
}

// ecp_randomize_jac
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 1112
static signed int ecp_randomize_jac(const mbedtls_ecp_group *grp, mbedtls_ecp_point *ecp_randomize_jac$$pt, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
  signed int ret;
  mbedtls_mpi l;
  mbedtls_mpi ll;
  size_t p_size;
  signed int count=0;
  p_size = (grp->pbits + 7ull) / 8ull;
  mbedtls_mpi_init(&l);
  mbedtls_mpi_init(&ll);
  signed int return_value_mbedtls_mpi_cmp_mpi;
  signed int return_value_mbedtls_mpi_cmp_int;
  do
  {

  __CPROVER_DUMP_L1:
    ;
    ret=mbedtls_mpi_fill_random(&l, p_size, f_rng, p_rng);
    if(!(ret == 0))
      goto cleanup;

    do
    {
      return_value_mbedtls_mpi_cmp_mpi=mbedtls_mpi_cmp_mpi(&l, &grp->P);
      if(!(return_value_mbedtls_mpi_cmp_mpi >= 0))
        break;

      do
      {
        ret=mbedtls_mpi_shift_r(&l, 1ull);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
    }
    while((_Bool)1);
    signed int tmp_post=count;
    count = count + 1;
    if(tmp_post >= 11)
      return -0x4D00;

    return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(&l, 1ll);
  }
  while(!(return_value_mbedtls_mpi_cmp_int >= 1));
  do
  {
    ret=mbedtls_mpi_mul_mpi(&ecp_randomize_jac$$pt->Z, &ecp_randomize_jac$$pt->Z, &l);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {

  __CPROVER_DUMP_L8:
    ;
    ret=ecp_modp(&ecp_randomize_jac$$pt->Z, grp);
    if(!(ret == 0))
      goto cleanup;

    mul_count = mul_count + 1ul;
  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_mul_mpi(&ll, &l, &l);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {

  __CPROVER_DUMP_L10:
    ;
    ret=ecp_modp(&ll, grp);
    if(!(ret == 0))
      goto cleanup;

    mul_count = mul_count + 1ul;
  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_mul_mpi(&ecp_randomize_jac$$pt->X, &ecp_randomize_jac$$pt->X, &ll);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {

  __CPROVER_DUMP_L12:
    ;
    ret=ecp_modp(&ecp_randomize_jac$$pt->X, grp);
    if(!(ret == 0))
      goto cleanup;

    mul_count = mul_count + 1ul;
  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_mul_mpi(&ll, &ll, &l);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {

  __CPROVER_DUMP_L14:
    ;
    ret=ecp_modp(&ll, grp);
    if(!(ret == 0))
      goto cleanup;

    mul_count = mul_count + 1ul;
  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_mul_mpi(&ecp_randomize_jac$$pt->Y, &ecp_randomize_jac$$pt->Y, &ll);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {

  __CPROVER_DUMP_L16:
    ;
    ret=ecp_modp(&ecp_randomize_jac$$pt->Y, grp);
    if(!(ret == 0))
      goto cleanup;

    mul_count = mul_count + 1ul;
  }
  while((_Bool)0);

cleanup:
  ;
  mbedtls_mpi_free(&l);
  mbedtls_mpi_free(&ll);
  return ret;
}

// ecp_safe_invert_jac
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 890
static signed int ecp_safe_invert_jac(const mbedtls_ecp_group *grp, mbedtls_ecp_point *Q, unsigned char inv)
{
  signed int ret;
  unsigned char nonzero;
  mbedtls_mpi mQY;
  mbedtls_mpi_init(&mQY);
  do
  {
    ret=mbedtls_mpi_sub_mpi(&mQY, &grp->P, &Q->Y);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  signed int return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(&Q->Y, 0ll);
  nonzero = (unsigned char)(return_value_mbedtls_mpi_cmp_int != 0);
  do
  {
    ret=mbedtls_mpi_safe_cond_assign(&Q->Y, &mQY, (unsigned char)((signed int)inv & (signed int)nonzero));
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);

cleanup:
  ;
  mbedtls_mpi_free(&mQY);
  return ret;
}

// ecp_select_comb
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 1286
static signed int ecp_select_comb(const mbedtls_ecp_group *grp, mbedtls_ecp_point *R, const mbedtls_ecp_point *T, unsigned char t_len, unsigned char i)
{
  signed int ret;
  unsigned char ii;
  unsigned char j;
  ii = (unsigned char)(((unsigned int)i & 0x7Fu) >> 1);
  j = 0;
  for( ; !((signed int)j >= (signed int)t_len); j = j + 1)
  {
    do
    {
      ret=mbedtls_mpi_safe_cond_assign(&R->X, &(T + (signed long long int)j)->X, (unsigned char)(j == ii));
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_safe_cond_assign(&R->Y, &(T + (signed long long int)j)->Y, (unsigned char)(j == ii));
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
  }
  do
  {
    ret=ecp_safe_invert_jac(grp, R, (unsigned char)((signed int)i >> 7));
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);

cleanup:
  ;
  return ret;
}

// encode_number
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 307
static inline CborError encode_number(CborEncoder *encoder, uint64_t ui, uint8_t shiftedMajorType)
{
  encoder->added = encoder->added + 1ull;
  CborError return_value_encode_number_no_update=encode_number_no_update(encoder, ui, shiftedMajorType);
  return return_value_encode_number_no_update;
}

// encode_number_no_update
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 278
static inline CborError encode_number_no_update(CborEncoder *encoder, uint64_t ui, uint8_t shiftedMajorType)
{
  uint64_t buf[2ll];
  uint8_t * const bufend=(uint8_t *)buf + (signed long long int)sizeof(uint64_t [2ll]) /*16ll*/ ;
  uint8_t *bufstart=bufend - 1ll;
  put64((void *)(buf + 1ll), ui);
  if(!(ui >= 24ull))
    *bufstart = *bufstart + shiftedMajorType;

  else
  {
    uint8_t more=0;
    if(ui >= 256ull)
      more = more + 1;

    if(ui >= 65536ull)
      more = more + 1;

    if(ui >= 4294967296ull)
      more = more + 1;

    bufstart = bufstart - (signed long long int)(1ull << (signed int)more);
    *bufstart = (uint8_t)((signed int)shiftedMajorType + 24 + (signed int)more);
  }
  CborError return_value_append_to_buffer=append_to_buffer(encoder, (const void *)bufstart, (size_t)(bufend - bufstart));
  return return_value_append_to_buffer;
}

// encode_string
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 406
static CborError encode_string(CborEncoder *encoder, size_t length, uint8_t shiftedMajorType, const void *string)
{
  CborError err=encode_number(encoder, length, shiftedMajorType);
  _Bool return_value_isOomError;
  if(!(err == /*enum*/CborNoError))
  {
    return_value_isOomError=isOomError(err);
    if(return_value_isOomError == (_Bool)0)
      return err;

  }

  CborError return_value_append_to_buffer=append_to_buffer(encoder, string, length);
  return return_value_append_to_buffer;
}

// entropy_dummy_source
// file ..\..\..\..\lib\third_party\mbedtls\library\entropy.c line 533
static signed int entropy_dummy_source(void *data, unsigned char *output, size_t len, size_t *olen)
{
  (void)data;
  memset((void *)output, 0x2A, len);
  *olen = len;
  return 0;
}

// entropy_gather_internal
// file ..\..\..\..\lib\third_party\mbedtls\library\entropy.c line 263
static signed int entropy_gather_internal(mbedtls_entropy_context *ctx)
{
  signed int ret;
  signed int i;
  signed int have_one_strong=0;
  unsigned char buf[128ll];
  size_t olen;
  if(ctx->source_count == 0)
    return -0x40;

  else
  {
    i = 0;
    if(!(i >= ctx->source_count))
    {
      if(ctx->source[(signed long long int)i].strong == 1)
        have_one_strong = 1;

      olen = 0ull;
      ret=ctx->source[(signed long long int)i].f_source(ctx->source[(signed long long int)i].p_source, buf, 128ull, &olen);
      if(olen >= 1ull)
      {
        ret=entropy_update(ctx, (unsigned char)i, buf, olen);
        if(!(ret == 0))
          return ret;

        ctx->source[(signed long long int)i].size = ctx->source[(signed long long int)i].size + olen;
      }

      i = i + 1;
    }

    if(have_one_strong == 0)
      ret = -0x3D;


  cleanup:
    ;
    mbedtls_zeroize$link6((void *)buf, sizeof(unsigned char [128ll]) /*128ull*/ );
    return ret;
  }
}

// entropy_update
// file ..\..\..\..\lib\third_party\mbedtls\library\entropy.c line 184
static signed int entropy_update(mbedtls_entropy_context *ctx, unsigned char source_id, const unsigned char *data, size_t len)
{
  unsigned char header[2ll];
  unsigned char tmp[32ll];
  size_t use_len=len;
  const unsigned char *p=data;
  signed int ret=0;
  if(use_len >= 33ull)
  {
    ret=mbedtls_sha256_ret(data, len, tmp, 0);
    if(!(ret == 0))
      goto cleanup;

    p = tmp;
    use_len = 32ull;
  }

  header[0ll] = source_id;
  header[1ll] = (unsigned char)(use_len & 255ull);
  _Bool tmp_if_expr;
  if(ctx->accumulator_started == 0)
  {
    ret=mbedtls_sha256_starts_ret(&ctx->accumulator, 0);
    tmp_if_expr = ret != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr = (_Bool)0;
  if(tmp_if_expr)
    goto cleanup;

  else
    ctx->accumulator_started = 1;
  ret=mbedtls_sha256_update_ret(&ctx->accumulator, header, 2ull);
  if(ret == 0)
    ret=mbedtls_sha256_update_ret(&ctx->accumulator, p, use_len);


cleanup:
  ;
  mbedtls_zeroize$link6((void *)tmp, sizeof(unsigned char [32ll]) /*32ull*/ );
  return ret;
}

// expl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 819
/*inline double expl(double _X)*/
/*{*/
  /*double return_value_exp=exp((double)_X);*/
  /*return return_value_exp;*/
/*}*/

// extract_length
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 149
static CborError extract_length(const CborParser *parser, const uint8_t **ptr, size_t *len)
{
  uint64_t v;
  CborError err=extract_number$link1(ptr, parser->end, &v);
  if(!(err == /*enum*/CborNoError))
  {
    *len = 0ull;
    return err;
  }

  else
  {
    *len = (size_t)v;
    if(!(v == *len))
      return /*enum*/CborErrorDataTooLarge;

    else
      return /*enum*/CborNoError;
  }
}

// extract_number
// file d:\tuttle\freertos\lib\third_party\tinycbor\extract_number_p.h line 53
static CborError extract_number(const uint8_t **ptr, const uint8_t *end, uint64_t *len)
{
  uint8_t additional_information=(uint8_t)((signed int)*(*ptr) & 31);
  *ptr = *ptr + 1ll;
  if(!((signed int)additional_information >= 24))
  {
    *len = (uint64_t)additional_information;
    return /*enum*/CborNoError;
  }

  else
    if((signed int)additional_information >= 28)
      return /*enum*/CborErrorIllegalNumber;

    else
    {
      size_t bytesNeeded=(size_t)(1 << (signed int)additional_information - 24);
      if(!((size_t)(end - *ptr) >= bytesNeeded))
        return /*enum*/CborErrorUnexpectedEOF;

      else
        if(bytesNeeded == 1ull)
          *len = (uint64_t)(uint8_t)(*ptr)[0ll];

        else
          if(bytesNeeded == 2ull)
          {
            uint16_t return_value_get16=get16(*ptr);
            *len = (uint64_t)return_value_get16;
          }

          else
            if(bytesNeeded == 4ull)
            {
              uint32_t return_value_get32=get32(*ptr);
              *len = (uint64_t)return_value_get32;
            }

            else
              *len=get64(*ptr);
      *ptr = *ptr + (signed long long int)bytesNeeded;
      return /*enum*/CborNoError;
    }
}

// extract_number$link1
// file d:\tuttle\freertos\lib\third_party\tinycbor\extract_number_p.h line 53
static CborError extract_number$link1(const uint8_t **ptr$link1, const uint8_t *end$link1, uint64_t *len$link1)
{
  uint8_t additional_information$link1=(uint8_t)((signed int)*(*ptr$link1) & 31);
  *ptr$link1 = *ptr$link1 + 1ll;
  if(!((signed int)additional_information$link1 >= 24))
  {
    *len$link1 = (uint64_t)additional_information$link1;
    return /*enum*/CborNoError;
  }

  else
    if((signed int)additional_information$link1 >= 28)
      return /*enum*/CborErrorIllegalNumber;

    else
    {
      size_t bytesNeeded$link1=(size_t)(1 << (signed int)additional_information$link1 - 24);
      if(!((size_t)(end$link1 - *ptr$link1) >= bytesNeeded$link1))
        return /*enum*/CborErrorUnexpectedEOF;

      else
        if(bytesNeeded$link1 == 1ull)
          *len$link1 = (uint64_t)(uint8_t)(*ptr$link1)[0ll];

        else
          if(bytesNeeded$link1 == 2ull)
          {
            uint16_t return_value_get16$link1=get16$link1(*ptr$link1);
            *len$link1 = (uint64_t)return_value_get16$link1;
          }

          else
            if(bytesNeeded$link1 == 4ull)
            {
              uint32_t return_value_get32$link1=get32$link1(*ptr$link1);
              *len$link1 = (uint64_t)return_value_get32$link1;
            }

            else
              *len$link1=get64$link1(*ptr$link1);
      *ptr$link1 = *ptr$link1 + (signed long long int)bytesNeeded$link1;
      return /*enum*/CborNoError;
    }
}

// fabsf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 656
inline float fabsf(float _X)
{
  double return_value_fabs=fabs((double)_X);
  return (float)return_value_fabs;
}

// fabsl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 827
/*inline double fabsl(double _X)*/
/*{*/
  /*double return_value_fabs=fabs((double)_X);*/
  /*return return_value_fabs;*/
/*}*/

// fix_negative
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp_curves.c line 1018
static inline signed int fix_negative(mbedtls_mpi *N, signed char c, mbedtls_mpi *C, size_t bits)
{
  signed int ret;
  if(bits == 224ull)
    C->p[(signed long long int)(C->n - 1ull)] = (mbedtls_mpi_uint)-((signed int)c) << 32;

  else
    C->p[(signed long long int)(C->n - 1ull)] = (mbedtls_mpi_uint)-((signed int)c);
  do
  {
    ret=mbedtls_mpi_sub_abs(N, C, N);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  N->s = -1;

cleanup:
  ;
  return ret;
}

// floorl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 834
/*inline double floorl(double _X)*/
/*{*/
  /*double return_value_floor=floor((double)_X);*/
  /*return return_value_floor;*/
/*}*/

// fmodl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 843
/*inline double fmodl(double _X, double _Y)*/
/*{*/
  /*double return_value_fmod=fmod((double)_X, (double)_Y);*/
  /*return return_value_fmod;*/
/*}*/

// fprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 869

// frexpf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 682
inline float frexpf(float _X, signed int *_Y)
{
  double return_value_frexp=frexp((double)_X, _Y);
  return (float)return_value_frexp;
}

// frexpl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 848
/*inline double frexpl(double _X, signed int *_Y)*/
/*{*/
  /*double return_value_frexp=frexp((double)_X, _Y);*/
  /*return return_value_frexp;*/
/*}*/

// fscanf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1232

// gai_strerrorA
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\ws2tcpip.h line 634
inline char * gai_strerrorA(signed int ecode)
{
  DWORD dwMsgLen;
  static char buff[1025ll];
  dwMsgLen=FormatMessageA((DWORD)(0x1000 | 0x200 | 0xFF), NULL, (DWORD)ecode, (DWORD)(1 << 10 | 0), (LPSTR)buff, 1024ul, ((va_list *)NULL));
  return buff;
}

// gai_strerrorW
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\ws2tcpip.h line 655
inline WCHAR * gai_strerrorW(signed int ecode)
{
  DWORD dwMsgLen;
  static WCHAR buff[1025ll];
  dwMsgLen=FormatMessageW((DWORD)(0x1000 | 0x200 | 0xFF), NULL, (DWORD)ecode, (DWORD)(1 << 10 | 0), (LPWSTR)buff, 1024ul, ((va_list *)NULL));
  return buff;
}

// gcm_aes_setkey_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 341
static signed int gcm_aes_setkey_wrap(void *ctx, const unsigned char *gcm_aes_setkey_wrap$$key, unsigned int key_bitlen)
{
  signed int return_value_mbedtls_gcm_setkey=mbedtls_gcm_setkey((mbedtls_gcm_context *)ctx, /*enum*/MBEDTLS_CIPHER_ID_AES, gcm_aes_setkey_wrap$$key, key_bitlen);
  return return_value_mbedtls_gcm_setkey;
}

// gcm_ctx_alloc
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 78
static void * gcm_ctx_alloc(void)
{
  void *ctx=mbedtls_calloc(1ull, sizeof(mbedtls_gcm_context) /*416ull*/ );
  if(!(ctx == NULL))
    mbedtls_gcm_init((mbedtls_gcm_context *)ctx);

  return ctx;
}

// gcm_ctx_free
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher_wrap.c line 88
static void gcm_ctx_free(void *ctx)
{
  mbedtls_gcm_free((mbedtls_gcm_context *)ctx);
  mbedtls_free(ctx);
}

// gcm_gen_table
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 104
static signed int gcm_gen_table(mbedtls_gcm_context *ctx)
{
  signed int ret;
  signed int i;
  signed int j;
  uint64_t hi;
  uint64_t lo;
  uint64_t vl;
  uint64_t vh;
  unsigned char h[16ll];
  size_t olen=0ull;
  memset((void *)h, 0, 16ull);
  ret=mbedtls_cipher_update(&ctx->cipher_ctx, h, 16ull, h, &olen);
  if(!(ret == 0))
    return ret;

  else
  {
    hi = (uint64_t)((uint32_t)h[0ll] << 24 | (uint32_t)h[(signed long long int)(0 + 1)] << 16 | (uint32_t)h[(signed long long int)(0 + 2)] << 8 | (uint32_t)h[(signed long long int)(0 + 3)]);
    lo = (uint64_t)((uint32_t)h[4ll] << 24 | (uint32_t)h[(signed long long int)(4 + 1)] << 16 | (uint32_t)h[(signed long long int)(4 + 2)] << 8 | (uint32_t)h[(signed long long int)(4 + 3)]);
    vh = (uint64_t)hi << 32 | lo;
    hi = (uint64_t)((uint32_t)h[8ll] << 24 | (uint32_t)h[(signed long long int)(8 + 1)] << 16 | (uint32_t)h[(signed long long int)(8 + 2)] << 8 | (uint32_t)h[(signed long long int)(8 + 3)]);
    lo = (uint64_t)((uint32_t)h[12ll] << 24 | (uint32_t)h[(signed long long int)(12 + 1)] << 16 | (uint32_t)h[(signed long long int)(12 + 2)] << 8 | (uint32_t)h[(signed long long int)(12 + 3)]);
    vl = (uint64_t)hi << 32 | lo;
    ctx->HL[8ll] = vl;
    ctx->HH[8ll] = vh;
    ctx->HH[0ll] = 0ull;
    ctx->HL[0ll] = 0ull;
    i = 4;
    for( ; i >= 1; i = i >> 1)
    {
      uint32_t T=(uint32_t)((vl & 1ull) * 3774873600ull);
      vl = vh << 63 | vl >> 1;
      vh = vh >> 1 ^ (uint64_t)T << 32;
      ctx->HL[(signed long long int)i] = vl;
      ctx->HH[(signed long long int)i] = vh;
    }
    i = 2;
    for( ; !(i >= 9); i = i * 2)
    {
      uint64_t *HiL=ctx->HL + (signed long long int)i;
      uint64_t *HiH=ctx->HH + (signed long long int)i;
      vh = *HiH;
      vl = *HiL;
      j = 1;
      for( ; !(j >= i); j = j + 1)
      {
        HiH[(signed long long int)j] = vh ^ ctx->HH[(signed long long int)j];
        HiL[(signed long long int)j] = vl ^ ctx->HL[(signed long long int)j];
      }
    }
    return 0;
  }
}

// gcm_mult
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 213
static void gcm_mult(mbedtls_gcm_context *ctx, const unsigned char *x, unsigned char *output)
{
  signed int i=0;
  unsigned char lo;
  unsigned char hi;
  unsigned char rem;
  uint64_t zh;
  uint64_t zl;
  lo = (unsigned char)((signed int)x[15ll] & 0xF);
  zh = ctx->HH[(signed long long int)lo];
  zl = ctx->HL[(signed long long int)lo];
  i = 15;
  for( ; i >= 0; i = i - 1)
  {
    lo = (unsigned char)((signed int)x[(signed long long int)i] & 0xF);
    hi = (unsigned char)((signed int)x[(signed long long int)i] >> 4);
    if(!(i == 15))
    {
      rem = (unsigned char)((signed int)(unsigned char)zl & 0xF);
      zl = zh << 60 | zl >> 4;
      zh = zh >> 4;
      zh = zh ^ (uint64_t)last4[(signed long long int)rem] << 48;
      zh = zh ^ ctx->HH[(signed long long int)lo];
      zl = zl ^ ctx->HL[(signed long long int)lo];
    }

    rem = (unsigned char)((signed int)(unsigned char)zl & 0xF);
    zl = zh << 60 | zl >> 4;
    zh = zh >> 4;
    zh = zh ^ (uint64_t)last4[(signed long long int)rem] << 48;
    zh = zh ^ ctx->HH[(signed long long int)hi];
    zl = zl ^ ctx->HL[(signed long long int)hi];
  }
  output[0ll] = (unsigned char)((zh >> 32) >> 24);
  output[(signed long long int)(0 + 1)] = (unsigned char)((zh >> 32) >> 16);
  output[(signed long long int)(0 + 2)] = (unsigned char)((zh >> 32) >> 8);
  output[(signed long long int)(0 + 3)] = (unsigned char)(zh >> 32);
  output[4ll] = (unsigned char)(zh >> 24);
  output[(signed long long int)(4 + 1)] = (unsigned char)(zh >> 16);
  output[(signed long long int)(4 + 2)] = (unsigned char)(zh >> 8);
  output[(signed long long int)(4 + 3)] = (unsigned char)zh;
  output[8ll] = (unsigned char)((zl >> 32) >> 24);
  output[(signed long long int)(8 + 1)] = (unsigned char)((zl >> 32) >> 16);
  output[(signed long long int)(8 + 2)] = (unsigned char)((zl >> 32) >> 8);
  output[(signed long long int)(8 + 3)] = (unsigned char)(zl >> 32);
  output[12ll] = (unsigned char)(zl >> 24);
  output[(signed long long int)(12 + 1)] = (unsigned char)(zl >> 16);
  output[(signed long long int)(12 + 2)] = (unsigned char)(zl >> 8);
  output[(signed long long int)(12 + 3)] = (unsigned char)zl;
}

// get16
// file d:\tuttle\freertos\lib\third_party\tinycbor\extract_number_p.h line 32
static inline uint16_t get16(const uint8_t *ptr)
{
  uint16_t result;
  memcpy((void *)&result, (const void *)ptr, sizeof(uint16_t) /*2ull*/ );
  unsigned short int return_value__byteswap_ushort=_byteswap_ushort(result);
  return return_value__byteswap_ushort;
}

// get16$link1
// file d:\tuttle\freertos\lib\third_party\tinycbor\extract_number_p.h line 32
static inline uint16_t get16$link1(const uint8_t *ptr$link1)
{
  uint16_t result$link1;
  memcpy((void *)&result$link1, (const void *)ptr$link1, sizeof(uint16_t) /*2ull*/ );
  unsigned short int return_value__byteswap_ushort$link1=_byteswap_ushort(result$link1);
  return return_value__byteswap_ushort$link1;
}

// get32
// file d:\tuttle\freertos\lib\third_party\tinycbor\extract_number_p.h line 39
static inline uint32_t get32(const uint8_t *ptr)
{
  uint32_t result;
  memcpy((void *)&result, (const void *)ptr, sizeof(uint32_t) /*4ull*/ );
  unsigned long int return_value__byteswap_ulong=_byteswap_ulong(result);
  return return_value__byteswap_ulong;
}

// get32$link1
// file d:\tuttle\freertos\lib\third_party\tinycbor\extract_number_p.h line 39
static inline uint32_t get32$link1(const uint8_t *ptr$link1)
{
  uint32_t result$link1;
  memcpy((void *)&result$link1, (const void *)ptr$link1, sizeof(uint32_t) /*4ull*/ );
  unsigned long int return_value__byteswap_ulong$link1=_byteswap_ulong(result$link1);
  return return_value__byteswap_ulong$link1;
}

// get64
// file d:\tuttle\freertos\lib\third_party\tinycbor\extract_number_p.h line 46
static inline uint64_t get64(const uint8_t *ptr)
{
  uint64_t result;
  memcpy((void *)&result, (const void *)ptr, sizeof(uint64_t) /*8ull*/ );
  unsigned long long int return_value__byteswap_uint64=_byteswap_uint64(result);
  return return_value__byteswap_uint64;
}

// get64$link1
// file d:\tuttle\freertos\lib\third_party\tinycbor\extract_number_p.h line 46
static inline uint64_t get64$link1(const uint8_t *ptr$link1)
{
  uint64_t result$link1;
  memcpy((void *)&result$link1, (const void *)ptr$link1, sizeof(uint64_t) /*8ull*/ );
  unsigned long long int return_value__byteswap_uint64$link1=_byteswap_uint64(result$link1);
  return return_value__byteswap_uint64$link1;
}

// getUserCmd
// file ..\common\application_code\main.c line 475
void getUserCmd(char *pucUserCmd)
{
  char cTmp;
  scanf("%c%c", pucUserCmd, &cTmp);
}

// get_no_padding
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 624
static signed int get_no_padding(unsigned char *input, size_t input_len, size_t *data_len)
{
  if(data_len == ((size_t *)NULL) || input == ((unsigned char *)NULL))
    return -0x6100;

  else
  {
    *data_len = input_len;
    return 0;
  }
}

// get_one_and_zeros_padding
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 520
static signed int get_one_and_zeros_padding(unsigned char *input, size_t input_len, size_t *data_len)
{
  size_t i;
  unsigned char done=0;
  unsigned char prev_done;
  unsigned char bad;
  if(data_len == ((size_t *)NULL) || input == ((unsigned char *)NULL))
    return -0x6100;

  else
  {
    bad = 128;
    *data_len = 0ull;
    i = input_len;
    for( ; i >= 1ull; i = i - 1ull)
    {
      prev_done = done;
      done = done | (unsigned char)((signed int)input[(signed long long int)(i - 1ull)] != 0);
      *data_len = *data_len | (i - 1ull) * (unsigned long long int)(done != prev_done);
      bad = bad ^ (unsigned char)((signed int)input[(signed long long int)(i - 1ull)] * (signed int)(done != prev_done));
    }
    return -0x6200 * (signed int)((signed int)bad != 0);
  }
}

// get_pkcs_padding
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 479
static signed int get_pkcs_padding(unsigned char *input, size_t input_len, size_t *data_len)
{
  size_t i;
  size_t pad_idx;
  unsigned char padding_len;
  unsigned char bad=0;
  if(data_len == ((size_t *)NULL) || input == ((unsigned char *)NULL))
    return -0x6100;

  else
  {
    padding_len = input[(signed long long int)(input_len - 1ull)];
    *data_len = input_len - (unsigned long long int)padding_len;
    bad = bad | (unsigned char)((unsigned long long int)padding_len > input_len);
    bad = bad | (unsigned char)((signed int)padding_len == 0);
    pad_idx = input_len - (unsigned long long int)padding_len;
    i = 0ull;
    for( ; !(i >= input_len); i = i + 1ull)
      bad = bad | (unsigned char)(((signed int)input[(signed long long int)i] ^ (signed int)padding_len) * (signed int)(i >= pad_idx));
    return -0x6200 * (signed int)((signed int)bad != 0);
  }
}

// get_zeros_and_len_padding
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 559
static signed int get_zeros_and_len_padding(unsigned char *input, size_t input_len, size_t *data_len)
{
  size_t i;
  size_t pad_idx;
  unsigned char padding_len;
  unsigned char bad=0;
  if(data_len == ((size_t *)NULL) || input == ((unsigned char *)NULL))
    return -0x6100;

  else
  {
    padding_len = input[(signed long long int)(input_len - 1ull)];
    *data_len = input_len - (unsigned long long int)padding_len;
    bad = bad | (unsigned char)((unsigned long long int)padding_len > input_len);
    bad = bad | (unsigned char)((signed int)padding_len == 0);
    pad_idx = input_len - (unsigned long long int)padding_len;
    i = 0ull;
    for( ; !(i >= 18446744073709551615ull + input_len); i = i + 1ull)
      bad = bad | (unsigned char)((signed int)input[(signed long long int)i] * (signed int)(i >= pad_idx));
    return -0x6200 * (signed int)((signed int)bad != 0);
  }
}

// get_zeros_padding
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 597
static signed int get_zeros_padding(unsigned char *input, size_t input_len, size_t *data_len)
{
  size_t i;
  unsigned char done=0;
  unsigned char prev_done;
  if(data_len == ((size_t *)NULL) || input == ((unsigned char *)NULL))
    return -0x6100;

  else
  {
    *data_len = 0ull;
    i = input_len;
    for( ; i >= 1ull; i = i - 1ull)
    {
      prev_done = done;
      done = done | (unsigned char)((signed int)input[(signed long long int)(i - 1ull)] != 0);
      *data_len = *data_len | i * (unsigned long long int)(done != prev_done);
    }
    return 0;
  }
}

// getipv4sourcefilter
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\ws2tcpip.h line 727
inline signed int getipv4sourcefilter(SOCKET Socket, IN_ADDR Interface, IN_ADDR Group, MULTICAST_MODE_TYPE *FilterMode, ULONG *SourceCount, IN_ADDR *SourceList)
{
  signed int Error;
  DWORD Size;
  DWORD Returned;
  PIP_MSFILTER Filter;
  if((unsigned long long int)*SourceCount >= 1073741819ull)
  {
    WSASetLastError(10055l);
    return -1;
  }

  else
  {
    Size = (DWORD)((sizeof(IP_MSFILTER) /*20ull*/  - sizeof(IN_ADDR) /*4ull*/ ) + (unsigned long long int)*SourceCount * sizeof(IN_ADDR) /*4ull*/ );
    HANDLE return_value_GetProcessHeap=GetProcessHeap();
    LPVOID return_value_HeapAlloc=HeapAlloc(return_value_GetProcessHeap, 0ul, (SIZE_T)Size);
    Filter = (PIP_MSFILTER)return_value_HeapAlloc;
    if(Filter == ((PIP_MSFILTER)NULL))
    {
      WSASetLastError(10055l);
      return -1;
    }

    else
    {
      Filter->imsf_multiaddr = Group;
      Filter->imsf_interface = Interface;
      Filter->imsf_numsrc = *SourceCount;
      Error=WSAIoctl(Socket, 0x80000000u | (unsigned int)(((signed long int)sizeof(ULONG) /*4l*/  & 0x7F) << 16) | (unsigned int)(116 << 8) | 124u | 0x80000000u, (LPVOID)Filter, Size, (LPVOID)Filter, Size, &Returned, ((LPWSAOVERLAPPED)NULL), ((LPWSAOVERLAPPED_COMPLETION_ROUTINE)NULL));
      if(Error == 0)
      {
        if(*SourceCount >= 1u)
        {
          memcpy((void *)SourceList, (const void *)Filter->imsf_slist, (unsigned long long int)*SourceCount * sizeof(IN_ADDR) /*4ull*/ );
          *SourceCount = Filter->imsf_numsrc;
        }

        *FilterMode = Filter->imsf_fmode;
      }

      HANDLE return_value_GetProcessHeap$0=GetProcessHeap();
      HeapFree(return_value_GetProcessHeap$0, 0ul, (LPVOID)Filter);
      return Error;
    }
  }
}

// hexDump
// file ..\..\..\..\lib\third_party\tinycbor\cborpretty.c line 113
static signed int hexDump(FILE *out, const uint8_t *buffer, size_t n)
{
  size_t tmp_post;
  do
  {
    tmp_post = n;
    n = n - 1ull;
    if(tmp_post == 0ull)
      break;

    signed int r;
    const uint8_t *tmp_post$0=buffer;
    buffer = buffer + 1ll;
    r=fprintf(out, "%02hhx", *tmp_post$0);
    if(!(r >= 0))
      return r;

  }
  while((_Bool)1);
  return 0;
}

// hmac_drbg_self_test_entropy
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 455
static signed int hmac_drbg_self_test_entropy(void *data, unsigned char *buf, size_t len)
{
  const unsigned char *p=(const unsigned char *)data;
  memcpy((void *)buf, (const void *)(p + (signed long long int)test_offset$link1), len);
  test_offset$link1 = test_offset$link1 + len;
  return 0;
}

// hypotf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 687
inline float hypotf(float _X, float _Y)
{
  float return_value__hypotf=_hypotf(_X, _Y);
  return return_value__hypotf;
}

// hypotl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 860
/*inline double hypotl(double _X, double _Y)*/
/*{*/
  /*double return_value__hypot=_hypot((double)_X, (double)_Y);*/
  /*return return_value__hypot;*/
/*}*/

// isOomError
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 221
static inline _Bool isOomError(CborError err)
{
  (void)err;
  return (_Bool)0;
}

// is_fixed_type
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 164
static _Bool is_fixed_type(uint8_t type)
{
  return (signed int)type != 96 && (signed int)type != 64 && (signed int)type != 128 && (signed int)type != 160;
}

// iterate_memcmp
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 913
static uintptr_t iterate_memcmp(char *s1, const uint8_t *s2, size_t len)
{
  signed int return_value_memcmp=memcmp((const void *)s1, (const void *)(const char *)s2, len);
  return (uintptr_t)(return_value_memcmp == 0);
}

// iterate_memcpy
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 918
static uintptr_t iterate_memcpy(char *dest, const uint8_t *src, size_t len)
{
  void *return_value_memcpy=memcpy((void *)dest, (const void *)src, len);
  return (uintptr_t)return_value_memcpy;
}

// iterate_noop
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 905
static uintptr_t iterate_noop(char *dest, const uint8_t *src, size_t len)
{
  (void)dest;
  (void)src;
  (void)len;
  return 1ull;
}

// iterate_string_chunks
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 923
static CborError iterate_string_chunks(const CborValue *value, char *buffer, size_t *buflen, _Bool *result, CborValue *next, IterateFunction func)
{
  _Bool return_value_cbor_value_is_byte_string=cbor_value_is_byte_string$link1(value);
  _Bool tmp_if_expr;
  _Bool return_value_cbor_value_is_text_string;
  if(!(return_value_cbor_value_is_byte_string == (_Bool)0))
    tmp_if_expr = (_Bool)1;

  else
  {
    return_value_cbor_value_is_text_string=cbor_value_is_text_string(value);
    tmp_if_expr = return_value_cbor_value_is_text_string != (_Bool)0 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion cbor_value_is_byte_string(value) || cbor_value_is_text_string(value) */
  assert(tmp_if_expr);
  size_t total;
  CborError err;
  const uint8_t *ptr=value->ptr;
  _Bool return_value_cbor_value_is_length_known=cbor_value_is_length_known(value);
  uintptr_t return_value;
  uintptr_t return_value$0;
  if(!(return_value_cbor_value_is_length_known == (_Bool)0))
  {
    err=extract_length(value->parser, &ptr, &total);
    if(!(err == /*enum*/CborNoError))
      return err;

    if(!((size_t)(value->parser->end - ptr) >= total))
      return /*enum*/CborErrorUnexpectedEOF;

    if(*buflen >= total)
    {
      return_value=func(buffer, ptr, total);
      *result = !(!(return_value != 0ull));
    }

    else
      *result = (_Bool)0;
    ptr = ptr + (signed long long int)total;
  }

  else
  {
    ptr = ptr + 1ll;
    total = 0ull;
    *result = (_Bool)0;
    while((_Bool)1)
    {
      size_t chunkLen;
      size_t newTotal;
      if(ptr == value->parser->end)
        return /*enum*/CborErrorUnexpectedEOF;

      if(*ptr == 255)
      {
        ptr = ptr + 1ll;
        break;
      }

      if(!((-32 & (signed int)*ptr) == (signed int)value->type))
        return /*enum*/CborErrorIllegalType;

      err=extract_length(value->parser, &ptr, &chunkLen);
      if(!(err == /*enum*/CborNoError))
        return err;

      _Bool return_value_add_check_overflow=add_check_overflow(total, chunkLen, &newTotal);
      if(!(return_value_add_check_overflow == (_Bool)0))
        return /*enum*/CborErrorDataTooLarge;

      if(!((size_t)(value->parser->end - ptr) >= chunkLen))
        return /*enum*/CborErrorUnexpectedEOF;

      _Bool tmp_if_expr$0;
      if(!(*result == (_Bool)0))
        tmp_if_expr$0 = *buflen >= newTotal ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$0 = (_Bool)0;
      if(tmp_if_expr$0)
      {
        return_value$0=func(buffer + (signed long long int)total, ptr, chunkLen);
        *result = !(!(return_value$0 != 0ull));
      }

      else
        *result = (_Bool)0;
      ptr = ptr + (signed long long int)chunkLen;
      total = newTotal;
    }
  }
  if(!(*result == (_Bool)0))
  {
    if(!(total >= *buflen))
    {
      uint8_t nul[1ll]={ 0 };
      uintptr_t return_value$1=func(buffer + (signed long long int)total, nul, 1ull);
      *result = !(!(return_value$1 != 0ull));
    }

  }

  *buflen = total;
  if(!(next == ((CborValue *)NULL)))
  {
    *next = *value;
    next->ptr = ptr;
    CborError return_value_preparse_next_value=preparse_next_value(next);
    return return_value_preparse_next_value;
  }

  else
    return /*enum*/CborNoError;
}

// jsmn_alloc_token
// file ..\..\..\..\lib\third_party\jsmn\jsmn.c line 6
static jsmntok_t * jsmn_alloc_token(jsmn_parser *parser, jsmntok_t *tokens, size_t num_tokens)
{
  jsmntok_t *tok;
  if((unsigned long long int)parser->toknext >= num_tokens)
    return ((jsmntok_t *)NULL);

  else
  {
    unsigned int tmp_post=parser->toknext;
    parser->toknext = parser->toknext + 1u;
    tok = &tokens[(signed long long int)tmp_post];
    tok->end = -1;
    tok->start = tok->end;
    tok->size = 0;
    tok->parent = -1;
    return tok;
  }
}

// jsmn_fill_token
// file ..\..\..\..\lib\third_party\jsmn\jsmn.c line 24
static void jsmn_fill_token(jsmntok_t *token, jsmntype_t type, signed int start, signed int end)
{
  token->type = type;
  token->start = start;
  token->end = end;
  token->size = 0;
}

// jsmn_init
// file ..\..\..\..\lib\third_party\jsmn\jsmn.c line 309
void jsmn_init(jsmn_parser *parser)
{
  parser->pos = 0u;
  parser->toknext = 0u;
  parser->toksuper = -1;
}

// jsmn_parse
// file ..\..\..\..\lib\third_party\jsmn\jsmn.c line 151
signed int jsmn_parse(jsmn_parser *parser, const char *js, size_t len, jsmntok_t *tokens, unsigned int num_tokens)
{
  signed int r;
  signed int i;
  jsmntok_t *token;
  signed int count=(signed int)parser->toknext;
  _Bool tmp_if_expr;
  do
  {
    if(!((unsigned long long int)parser->pos >= len))
      tmp_if_expr = (signed int)js[(signed long long int)parser->pos] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr = (_Bool)0;
    if(!tmp_if_expr)
      break;

    char c;
    jsmntype_t type;
    c = js[(signed long long int)parser->pos];
    switch((signed int)c)
    {
      case 123:

      case 91:
      {
        count = count + 1;
        if(tokens == ((jsmntok_t *)NULL))
          break;

        token=jsmn_alloc_token(parser, tokens, (size_t)num_tokens);
        if(token == ((jsmntok_t *)NULL))
          return -1;

        if(!(parser->toksuper == -1))
        {
          (tokens + (signed long long int)parser->toksuper)->size = (tokens + (signed long long int)parser->toksuper)->size + 1;
          token->parent = parser->toksuper;
        }

        token->type = (jsmntype_t)((signed int)c == 123 ? 1 : 2);
        token->start = (signed int)parser->pos;
        parser->toksuper = (signed int)(parser->toknext - 1u);
        break;
      }
      case 125:

      case 93:
      {
        if(tokens == ((jsmntok_t *)NULL))
          break;

        type = (jsmntype_t)((signed int)c == 125 ? 1 : 2);
        if(!(parser->toknext >= 1u))
          return -2;

        token = &tokens[(signed long long int)(parser->toknext - 1u)];
        while((_Bool)1)
        {
          if(!(token->start == -1))
          {
            if(token->end == -1)
            {
              if(!(token->type == type))
                return -2;

              token->end = (signed int)(parser->pos + 1u);
              parser->toksuper = token->parent;
              break;
            }

          }

          if(token->parent == -1)
          {
            _Bool tmp_if_expr$0;
            if(!(token->type == type))
              tmp_if_expr$0 = (_Bool)1;

            else
              tmp_if_expr$0 = parser->toksuper == -1 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$0)
              return -2;

            break;
          }

          token = &tokens[(signed long long int)token->parent];
        }
        break;
      }
      case 34:
      {
        r=jsmn_parse_string(parser, js, len, tokens, (size_t)num_tokens);
        if(!(r >= 0))
          return r;

        count = count + 1;
        if(!(parser->toksuper == -1))
        {
          if(!(tokens == ((jsmntok_t *)NULL)))
            (tokens + (signed long long int)parser->toksuper)->size = (tokens + (signed long long int)parser->toksuper)->size + 1;

        }

        break;
      }
      case 9:

      case 13:

      case 10:

      case 32:
        break;
      case 58:
      {
        parser->toksuper = (signed int)(parser->toknext - 1u);
        break;
      }
      case 44:
      {
        if(!(tokens == ((jsmntok_t *)NULL)))
        {
          if(!(parser->toksuper == -1))
          {
            if(!((signed int)(tokens + (signed long long int)parser->toksuper)->type == 2))
            {
              if(!((signed int)(tokens + (signed long long int)parser->toksuper)->type == 1))
                parser->toksuper = (tokens + (signed long long int)parser->toksuper)->parent;

            }

          }

        }

        break;
      }
      default:
      {
        r=jsmn_parse_primitive(parser, js, len, tokens, (size_t)num_tokens);
        if(!(r >= 0))
          return r;

        count = count + 1;
        if(!(parser->toksuper == -1))
        {
          if(!(tokens == ((jsmntok_t *)NULL)))
            (tokens + (signed long long int)parser->toksuper)->size = (tokens + (signed long long int)parser->toksuper)->size + 1;

        }

      }
    }
    parser->pos = parser->pos + 1u;
  }
  while((_Bool)1);
  if(!(tokens == ((jsmntok_t *)NULL)))
  {
    i = (signed int)(parser->toknext - 1u);
    for( ; i >= 0; i = i - 1)
      if(!((tokens + (signed long long int)i)->start == -1))
      {
        if((tokens + (signed long long int)i)->end == -1)
          return -3;

      }

  }

  return count;
}

// jsmn_parse_primitive
// file ..\..\..\..\lib\third_party\jsmn\jsmn.c line 35
static signed int jsmn_parse_primitive(jsmn_parser *parser, const char *js, size_t len, jsmntok_t *tokens, size_t num_tokens)
{
  jsmntok_t *token;
  signed int start=(signed int)parser->pos;
  _Bool tmp_if_expr;
  do
  {
    if(!((unsigned long long int)parser->pos >= len))
      tmp_if_expr = (signed int)js[(signed long long int)parser->pos] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr = (_Bool)0;
    if(!tmp_if_expr)
      break;

    if(!((signed int)js[(signed long long int)parser->pos] == 9) && !((signed int)js[(signed long long int)parser->pos] == 10) && !((signed int)js[(signed long long int)parser->pos] == 13) && !((signed int)js[(signed long long int)parser->pos] == 32) && !((signed int)js[(signed long long int)parser->pos] == 44) && !((signed int)js[(signed long long int)parser->pos] == 58) && !((signed int)js[(signed long long int)parser->pos] == 93) && !((signed int)js[(signed long long int)parser->pos] == 125))
      goto __CPROVER_DUMP_L5;

    goto found;

  __CPROVER_DUMP_L5:
    ;
    _Bool tmp_if_expr$0;
    if(!((signed int)js[(signed long long int)parser->pos] >= 32))
      tmp_if_expr$0 = (_Bool)1;

    else
      tmp_if_expr$0 = (signed int)js[(signed long long int)parser->pos] >= 127 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$0)
    {
      parser->pos = (unsigned int)start;
      return -2;
    }

    parser->pos = parser->pos + 1u;
  }
  while((_Bool)1);

found:
  ;
  if(tokens == ((jsmntok_t *)NULL))
  {
    parser->pos = parser->pos - 1u;
    return 0;
  }

  else
  {
    token=jsmn_alloc_token(parser, tokens, num_tokens);
    if(token == ((jsmntok_t *)NULL))
    {
      parser->pos = (unsigned int)start;
      return -1;
    }

    else
    {
      jsmn_fill_token(token, /*enum*/JSMN_PRIMITIVE, start, (signed int)parser->pos);
      token->parent = parser->toksuper;
      parser->pos = parser->pos - 1u;
      return 0;
    }
  }
}

// jsmn_parse_string
// file ..\..\..\..\lib\third_party\jsmn\jsmn.c line 84
static signed int jsmn_parse_string(jsmn_parser *parser, const char *js, size_t len, jsmntok_t *tokens, size_t num_tokens)
{
  jsmntok_t *token;
  signed int start=(signed int)parser->pos;
  parser->pos = parser->pos + 1u;
  _Bool tmp_if_expr;
  _Bool tmp_if_expr$0;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$5;
  do
  {
    if(!((unsigned long long int)parser->pos >= len))
      tmp_if_expr = (signed int)js[(signed long long int)parser->pos] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr = (_Bool)0;
    if(!tmp_if_expr)
      break;

    char c=js[(signed long long int)parser->pos];
    if((signed int)c == 34)
    {
      if(tokens == ((jsmntok_t *)NULL))
        return 0;

      token=jsmn_alloc_token(parser, tokens, num_tokens);
      if(token == ((jsmntok_t *)NULL))
      {
        parser->pos = (unsigned int)start;
        return -1;
      }

      jsmn_fill_token(token, /*enum*/JSMN_STRING, start + 1, (signed int)parser->pos);
      token->parent = parser->toksuper;
      return 0;
    }

    if((signed int)c == 92)
    {
      if(!((unsigned long long int)(1u + parser->pos) >= len))
      {
        signed int i;
        parser->pos = parser->pos + 1u;
        switch((signed int)js[(signed long long int)parser->pos])
        {
          case 34:

          case 47:

          case 92:

          case 98:

          case 102:

          case 114:

          case 110:

          case 116:
            break;
          case 117:
          {
            parser->pos = parser->pos + 1u;
            i = 0;
            do
            {
              if(!(i >= 4))
                tmp_if_expr$0 = (unsigned long long int)parser->pos < len ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$0 = (_Bool)0;
              if(tmp_if_expr$0)
                tmp_if_expr$1 = (signed int)js[(signed long long int)parser->pos] != 0 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$1 = (_Bool)0;
              if(!tmp_if_expr$1)
                break;

              _Bool tmp_if_expr$2;
              if((signed int)js[(signed long long int)parser->pos] >= 48)
                tmp_if_expr$2 = (signed int)js[(signed long long int)parser->pos] <= 57 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$2 = (_Bool)0;
              _Bool tmp_if_expr$4;
              if(tmp_if_expr$2)
                tmp_if_expr$4 = (_Bool)1;

              else
              {
                if((signed int)js[(signed long long int)parser->pos] >= 65)
                  tmp_if_expr$3 = (signed int)js[(signed long long int)parser->pos] <= 70 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$3 = (_Bool)0;
                tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
              }
              _Bool tmp_if_expr$6;
              if(tmp_if_expr$4)
                tmp_if_expr$6 = (_Bool)1;

              else
              {
                if((signed int)js[(signed long long int)parser->pos] >= 97)
                  tmp_if_expr$5 = (signed int)js[(signed long long int)parser->pos] <= 102 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$5 = (_Bool)0;
                tmp_if_expr$6 = tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
              }
              if(!tmp_if_expr$6)
              {
                parser->pos = (unsigned int)start;
                return -2;
              }

              parser->pos = parser->pos + 1u;
              i = i + 1;
            }
            while((_Bool)1);
            parser->pos = parser->pos - 1u;
            break;
          }
          default:
          {
            parser->pos = (unsigned int)start;
            return -2;
          }
        }
      }

    }

    parser->pos = parser->pos + 1u;
  }
  while((_Bool)1);
  parser->pos = (unsigned int)start;
  return -3;
}

// lTCPAddRxdata
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 2955
int32_t lTCPAddRxdata(FreeRTOS_Socket_t *pxSocket, size_t uxOffset, const uint8_t *pcData, uint32_t ulByteCount)
{
  const StreamBuffer_t *pxStream=pxSocket->u.xTCP.rxStream;
  int32_t xResult;
  if(pxStream == ((const StreamBuffer_t *)NULL))
  {
    pxStream=prvTCPCreateStream(pxSocket, 1);
    if(pxStream == ((const StreamBuffer_t *)NULL))
      return -1;

  }

  size_t return_value_uxStreamBufferAdd=uxStreamBufferAdd(pxStream, uxOffset, pcData, (size_t)ulByteCount);
  xResult = (int32_t)return_value_uxStreamBufferAdd;
  if(uxOffset == 0ull)
  {
    if((unsigned int)pxSocket->u.xTCP.bits.bLowWater == 0u)
    {
      size_t uxFrontSpace=uxStreamBufferFrontSpace(pxSocket->u.xTCP.rxStream);
      if(pxSocket->u.xTCP.uxLittleSpace >= uxFrontSpace)
      {
        pxSocket->u.xTCP.bits.bLowWater = 1u;
        pxSocket->u.xTCP.bits.bWinChange = 1u;
        pxSocket->u.xTCP.usTimeout = 1;
        xSendEventToIPTask(/*enum*/eTCPTimerEvent);
      }

    }

    pxSocket->xEventBits = pxSocket->xEventBits | 1u;
  }

  return xResult;
}

// lTCPIncrementTxPosition
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 974
static int32_t lTCPIncrementTxPosition(int32_t lPosition, int32_t lMax, int32_t lCount)
{
  lPosition = lPosition + lCount;
  if(lPosition >= lMax)
    lPosition = lPosition - lMax;

  return lPosition;
}

// lTCPWindowRxCheck
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 751
int32_t lTCPWindowRxCheck(TCPWindow_t *pxWindow, uint32_t ulSequenceNumber, uint32_t ulLength, uint32_t ulSpace)
{
  uint32_t ulCurrentSequenceNumber;
  uint32_t ulLast;
  uint32_t ulSavedSequenceNumber;
  int32_t lReturn;
  int32_t lDistance;
  TCPSegment_t *pxFound;
  ulCurrentSequenceNumber = pxWindow->rx.ulCurrentSequenceNumber;
  pxWindow->ucOptionLength = 0;
  pxWindow->ulUserDataLength = 0ul;
  if(ulCurrentSequenceNumber == ulSequenceNumber)
  {
    if(!(ulSpace >= ulLength))
    {
      while((_Bool)0)
        ;
      lReturn = -1;
    }

    else
    {
      ulCurrentSequenceNumber = ulCurrentSequenceNumber + ulLength;
      if(!(pxWindow->xRxSegments.uxNumberOfItems == 0u))
      {
        ulSavedSequenceNumber = ulCurrentSequenceNumber;
        do
        {
          pxFound=xTCPWindowRxConfirm(pxWindow, ulSequenceNumber, ulLength);
          if(!(pxFound == ((TCPSegment_t *)NULL)))
            vTCPWindowFree(pxFound);

        }
        while(!(pxFound == ((TCPSegment_t *)NULL)));
        do
        {
          pxFound=xTCPWindowRxFind(pxWindow, ulCurrentSequenceNumber);
          if(pxFound == ((TCPSegment_t *)NULL))
            break;

          ulCurrentSequenceNumber = ulCurrentSequenceNumber + (uint32_t)pxFound->lDataLength;
          vTCPWindowFree(pxFound);
        }
        while((_Bool)1);
        if(!(ulSavedSequenceNumber == ulCurrentSequenceNumber))
        {
          pxWindow->ulUserDataLength = ulCurrentSequenceNumber - ulSavedSequenceNumber;
          if(xTCPWindowLoggingLevel >= 1)
            while((_Bool)0)
              ;

        }

      }

      pxWindow->rx.ulCurrentSequenceNumber = ulCurrentSequenceNumber;
      lReturn = 0;
    }
  }

  else
    if(ulCurrentSequenceNumber == 1ul + ulSequenceNumber)
      lReturn = -1;

    else
    {
      ulLast = ulSequenceNumber + ulLength;
      lDistance = (int32_t)(ulLast - ulCurrentSequenceNumber);
      if(!(lDistance >= 1))
        lReturn = -1;

      else
        if(!((int32_t)ulSpace >= lDistance))
        {
          while((_Bool)0)
            ;
          lReturn = -1;
        }

        else
        {
          do
          {
            pxFound=xTCPWindowRxFind(pxWindow, ulLast);
            if(pxFound == ((TCPSegment_t *)NULL))
              break;

            ulLast = ulLast + (uint32_t)pxFound->lDataLength;
          }
          while((_Bool)1);
          if(xTCPWindowLoggingLevel >= 1)
            while((_Bool)0)
              ;

          pxWindow->ulOptionsData[0ll] = 0xA050101ul;
          pxWindow->ulOptionsData[1ll] = (uint32_t)((uint32_t)ulSequenceNumber << 24 | ((uint32_t)ulSequenceNumber & 0xFF00ul) << 8 | ((uint32_t)ulSequenceNumber & 0xFF0000ul) >> 8 | (uint32_t)ulSequenceNumber >> 24);
          pxWindow->ulOptionsData[2ll] = (uint32_t)((uint32_t)ulLast << 24 | ((uint32_t)ulLast & 0xFF00ul) << 8 | ((uint32_t)ulLast & 0xFF0000ul) >> 8 | (uint32_t)ulLast >> 24);
          pxWindow->ucOptionLength = (uint8_t)(3ull * sizeof(uint32_t) /*4ull*/ );
          pxFound=xTCPWindowRxFind(pxWindow, ulSequenceNumber);
          if(!(pxFound == ((TCPSegment_t *)NULL)))
            lReturn = -1;

          else
          {
            pxFound=xTCPWindowNew(pxWindow, ulSequenceNumber, (int32_t)ulLength, 1);
            if(pxFound == ((TCPSegment_t *)NULL))
            {
              pxWindow->ucOptionLength = 0;
              lReturn = -1;
            }

            else
            {
              if(!(xTCPWindowLoggingLevel == 0))
              {
                while((_Bool)0)
                  ;
                while((_Bool)0)
                  ;
              }

              lReturn = (int32_t)(ulSequenceNumber - ulCurrentSequenceNumber);
            }
          }
        }
    }
  return lReturn;
}

// lTCPWindowTxAdd
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 992
int32_t lTCPWindowTxAdd(TCPWindow_t *pxWindow, uint32_t ulLength, int32_t lPosition, int32_t lMax)
{
  int32_t lBytesLeft=(int32_t)ulLength;
  int32_t lToWrite;
  int32_t lDone=0;
  TCPSegment_t *pxSegment=pxWindow->pxHeadSegment;
  if(!(pxSegment == ((TCPSegment_t *)NULL)))
  {
    if(!(pxSegment->lDataLength >= pxSegment->lMaxLength))
    {
      if((unsigned int)pxSegment->u.bits.bOutstanding == 0u)
      {
        if(!(pxSegment->lDataLength == 0))
        {
          lToWrite=FreeRTOS_min_int32$link2(lBytesLeft, pxSegment->lMaxLength - pxSegment->lDataLength);
          pxSegment->lDataLength = pxSegment->lDataLength + lToWrite;
          if(pxSegment->lDataLength >= pxSegment->lMaxLength)
            pxWindow->pxHeadSegment = ((TCPSegment_t *)NULL);

          lBytesLeft = lBytesLeft - lToWrite;
          pxWindow->ulNextTxSequenceNumber = pxWindow->ulNextTxSequenceNumber + (uint32_t)lToWrite;
          lDone = lDone + lToWrite;
          if(xTCPWindowLoggingLevel >= 2)
          {
            if(!((unsigned int)pxWindow->usOurPortNumber == 23u))
            {
              while((_Bool)0)
                ;
              while((_Bool)0)
                ;
            }

          }

          lPosition=lTCPIncrementTxPosition(lPosition, lMax, lToWrite);
        }

      }

    }

  }

  _Bool tmp_if_expr;
  while(lBytesLeft >= 1)
  {
    pxSegment=xTCPWindowNew(pxWindow, pxWindow->ulNextTxSequenceNumber, (int32_t)pxWindow->usMSS, 0);
    if(!(pxSegment == ((TCPSegment_t *)NULL)))
    {
      lToWrite=FreeRTOS_min_int32$link2(lBytesLeft, pxSegment->lMaxLength);
      pxSegment->lDataLength = lToWrite;
      pxSegment->lStreamPos = lPosition;
      lBytesLeft = lBytesLeft - lToWrite;
      lPosition=lTCPIncrementTxPosition(lPosition, lMax, lToWrite);
      pxWindow->ulNextTxSequenceNumber = pxWindow->ulNextTxSequenceNumber + (uint32_t)lToWrite;
      lDone = lDone + lToWrite;
      vListInsertFifo(&pxWindow->xTxQueue, &pxSegment->xQueueItem);
      if(!(pxSegment->lDataLength >= pxSegment->lMaxLength))
        pxWindow->pxHeadSegment = pxSegment;

      else
        pxWindow->pxHeadSegment = ((TCPSegment_t *)NULL);
      if(!((unsigned int)pxWindow->usOurPortNumber == 23u))
      {
        _Bool tmp_if_expr$0;
        if(xTCPWindowLoggingLevel >= 3)
          tmp_if_expr$0 = (_Bool)1;

        else
        {
          if(xTCPWindowLoggingLevel >= 2)
            tmp_if_expr = pxWindow->pxHeadSegment != ((TCPSegment_t *)NULL) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr = (_Bool)0;
          tmp_if_expr$0 = tmp_if_expr ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$0)
        {
          while((_Bool)0)
            ;
          while((_Bool)0)
            ;
        }

      }

    }

    else
    {
      if(!(lDone == 0))
        while((_Bool)0)
          ;

      break;
    }
  }
  return lDone;
}

// ldexpf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 692
inline float ldexpf(float _X, signed int _Y)
{
  double return_value_ldexp=ldexp((double)_X, _Y);
  return (float)return_value_ldexp;
}

// ldexpl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 865
/*inline double ldexpl(double _X, signed int _Y)*/
/*{*/
  /*double return_value_ldexp=ldexp((double)_X, _Y);*/
  /*return return_value_ldexp;*/
/*}*/

// log10l
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 879
/*inline double log10l(double _X)*/
/*{*/
  /*double return_value_log10=log10((double)_X);*/
  /*return return_value_log10;*/
/*}*/

// logl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 874
/*inline double logl(double _X)*/
/*{*/
  /*double return_value_log=log((double)_X);*/
  /*return return_value_log;*/
/*}*/

// main
// file ..\common\application_code\main.c line 152
signed int main(void)
{
  const uint32_t ulLongTime_ms=(TickType_t)((1000ul * 1000u) / 1000u);
  prvMiscInitialisation();
  vLoggingPrintf("FreeRTOS_IPInit\n");
  FreeRTOS_IPInit(ucIPAddress, ucNetMask, ucGatewayAddress, ucDNSServerAddress, ucMACAddress);
  vLoggingPrintf("vTaskStartScheduler\n");
  vTaskStartScheduler();
  while((_Bool)1)
    Sleep(ulLongTime_ms);
}

// mbedtls_aes_crypt_cbc
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 928
signed int mbedtls_aes_crypt_cbc(mbedtls_aes_context *ctx, signed int mode, size_t length, unsigned char *mbedtls_aes_crypt_cbc$$iv, const unsigned char *input, unsigned char *output)
{
  signed int i;
  unsigned char temp[16ll];
  if(!(length % 16ull == 0ull))
    return -0x22;

  else
  {
    if(mode == 0)
      for( ; length >= 1ull; length = length - 16ull)
      {
        memcpy((void *)temp, (const void *)input, 16ull);
        mbedtls_aes_crypt_ecb(ctx, mode, input, output);
        i = 0;
        for( ; !(i >= 16); i = i + 1)
          output[(signed long long int)i] = (unsigned char)((signed int)output[(signed long long int)i] ^ (signed int)mbedtls_aes_crypt_cbc$$iv[(signed long long int)i]);
        memcpy((void *)mbedtls_aes_crypt_cbc$$iv, (const void *)temp, 16ull);
        input = input + 16ll;
        output = output + 16ll;
      }

    else
      for( ; length >= 1ull; length = length - 16ull)
      {
        i = 0;
        for( ; !(i >= 16); i = i + 1)
          output[(signed long long int)i] = (unsigned char)((signed int)input[(signed long long int)i] ^ (signed int)mbedtls_aes_crypt_cbc$$iv[(signed long long int)i]);
        mbedtls_aes_crypt_ecb(ctx, mode, output, output);
        memcpy((void *)mbedtls_aes_crypt_cbc$$iv, (const void *)output, 16ull);
        input = input + 16ll;
        output = output + 16ll;
      }
    return 0;
  }
}

// mbedtls_aes_crypt_cfb128
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 994
signed int mbedtls_aes_crypt_cfb128(mbedtls_aes_context *ctx, signed int mode, size_t length, size_t *iv_off, unsigned char *mbedtls_aes_crypt_cfb128$$iv, const unsigned char *input, unsigned char *output)
{
  signed int c;
  size_t n=*iv_off;
  size_t tmp_post;
  size_t tmp_post$2;
  if(mode == 0)
    do
    {
      tmp_post = length;
      length = length - 1ull;
      if(tmp_post == 0ull)
        break;

      if(n == 0ull)
        mbedtls_aes_crypt_ecb(ctx, 1, mbedtls_aes_crypt_cfb128$$iv, mbedtls_aes_crypt_cfb128$$iv);

      const unsigned char *tmp_post$0=input;
      input = input + 1ll;
      c = (signed int)*tmp_post$0;
      unsigned char *tmp_post$1=output;
      output = output + 1ll;
      *tmp_post$1 = (unsigned char)(c ^ (signed int)mbedtls_aes_crypt_cfb128$$iv[(signed long long int)n]);
      mbedtls_aes_crypt_cfb128$$iv[(signed long long int)n] = (unsigned char)c;
      n = n + 1ull & 15ull;
    }
    while((_Bool)1);

  else
    do
    {
      tmp_post$2 = length;
      length = length - 1ull;
      if(tmp_post$2 == 0ull)
        break;

      if(n == 0ull)
        mbedtls_aes_crypt_ecb(ctx, 1, mbedtls_aes_crypt_cfb128$$iv, mbedtls_aes_crypt_cfb128$$iv);

      unsigned char *tmp_post$3=output;
      output = output + 1ll;
      const unsigned char *tmp_post$4=input;
      input = input + 1ll;
      *tmp_post$3 = (unsigned char)((signed int)mbedtls_aes_crypt_cfb128$$iv[(signed long long int)n] ^ (signed int)*tmp_post$4);
      mbedtls_aes_crypt_cfb128$$iv[(signed long long int)n] = *tmp_post$3;
      n = n + 1ull & 15ull;
    }
    while((_Bool)1);
  *iv_off = n;
  return 0;
}

// mbedtls_aes_crypt_cfb8
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 1040
signed int mbedtls_aes_crypt_cfb8(mbedtls_aes_context *ctx, signed int mode, size_t length, unsigned char *mbedtls_aes_crypt_cfb8$$iv, const unsigned char *input, unsigned char *output)
{
  unsigned char c;
  unsigned char ov[17ll];
  size_t tmp_post;
  do
  {
    tmp_post = length;
    length = length - 1ull;
    if(tmp_post == 0ull)
      break;

    memcpy((void *)ov, (const void *)mbedtls_aes_crypt_cfb8$$iv, 16ull);
    mbedtls_aes_crypt_ecb(ctx, 1, mbedtls_aes_crypt_cfb8$$iv, mbedtls_aes_crypt_cfb8$$iv);
    if(mode == 0)
      ov[16ll] = *input;

    unsigned char *tmp_post$0=output;
    output = output + 1ll;
    const unsigned char *tmp_post$1=input;
    input = input + 1ll;
    *tmp_post$0 = (unsigned char)((signed int)mbedtls_aes_crypt_cfb8$$iv[0ll] ^ (signed int)*tmp_post$1);
    c = *tmp_post$0;
    if(mode == 1)
      ov[16ll] = c;

    memcpy((void *)mbedtls_aes_crypt_cfb8$$iv, (const void *)(ov + 1ll), 16ull);
  }
  while((_Bool)1);
  return 0;
}

// mbedtls_aes_crypt_ctr
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 1074
signed int mbedtls_aes_crypt_ctr(mbedtls_aes_context *ctx, size_t length, size_t *nc_off, unsigned char *nonce_counter, unsigned char *stream_block, const unsigned char *input, unsigned char *output)
{
  signed int c;
  signed int i;
  size_t n=*nc_off;
  size_t tmp_post;
  do
  {
    tmp_post = length;
    length = length - 1ull;
    if(tmp_post == 0ull)
      break;

    if(n == 0ull)
    {
      mbedtls_aes_crypt_ecb(ctx, 1, nonce_counter, stream_block);
      i = 16;
      for( ; i >= 1; i = i - 1)
      {
        nonce_counter[(signed long long int)(i - 1)] = nonce_counter[(signed long long int)(i - 1)] + 1;
        if(!((signed int)nonce_counter[(signed long long int)(-1 + i)] == 0))
          break;

      }
    }

    const unsigned char *tmp_post$0=input;
    input = input + 1ll;
    c = (signed int)*tmp_post$0;
    unsigned char *tmp_post$1=output;
    output = output + 1ll;
    *tmp_post$1 = (unsigned char)(c ^ (signed int)stream_block[(signed long long int)n]);
    n = n + 1ull & 15ull;
  }
  while((_Bool)1);
  *nc_off = n;
  return 0;
}

// mbedtls_aes_crypt_ecb
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 896
signed int mbedtls_aes_crypt_ecb(mbedtls_aes_context *ctx, signed int mode, const unsigned char *input, unsigned char *output)
{
  signed int return_value_mbedtls_internal_aes_encrypt;
  signed int return_value_mbedtls_internal_aes_decrypt;
  if(mode == 1)
  {
    return_value_mbedtls_internal_aes_encrypt=mbedtls_internal_aes_encrypt(ctx, input, output);
    return return_value_mbedtls_internal_aes_encrypt;
  }

  else
  {
    return_value_mbedtls_internal_aes_decrypt=mbedtls_internal_aes_decrypt(ctx, input, output);
    return return_value_mbedtls_internal_aes_decrypt;
  }
}

// mbedtls_aes_free
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 520
void mbedtls_aes_free(mbedtls_aes_context *ctx)
{
  if(!(ctx == ((mbedtls_aes_context *)NULL)))
    mbedtls_zeroize((void *)ctx, sizeof(mbedtls_aes_context) /*288ull*/ );

}

// mbedtls_aes_init
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 515
void mbedtls_aes_init(mbedtls_aes_context *ctx)
{
  memset((void *)ctx, 0, sizeof(mbedtls_aes_context) /*288ull*/ );
}

// mbedtls_aes_self_test
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 1288
signed int mbedtls_aes_self_test(signed int verbose)
{
  signed int ret=0;
  signed int i;
  signed int j;
  signed int u;
  signed int mode;
  unsigned int keybits;
  unsigned char mbedtls_aes_self_test$$1$$key[32ll];
  unsigned char buf[64ll];
  const unsigned char *aes_tests;
  unsigned char mbedtls_aes_self_test$$1$$iv[16ll];
  unsigned char prv[16ll];
  size_t offset;
  signed int len;
  unsigned char nonce_counter[16ll];
  unsigned char stream_block[16ll];
  mbedtls_aes_context ctx;
  memset((void *)mbedtls_aes_self_test$$1$$key, 0, 32ull);
  mbedtls_aes_init(&ctx);
  i = 0;
  for( ; !(i >= 6); i = i + 1)
  {
    u = i >> 1;
    keybits = (unsigned int)(128 + u * 64);
    mode = i & 1;
    if(!(verbose == 0))
      printf("  AES-ECB-%3d (%s): ", keybits, mode == 0 ? "dec" : "enc");

    memset((void *)buf, 0, 16ull);
    if(mode == 0)
    {
      ret=mbedtls_aes_setkey_dec(&ctx, mbedtls_aes_self_test$$1$$key, keybits);
      aes_tests = aes_test_ecb_dec[(signed long long int)u];
    }

    else
    {
      ret=mbedtls_aes_setkey_enc(&ctx, mbedtls_aes_self_test$$1$$key, keybits);
      aes_tests = aes_test_ecb_enc[(signed long long int)u];
    }
    if(ret == -35 && keybits == 192u)
    {
      printf("skipped\n");
      goto __CPROVER_DUMP_L11;
    }

    else
      if(!(ret == 0))
        goto exit;

    j = 0;
    for( ; !(j >= 10000); j = j + 1)
    {
      ret=mbedtls_aes_crypt_ecb(&ctx, mode, buf, buf);
      if(!(ret == 0))
        goto exit;

    }
    signed int return_value_memcmp=memcmp((const void *)buf, (const void *)aes_tests, 16ull);
    if(!(return_value_memcmp == 0))
    {
      ret = 1;
      goto exit;
    }

    if(!(verbose == 0))
      printf("passed\n");


  __CPROVER_DUMP_L11:
    ;
  }
  if(!(verbose == 0))
    printf("\n");

  i = 0;
  for( ; !(i >= 6); i = i + 1)
  {
    u = i >> 1;
    keybits = (unsigned int)(128 + u * 64);
    mode = i & 1;
    if(!(verbose == 0))
      printf("  AES-CBC-%3d (%s): ", keybits, mode == 0 ? "dec" : "enc");

    memset((void *)mbedtls_aes_self_test$$1$$iv, 0, 16ull);
    memset((void *)prv, 0, 16ull);
    memset((void *)buf, 0, 16ull);
    if(mode == 0)
    {
      ret=mbedtls_aes_setkey_dec(&ctx, mbedtls_aes_self_test$$1$$key, keybits);
      aes_tests = aes_test_cbc_dec[(signed long long int)u];
    }

    else
    {
      ret=mbedtls_aes_setkey_enc(&ctx, mbedtls_aes_self_test$$1$$key, keybits);
      aes_tests = aes_test_cbc_enc[(signed long long int)u];
    }
    if(ret == -35 && keybits == 192u)
    {
      printf("skipped\n");
      goto __CPROVER_DUMP_L25;
    }

    else
      if(!(ret == 0))
        goto exit;

    j = 0;
    for( ; !(j >= 10000); j = j + 1)
    {
      if(mode == 1)
      {
        unsigned char tmp[16ll];
        memcpy((void *)tmp, (const void *)prv, 16ull);
        memcpy((void *)prv, (const void *)buf, 16ull);
        memcpy((void *)buf, (const void *)tmp, 16ull);
      }

      ret=mbedtls_aes_crypt_cbc(&ctx, mode, 16ull, mbedtls_aes_self_test$$1$$iv, buf, buf);
      if(!(ret == 0))
        goto exit;

    }
    signed int return_value_memcmp$0=memcmp((const void *)buf, (const void *)aes_tests, 16ull);
    if(!(return_value_memcmp$0 == 0))
    {
      ret = 1;
      goto exit;
    }

    if(!(verbose == 0))
      printf("passed\n");


  __CPROVER_DUMP_L25:
    ;
  }
  if(!(verbose == 0))
    printf("\n");

  i = 0;
  for( ; !(i >= 6); i = i + 1)
  {
    u = i >> 1;
    keybits = (unsigned int)(128 + u * 64);
    mode = i & 1;
    if(!(verbose == 0))
      printf("  AES-CFB128-%3d (%s): ", keybits, mode == 0 ? "dec" : "enc");

    memcpy((void *)mbedtls_aes_self_test$$1$$iv, (const void *)aes_test_cfb128_iv, 16ull);
    memcpy((void *)mbedtls_aes_self_test$$1$$key, (const void *)aes_test_cfb128_key[(signed long long int)u], (size_t)(keybits / 8u));
    offset = 0ull;
    ret=mbedtls_aes_setkey_enc(&ctx, mbedtls_aes_self_test$$1$$key, keybits);
    if(ret == -35 && keybits == 192u)
    {
      printf("skipped\n");
      goto __CPROVER_DUMP_L36;
    }

    else
      if(!(ret == 0))
        goto exit;

    if(mode == 0)
    {
      memcpy((void *)buf, (const void *)aes_test_cfb128_ct[(signed long long int)u], 64ull);
      aes_tests = aes_test_cfb128_pt;
    }

    else
    {
      memcpy((void *)buf, (const void *)aes_test_cfb128_pt, 64ull);
      aes_tests = aes_test_cfb128_ct[(signed long long int)u];
    }
    ret=mbedtls_aes_crypt_cfb128(&ctx, mode, 64ull, &offset, mbedtls_aes_self_test$$1$$iv, buf, buf);
    if(!(ret == 0))
      goto exit;

    signed int return_value_memcmp$1=memcmp((const void *)buf, (const void *)aes_tests, 64ull);
    if(!(return_value_memcmp$1 == 0))
    {
      ret = 1;
      goto exit;
    }

    if(!(verbose == 0))
      printf("passed\n");


  __CPROVER_DUMP_L36:
    ;
  }
  if(!(verbose == 0))
    printf("\n");

  i = 0;
  for( ; !(i >= 6); i = i + 1)
  {
    u = i >> 1;
    mode = i & 1;
    if(!(verbose == 0))
      printf("  AES-CTR-128 (%s): ", mode == 0 ? "dec" : "enc");

    memcpy((void *)nonce_counter, (const void *)aes_test_ctr_nonce_counter[(signed long long int)u], 16ull);
    memcpy((void *)mbedtls_aes_self_test$$1$$key, (const void *)aes_test_ctr_key[(signed long long int)u], 16ull);
    offset = 0ull;
    ret=mbedtls_aes_setkey_enc(&ctx, mbedtls_aes_self_test$$1$$key, 128u);
    if(!(ret == 0))
      goto exit;

    len = aes_test_ctr_len[(signed long long int)u];
    if(mode == 0)
    {
      memcpy((void *)buf, (const void *)aes_test_ctr_ct[(signed long long int)u], (size_t)len);
      aes_tests = aes_test_ctr_pt[(signed long long int)u];
    }

    else
    {
      memcpy((void *)buf, (const void *)aes_test_ctr_pt[(signed long long int)u], (size_t)len);
      aes_tests = aes_test_ctr_ct[(signed long long int)u];
    }
    ret=mbedtls_aes_crypt_ctr(&ctx, (size_t)len, &offset, nonce_counter, stream_block, buf, buf);
    if(!(ret == 0))
      goto exit;

    signed int return_value_memcmp$2=memcmp((const void *)buf, (const void *)aes_tests, (size_t)len);
    if(!(return_value_memcmp$2 == 0))
    {
      ret = 1;
      goto exit;
    }

    if(!(verbose == 0))
      printf("passed\n");

  }
  if(!(verbose == 0))
    printf("\n");

  ret = 0;

exit:
  ;
  if(!(ret == 0) && !(verbose == 0))
    printf("failed\n");

  mbedtls_aes_free(&ctx);
  return ret;
}

// mbedtls_aes_setkey_dec
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 646
signed int mbedtls_aes_setkey_dec(mbedtls_aes_context *ctx, const unsigned char *mbedtls_aes_setkey_dec$$key, unsigned int keybits)
{
  signed int i;
  signed int j;
  signed int ret;
  mbedtls_aes_context cty;
  uint32_t *RK;
  uint32_t *SK;
  mbedtls_aes_init(&cty);
  RK = ctx->buf;
  ctx->rk = RK;
  ret=mbedtls_aes_setkey_enc(&cty, mbedtls_aes_setkey_dec$$key, keybits);
  uint32_t *tmp_post;
  uint32_t *tmp_post$0;
  uint32_t *tmp_post$1;
  uint32_t *tmp_post$2;
  uint32_t *tmp_post$3;
  uint32_t *tmp_post$4;
  uint32_t *tmp_post$5;
  uint32_t *tmp_post$6;
  uint32_t *tmp_post$8;
  uint32_t *tmp_post$9;
  uint32_t *tmp_post$10;
  uint32_t *tmp_post$11;
  uint32_t *tmp_post$12;
  uint32_t *tmp_post$13;
  uint32_t *tmp_post$14;
  uint32_t *tmp_post$15;
  if(ret == 0)
  {
    ctx->nr = cty.nr;
    SK = cty.rk + (signed long long int)(cty.nr * 4);
    tmp_post = RK;
    RK = RK + 1ll;
    tmp_post$0 = SK;
    SK = SK + 1ll;
    *tmp_post = *tmp_post$0;
    tmp_post$1 = RK;
    RK = RK + 1ll;
    tmp_post$2 = SK;
    SK = SK + 1ll;
    *tmp_post$1 = *tmp_post$2;
    tmp_post$3 = RK;
    RK = RK + 1ll;
    tmp_post$4 = SK;
    SK = SK + 1ll;
    *tmp_post$3 = *tmp_post$4;
    tmp_post$5 = RK;
    RK = RK + 1ll;
    tmp_post$6 = SK;
    SK = SK + 1ll;
    *tmp_post$5 = *tmp_post$6;
    i = ctx->nr - 1;
    SK = SK - 8ll;
    for( ; i >= 1; SK = SK - 8ll)
    {
      j = 0;
      for( ; !(j >= 4); SK = SK + 1ll)
      {
        uint32_t *tmp_post$7=RK;
        RK = RK + 1ll;
        *tmp_post$7 = RT0[(signed long long int)FSb[(signed long long int)(*SK & 255u)]] ^ RT1[(signed long long int)FSb[(signed long long int)(*SK >> 8 & 255u)]] ^ RT2[(signed long long int)FSb[(signed long long int)(*SK >> 16 & 255u)]] ^ RT3[(signed long long int)FSb[(signed long long int)(*SK >> 24 & 255u)]];
        j = j + 1;
      }
      i = i - 1;
    }
    tmp_post$8 = RK;
    RK = RK + 1ll;
    tmp_post$9 = SK;
    SK = SK + 1ll;
    *tmp_post$8 = *tmp_post$9;
    tmp_post$10 = RK;
    RK = RK + 1ll;
    tmp_post$11 = SK;
    SK = SK + 1ll;
    *tmp_post$10 = *tmp_post$11;
    tmp_post$12 = RK;
    RK = RK + 1ll;
    tmp_post$13 = SK;
    SK = SK + 1ll;
    *tmp_post$12 = *tmp_post$13;
    tmp_post$14 = RK;
    RK = RK + 1ll;
    tmp_post$15 = SK;
    SK = SK + 1ll;
    *tmp_post$14 = *tmp_post$15;
  }


exit:
  ;
  mbedtls_aes_free(&cty);
  return ret;
}

// mbedtls_aes_setkey_enc
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 532
signed int mbedtls_aes_setkey_enc(mbedtls_aes_context *ctx, const unsigned char *mbedtls_aes_setkey_enc$$key, unsigned int keybits)
{
  unsigned int i;
  uint32_t *RK;
  switch(keybits)
  {
    case 128u:
    {
      ctx->nr = 10;
      break;
    }
    case 192u:
    {
      ctx->nr = 12;
      break;
    }
    case 256u:
    {
      ctx->nr = 14;
      break;
    }
    default:
      return -0x20;
  }
  RK = ctx->buf;
  ctx->rk = RK;
  i = 0u;
  for( ; !(i >= keybits >> 5); i = i + 1u)
    RK[(signed long long int)i] = (uint32_t)mbedtls_aes_setkey_enc$$key[(signed long long int)(i << 2)] | (uint32_t)mbedtls_aes_setkey_enc$$key[(signed long long int)((i << 2) + 1u)] << 8 | (uint32_t)mbedtls_aes_setkey_enc$$key[(signed long long int)((i << 2) + 2u)] << 16 | (uint32_t)mbedtls_aes_setkey_enc$$key[(signed long long int)((i << 2) + 3u)] << 24;
  switch(ctx->nr)
  {
    case 10:
    {
      i = 0u;
      for( ; !(i >= 10u); RK = RK + 4ll)
      {
        RK[4ll] = RK[0ll] ^ RCON[(signed long long int)i] ^ (uint32_t)FSb[(signed long long int)(RK[3ll] >> 8 & 255u)] ^ (uint32_t)FSb[(signed long long int)(RK[3ll] >> 16 & 255u)] << 8 ^ (uint32_t)FSb[(signed long long int)(RK[3ll] >> 24 & 255u)] << 16 ^ (uint32_t)FSb[(signed long long int)(RK[3ll] & 255u)] << 24;
        RK[5ll] = RK[1ll] ^ RK[4ll];
        RK[6ll] = RK[2ll] ^ RK[5ll];
        RK[7ll] = RK[3ll] ^ RK[6ll];
        i = i + 1u;
      }
      break;
    }
    case 12:
    {
      i = 0u;
      for( ; !(i >= 8u); RK = RK + 6ll)
      {
        RK[6ll] = RK[0ll] ^ RCON[(signed long long int)i] ^ (uint32_t)FSb[(signed long long int)(RK[5ll] >> 8 & 255u)] ^ (uint32_t)FSb[(signed long long int)(RK[5ll] >> 16 & 255u)] << 8 ^ (uint32_t)FSb[(signed long long int)(RK[5ll] >> 24 & 255u)] << 16 ^ (uint32_t)FSb[(signed long long int)(RK[5ll] & 255u)] << 24;
        RK[7ll] = RK[1ll] ^ RK[6ll];
        RK[8ll] = RK[2ll] ^ RK[7ll];
        RK[9ll] = RK[3ll] ^ RK[8ll];
        RK[10ll] = RK[4ll] ^ RK[9ll];
        RK[11ll] = RK[5ll] ^ RK[10ll];
        i = i + 1u;
      }
      break;
    }
    case 14:
    {
      i = 0u;
      for( ; !(i >= 7u); RK = RK + 8ll)
      {
        RK[8ll] = RK[0ll] ^ RCON[(signed long long int)i] ^ (uint32_t)FSb[(signed long long int)(RK[7ll] >> 8 & 255u)] ^ (uint32_t)FSb[(signed long long int)(RK[7ll] >> 16 & 255u)] << 8 ^ (uint32_t)FSb[(signed long long int)(RK[7ll] >> 24 & 255u)] << 16 ^ (uint32_t)FSb[(signed long long int)(RK[7ll] & 255u)] << 24;
        RK[9ll] = RK[1ll] ^ RK[8ll];
        RK[10ll] = RK[2ll] ^ RK[9ll];
        RK[11ll] = RK[3ll] ^ RK[10ll];
        RK[12ll] = RK[4ll] ^ (uint32_t)FSb[(signed long long int)(RK[11ll] & 255u)] ^ (uint32_t)FSb[(signed long long int)(RK[11ll] >> 8 & 255u)] << 8 ^ (uint32_t)FSb[(signed long long int)(RK[11ll] >> 16 & 255u)] << 16 ^ (uint32_t)FSb[(signed long long int)(RK[11ll] >> 24 & 255u)] << 24;
        RK[13ll] = RK[5ll] ^ RK[12ll];
        RK[14ll] = RK[6ll] ^ RK[13ll];
        RK[15ll] = RK[7ll] ^ RK[14ll];
        i = i + 1u;
      }
    }
  }
  return 0;
}

// mbedtls_asn1_find_named_data
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1parse.c line 376
mbedtls_asn1_named_data * mbedtls_asn1_find_named_data(mbedtls_asn1_named_data *list, const char *oid, size_t len)
{
  signed int return_value_memcmp;
  while(!(list == ((mbedtls_asn1_named_data *)NULL)))
  {
    if(list->oid.len == len)
    {
      return_value_memcmp=memcmp((const void *)list->oid.p, (const void *)oid, len);
      if(return_value_memcmp == 0)
        break;

    }

    list = list->next;
  }
  return list;
}

// mbedtls_asn1_free_named_data
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1parse.c line 353
void mbedtls_asn1_free_named_data(mbedtls_asn1_named_data *cur)
{
  if(!(cur == ((mbedtls_asn1_named_data *)NULL)))
  {
    mbedtls_free((void *)cur->oid.p);
    mbedtls_free((void *)cur->val.p);
    mbedtls_zeroize$link1((void *)cur, sizeof(mbedtls_asn1_named_data) /*64ull*/ );
  }

}

// mbedtls_asn1_free_named_data_list
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1parse.c line 364
void mbedtls_asn1_free_named_data_list(mbedtls_asn1_named_data **head)
{
  mbedtls_asn1_named_data *cur;
  cur = *head;
  if(!(cur == ((mbedtls_asn1_named_data *)NULL)))
  {
    *head = cur->next;
    mbedtls_asn1_free_named_data(cur);
    mbedtls_free((void *)cur);
  }

}

// mbedtls_asn1_get_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1parse.c line 291
signed int mbedtls_asn1_get_alg(unsigned char **p, const unsigned char *end, mbedtls_asn1_buf *alg, mbedtls_asn1_buf *params)
{
  signed int ret;
  size_t len;
  ret=mbedtls_asn1_get_tag(p, end, &len, 0x20 | 0x10);
  if(!(ret == 0))
    return ret;

  else
    if(!(end - *p >= 1ll))
      return -0x60;

    else
    {
      alg->tag = (signed int)*(*p);
      end = *p + (signed long long int)len;
      ret=mbedtls_asn1_get_tag(p, end, &alg->len, 0x6);
      if(!(ret == 0))
        return ret;

      else
      {
        alg->p = *p;
        *p = *p + (signed long long int)alg->len;
        if(*p == end)
        {
          mbedtls_zeroize$link1((void *)params, sizeof(mbedtls_asn1_buf) /*24ull*/ );
          return 0;
        }

        else
        {
          params->tag = (signed int)*(*p);
          *p = *p + 1ll;
          ret=mbedtls_asn1_get_len(p, end, &params->len);
          if(!(ret == 0))
            return ret;

          else
          {
            params->p = *p;
            *p = *p + (signed long long int)params->len;
            if(!(*p == end))
              return -0x66;

            else
              return 0;
          }
        }
      }
    }
}

// mbedtls_asn1_get_alg_null
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1parse.c line 335
signed int mbedtls_asn1_get_alg_null(unsigned char **p, const unsigned char *end, mbedtls_asn1_buf *alg)
{
  signed int ret;
  mbedtls_asn1_buf params;
  memset((void *)&params, 0, sizeof(mbedtls_asn1_buf) /*24ull*/ );
  ret=mbedtls_asn1_get_alg(p, end, alg, &params);
  if(!(ret == 0))
    return ret;

  else
    if(!(params.tag == 0) && !(params.tag == 0x5) || !(params.len == 0ull))
      return -0x68;

    else
      return 0;
}

// mbedtls_asn1_get_bitstring
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1parse.c line 189
signed int mbedtls_asn1_get_bitstring(unsigned char **p, const unsigned char *end, mbedtls_asn1_bitstring *bs)
{
  signed int ret=mbedtls_asn1_get_tag(p, end, &bs->len, 0x3);
  if(!(ret == 0))
    return ret;

  else
    if(!(bs->len >= 1ull))
      return -0x60;

    else
    {
      bs->len = bs->len - 1ull;
      bs->unused_bits = *(*p);
      if((signed int)bs->unused_bits >= 8)
        return -0x64;

      else
      {
        *p = *p + 1ll;
        bs->p = *p;
        *p = *p + (signed long long int)bs->len;
        if(!(*p == end))
          return -0x66;

        else
          return 0;
      }
    }
}

// mbedtls_asn1_get_bitstring_null
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1parse.c line 222
signed int mbedtls_asn1_get_bitstring_null(unsigned char **p, const unsigned char *end, size_t *len)
{
  signed int ret=mbedtls_asn1_get_tag(p, end, len, 0x3);
  unsigned char *tmp_post$0;
  if(!(ret == 0))
    return ret;

  else
  {
    size_t tmp_post=*len;
    *len = *len - 1ull;
    _Bool tmp_if_expr;
    if(!(tmp_post >= 2ull))
      tmp_if_expr = (_Bool)1;

    else
    {
      tmp_post$0 = *p;
      *p = *p + 1ll;
      tmp_if_expr = (signed int)*tmp_post$0 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr)
      return -0x68;

    else
      return 0;
  }
}

// mbedtls_asn1_get_bool
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1parse.c line 127
signed int mbedtls_asn1_get_bool(unsigned char **p, const unsigned char *end, signed int *val)
{
  signed int ret;
  size_t len;
  ret=mbedtls_asn1_get_tag(p, end, &len, 0x1);
  if(!(ret == 0))
    return ret;

  else
    if(!(len == 1ull))
      return -0x64;

    else
    {
      *val = (signed int)*(*p) != 0 ? 1 : 0;
      *p = *p + 1ll;
      return 0;
    }
}

// mbedtls_asn1_get_int
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1parse.c line 146
signed int mbedtls_asn1_get_int(unsigned char **p, const unsigned char *end, signed int *val)
{
  signed int ret;
  size_t len;
  ret=mbedtls_asn1_get_tag(p, end, &len, 0x2);
  size_t tmp_post;
  if(!(ret == 0))
    return ret;

  else
  {
    _Bool tmp_if_expr;
    if(len == 0ull || len >= 5ull)
      tmp_if_expr = (_Bool)1;

    else
      tmp_if_expr = ((signed int)*(*p) & 0x80) != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr)
      return -0x64;

    else
    {
      *val = 0;
      do
      {
        tmp_post = len;
        len = len - 1ull;
        if(!(tmp_post >= 1ull))
          break;

        *val = *val << 8 | (signed int)*(*p);
        *p = *p + 1ll;
      }
      while((_Bool)1);
      return 0;
    }
  }
}

// mbedtls_asn1_get_len
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1parse.c line 54
signed int mbedtls_asn1_get_len(unsigned char **p, const unsigned char *end, size_t *len)
{
  unsigned char *tmp_post;
  if(!(end - *p >= 1ll))
    return -0x60;

  else
  {
    if((0x80 & (signed int)*(*p)) == 0)
    {
      tmp_post = *p;
      *p = *p + 1ll;
      *len = (size_t)*tmp_post;
    }

    else
      switch((signed int)*(*p) & 0x7F)
      {
        case 1:
        {
          if(!(end - *p >= 2ll))
            return -0x60;

          *len = (size_t)(*p)[1ll];
          *p = *p + 2ll;
          break;
        }
        case 2:
        {
          if(!(end - *p >= 3ll))
            return -0x60;

          *len = (size_t)(*p)[1ll] << 8 | (unsigned long long int)(*p)[2ll];
          *p = *p + 3ll;
          break;
        }
        case 3:
        {
          if(!(end - *p >= 4ll))
            return -0x60;

          *len = (size_t)(*p)[1ll] << 16 | (size_t)(*p)[2ll] << 8 | (unsigned long long int)(*p)[3ll];
          *p = *p + 4ll;
          break;
        }
        case 4:
        {
          if(!(end - *p >= 5ll))
            return -0x60;

          *len = (size_t)(*p)[1ll] << 24 | (size_t)(*p)[2ll] << 16 | (size_t)(*p)[3ll] << 8 | (unsigned long long int)(*p)[4ll];
          *p = *p + 5ll;
          break;
        }
        default:
          return -0x64;
      }
    if(!((size_t)(end - *p) >= *len))
      return -0x60;

    else
      return 0;
  }
}

// mbedtls_asn1_get_mpi
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1parse.c line 171
signed int mbedtls_asn1_get_mpi(unsigned char **p, const unsigned char *end, mbedtls_mpi *X)
{
  signed int ret;
  size_t len;
  ret=mbedtls_asn1_get_tag(p, end, &len, 0x2);
  if(!(ret == 0))
    return ret;

  else
  {
    ret=mbedtls_mpi_read_binary(X, *p, len);
    *p = *p + (signed long long int)len;
    return ret;
  }
}

// mbedtls_asn1_get_sequence_of
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1parse.c line 241
signed int mbedtls_asn1_get_sequence_of(unsigned char **p, const unsigned char *end, mbedtls_asn1_sequence *cur, signed int mbedtls_asn1_get_sequence_of$$tag)
{
  signed int ret;
  size_t len;
  mbedtls_asn1_buf *buf;
  ret=mbedtls_asn1_get_tag(p, end, &len, 0x20 | 0x10);
  if(!(ret == 0))
    return ret;

  else
    if(!(*p + (signed long long int)len == end))
      return -0x66;

    else
    {
      while(!(*p >= end))
      {
        buf = &cur->buf;
        buf->tag = (signed int)*(*p);
        ret=mbedtls_asn1_get_tag(p, end, &buf->len, mbedtls_asn1_get_sequence_of$$tag);
        if(!(ret == 0))
          return ret;

        buf->p = *p;
        *p = *p + (signed long long int)buf->len;
        if(!(*p >= end))
        {
          void *return_value=mbedtls_calloc(1ull, sizeof(mbedtls_asn1_sequence) /*32ull*/ );
          cur->next = (mbedtls_asn1_sequence *)return_value;
          if(cur->next == ((struct mbedtls_asn1_sequence *)NULL))
            return -0x6A;

          cur = cur->next;
        }

      }
      cur->next = ((struct mbedtls_asn1_sequence *)NULL);
      if(!(*p == end))
        return -0x66;

      else
        return 0;
    }
}

// mbedtls_asn1_get_tag
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1parse.c line 112
signed int mbedtls_asn1_get_tag(unsigned char **p, const unsigned char *end, size_t *len, signed int mbedtls_asn1_get_tag$$tag)
{
  if(!(end - *p >= 1ll))
    return -0x60;

  else
    if(!((signed int)*(*p) == mbedtls_asn1_get_tag$$tag))
      return -0x62;

    else
    {
      *p = *p + 1ll;
      signed int return_value_mbedtls_asn1_get_len=mbedtls_asn1_get_len(p, end, len);
      return return_value_mbedtls_asn1_get_len;
    }
}

// mbedtls_asn1_store_named_data
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1write.c line 331
mbedtls_asn1_named_data * mbedtls_asn1_store_named_data(mbedtls_asn1_named_data **head, const char *oid, size_t oid_len, const unsigned char *val, size_t val_len)
{
  mbedtls_asn1_named_data *cur=mbedtls_asn1_find_named_data(*head, oid, oid_len);
  if(cur == ((mbedtls_asn1_named_data *)NULL))
  {
    void *return_value=mbedtls_calloc(1ull, sizeof(mbedtls_asn1_named_data) /*64ull*/ );
    cur = (mbedtls_asn1_named_data *)return_value;
    if(cur == ((mbedtls_asn1_named_data *)NULL))
      return ((mbedtls_asn1_named_data *)NULL);

    cur->oid.len = oid_len;
    void *return_value$0=mbedtls_calloc(1ull, oid_len);
    cur->oid.p = (unsigned char *)return_value$0;
    if(cur->oid.p == ((unsigned char *)NULL))
    {
      mbedtls_free((void *)cur);
      return ((mbedtls_asn1_named_data *)NULL);
    }

    memcpy((void *)cur->oid.p, (const void *)oid, oid_len);
    cur->val.len = val_len;
    void *return_value$1=mbedtls_calloc(1ull, val_len);
    cur->val.p = (unsigned char *)return_value$1;
    if(cur->val.p == ((unsigned char *)NULL))
    {
      mbedtls_free((void *)cur->oid.p);
      mbedtls_free((void *)cur);
      return ((mbedtls_asn1_named_data *)NULL);
    }

    cur->next = *head;
    *head = cur;
  }

  else
    if(!(cur->val.len >= val_len))
    {
      void *p=mbedtls_calloc(1ull, val_len);
      if(p == NULL)
        return ((mbedtls_asn1_named_data *)NULL);

      mbedtls_free((void *)cur->val.p);
      cur->val.p = (unsigned char *)p;
      cur->val.len = val_len;
    }

  if(!(val == ((const unsigned char *)NULL)))
    memcpy((void *)cur->val.p, (const void *)val, val_len);

  return cur;
}

// mbedtls_asn1_write_algorithm_identifier
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1write.c line 192
signed int mbedtls_asn1_write_algorithm_identifier(unsigned char **p, unsigned char *start, const char *oid, size_t oid_len, size_t par_len)
{
  signed int ret;
  size_t len=0ull;
  if(par_len == 0ull)
    do
    {
      ret=mbedtls_asn1_write_null(p, start);
      if(!(ret >= 0))
        return ret;

      else
        len = len + (size_t)ret;
    }
    while((_Bool)0);

  else
    len = len + par_len;
  do
  {
    ret=mbedtls_asn1_write_oid(p, start, oid, oid_len);
    if(!(ret >= 0))
      return ret;

    else
      len = len + (size_t)ret;
  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_asn1_write_len(p, start, len);
    if(!(ret >= 0))
      return ret;

    else
      len = len + (size_t)ret;
  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_asn1_write_tag(p, start, (unsigned char)(0x20 | 0x10));
    if(!(ret >= 0))
      return ret;

    else
      len = len + (size_t)ret;
  }
  while((_Bool)0);
  return (signed int)len;
}

// mbedtls_asn1_write_bitstring
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1write.c line 290
signed int mbedtls_asn1_write_bitstring(unsigned char **p, unsigned char *start, const unsigned char *buf, size_t bits)
{
  signed int ret;
  size_t len=0ull;
  size_t size=bits / 8ull + (unsigned long long int)(bits % 8ull != 0ull ? 1 : 0);
  _Bool tmp_if_expr;
  if(!(*p >= start))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = (size_t)(*p - start) < size + 1ull ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return -0x6C;

  else
  {
    len = size + 1ull;
    *p = *p - (signed long long int)size;
    memcpy((void *)*p, (const void *)buf, size);
    *p = *p - 1ll;
    *(*p) = (unsigned char)(size * 8ull - bits);
    do
    {
      ret=mbedtls_asn1_write_len(p, start, len);
      if(!(ret >= 0))
        return ret;

      else
        len = len + (size_t)ret;
    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_asn1_write_tag(p, start, 3);
      if(!(ret >= 0))
        return ret;

      else
        len = len + (size_t)ret;
    }
    while((_Bool)0);
    return (signed int)len;
  }
}

// mbedtls_asn1_write_bool
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1write.c line 213
signed int mbedtls_asn1_write_bool(unsigned char **p, unsigned char *start, signed int boolean)
{
  signed int ret;
  size_t len=0ull;
  if(!(*p - start >= 1ll))
    return -0x6C;

  else
  {
    *p = *p - 1ll;
    *(*p) = (unsigned char)(boolean != 0 ? 255 : 0);
    len = len + 1ull;
    do
    {
      ret=mbedtls_asn1_write_len(p, start, len);
      if(!(ret >= 0))
        return ret;

      else
        len = len + (size_t)ret;
    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_asn1_write_tag(p, start, 1);
      if(!(ret >= 0))
        return ret;

      else
        len = len + (size_t)ret;
    }
    while((_Bool)0);
    return (signed int)len;
  }
}

// mbedtls_asn1_write_ia5_string
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1write.c line 275
signed int mbedtls_asn1_write_ia5_string(unsigned char **p, unsigned char *start, const char *text, size_t text_len)
{
  signed int ret;
  size_t len=0ull;
  do
  {
    ret=mbedtls_asn1_write_raw_buffer(p, start, (const unsigned char *)text, text_len);
    if(!(ret >= 0))
      return ret;

    else
      len = len + (size_t)ret;
  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_asn1_write_len(p, start, len);
    if(!(ret >= 0))
      return ret;

    else
      len = len + (size_t)ret;
  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_asn1_write_tag(p, start, 22);
    if(!(ret >= 0))
      return ret;

    else
      len = len + (size_t)ret;
  }
  while((_Bool)0);
  return (signed int)len;
}

// mbedtls_asn1_write_int
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1write.c line 230
signed int mbedtls_asn1_write_int(unsigned char **p, unsigned char *start, signed int val)
{
  signed int ret;
  size_t len=0ull;
  if(!(*p - start >= 1ll))
    return -0x6C;

  else
  {
    len = len + 1ull;
    *p = *p - 1ll;
    *(*p) = (unsigned char)val;
    if(val >= 1)
    {
      if(!((0x80 & (signed int)*(*p)) == 0))
      {
        if(!(*p - start >= 1ll))
          return -0x6C;

        *p = *p - 1ll;
        *(*p) = 0;
        len = len + 1ull;
      }

    }

    do
    {
      ret=mbedtls_asn1_write_len(p, start, len);
      if(!(ret >= 0))
        return ret;

      else
        len = len + (size_t)ret;
    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_asn1_write_tag(p, start, 2);
      if(!(ret >= 0))
        return ret;

      else
        len = len + (size_t)ret;
    }
    while((_Bool)0);
    return (signed int)len;
  }
}

// mbedtls_asn1_write_len
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1write.c line 42
signed int mbedtls_asn1_write_len(unsigned char **p, unsigned char *start, size_t len)
{
  if(!(len >= 128ull))
  {
    if(!(*p - start >= 1ll))
      return -0x6C;

    *p = *p - 1ll;
    *(*p) = (unsigned char)len;
    return 1;
  }

  else
    if(!(len >= 256ull))
    {
      if(!(*p - start >= 2ll))
        return -0x6C;

      *p = *p - 1ll;
      *(*p) = (unsigned char)len;
      *p = *p - 1ll;
      *(*p) = 129;
      return 2;
    }

    else
      if(!(len >= 65536ull))
      {
        if(!(*p - start >= 3ll))
          return -0x6C;

        *p = *p - 1ll;
        *(*p) = (unsigned char)(len & 255ull);
        *p = *p - 1ll;
        *(*p) = (unsigned char)(len >> 8 & 255ull);
        *p = *p - 1ll;
        *(*p) = 130;
        return 3;
      }

      else
        if(!(len >= 16777216ull))
        {
          if(!(*p - start >= 4ll))
            return -0x6C;

          *p = *p - 1ll;
          *(*p) = (unsigned char)(len & 255ull);
          *p = *p - 1ll;
          *(*p) = (unsigned char)(len >> 8 & 255ull);
          *p = *p - 1ll;
          *(*p) = (unsigned char)(len >> 16 & 255ull);
          *p = *p - 1ll;
          *(*p) = 131;
          return 4;
        }

        else
          if(!(len >= 4294967296ull))
          {
            if(!(*p - start >= 5ll))
              return -0x6C;

            *p = *p - 1ll;
            *(*p) = (unsigned char)(len & 255ull);
            *p = *p - 1ll;
            *(*p) = (unsigned char)(len >> 8 & 255ull);
            *p = *p - 1ll;
            *(*p) = (unsigned char)(len >> 16 & 255ull);
            *p = *p - 1ll;
            *(*p) = (unsigned char)(len >> 24 & 255ull);
            *p = *p - 1ll;
            *(*p) = 132;
            return 5;
          }

          else
            return -0x64;
}

// mbedtls_asn1_write_mpi
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1write.c line 128
signed int mbedtls_asn1_write_mpi(unsigned char **p, unsigned char *start, const mbedtls_mpi *X)
{
  signed int ret;
  size_t len=0ull;
  len=mbedtls_mpi_size(X);
  _Bool tmp_if_expr;
  if(!(*p >= start))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = (size_t)(*p - start) < len ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return -0x6C;

  else
  {
    *p = *p - (signed long long int)len;
    do
    {
      ret=mbedtls_mpi_write_binary(X, *p, len);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    if(X->s == 1)
    {
      if(!((0x80 & (signed int)*(*p)) == 0))
      {
        if(!(*p - start >= 1ll))
          return -0x6C;

        *p = *p - 1ll;
        *(*p) = 0;
        len = len + 1ull;
      }

    }

    do
    {
      ret=mbedtls_asn1_write_len(p, start, len);
      if(!(ret >= 0))
        return ret;

      else
        len = len + (size_t)ret;
    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_asn1_write_tag(p, start, 2);
      if(!(ret >= 0))
        return ret;

      else
        len = len + (size_t)ret;
    }
    while((_Bool)0);
    ret = (signed int)len;

  cleanup:
    ;
    return ret;
  }
}

// mbedtls_asn1_write_null
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1write.c line 165
signed int mbedtls_asn1_write_null(unsigned char **p, unsigned char *start)
{
  signed int ret;
  size_t len=0ull;
  do
  {
    ret=mbedtls_asn1_write_len(p, start, 0ull);
    if(!(ret >= 0))
      return ret;

    else
      len = len + (size_t)ret;
  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_asn1_write_tag(p, start, 5);
    if(!(ret >= 0))
      return ret;

    else
      len = len + (size_t)ret;
  }
  while((_Bool)0);
  return (signed int)len;
}

// mbedtls_asn1_write_octet_string
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1write.c line 317
signed int mbedtls_asn1_write_octet_string(unsigned char **p, unsigned char *start, const unsigned char *buf, size_t size)
{
  signed int ret;
  size_t len=0ull;
  do
  {
    ret=mbedtls_asn1_write_raw_buffer(p, start, buf, size);
    if(!(ret >= 0))
      return ret;

    else
      len = len + (size_t)ret;
  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_asn1_write_len(p, start, len);
    if(!(ret >= 0))
      return ret;

    else
      len = len + (size_t)ret;
  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_asn1_write_tag(p, start, 4);
    if(!(ret >= 0))
      return ret;

    else
      len = len + (size_t)ret;
  }
  while((_Bool)0);
  return (signed int)len;
}

// mbedtls_asn1_write_oid
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1write.c line 178
signed int mbedtls_asn1_write_oid(unsigned char **p, unsigned char *start, const char *oid, size_t oid_len)
{
  signed int ret;
  size_t len=0ull;
  do
  {
    ret=mbedtls_asn1_write_raw_buffer(p, start, (const unsigned char *)oid, oid_len);
    if(!(ret >= 0))
      return ret;

    else
      len = len + (size_t)ret;
  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_asn1_write_len(p, start, len);
    if(!(ret >= 0))
      return ret;

    else
      len = len + (size_t)ret;
  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_asn1_write_tag(p, start, 6);
    if(!(ret >= 0))
      return ret;

    else
      len = len + (size_t)ret;
  }
  while((_Bool)0);
  return (signed int)len;
}

// mbedtls_asn1_write_printable_string
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1write.c line 260
signed int mbedtls_asn1_write_printable_string(unsigned char **p, unsigned char *start, const char *text, size_t text_len)
{
  signed int ret;
  size_t len=0ull;
  do
  {
    ret=mbedtls_asn1_write_raw_buffer(p, start, (const unsigned char *)text, text_len);
    if(!(ret >= 0))
      return ret;

    else
      len = len + (size_t)ret;
  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_asn1_write_len(p, start, len);
    if(!(ret >= 0))
      return ret;

    else
      len = len + (size_t)ret;
  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_asn1_write_tag(p, start, 19);
    if(!(ret >= 0))
      return ret;

    else
      len = len + (size_t)ret;
  }
  while((_Bool)0);
  return (signed int)len;
}

// mbedtls_asn1_write_raw_buffer
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1write.c line 112
signed int mbedtls_asn1_write_raw_buffer(unsigned char **p, unsigned char *start, const unsigned char *buf, size_t size)
{
  size_t len=0ull;
  _Bool tmp_if_expr;
  if(!(*p >= start))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = (size_t)(*p - start) < size ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return -0x6C;

  else
  {
    len = size;
    *p = *p - (signed long long int)len;
    memcpy((void *)*p, (const void *)buf, len);
    return (signed int)len;
  }
}

// mbedtls_asn1_write_tag
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1write.c line 102
signed int mbedtls_asn1_write_tag(unsigned char **p, unsigned char *start, unsigned char mbedtls_asn1_write_tag$$tag)
{
  if(!(*p - start >= 1ll))
    return -0x6C;

  else
  {
    *p = *p - 1ll;
    *(*p) = mbedtls_asn1_write_tag$$tag;
    return 1;
  }
}

// mbedtls_base64_decode
// file ..\..\..\..\lib\third_party\mbedtls\library\base64.c line 144
signed int mbedtls_base64_decode(unsigned char *dst, size_t dlen, size_t *olen, const unsigned char *src, size_t slen)
{
  size_t i;
  size_t n;
  uint32_t j;
  uint32_t x;
  unsigned char *p;
  j = 0u;
  n = (size_t)j;
  i = n;
  for( ; !(i >= slen); i = i + 1ull)
  {
    x = 0u;
    for( ; !(i >= slen); x = x + 1u)
    {
      if(!((signed int)src[(signed long long int)i] == 32))
        break;

      i = i + 1ull;
    }
    if(i == slen)
      break;

    if(slen + -i >= 2ull)
    {
      if((signed int)src[(signed long long int)i] == 13)
      {
        if((signed int)src[1ll + (signed long long int)i] == 10)
          goto __CPROVER_DUMP_L15;

      }

    }

    if(!((signed int)src[(signed long long int)i] == 10))
    {
      if(!(x == 0u))
        return -0x2C;

      if((signed int)src[(signed long long int)i] == 61)
      {
        j = j + 1u;
        if(j >= 3u)
          return -0x2C;

      }

      _Bool tmp_if_expr;
      if((signed int)src[(signed long long int)i] >= 128)
        tmp_if_expr = (_Bool)1;

      else
        tmp_if_expr = (signed int)base64_dec_map[(signed long long int)src[(signed long long int)i]] == 127 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr)
        return -0x2C;

      if(!((signed int)base64_dec_map[(signed long long int)src[(signed long long int)i]] >= 64))
      {
        if(!(j == 0u))
          return -0x2C;

      }

      n = n + 1ull;
    }


  __CPROVER_DUMP_L15:
    ;
  }
  unsigned char *tmp_post;
  unsigned char *tmp_post$0;
  unsigned char *tmp_post$1;
  if(n == 0ull)
  {
    *olen = 0ull;
    return 0;
  }

  else
  {
    n = 6ull * (n >> 3) + (6ull * (n & 7ull) + 7ull >> 3);
    n = n - (size_t)j;
    if(dst == ((unsigned char *)NULL) || !(dlen >= n))
    {
      *olen = n;
      return -0x2A;
    }

    else
    {
      j = 3u;
      x = 0u;
      n = (size_t)x;
      p = dst;
      for( ; i >= 1ull; src = src + 1ll)
      {
        _Bool tmp_if_expr$0;
        if((signed int)*src == 13)
          tmp_if_expr$0 = (_Bool)1;

        else
          tmp_if_expr$0 = (signed int)*src == 10 ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr$1;
        if(tmp_if_expr$0)
          tmp_if_expr$1 = (_Bool)1;

        else
          tmp_if_expr$1 = (signed int)*src == 32 ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr$1)
        {
          j = j - (uint32_t)((signed int)base64_dec_map[(signed long long int)*src] == 64);
          x = x << 6 | (unsigned int)((signed int)base64_dec_map[(signed long long int)*src] & 0x3F);
          n = n + 1ull;
          if(n == 4ull)
          {
            n = 0ull;
            if(j >= 1u)
            {
              tmp_post = p;
              p = p + 1ll;
              *tmp_post = (unsigned char)(x >> 16);
            }

            if(j >= 2u)
            {
              tmp_post$0 = p;
              p = p + 1ll;
              *tmp_post$0 = (unsigned char)(x >> 8);
            }

            if(j >= 3u)
            {
              tmp_post$1 = p;
              p = p + 1ll;
              *tmp_post$1 = (unsigned char)x;
            }

          }

        }

        i = i - 1ull;
      }
      *olen = (size_t)(p - dst);
      return 0;
    }
  }
}

// mbedtls_base64_encode
// file ..\..\..\..\lib\third_party\mbedtls\library\base64.c line 77
signed int mbedtls_base64_encode(unsigned char *dst, size_t dlen, size_t *olen, const unsigned char *src, size_t slen)
{
  size_t i;
  size_t n;
  signed int C1;
  signed int C2;
  signed int C3;
  unsigned char *p;
  const unsigned char *tmp_post$7;
  unsigned char *tmp_post$10;
  unsigned char *tmp_post$11;
  if(slen == 0ull)
  {
    *olen = 0ull;
    return 0;
  }

  else
  {
    n = slen / 3ull + (unsigned long long int)(slen % 3ull != 0ull);
    if(n >= 4611686018427387904ull)
    {
      *olen = (size_t)-1;
      return -0x2A;
    }

    else
    {
      n = n * 4ull;
      if(dst == ((unsigned char *)NULL) || !(dlen >= 1ull + n))
      {
        *olen = n + 1ull;
        return -0x2A;
      }

      else
      {
        n = (slen / 3ull) * 3ull;
        i = 0ull;
        p = dst;
        for( ; !(i >= n); i = i + 3ull)
        {
          const unsigned char *tmp_post=src;
          src = src + 1ll;
          C1 = (signed int)*tmp_post;
          const unsigned char *tmp_post$0=src;
          src = src + 1ll;
          C2 = (signed int)*tmp_post$0;
          const unsigned char *tmp_post$1=src;
          src = src + 1ll;
          C3 = (signed int)*tmp_post$1;
          unsigned char *tmp_post$2=p;
          p = p + 1ll;
          *tmp_post$2 = base64_enc_map[(signed long long int)(C1 >> 2 & 0x3F)];
          unsigned char *tmp_post$3=p;
          p = p + 1ll;
          *tmp_post$3 = base64_enc_map[(signed long long int)(((C1 & 3) << 4) + (C2 >> 4) & 0x3F)];
          unsigned char *tmp_post$4=p;
          p = p + 1ll;
          *tmp_post$4 = base64_enc_map[(signed long long int)(((C2 & 15) << 2) + (C3 >> 6) & 0x3F)];
          unsigned char *tmp_post$5=p;
          p = p + 1ll;
          *tmp_post$5 = base64_enc_map[(signed long long int)(C3 & 0x3F)];
        }
        if(!(i >= slen))
        {
          const unsigned char *tmp_post$6=src;
          src = src + 1ll;
          C1 = (signed int)*tmp_post$6;
          signed int tmp_if_expr;
          if(!(1ull + i >= slen))
          {
            tmp_post$7 = src;
            src = src + 1ll;
            tmp_if_expr = (signed int)*tmp_post$7;
          }

          else
            tmp_if_expr = 0;
          C2 = tmp_if_expr;
          unsigned char *tmp_post$8=p;
          p = p + 1ll;
          *tmp_post$8 = base64_enc_map[(signed long long int)(C1 >> 2 & 0x3F)];
          unsigned char *tmp_post$9=p;
          p = p + 1ll;
          *tmp_post$9 = base64_enc_map[(signed long long int)(((C1 & 3) << 4) + (C2 >> 4) & 0x3F)];
          if(!(1ull + i >= slen))
          {
            tmp_post$10 = p;
            p = p + 1ll;
            *tmp_post$10 = base64_enc_map[(signed long long int)((C2 & 15) << 2 & 0x3F)];
          }

          else
          {
            tmp_post$11 = p;
            p = p + 1ll;
            *tmp_post$11 = 61;
          }
          unsigned char *tmp_post$12=p;
          p = p + 1ll;
          *tmp_post$12 = 61;
        }

        *olen = (size_t)(p - dst);
        *p = 0;
        return 0;
      }
    }
  }
}

// mbedtls_base64_self_test
// file ..\..\..\..\lib\third_party\mbedtls\library\base64.c line 251
signed int mbedtls_base64_self_test(signed int verbose)
{
  size_t len;
  const unsigned char *src;
  unsigned char buffer[128ll];
  if(!(verbose == 0))
    printf("  Base64 encoding test: ");

  src = base64_test_dec;
  signed int return_value_mbedtls_base64_encode=mbedtls_base64_encode(buffer, sizeof(unsigned char [128ll]) /*128ull*/ , &len, src, 64ull);
  _Bool tmp_if_expr;
  signed int return_value_memcmp;
  if(!(return_value_mbedtls_base64_encode == 0))
    tmp_if_expr = (_Bool)1;

  else
  {
    return_value_memcmp=memcmp((const void *)base64_test_enc, (const void *)buffer, 88ull);
    tmp_if_expr = return_value_memcmp != 0 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_memcmp$0;
  if(tmp_if_expr)
  {
    if(!(verbose == 0))
      printf("failed\n");

    return 1;
  }

  else
  {
    if(!(verbose == 0))
      printf("passed\n  Base64 decoding test: ");

    src = base64_test_enc;
    signed int return_value_mbedtls_base64_decode=mbedtls_base64_decode(buffer, sizeof(unsigned char [128ll]) /*128ull*/ , &len, src, 88ull);
    _Bool tmp_if_expr$0;
    if(!(return_value_mbedtls_base64_decode == 0))
      tmp_if_expr$0 = (_Bool)1;

    else
    {
      return_value_memcmp$0=memcmp((const void *)base64_test_dec, (const void *)buffer, 64ull);
      tmp_if_expr$0 = return_value_memcmp$0 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$0)
    {
      if(!(verbose == 0))
        printf("failed\n");

      return 1;
    }

    else
    {
      if(!(verbose == 0))
        printf("passed\n\n");

      return 0;
    }
  }
}

// mbedtls_cipher_auth_decrypt
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 883
signed int mbedtls_cipher_auth_decrypt(mbedtls_cipher_context_t *ctx, const unsigned char *mbedtls_cipher_auth_decrypt$$iv, size_t mbedtls_cipher_auth_decrypt$$iv_len, const unsigned char *ad, size_t ad_len, const unsigned char *input, size_t ilen, unsigned char *output, size_t *olen, const unsigned char *mbedtls_cipher_auth_decrypt$$tag, size_t tag_len)
{
  if((signed int)ctx->cipher_info->mode == 6)
  {
    signed int ret;
    *olen = ilen;
    ret=mbedtls_gcm_auth_decrypt((mbedtls_gcm_context *)ctx->cipher_ctx, ilen, mbedtls_cipher_auth_decrypt$$iv, mbedtls_cipher_auth_decrypt$$iv_len, ad, ad_len, mbedtls_cipher_auth_decrypt$$tag, tag_len, input, output);
    if(ret == -18)
      ret = -0x6300;

    return ret;
  }

  else
    return -0x6080;
}

// mbedtls_cipher_auth_encrypt
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 851
signed int mbedtls_cipher_auth_encrypt(mbedtls_cipher_context_t *ctx, const unsigned char *mbedtls_cipher_auth_encrypt$$iv, size_t mbedtls_cipher_auth_encrypt$$iv_len, const unsigned char *ad, size_t ad_len, const unsigned char *input, size_t ilen, unsigned char *output, size_t *olen, unsigned char *mbedtls_cipher_auth_encrypt$$tag, size_t tag_len)
{
  if((signed int)ctx->cipher_info->mode == 6)
  {
    *olen = ilen;
    signed int return_value_mbedtls_gcm_crypt_and_tag=mbedtls_gcm_crypt_and_tag((mbedtls_gcm_context *)ctx->cipher_ctx, 1, ilen, mbedtls_cipher_auth_encrypt$$iv, mbedtls_cipher_auth_encrypt$$iv_len, ad, ad_len, input, output, tag_len, mbedtls_cipher_auth_encrypt$$tag);
    return return_value_mbedtls_gcm_crypt_and_tag;
  }

  else
    return -0x6080;
}

// mbedtls_cipher_check_tag
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 779
signed int mbedtls_cipher_check_tag(mbedtls_cipher_context_t *ctx, const unsigned char *mbedtls_cipher_check_tag$$tag, size_t tag_len)
{
  signed int ret;
  _Bool tmp_if_expr;
  if(ctx == ((mbedtls_cipher_context_t *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ((const mbedtls_cipher_info_t *)NULL) == ctx->cipher_info ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$0;
  if(tmp_if_expr)
    tmp_if_expr$0 = (_Bool)1;

  else
    tmp_if_expr$0 = 0 != (signed int)ctx->operation ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$0)
    return -0x6100;

  else
    if((signed int)ctx->cipher_info->mode == 6)
    {
      unsigned char check_tag[16ll];
      size_t i;
      signed int diff;
      if(tag_len >= 17ull)
        return -0x6100;

      ret=mbedtls_gcm_finish((mbedtls_gcm_context *)ctx->cipher_ctx, check_tag, tag_len);
      if(!(ret == 0))
        return ret;

      diff = 0;
      i = 0ull;
      for( ; !(i >= tag_len); i = i + 1ull)
        diff = diff | (signed int)mbedtls_cipher_check_tag$$tag[(signed long long int)i] ^ (signed int)check_tag[(signed long long int)i];
      if(!(diff == 0))
        return -0x6300;

      return 0;
    }

    else
      return 0;
}

// mbedtls_cipher_crypt
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 822
signed int mbedtls_cipher_crypt(mbedtls_cipher_context_t *ctx, const unsigned char *mbedtls_cipher_crypt$$iv, size_t mbedtls_cipher_crypt$$iv_len, const unsigned char *input, size_t ilen, unsigned char *output, size_t *olen)
{
  signed int ret;
  size_t finish_olen;
  ret=mbedtls_cipher_set_iv(ctx, mbedtls_cipher_crypt$$iv, mbedtls_cipher_crypt$$iv_len);
  if(!(ret == 0))
    return ret;

  else
  {
    ret=mbedtls_cipher_reset(ctx);
    if(!(ret == 0))
      return ret;

    else
    {
      ret=mbedtls_cipher_update(ctx, input, ilen, output, olen);
      if(!(ret == 0))
        return ret;

      else
      {
        ret=mbedtls_cipher_finish(ctx, output + (signed long long int)*olen, &finish_olen);
        if(!(ret == 0))
          return ret;

        else
        {
          *olen = *olen + finish_olen;
          return 0;
        }
      }
    }
  }
}

// mbedtls_cipher_finish
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 636
signed int mbedtls_cipher_finish(mbedtls_cipher_context_t *ctx, unsigned char *output, size_t *olen)
{
  _Bool tmp_if_expr;
  if(ctx == ((mbedtls_cipher_context_t *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ((const mbedtls_cipher_info_t *)NULL) == ctx->cipher_info ? (_Bool)1 : (_Bool)0;
  unsigned int return_value_mbedtls_cipher_get_block_size;
  unsigned int return_value_mbedtls_cipher_get_block_size$1;
  signed int return_value;
  if(olen == ((size_t *)NULL) || tmp_if_expr)
    return -0x6100;

  else
  {
    *olen = 0ull;
    _Bool tmp_if_expr$0;
    if((signed int)ctx->cipher_info->mode == 3)
      tmp_if_expr$0 = (_Bool)1;

    else
      tmp_if_expr$0 = 5 == (signed int)ctx->cipher_info->mode ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$1;
    if(tmp_if_expr$0)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = 6 == (signed int)ctx->cipher_info->mode ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$2;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = 7 == (signed int)ctx->cipher_info->mode ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      return 0;

    else
      if((signed int)ctx->cipher_info->mode == 1)
      {
        if(!(ctx->unprocessed_len == 0ull))
          return -0x6280;

        return 0;
      }

      else
        if((signed int)ctx->cipher_info->mode == 2)
        {
          signed int ret=0;
          if((signed int)ctx->operation == 1)
          {
            if(ctx->add_padding == ((void (*)(unsigned char *, size_t, size_t))NULL))
            {
              if(!(ctx->unprocessed_len == 0ull))
                return -0x6280;

              return 0;
            }

            signed int return_value_mbedtls_cipher_get_iv_size=mbedtls_cipher_get_iv_size(ctx);
            ctx->add_padding(ctx->unprocessed_data, (size_t)return_value_mbedtls_cipher_get_iv_size, ctx->unprocessed_len);
          }

          else
          {
            return_value_mbedtls_cipher_get_block_size=mbedtls_cipher_get_block_size(ctx);
            if(!((unsigned long long int)return_value_mbedtls_cipher_get_block_size == ctx->unprocessed_len))
            {
              if(ctx->add_padding == ((void (*)(unsigned char *, size_t, size_t))NULL))
              {
                if(ctx->unprocessed_len == 0ull)
                  return 0;

              }

              return -0x6280;
            }

          }
          unsigned int return_value_mbedtls_cipher_get_block_size$0=mbedtls_cipher_get_block_size(ctx);
          ret=ctx->cipher_info->base->cbc_func(ctx->cipher_ctx, ctx->operation, (size_t)return_value_mbedtls_cipher_get_block_size$0, ctx->iv, ctx->unprocessed_data, output);
          if(!(ret == 0))
            return ret;

          if((signed int)ctx->operation == 0)
          {
            return_value_mbedtls_cipher_get_block_size$1=mbedtls_cipher_get_block_size(ctx);
            return_value=ctx->get_padding(output, (size_t)return_value_mbedtls_cipher_get_block_size$1, olen);
            return return_value;
          }

          unsigned int return_value_mbedtls_cipher_get_block_size$2=mbedtls_cipher_get_block_size(ctx);
          *olen = (size_t)return_value_mbedtls_cipher_get_block_size$2;
          return 0;
        }

        else
          return -0x6080;
  }
}

// mbedtls_cipher_free
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 136
void mbedtls_cipher_free(mbedtls_cipher_context_t *ctx)
{
  if(!(ctx == ((mbedtls_cipher_context_t *)NULL)))
  {
    if(!(ctx->cipher_ctx == NULL))
      ctx->cipher_info->base->ctx_free_func(ctx->cipher_ctx);

    mbedtls_zeroize$link3((void *)ctx, sizeof(mbedtls_cipher_context_t) /*88ull*/ );
  }

}

// mbedtls_cipher_get_block_size
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/cipher.h line 374
static inline unsigned int mbedtls_cipher_get_block_size(const mbedtls_cipher_context_t *ctx)
{
  _Bool tmp_if_expr;
  if(ctx == ((const mbedtls_cipher_context_t *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ((const mbedtls_cipher_info_t *)NULL) == ctx->cipher_info ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return 0u;

  else
    return ctx->cipher_info->block_size;
}

// mbedtls_cipher_get_block_size$link1
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\cipher.h line 374
static inline unsigned int mbedtls_cipher_get_block_size$link1(const mbedtls_cipher_context_t *ctx$link1)
{
  _Bool tmp_if_expr$link1;
  if(ctx$link1 == ((const mbedtls_cipher_context_t *)NULL))
    tmp_if_expr$link1 = (_Bool)1;

  else
    tmp_if_expr$link1 = ((const mbedtls_cipher_info_t *)NULL) == ctx$link1->cipher_info ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$link1)
    return 0u;

  else
    return ctx$link1->cipher_info->block_size;
}

// mbedtls_cipher_get_cipher_mode
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\cipher.h line 391
static inline mbedtls_cipher_mode_t mbedtls_cipher_get_cipher_mode(const mbedtls_cipher_context_t *ctx)
{
  _Bool tmp_if_expr;
  if(ctx == ((const mbedtls_cipher_context_t *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ((const mbedtls_cipher_info_t *)NULL) == ctx->cipher_info ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return /*enum*/MBEDTLS_MODE_NONE;

  else
    return ctx->cipher_info->mode;
}

// mbedtls_cipher_get_iv_size
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/cipher.h line 409
static inline signed int mbedtls_cipher_get_iv_size(const mbedtls_cipher_context_t *ctx)
{
  _Bool tmp_if_expr;
  if(ctx == ((const mbedtls_cipher_context_t *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ((const mbedtls_cipher_info_t *)NULL) == ctx->cipher_info ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return 0;

  else
    if(!(ctx->iv_size == 0ull))
      return (signed int)ctx->iv_size;

    else
      return (signed int)ctx->cipher_info->iv_size;
}

// mbedtls_cipher_info_from_string
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 102
const mbedtls_cipher_info_t * mbedtls_cipher_info_from_string(const char *cipher_name)
{
  const mbedtls_cipher_definition_t *def;
  signed int return_value_strcmp;
  if(cipher_name == ((const char *)NULL))
    return ((const mbedtls_cipher_info_t *)NULL);

  else
  {
    def = mbedtls_cipher_definitions;
    for( ; !(def->info == ((const mbedtls_cipher_info_t *)NULL)); def = def + 1ll)
    {
      return_value_strcmp=strcmp(def->info->name, cipher_name);
      if(return_value_strcmp == 0)
        return def->info;

    }
    return ((const mbedtls_cipher_info_t *)NULL);
  }
}

// mbedtls_cipher_info_from_type
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 91
const mbedtls_cipher_info_t * mbedtls_cipher_info_from_type(const mbedtls_cipher_type_t cipher_type)
{
  const mbedtls_cipher_definition_t *def=mbedtls_cipher_definitions;
  for( ; !(def->info == ((const mbedtls_cipher_info_t *)NULL)); def = def + 1ll)
    if(def->type == cipher_type)
      return def->info;

  return ((const mbedtls_cipher_info_t *)NULL);
}

// mbedtls_cipher_info_from_values
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 116
const mbedtls_cipher_info_t * mbedtls_cipher_info_from_values(const mbedtls_cipher_id_t cipher_id, signed int key_bitlen, const mbedtls_cipher_mode_t mode)
{
  const mbedtls_cipher_definition_t *def=mbedtls_cipher_definitions;
  for( ; !(def->info == ((const mbedtls_cipher_info_t *)NULL)); def = def + 1ll)
    if(def->info->base->cipher == cipher_id)
    {
      if(def->info->key_bitlen == (unsigned int)key_bitlen)
      {
        if(def->info->mode == mode)
          return def->info;

      }

    }

  return ((const mbedtls_cipher_info_t *)NULL);
}

// mbedtls_cipher_init
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 131
void mbedtls_cipher_init(mbedtls_cipher_context_t *ctx)
{
  memset((void *)ctx, 0, sizeof(mbedtls_cipher_context_t) /*88ull*/ );
}

// mbedtls_cipher_list
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 70
const signed int * mbedtls_cipher_list(void)
{
  const mbedtls_cipher_definition_t *def;
  signed int *type;
  signed int *tmp_post;
  const mbedtls_cipher_definition_t *tmp_post$0;
  if(supported_init == 0)
  {
    def = mbedtls_cipher_definitions;
    type = mbedtls_cipher_supported;
    for( ; !((signed int)def->type == 0); *tmp_post = (signed int)tmp_post$0->type)
    {
      tmp_post = type;
      type = type + 1ll;
      tmp_post$0 = def;
      def = def + 1ll;
    }
    *type = 0;
    supported_init = 1;
  }

  return mbedtls_cipher_supported;
}

// mbedtls_cipher_reset
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 243
signed int mbedtls_cipher_reset(mbedtls_cipher_context_t *ctx)
{
  _Bool tmp_if_expr;
  if(ctx == ((mbedtls_cipher_context_t *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ((const mbedtls_cipher_info_t *)NULL) == ctx->cipher_info ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return -0x6100;

  else
  {
    ctx->unprocessed_len = 0ull;
    return 0;
  }
}

// mbedtls_cipher_set_iv
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 214
signed int mbedtls_cipher_set_iv(mbedtls_cipher_context_t *ctx, const unsigned char *mbedtls_cipher_set_iv$$iv, size_t mbedtls_cipher_set_iv$$iv_len)
{
  size_t actual_iv_size;
  _Bool tmp_if_expr;
  if(ctx == ((mbedtls_cipher_context_t *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ((const mbedtls_cipher_info_t *)NULL) == ctx->cipher_info ? (_Bool)1 : (_Bool)0;
  if(mbedtls_cipher_set_iv$$iv == ((const unsigned char *)NULL) || tmp_if_expr)
    return -0x6100;

  else
    if(mbedtls_cipher_set_iv$$iv_len >= 17ull)
      return -0x6080;

    else
    {
      if(!((0x1 & ctx->cipher_info->flags) == 0))
        actual_iv_size = mbedtls_cipher_set_iv$$iv_len;

      else
      {
        actual_iv_size = (size_t)ctx->cipher_info->iv_size;
        if(!(mbedtls_cipher_set_iv$$iv_len >= actual_iv_size))
          return -0x6100;

      }
      memcpy((void *)ctx->iv, (const void *)mbedtls_cipher_set_iv$$iv, actual_iv_size);
      ctx->iv_size = actual_iv_size;
      return 0;
    }
}

// mbedtls_cipher_set_padding_mode
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 716
signed int mbedtls_cipher_set_padding_mode(mbedtls_cipher_context_t *ctx, mbedtls_cipher_padding_t mode)
{
  _Bool tmp_if_expr;
  if(ctx == ((mbedtls_cipher_context_t *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = 2 != (signed int)ctx->cipher_info->mode ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return -0x6100;

  else
  {
    switch((signed int)mode)
    {
      case 0:
      {
        ctx->add_padding = add_pkcs_padding;
        ctx->get_padding = get_pkcs_padding;
        break;
      }
      case 1:
      {
        ctx->add_padding = add_one_and_zeros_padding;
        ctx->get_padding = get_one_and_zeros_padding;
        break;
      }
      case 2:
      {
        ctx->add_padding = add_zeros_and_len_padding;
        ctx->get_padding = get_zeros_and_len_padding;
        break;
      }
      case 3:
      {
        ctx->add_padding = add_zeros_padding;
        ctx->get_padding = get_zeros_padding;
        break;
      }
      case 4:
      {
        ctx->add_padding = ((void (*)(unsigned char *, size_t, size_t))NULL);
        ctx->get_padding = get_no_padding;
        break;
      }
      default:
        return -0x6080;
    }
    return 0;
  }
}

// mbedtls_cipher_setkey
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 181
signed int mbedtls_cipher_setkey(mbedtls_cipher_context_t *ctx, const unsigned char *mbedtls_cipher_setkey$$key, signed int key_bitlen, const mbedtls_operation_t operation)
{
  _Bool tmp_if_expr;
  if(ctx == ((mbedtls_cipher_context_t *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ((const mbedtls_cipher_info_t *)NULL) == ctx->cipher_info ? (_Bool)1 : (_Bool)0;
  signed int return_value$0;
  if(tmp_if_expr)
    return -0x6100;

  else
  {
    if((0x2 & ctx->cipher_info->flags) == 0)
    {
      if(!((signed int)ctx->cipher_info->key_bitlen == key_bitlen))
        return -0x6100;

    }

    ctx->key_bitlen = key_bitlen;
    ctx->operation = operation;
    _Bool tmp_if_expr$0;
    if((signed int)operation == 1)
      tmp_if_expr$0 = (_Bool)1;

    else
      tmp_if_expr$0 = 3 == (signed int)ctx->cipher_info->mode ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$1;
    if(tmp_if_expr$0)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = 5 == (signed int)ctx->cipher_info->mode ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      signed int return_value=ctx->cipher_info->base->setkey_enc_func(ctx->cipher_ctx, mbedtls_cipher_setkey$$key, (unsigned int)ctx->key_bitlen);
      return return_value;
    }

    else
      if((signed int)operation == 0)
      {
        return_value$0=ctx->cipher_info->base->setkey_dec_func(ctx->cipher_ctx, mbedtls_cipher_setkey$$key, (unsigned int)ctx->key_bitlen);
        return return_value$0;
      }

      else
        return -0x6100;
  }
}

// mbedtls_cipher_setup
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 155
signed int mbedtls_cipher_setup(mbedtls_cipher_context_t *ctx, const mbedtls_cipher_info_t *cipher_info)
{
  if(ctx == ((mbedtls_cipher_context_t *)NULL) || cipher_info == ((const mbedtls_cipher_info_t *)NULL))
    return -0x6100;

  else
  {
    memset((void *)ctx, 0, sizeof(mbedtls_cipher_context_t) /*88ull*/ );
    ctx->cipher_ctx=cipher_info->base->ctx_alloc_func();
    if(ctx->cipher_ctx == NULL)
      return -0x6180;

    else
    {
      ctx->cipher_info = cipher_info;
      mbedtls_cipher_set_padding_mode(ctx, /*enum*/MBEDTLS_PADDING_PKCS7);
      return 0;
    }
  }
}

// mbedtls_cipher_update
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 270
signed int mbedtls_cipher_update(mbedtls_cipher_context_t *ctx, const unsigned char *input, size_t ilen, unsigned char *output, size_t *olen)
{
  signed int ret;
  size_t block_size=0ull;
  _Bool tmp_if_expr;
  if(ctx == ((mbedtls_cipher_context_t *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ((const mbedtls_cipher_info_t *)NULL) == ctx->cipher_info ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$5;
  if(olen == ((size_t *)NULL) || tmp_if_expr)
    return -0x6100;

  else
  {
    *olen = 0ull;
    unsigned int return_value_mbedtls_cipher_get_block_size=mbedtls_cipher_get_block_size(ctx);
    block_size = (size_t)return_value_mbedtls_cipher_get_block_size;
    if((signed int)ctx->cipher_info->mode == 1)
    {
      if(!(ilen == block_size))
        return -0x6280;

      *olen = ilen;
      ret=ctx->cipher_info->base->ecb_func(ctx->cipher_ctx, ctx->operation, input, output);
      if(!(ret == 0))
        return ret;

      return 0;
    }

    else
      if((signed int)ctx->cipher_info->mode == 6)
      {
        *olen = ilen;
        signed int return_value_mbedtls_gcm_update=mbedtls_gcm_update((mbedtls_gcm_context *)ctx->cipher_ctx, ilen, input, output);
        return return_value_mbedtls_gcm_update;
      }

      else
        if(block_size == 0ull)
          return -0x6380;

        else
        {
          if(input == output)
          {
            if(!(ctx->unprocessed_len == 0ull) || !(ilen % block_size == 0ull))
              return -0x6100;

          }

          if((signed int)ctx->cipher_info->mode == 2)
          {
            size_t copy_len=0ull;
            _Bool tmp_if_expr$0;
            if((signed int)ctx->operation == 0)
              tmp_if_expr$0 = ((void (*)(unsigned char *, size_t, size_t))NULL) != ctx->add_padding ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$0 = (_Bool)0;
            _Bool tmp_if_expr$1;
            if(tmp_if_expr$0)
              tmp_if_expr$1 = ilen <= block_size - ctx->unprocessed_len ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$1 = (_Bool)0;
            _Bool tmp_if_expr$4;
            if(tmp_if_expr$1)
              tmp_if_expr$4 = (_Bool)1;

            else
            {
              if((signed int)ctx->operation == 0)
                tmp_if_expr$2 = ((void (*)(unsigned char *, size_t, size_t))NULL) == ctx->add_padding ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$2 = (_Bool)0;
              if(tmp_if_expr$2)
                tmp_if_expr$3 = ilen < block_size - ctx->unprocessed_len ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$3 = (_Bool)0;
              tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
            }
            _Bool tmp_if_expr$6;
            if(tmp_if_expr$4)
              tmp_if_expr$6 = (_Bool)1;

            else
            {
              if((signed int)ctx->operation == 1)
                tmp_if_expr$5 = ilen < block_size - ctx->unprocessed_len ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$5 = (_Bool)0;
              tmp_if_expr$6 = tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$6)
            {
              memcpy((void *)&ctx->unprocessed_data[(signed long long int)ctx->unprocessed_len], (const void *)input, ilen);
              ctx->unprocessed_len = ctx->unprocessed_len + ilen;
              return 0;
            }

            if(!(ctx->unprocessed_len == 0ull))
            {
              copy_len = block_size - ctx->unprocessed_len;
              memcpy((void *)&ctx->unprocessed_data[(signed long long int)ctx->unprocessed_len], (const void *)input, copy_len);
              ret=ctx->cipher_info->base->cbc_func(ctx->cipher_ctx, ctx->operation, block_size, ctx->iv, ctx->unprocessed_data, output);
              if(!(ret == 0))
                return ret;

              *olen = *olen + block_size;
              output = output + (signed long long int)block_size;
              ctx->unprocessed_len = 0ull;
              input = input + (signed long long int)copy_len;
              ilen = ilen - copy_len;
            }

            if(!(ilen == 0ull))
            {
              if(block_size == 0ull)
                return -0x6380;

              copy_len = ilen % block_size;
              if(copy_len == 0ull)
              {
                if((signed int)ctx->operation == 0)
                {
                  if(!(ctx->add_padding == ((void (*)(unsigned char *, size_t, size_t))NULL)))
                    copy_len = block_size;

                }

              }

              memcpy((void *)ctx->unprocessed_data, (const void *)&input[(signed long long int)(ilen - copy_len)], copy_len);
              ctx->unprocessed_len = ctx->unprocessed_len + copy_len;
              ilen = ilen - copy_len;
            }

            if(!(ilen == 0ull))
            {
              ret=ctx->cipher_info->base->cbc_func(ctx->cipher_ctx, ctx->operation, ilen, ctx->iv, input, output);
              if(!(ret == 0))
                return ret;

              *olen = *olen + ilen;
            }

            return 0;
          }

          else
            if((signed int)ctx->cipher_info->mode == 3)
            {
              ret=ctx->cipher_info->base->cfb_func(ctx->cipher_ctx, ctx->operation, ilen, &ctx->unprocessed_len, ctx->iv, input, output);
              if(!(ret == 0))
                return ret;

              *olen = ilen;
              return 0;
            }

            else
              if((signed int)ctx->cipher_info->mode == 5)
              {
                ret=ctx->cipher_info->base->ctr_func(ctx->cipher_ctx, ilen, &ctx->unprocessed_len, ctx->iv, ctx->unprocessed_data, input, output);
                if(!(ret == 0))
                  return ret;

                *olen = ilen;
                return 0;
              }

              else
                return -0x6080;
        }
  }
}

// mbedtls_cipher_update_ad
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 254
signed int mbedtls_cipher_update_ad(mbedtls_cipher_context_t *ctx, const unsigned char *ad, size_t ad_len)
{
  _Bool tmp_if_expr;
  if(ctx == ((mbedtls_cipher_context_t *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ((const mbedtls_cipher_info_t *)NULL) == ctx->cipher_info ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return -0x6100;

  else
    if((signed int)ctx->cipher_info->mode == 6)
    {
      signed int return_value_mbedtls_gcm_starts=mbedtls_gcm_starts((mbedtls_gcm_context *)ctx->cipher_ctx, (signed int)ctx->operation, ctx->iv, ctx->iv_size, ad, ad_len);
      return return_value_mbedtls_gcm_starts;
    }

    else
      return 0;
}

// mbedtls_cipher_write_tag
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 764
signed int mbedtls_cipher_write_tag(mbedtls_cipher_context_t *ctx, unsigned char *mbedtls_cipher_write_tag$$tag, size_t tag_len)
{
  _Bool tmp_if_expr;
  if(ctx == ((mbedtls_cipher_context_t *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ((const mbedtls_cipher_info_t *)NULL) == ctx->cipher_info ? (_Bool)1 : (_Bool)0;
  signed int return_value_mbedtls_gcm_finish;
  if(mbedtls_cipher_write_tag$$tag == ((unsigned char *)NULL) || tmp_if_expr)
    return -0x6100;

  else
    if(!((signed int)ctx->operation == 1))
      return -0x6100;

    else
      if((signed int)ctx->cipher_info->mode == 6)
      {
        return_value_mbedtls_gcm_finish=mbedtls_gcm_finish((mbedtls_gcm_context *)ctx->cipher_ctx, mbedtls_cipher_write_tag$$tag, tag_len);
        return return_value_mbedtls_gcm_finish;
      }

      else
        return 0;
}

// mbedtls_clz
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 373
static size_t mbedtls_clz(const mbedtls_mpi_uint x)
{
  size_t j;
  mbedtls_mpi_uint mask=1ull << (sizeof(mbedtls_mpi_uint) /*8ull*/  << 3) - 1ull;
  j = 0ull;
  for( ; !(j >= 64ull); j = j + 1ull)
  {
    if(!((mask & x) == 0ull))
      break;

    mask = mask >> 1;
  }
  return j;
}

// mbedtls_ctr_drbg_free
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 119
void mbedtls_ctr_drbg_free(mbedtls_ctr_drbg_context *ctx)
{
  if(!(ctx == ((mbedtls_ctr_drbg_context *)NULL)))
  {
    mbedtls_aes_free(&ctx->aes_ctx);
    mbedtls_zeroize$link4((void *)ctx, sizeof(mbedtls_ctr_drbg_context) /*344ull*/ );
  }

}

// mbedtls_ctr_drbg_init
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 60
void mbedtls_ctr_drbg_init(mbedtls_ctr_drbg_context *ctx)
{
  memset((void *)ctx, 0, sizeof(mbedtls_ctr_drbg_context) /*344ull*/ );
}

// mbedtls_ctr_drbg_random
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 457
signed int mbedtls_ctr_drbg_random(void *p_rng, unsigned char *output, size_t output_len)
{
  signed int ret;
  mbedtls_ctr_drbg_context *ctx=(mbedtls_ctr_drbg_context *)p_rng;
  ret=mbedtls_ctr_drbg_random_with_add((void *)ctx, output, output_len, ((const unsigned char *)NULL), 0ull);
  return ret;
}

// mbedtls_ctr_drbg_random_with_add
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 378
signed int mbedtls_ctr_drbg_random_with_add(void *p_rng, unsigned char *output, size_t output_len, const unsigned char *mbedtls_ctr_drbg_random_with_add$$additional, size_t mbedtls_ctr_drbg_random_with_add$$add_len)
{
  signed int ret=0;
  mbedtls_ctr_drbg_context *ctx=(mbedtls_ctr_drbg_context *)p_rng;
  unsigned char add_input[48ll];
  unsigned char *p=output;
  unsigned char tmp[16ll];
  signed int i;
  size_t use_len;
  if(output_len >= 1025ull)
    return -0x36;

  else
    if(mbedtls_ctr_drbg_random_with_add$$add_len >= 257ull)
      return -0x38;

    else
    {
      memset((void *)add_input, 0, (size_t)(32 + 16));
      _Bool tmp_if_expr;
      if(!(ctx->reseed_interval >= ctx->reseed_counter))
        tmp_if_expr = (_Bool)1;

      else
        tmp_if_expr = ctx->prediction_resistance != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr)
      {
        ret=mbedtls_ctr_drbg_reseed(ctx, mbedtls_ctr_drbg_random_with_add$$additional, mbedtls_ctr_drbg_random_with_add$$add_len);
        if(!(ret == 0))
          return ret;

        mbedtls_ctr_drbg_random_with_add$$add_len = 0ull;
      }

      if(mbedtls_ctr_drbg_random_with_add$$add_len >= 1ull)
      {
        ret=block_cipher_df(add_input, mbedtls_ctr_drbg_random_with_add$$additional, mbedtls_ctr_drbg_random_with_add$$add_len);
        if(!(ret == 0))
          return ret;

        ret=ctr_drbg_update_internal(ctx, add_input);
        if(!(ret == 0))
          return ret;

      }

      for( ; output_len >= 1ull; output_len = output_len - use_len)
      {
        i = 16;
        for( ; i >= 1; i = i - 1)
        {
          ctx->counter[(signed long long int)(i - 1)] = ctx->counter[(signed long long int)(i - 1)] + 1;
          if(!((signed int)ctx->counter[(signed long long int)(-1 + i)] == 0))
            break;

        }
        ret=mbedtls_aes_crypt_ecb(&ctx->aes_ctx, 1, ctx->counter, tmp);
        if(!(ret == 0))
          return ret;

        use_len = output_len > 16ull ? 16ull : output_len;
        memcpy((void *)p, (const void *)tmp, use_len);
        p = p + (signed long long int)use_len;
      }
      ret=ctr_drbg_update_internal(ctx, add_input);
      if(!(ret == 0))
        return ret;

      else
      {
        ctx->reseed_counter = ctx->reseed_counter + 1;
        return 0;
      }
    }
}

// mbedtls_ctr_drbg_reseed
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 325
signed int mbedtls_ctr_drbg_reseed(mbedtls_ctr_drbg_context *ctx, const unsigned char *mbedtls_ctr_drbg_reseed$$additional, size_t len)
{
  unsigned char seed[384ll];
  size_t seedlen=0ull;
  signed int ret;
  _Bool tmp_if_expr;
  if(ctx->entropy_len >= 385ull)
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = len > 384ull - ctx->entropy_len ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return -0x38;

  else
  {
    memset((void *)seed, 0, 384ull);
    signed int return_value=ctx->f_entropy(ctx->p_entropy, seed, ctx->entropy_len);
    if(!(return_value == 0))
      return -0x34;

    else
    {
      seedlen = seedlen + ctx->entropy_len;
      if(!(mbedtls_ctr_drbg_reseed$$additional == ((const unsigned char *)NULL)) && !(len == 0ull))
      {
        memcpy((void *)(seed + (signed long long int)seedlen), (const void *)mbedtls_ctr_drbg_reseed$$additional, len);
        seedlen = seedlen + len;
      }

      ret=block_cipher_df(seed, seed, seedlen);
      if(!(ret == 0))
        return ret;

      else
      {
        ret=ctr_drbg_update_internal(ctx, seed);
        if(!(ret == 0))
          return ret;

        else
        {
          ctx->reseed_counter = 1;
          return 0;
        }
      }
    }
  }
}

// mbedtls_ctr_drbg_seed
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 109
signed int mbedtls_ctr_drbg_seed(mbedtls_ctr_drbg_context *ctx, signed int (*f_entropy)(void *, unsigned char *, size_t), void *p_entropy, const unsigned char *custom, size_t len)
{
  signed int return_value_mbedtls_ctr_drbg_seed_entropy_len=mbedtls_ctr_drbg_seed_entropy_len(ctx, f_entropy, p_entropy, custom, len, 32ull);
  return return_value_mbedtls_ctr_drbg_seed_entropy_len;
}

// mbedtls_ctr_drbg_seed_entropy_len
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 73
signed int mbedtls_ctr_drbg_seed_entropy_len(mbedtls_ctr_drbg_context *ctx, signed int (*f_entropy)(void *, unsigned char *, size_t), void *p_entropy, const unsigned char *custom, size_t len, size_t entropy_len)
{
  signed int ret;
  unsigned char mbedtls_ctr_drbg_seed_entropy_len$$1$$key[32ll];
  memset((void *)mbedtls_ctr_drbg_seed_entropy_len$$1$$key, 0, 32ull);
  mbedtls_aes_init(&ctx->aes_ctx);
  ctx->f_entropy = f_entropy;
  ctx->p_entropy = p_entropy;
  ctx->entropy_len = entropy_len;
  ctx->reseed_interval = 10000;
  ret=mbedtls_aes_setkey_enc(&ctx->aes_ctx, mbedtls_ctr_drbg_seed_entropy_len$$1$$key, (unsigned int)(32 * 8));
  if(!(ret == 0))
    return ret;

  else
  {
    ret=mbedtls_ctr_drbg_reseed(ctx, custom, len);
    if(!(ret == 0))
      return ret;

    else
      return 0;
  }
}

// mbedtls_ctr_drbg_self_test
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 600
signed int mbedtls_ctr_drbg_self_test(signed int verbose)
{
  mbedtls_ctr_drbg_context ctx;
  unsigned char buf[16ll];
  mbedtls_ctr_drbg_init(&ctx);
  if(!(verbose == 0))
    printf("  CTR_DRBG (PR = TRUE) : ");

  test_offset = 0ull;
  signed int return_value_mbedtls_ctr_drbg_seed_entropy_len=mbedtls_ctr_drbg_seed_entropy_len(&ctx, ctr_drbg_self_test_entropy, (void *)entropy_source_pr, nonce_pers_pr, 16ull, 32ull);
  if(!(return_value_mbedtls_ctr_drbg_seed_entropy_len == 0))
  {
    if(!(verbose == 0))
      printf("failed\n");

    return 1;
  }

  else
  {
    mbedtls_ctr_drbg_set_prediction_resistance(&ctx, 1);
    signed int return_value_mbedtls_ctr_drbg_random=mbedtls_ctr_drbg_random((void *)&ctx, buf, 16ull);
    if(!(return_value_mbedtls_ctr_drbg_random == 0))
    {
      if(!(verbose == 0))
        printf("failed\n");

      return 1;
    }

    else
    {
      signed int return_value_mbedtls_ctr_drbg_random$0=mbedtls_ctr_drbg_random((void *)&ctx, buf, 16ull);
      if(!(return_value_mbedtls_ctr_drbg_random$0 == 0))
      {
        if(!(verbose == 0))
          printf("failed\n");

        return 1;
      }

      else
      {
        signed int return_value_memcmp=memcmp((const void *)buf, (const void *)result_pr, 16ull);
        if(!(return_value_memcmp == 0))
        {
          if(!(verbose == 0))
            printf("failed\n");

          return 1;
        }

        else
        {
          mbedtls_ctr_drbg_free(&ctx);
          if(!(verbose == 0))
            printf("passed\n");

          if(!(verbose == 0))
            printf("  CTR_DRBG (PR = FALSE): ");

          mbedtls_ctr_drbg_init(&ctx);
          test_offset = 0ull;
          signed int return_value_mbedtls_ctr_drbg_seed_entropy_len$0=mbedtls_ctr_drbg_seed_entropy_len(&ctx, ctr_drbg_self_test_entropy, (void *)entropy_source_nopr, nonce_pers_nopr, 16ull, 32ull);
          if(!(return_value_mbedtls_ctr_drbg_seed_entropy_len$0 == 0))
          {
            if(!(verbose == 0))
              printf("failed\n");

            return 1;
          }

          else
          {
            signed int return_value_mbedtls_ctr_drbg_random$1=mbedtls_ctr_drbg_random((void *)&ctx, buf, 16ull);
            if(!(return_value_mbedtls_ctr_drbg_random$1 == 0))
            {
              if(!(verbose == 0))
                printf("failed\n");

              return 1;
            }

            else
            {
              signed int return_value_mbedtls_ctr_drbg_reseed=mbedtls_ctr_drbg_reseed(&ctx, ((const unsigned char *)NULL), 0ull);
              if(!(return_value_mbedtls_ctr_drbg_reseed == 0))
              {
                if(!(verbose == 0))
                  printf("failed\n");

                return 1;
              }

              else
              {
                signed int return_value_mbedtls_ctr_drbg_random$2=mbedtls_ctr_drbg_random((void *)&ctx, buf, 16ull);
                if(!(return_value_mbedtls_ctr_drbg_random$2 == 0))
                {
                  if(!(verbose == 0))
                    printf("failed\n");

                  return 1;
                }

                else
                {
                  signed int return_value_memcmp$0=memcmp((const void *)buf, (const void *)result_nopr, 16ull);
                  if(!(return_value_memcmp$0 == 0))
                  {
                    if(!(verbose == 0))
                      printf("failed\n");

                    return 1;
                  }

                  else
                  {
                    mbedtls_ctr_drbg_free(&ctx);
                    if(!(verbose == 0))
                      printf("passed\n");

                    if(!(verbose == 0))
                      printf("\n");

                    return 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// mbedtls_ctr_drbg_set_entropy_len
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 136
void mbedtls_ctr_drbg_set_entropy_len(mbedtls_ctr_drbg_context *ctx, size_t len)
{
  ctx->entropy_len = len;
}

// mbedtls_ctr_drbg_set_prediction_resistance
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 131
void mbedtls_ctr_drbg_set_prediction_resistance(mbedtls_ctr_drbg_context *ctx, signed int resistance)
{
  ctx->prediction_resistance = resistance;
}

// mbedtls_ctr_drbg_set_reseed_interval
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 141
void mbedtls_ctr_drbg_set_reseed_interval(mbedtls_ctr_drbg_context *ctx, signed int interval)
{
  ctx->reseed_interval = interval;
}

// mbedtls_ctr_drbg_update
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 308
void mbedtls_ctr_drbg_update(mbedtls_ctr_drbg_context *ctx, const unsigned char *mbedtls_ctr_drbg_update$$additional, size_t mbedtls_ctr_drbg_update$$add_len)
{
  unsigned char add_input[48ll];
  if(mbedtls_ctr_drbg_update$$add_len >= 1ull)
  {
    if(mbedtls_ctr_drbg_update$$add_len >= 385ull)
      mbedtls_ctr_drbg_update$$add_len = 384ull;

    block_cipher_df(add_input, mbedtls_ctr_drbg_update$$additional, mbedtls_ctr_drbg_update$$add_len);
    ctr_drbg_update_internal(ctx, add_input);
  }

}

// mbedtls_ecdh_calc_secret
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdh.c line 245
signed int mbedtls_ecdh_calc_secret(mbedtls_ecdh_context *ctx, size_t *olen, unsigned char *buf, size_t blen, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
  signed int ret;
  if(ctx == ((mbedtls_ecdh_context *)NULL))
    return -0x4F80;

  else
  {
    ret=mbedtls_ecdh_compute_shared(&ctx->grp, &ctx->z, &ctx->Qp, &ctx->d, f_rng, p_rng);
    if(!(ret == 0))
      return ret;

    else
    {
      size_t return_value_mbedtls_mpi_size=mbedtls_mpi_size(&ctx->z);
      if(!(blen >= return_value_mbedtls_mpi_size))
        return -0x4F80;

      else
      {
        *olen = ctx->grp.pbits / 8ull + (unsigned long long int)(ctx->grp.pbits % 8ull != 0ull);
        signed int return_value_mbedtls_mpi_write_binary=mbedtls_mpi_write_binary(&ctx->z, buf, *olen);
        return return_value_mbedtls_mpi_write_binary;
      }
    }
  }
}

// mbedtls_ecdh_compute_shared
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdh.c line 57
signed int mbedtls_ecdh_compute_shared(mbedtls_ecp_group *grp, mbedtls_mpi *z, const mbedtls_ecp_point *Q, const mbedtls_mpi *d, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
  signed int ret;
  mbedtls_ecp_point P;
  mbedtls_ecp_point_init(&P);
  do
  {
    ret=mbedtls_ecp_check_pubkey(grp, Q);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_ecp_mul(grp, &P, d, Q, f_rng, p_rng);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  signed int return_value_mbedtls_ecp_is_zero=mbedtls_ecp_is_zero(&P);
  if(!(return_value_mbedtls_ecp_is_zero == 0))
    ret = -0x4F80;

  else
    do
    {
      ret=mbedtls_mpi_copy(z, &P.X);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);

cleanup:
  ;
  mbedtls_ecp_point_free(&P);
  return ret;
}

// mbedtls_ecdh_free
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdh.c line 100
void mbedtls_ecdh_free(mbedtls_ecdh_context *ctx)
{
  if(!(ctx == ((mbedtls_ecdh_context *)NULL)))
  {
    mbedtls_ecp_group_free(&ctx->grp);
    mbedtls_ecp_point_free(&ctx->Q);
    mbedtls_ecp_point_free(&ctx->Qp);
    mbedtls_ecp_point_free(&ctx->Vi);
    mbedtls_ecp_point_free(&ctx->Vf);
    mbedtls_mpi_free(&ctx->d);
    mbedtls_mpi_free(&ctx->z);
    mbedtls_mpi_free(&ctx->_d);
  }

}

// mbedtls_ecdh_gen_public
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdh.c line 45
signed int mbedtls_ecdh_gen_public(mbedtls_ecp_group *grp, mbedtls_mpi *d, mbedtls_ecp_point *Q, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
  signed int return_value_mbedtls_ecp_gen_keypair=mbedtls_ecp_gen_keypair(grp, d, Q, f_rng, p_rng);
  return return_value_mbedtls_ecp_gen_keypair;
}

// mbedtls_ecdh_get_params
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdh.c line 177
signed int mbedtls_ecdh_get_params(mbedtls_ecdh_context *ctx, const mbedtls_ecp_keypair *mbedtls_ecdh_get_params$$key, mbedtls_ecdh_side side)
{
  signed int ret=mbedtls_ecp_group_copy(&ctx->grp, &mbedtls_ecdh_get_params$$key->grp);
  signed int return_value_mbedtls_ecp_copy;
  if(!(ret == 0))
    return ret;

  else
    if((signed int)side == 1)
    {
      return_value_mbedtls_ecp_copy=mbedtls_ecp_copy(&ctx->Qp, &mbedtls_ecdh_get_params$$key->Q);
      return return_value_mbedtls_ecp_copy;
    }

    else
      if(!((signed int)side == 0))
        return -0x4F80;

      else
      {
        ret=mbedtls_ecp_copy(&ctx->Q, &mbedtls_ecdh_get_params$$key->Q);
        _Bool tmp_if_expr;
        if(!(ret == 0))
          tmp_if_expr = (_Bool)1;

        else
        {
          ret=mbedtls_mpi_copy(&ctx->d, &mbedtls_ecdh_get_params$$key->d);
          tmp_if_expr = ret != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr)
          return ret;

        else
          return 0;
      }
}

// mbedtls_ecdh_init
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdh.c line 92
void mbedtls_ecdh_init(mbedtls_ecdh_context *ctx)
{
  memset((void *)ctx, 0, sizeof(mbedtls_ecdh_context) /*616ull*/ );
}

// mbedtls_ecdh_make_params
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdh.c line 122
signed int mbedtls_ecdh_make_params(mbedtls_ecdh_context *ctx, size_t *olen, unsigned char *buf, size_t blen, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
  signed int ret;
  size_t grp_len;
  size_t mbedtls_ecdh_make_params$$1$$pt_len;
  _Bool tmp_if_expr;
  if(ctx == ((mbedtls_ecdh_context *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ctx->grp.pbits == 0ull ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return -0x4F80;

  else
  {
    ret=mbedtls_ecdh_gen_public(&ctx->grp, &ctx->d, &ctx->Q, f_rng, p_rng);
    if(!(ret == 0))
      return ret;

    else
    {
      ret=mbedtls_ecp_tls_write_group(&ctx->grp, &grp_len, buf, blen);
      if(!(ret == 0))
        return ret;

      else
      {
        buf = buf + (signed long long int)grp_len;
        blen = blen - grp_len;
        ret=mbedtls_ecp_tls_write_point(&ctx->grp, &ctx->Q, ctx->point_format, &mbedtls_ecdh_make_params$$1$$pt_len, buf, blen);
        if(!(ret == 0))
          return ret;

        else
        {
          *olen = grp_len + mbedtls_ecdh_make_params$$1$$pt_len;
          return 0;
        }
      }
    }
  }
}

// mbedtls_ecdh_make_public
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdh.c line 203
signed int mbedtls_ecdh_make_public(mbedtls_ecdh_context *ctx, size_t *olen, unsigned char *buf, size_t blen, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
  signed int ret;
  _Bool tmp_if_expr;
  if(ctx == ((mbedtls_ecdh_context *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ctx->grp.pbits == 0ull ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return -0x4F80;

  else
  {
    ret=mbedtls_ecdh_gen_public(&ctx->grp, &ctx->d, &ctx->Q, f_rng, p_rng);
    if(!(ret == 0))
      return ret;

    else
    {
      signed int return_value_mbedtls_ecp_tls_write_point=mbedtls_ecp_tls_write_point(&ctx->grp, &ctx->Q, ctx->point_format, olen, buf, blen);
      return return_value_mbedtls_ecp_tls_write_point;
    }
  }
}

// mbedtls_ecdh_read_params
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdh.c line 159
signed int mbedtls_ecdh_read_params(mbedtls_ecdh_context *ctx, const unsigned char **buf, const unsigned char *end)
{
  signed int ret=mbedtls_ecp_tls_read_group(&ctx->grp, buf, (size_t)(end - *buf));
  if(!(ret == 0))
    return ret;

  else
  {
    ret=mbedtls_ecp_tls_read_point(&ctx->grp, &ctx->Qp, buf, (size_t)(end - *buf));
    if(!(ret == 0))
      return ret;

    else
      return 0;
  }
}

// mbedtls_ecdh_read_public
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdh.c line 224
signed int mbedtls_ecdh_read_public(mbedtls_ecdh_context *ctx, const unsigned char *buf, size_t blen)
{
  signed int ret;
  const unsigned char *p=buf;
  if(ctx == ((mbedtls_ecdh_context *)NULL))
    return -0x4F80;

  else
  {
    ret=mbedtls_ecp_tls_read_point(&ctx->grp, &ctx->Qp, &p, blen);
    if(!(ret == 0))
      return ret;

    else
      if(!((size_t)(p - buf) == blen))
        return -0x4F80;

      else
        return 0;
  }
}

// mbedtls_ecdsa_free
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdsa.c line 456
void mbedtls_ecdsa_free(mbedtls_ecdsa_context *ctx)
{
  mbedtls_ecp_keypair_free(ctx);
}

// mbedtls_ecdsa_from_keypair
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdsa.c line 431
signed int mbedtls_ecdsa_from_keypair(mbedtls_ecdsa_context *ctx, const mbedtls_ecp_keypair *mbedtls_ecdsa_from_keypair$$key)
{
  signed int ret=mbedtls_ecp_group_copy(&ctx->grp, &mbedtls_ecdsa_from_keypair$$key->grp);
  _Bool tmp_if_expr;
  if(!(ret == 0))
    tmp_if_expr = (_Bool)1;

  else
  {
    ret=mbedtls_mpi_copy(&ctx->d, &mbedtls_ecdsa_from_keypair$$key->d);
    tmp_if_expr = ret != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$0;
  if(tmp_if_expr)
    tmp_if_expr$0 = (_Bool)1;

  else
  {
    ret=mbedtls_ecp_copy(&ctx->Q, &mbedtls_ecdsa_from_keypair$$key->Q);
    tmp_if_expr$0 = ret != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$0)
    mbedtls_ecdsa_free(ctx);

  return ret;
}

// mbedtls_ecdsa_genkey
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdsa.c line 420
signed int mbedtls_ecdsa_genkey(mbedtls_ecdsa_context *ctx, mbedtls_ecp_group_id gid, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
  signed int return_value_mbedtls_ecp_group_load=mbedtls_ecp_group_load(&ctx->grp, gid);
  _Bool tmp_if_expr;
  signed int return_value_mbedtls_ecp_gen_keypair;
  if(!(return_value_mbedtls_ecp_group_load == 0))
    tmp_if_expr = (_Bool)1;

  else
  {
    return_value_mbedtls_ecp_gen_keypair=mbedtls_ecp_gen_keypair(&ctx->grp, &ctx->d, &ctx->Q, f_rng, p_rng);
    tmp_if_expr = return_value_mbedtls_ecp_gen_keypair != 0 ? (_Bool)1 : (_Bool)0;
  }
  return (signed int)tmp_if_expr;
}

// mbedtls_ecdsa_init
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdsa.c line 448
void mbedtls_ecdsa_init(mbedtls_ecdsa_context *ctx)
{
  mbedtls_ecp_keypair_init(ctx);
}

// mbedtls_ecdsa_read_signature
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdsa.c line 365
signed int mbedtls_ecdsa_read_signature(mbedtls_ecdsa_context *ctx, const unsigned char *hash, size_t hlen, const unsigned char *sig, size_t slen)
{
  signed int ret;
  unsigned char *p=(unsigned char *)sig;
  const unsigned char *end=sig + (signed long long int)slen;
  size_t len;
  mbedtls_mpi r;
  mbedtls_mpi s;
  mbedtls_mpi_init(&r);
  mbedtls_mpi_init(&s);
  ret=mbedtls_asn1_get_tag(&p, end, &len, 0x20 | 0x10);
  _Bool tmp_if_expr;
  if(!(ret == 0))
    ret = ret + -0x4F80;

  else
    if(!(p + (signed long long int)len == end))
      ret = -0x4F80 + -0x66;

    else
    {
      ret=mbedtls_asn1_get_mpi(&p, end, &r);
      if(!(ret == 0))
        tmp_if_expr = (_Bool)1;

      else
      {
        ret=mbedtls_asn1_get_mpi(&p, end, &s);
        tmp_if_expr = ret != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr)
        ret = ret + -0x4F80;

      else
      {
        ret=mbedtls_ecdsa_verify(&ctx->grp, hash, hlen, &ctx->Q, &r, &s);
        if(ret == 0)
        {
          if(!(p == end))
            ret = -0x4C00;

        }

      }
    }

cleanup:
  ;
  mbedtls_mpi_free(&r);
  mbedtls_mpi_free(&s);
  return ret;
}

// mbedtls_ecdsa_sign
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdsa.c line 73
signed int mbedtls_ecdsa_sign(mbedtls_ecp_group *grp, mbedtls_mpi *r, mbedtls_mpi *s, const mbedtls_mpi *d, const unsigned char *buf, size_t blen, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
  signed int ret;
  signed int key_tries;
  signed int sign_tries;
  signed int blind_tries;
  mbedtls_ecp_point R;
  mbedtls_mpi k;
  mbedtls_mpi e;
  mbedtls_mpi t;
  signed int return_value_mbedtls_mpi_cmp_mpi;
  signed int return_value_mbedtls_mpi_cmp_int$1;
  signed int return_value_mbedtls_mpi_cmp_int$2;
  _Bool tmp_if_expr$0;
  signed int return_value_mbedtls_mpi_cmp_mpi$0;
  signed int return_value_mbedtls_mpi_cmp_int$0;
  if(grp->N.p == ((mbedtls_mpi_uint *)NULL))
    return -0x4F80;

  else
  {
    signed int return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(d, 1ll);
    _Bool tmp_if_expr;
    if(!(return_value_mbedtls_mpi_cmp_int >= 0))
      tmp_if_expr = (_Bool)1;

    else
    {
      return_value_mbedtls_mpi_cmp_mpi=mbedtls_mpi_cmp_mpi(d, &grp->N);
      tmp_if_expr = return_value_mbedtls_mpi_cmp_mpi >= 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr)
      return -0x4C80;

    else
    {
      mbedtls_ecp_point_init(&R);
      mbedtls_mpi_init(&k);
      mbedtls_mpi_init(&e);
      mbedtls_mpi_init(&t);
      sign_tries = 0;
      do
      {
        key_tries = 0;
        do
        {

        __CPROVER_DUMP_L6:
          ;
          ret=mbedtls_ecp_gen_keypair(grp, &k, &R, f_rng, p_rng);
          if(!(ret == 0))
            goto cleanup;

          do
          {
            ret=mbedtls_mpi_mod_mpi(r, &R.X, &grp->N);
            if(!(ret == 0))
              goto cleanup;

          }
          while((_Bool)0);
          signed int tmp_post=key_tries;
          key_tries = key_tries + 1;
          if(tmp_post >= 11)
          {
            ret = -0x4D00;
            goto cleanup;
          }

          return_value_mbedtls_mpi_cmp_int$1=mbedtls_mpi_cmp_int(r, 0ll);
        }
        while(return_value_mbedtls_mpi_cmp_int$1 == 0);
        do
        {
          ret=derive_mpi(grp, &e, buf, blen);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        blind_tries = 0;
        do
        {
          size_t n_size=(grp->nbits + 7ull) / 8ull;
          do
          {
            ret=mbedtls_mpi_fill_random(&t, n_size, f_rng, p_rng);
            if(!(ret == 0))
              goto cleanup;

          }
          while((_Bool)0);
          do
          {
            ret=mbedtls_mpi_shift_r(&t, 8ull * n_size - grp->nbits);
            if(!(ret == 0))
              goto cleanup;

          }
          while((_Bool)0);
          blind_tries = blind_tries + 1;
          if(blind_tries >= 31)
            return -0x4D00;

          return_value_mbedtls_mpi_cmp_int$2=mbedtls_mpi_cmp_int(&t, 1ll);
          if(!(return_value_mbedtls_mpi_cmp_int$2 >= 0))
            tmp_if_expr$0 = (_Bool)1;

          else
          {
            return_value_mbedtls_mpi_cmp_mpi$0=mbedtls_mpi_cmp_mpi(&t, &grp->N);
            tmp_if_expr$0 = return_value_mbedtls_mpi_cmp_mpi$0 >= 0 ? (_Bool)1 : (_Bool)0;
          }
        }
        while(tmp_if_expr$0);
        do
        {
          ret=mbedtls_mpi_mul_mpi(s, r, d);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        do
        {
          ret=mbedtls_mpi_add_mpi(&e, &e, s);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        do
        {
          ret=mbedtls_mpi_mul_mpi(&e, &e, &t);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        do
        {
          ret=mbedtls_mpi_mul_mpi(&k, &k, &t);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        do
        {
          ret=mbedtls_mpi_inv_mod(s, &k, &grp->N);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        do
        {
          ret=mbedtls_mpi_mul_mpi(s, s, &e);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        do
        {
          ret=mbedtls_mpi_mod_mpi(s, s, &grp->N);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        signed int tmp_post$0=sign_tries;
        sign_tries = sign_tries + 1;
        if(tmp_post$0 >= 11)
        {
          ret = -0x4D00;
          goto cleanup;
        }

        return_value_mbedtls_mpi_cmp_int$0=mbedtls_mpi_cmp_int(s, 0ll);
      }
      while(return_value_mbedtls_mpi_cmp_int$0 == 0);

    cleanup:
      ;
      mbedtls_ecp_point_free(&R);
      mbedtls_mpi_free(&k);
      mbedtls_mpi_free(&e);
      mbedtls_mpi_free(&t);
      return ret;
    }
  }
}

// mbedtls_ecdsa_sign_det
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdsa.c line 167
signed int mbedtls_ecdsa_sign_det(mbedtls_ecp_group *grp, mbedtls_mpi *r, mbedtls_mpi *s, const mbedtls_mpi *d, const unsigned char *buf, size_t blen, mbedtls_md_type_t md_alg)
{
  signed int ret;
  mbedtls_hmac_drbg_context rng_ctx;
  unsigned char data[132ll];
  size_t grp_len=(grp->nbits + 7ull) / 8ull;
  const mbedtls_md_info_t *md_info;
  mbedtls_mpi h;
  md_info=mbedtls_md_info_from_type(md_alg);
  if(md_info == ((const mbedtls_md_info_t *)NULL))
    return -0x4F80;

  else
  {
    mbedtls_mpi_init(&h);
    mbedtls_hmac_drbg_init(&rng_ctx);
    do
    {
      ret=mbedtls_mpi_write_binary(d, data, grp_len);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=derive_mpi(grp, &h, buf, blen);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_write_binary(&h, data + (signed long long int)grp_len, grp_len);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    mbedtls_hmac_drbg_seed_buf(&rng_ctx, md_info, data, 2ull * grp_len);
    ret=mbedtls_ecdsa_sign(grp, r, s, d, buf, blen, mbedtls_hmac_drbg_random, (void *)&rng_ctx);

  cleanup:
    ;
    mbedtls_hmac_drbg_free(&rng_ctx);
    mbedtls_mpi_free(&h);
    return ret;
  }
}

// mbedtls_ecdsa_verify
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdsa.c line 206
signed int mbedtls_ecdsa_verify(mbedtls_ecp_group *grp, const unsigned char *buf, size_t blen, const mbedtls_ecp_point *Q, const mbedtls_mpi *r, const mbedtls_mpi *s)
{
  signed int ret;
  mbedtls_mpi e;
  mbedtls_mpi s_inv;
  mbedtls_mpi u1;
  mbedtls_mpi u2;
  mbedtls_ecp_point R;
  mbedtls_ecp_point_init(&R);
  mbedtls_mpi_init(&e);
  mbedtls_mpi_init(&s_inv);
  mbedtls_mpi_init(&u1);
  mbedtls_mpi_init(&u2);
  signed int return_value_mbedtls_mpi_cmp_mpi;
  signed int return_value_mbedtls_mpi_cmp_int$0;
  signed int return_value_mbedtls_mpi_cmp_mpi$0;
  signed int return_value_mbedtls_ecp_is_zero;
  signed int return_value_mbedtls_mpi_cmp_mpi$1;
  if(grp->N.p == ((mbedtls_mpi_uint *)NULL))
    return -0x4F80;

  else
  {
    signed int return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(r, 1ll);
    _Bool tmp_if_expr;
    if(!(return_value_mbedtls_mpi_cmp_int >= 0))
      tmp_if_expr = (_Bool)1;

    else
    {
      return_value_mbedtls_mpi_cmp_mpi=mbedtls_mpi_cmp_mpi(r, &grp->N);
      tmp_if_expr = return_value_mbedtls_mpi_cmp_mpi >= 0 ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr$0;
    if(tmp_if_expr)
      tmp_if_expr$0 = (_Bool)1;

    else
    {
      return_value_mbedtls_mpi_cmp_int$0=mbedtls_mpi_cmp_int(s, 1ll);
      tmp_if_expr$0 = return_value_mbedtls_mpi_cmp_int$0 < 0 ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr$1;
    if(tmp_if_expr$0)
      tmp_if_expr$1 = (_Bool)1;

    else
    {
      return_value_mbedtls_mpi_cmp_mpi$0=mbedtls_mpi_cmp_mpi(s, &grp->N);
      tmp_if_expr$1 = return_value_mbedtls_mpi_cmp_mpi$0 >= 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$1)
      ret = -0x4E00;

    else
    {
      do
      {
        ret=mbedtls_ecp_check_pubkey(grp, Q);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=derive_mpi(grp, &e, buf, blen);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_inv_mod(&s_inv, s, &grp->N);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_mul_mpi(&u1, &e, &s_inv);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_mod_mpi(&u1, &u1, &grp->N);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_mul_mpi(&u2, r, &s_inv);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_mod_mpi(&u2, &u2, &grp->N);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_ecp_muladd(grp, &R, &u1, &grp->G, &u2, Q);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      return_value_mbedtls_ecp_is_zero=mbedtls_ecp_is_zero(&R);
      if(!(return_value_mbedtls_ecp_is_zero == 0))
        ret = -0x4E00;

      else
      {
        do
        {
          ret=mbedtls_mpi_mod_mpi(&R.X, &R.X, &grp->N);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        return_value_mbedtls_mpi_cmp_mpi$1=mbedtls_mpi_cmp_mpi(&R.X, r);
        if(!(return_value_mbedtls_mpi_cmp_mpi$1 == 0))
          ret = -0x4E00;

      }
    }

  cleanup:
    ;
    mbedtls_ecp_point_free(&R);
    mbedtls_mpi_free(&e);
    mbedtls_mpi_free(&s_inv);
    mbedtls_mpi_free(&u1);
    mbedtls_mpi_free(&u2);
    return ret;
  }
}

// mbedtls_ecdsa_write_signature
// file ..\..\..\..\lib\third_party\mbedtls\library\ecdsa.c line 316
signed int mbedtls_ecdsa_write_signature(mbedtls_ecdsa_context *ctx, mbedtls_md_type_t md_alg, const unsigned char *hash, size_t hlen, unsigned char *sig, size_t *slen, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
  signed int ret;
  mbedtls_mpi r;
  mbedtls_mpi s;
  mbedtls_mpi_init(&r);
  mbedtls_mpi_init(&s);
  (void)f_rng;
  (void)p_rng;
  do
  {
    ret=mbedtls_ecdsa_sign_det(&ctx->grp, &r, &s, &ctx->d, hash, hlen, md_alg);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=ecdsa_signature_to_asn1(&r, &s, sig, slen);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);

cleanup:
  ;
  mbedtls_mpi_free(&r);
  mbedtls_mpi_free(&s);
  return ret;
}

// mbedtls_ecp_check_privkey
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 1889
signed int mbedtls_ecp_check_privkey(const mbedtls_ecp_group *grp, const mbedtls_mpi *d)
{
  ecp_curve_type return_value_ecp_get_type=ecp_get_type(grp);
  signed int return_value_mbedtls_mpi_cmp_mpi;
  if((signed int)return_value_ecp_get_type == 1)
  {
    signed int return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(d, 1ll);
    _Bool tmp_if_expr;
    if(!(return_value_mbedtls_mpi_cmp_int >= 0))
      tmp_if_expr = (_Bool)1;

    else
    {
      return_value_mbedtls_mpi_cmp_mpi=mbedtls_mpi_cmp_mpi(d, &grp->N);
      tmp_if_expr = return_value_mbedtls_mpi_cmp_mpi >= 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr)
      return -0x4C80;

    else
      return 0;
  }

  return -0x4F80;
}

// mbedtls_ecp_check_pub_priv
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 2035
signed int mbedtls_ecp_check_pub_priv(const mbedtls_ecp_keypair *pub, const mbedtls_ecp_keypair *prv)
{
  signed int ret;
  mbedtls_ecp_point Q;
  mbedtls_ecp_group grp;
  _Bool tmp_if_expr;
  if((signed int)pub->grp.id == 0)
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = pub->grp.id != prv->grp.id ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$0;
  signed int return_value_mbedtls_mpi_cmp_mpi;
  if(tmp_if_expr)
    tmp_if_expr$0 = (_Bool)1;

  else
  {
    return_value_mbedtls_mpi_cmp_mpi=mbedtls_mpi_cmp_mpi(&pub->Q.X, &prv->Q.X);
    tmp_if_expr$0 = return_value_mbedtls_mpi_cmp_mpi != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$1;
  signed int return_value_mbedtls_mpi_cmp_mpi$0;
  if(tmp_if_expr$0)
    tmp_if_expr$1 = (_Bool)1;

  else
  {
    return_value_mbedtls_mpi_cmp_mpi$0=mbedtls_mpi_cmp_mpi(&pub->Q.Y, &prv->Q.Y);
    tmp_if_expr$1 = return_value_mbedtls_mpi_cmp_mpi$0 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$2;
  signed int return_value_mbedtls_mpi_cmp_mpi$1;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    return_value_mbedtls_mpi_cmp_mpi$1=mbedtls_mpi_cmp_mpi(&pub->Q.Z, &prv->Q.Z);
    tmp_if_expr$2 = return_value_mbedtls_mpi_cmp_mpi$1 != 0 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_mbedtls_mpi_cmp_mpi$3;
  signed int return_value_mbedtls_mpi_cmp_mpi$4;
  if(tmp_if_expr$2)
    return -0x4F80;

  else
  {
    mbedtls_ecp_point_init(&Q);
    mbedtls_ecp_group_init(&grp);
    mbedtls_ecp_group_copy(&grp, &prv->grp);
    do
    {
      ret=mbedtls_ecp_mul(&grp, &Q, &prv->d, &prv->grp.G, ((signed int (*)(void *, unsigned char *, size_t))NULL), NULL);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    signed int return_value_mbedtls_mpi_cmp_mpi$2=mbedtls_mpi_cmp_mpi(&Q.X, &prv->Q.X);
    _Bool tmp_if_expr$3;
    if(!(return_value_mbedtls_mpi_cmp_mpi$2 == 0))
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      return_value_mbedtls_mpi_cmp_mpi$3=mbedtls_mpi_cmp_mpi(&Q.Y, &prv->Q.Y);
      tmp_if_expr$3 = return_value_mbedtls_mpi_cmp_mpi$3 != 0 ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr$4;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value_mbedtls_mpi_cmp_mpi$4=mbedtls_mpi_cmp_mpi(&Q.Z, &prv->Q.Z);
      tmp_if_expr$4 = return_value_mbedtls_mpi_cmp_mpi$4 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$4)
      ret = -0x4F80;


  cleanup:
    ;
    mbedtls_ecp_point_free(&Q);
    mbedtls_ecp_group_free(&grp);
    return ret;
  }
}

// mbedtls_ecp_check_pubkey
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 1869
signed int mbedtls_ecp_check_pubkey(const mbedtls_ecp_group *grp, const mbedtls_ecp_point *mbedtls_ecp_check_pubkey$$pt)
{
  signed int return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(&mbedtls_ecp_check_pubkey$$pt->Z, 1ll);
  signed int return_value_ecp_check_pubkey_sw;
  if(!(return_value_mbedtls_mpi_cmp_int == 0))
    return -0x4C80;

  else
  {
    ecp_curve_type return_value_ecp_get_type=ecp_get_type(grp);
    if((signed int)return_value_ecp_get_type == 1)
    {
      return_value_ecp_check_pubkey_sw=ecp_check_pubkey_sw(grp, mbedtls_ecp_check_pubkey$$pt);
      return return_value_ecp_check_pubkey_sw;
    }

    else
      return -0x4F80;
  }
}

// mbedtls_ecp_copy
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 370
signed int mbedtls_ecp_copy(mbedtls_ecp_point *P, const mbedtls_ecp_point *Q)
{
  signed int ret;
  do
  {
    ret=mbedtls_mpi_copy(&P->X, &Q->X);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_copy(&P->Y, &Q->Y);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_copy(&P->Z, &Q->Z);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);

cleanup:
  ;
  return ret;
}

// mbedtls_ecp_curve_info_from_grp_id
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 210
const mbedtls_ecp_curve_info * mbedtls_ecp_curve_info_from_grp_id(mbedtls_ecp_group_id grp_id)
{
  const mbedtls_ecp_curve_info *curve_info=mbedtls_ecp_curve_list();
  for( ; !((signed int)curve_info->grp_id == 0); curve_info = curve_info + 1ll)
    if(curve_info->grp_id == grp_id)
      return curve_info;

  return ((const mbedtls_ecp_curve_info *)NULL);
}

// mbedtls_ecp_curve_info_from_name
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 246
const mbedtls_ecp_curve_info * mbedtls_ecp_curve_info_from_name(const char *name)
{
  const mbedtls_ecp_curve_info *curve_info=mbedtls_ecp_curve_list();
  for( ; !((signed int)curve_info->grp_id == 0); curve_info = curve_info + 1ll)
  {
    signed int return_value_strcmp=strcmp(curve_info->name, name);
    if(return_value_strcmp == 0)
      return curve_info;

  }
  return ((const mbedtls_ecp_curve_info *)NULL);
}

// mbedtls_ecp_curve_info_from_tls_id
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 228
const mbedtls_ecp_curve_info * mbedtls_ecp_curve_info_from_tls_id(uint16_t tls_id)
{
  const mbedtls_ecp_curve_info *curve_info=mbedtls_ecp_curve_list();
  for( ; !((signed int)curve_info->grp_id == 0); curve_info = curve_info + 1ll)
    if(curve_info->tls_id == tls_id)
      return curve_info;

  return ((const mbedtls_ecp_curve_info *)NULL);
}

// mbedtls_ecp_curve_list
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 176
const mbedtls_ecp_curve_info * mbedtls_ecp_curve_list(void)
{
  return ecp_supported_curves;
}

// mbedtls_ecp_gen_key
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 2021
signed int mbedtls_ecp_gen_key(mbedtls_ecp_group_id grp_id, mbedtls_ecp_keypair *mbedtls_ecp_gen_key$$key, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
  signed int ret=mbedtls_ecp_group_load(&mbedtls_ecp_gen_key$$key->grp, grp_id);
  if(!(ret == 0))
    return ret;

  else
  {
    signed int return_value_mbedtls_ecp_gen_keypair=mbedtls_ecp_gen_keypair(&mbedtls_ecp_gen_key$$key->grp, &mbedtls_ecp_gen_key$$key->d, &mbedtls_ecp_gen_key$$key->Q, f_rng, p_rng);
    return return_value_mbedtls_ecp_gen_keypair;
  }
}

// mbedtls_ecp_gen_keypair
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 2010
signed int mbedtls_ecp_gen_keypair(mbedtls_ecp_group *grp, mbedtls_mpi *d, mbedtls_ecp_point *Q, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
  signed int return_value_mbedtls_ecp_gen_keypair_base=mbedtls_ecp_gen_keypair_base(grp, &grp->G, d, Q, f_rng, p_rng);
  return return_value_mbedtls_ecp_gen_keypair_base;
}

// mbedtls_ecp_gen_keypair_base
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 1926
signed int mbedtls_ecp_gen_keypair_base(mbedtls_ecp_group *grp, const mbedtls_ecp_point *G, mbedtls_mpi *d, mbedtls_ecp_point *Q, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
  signed int ret;
  size_t n_size=(grp->nbits + 7ull) / 8ull;
  ecp_curve_type return_value_ecp_get_type=ecp_get_type(grp);
  signed int return_value_mbedtls_mpi_cmp_int;
  _Bool tmp_if_expr;
  signed int return_value_mbedtls_mpi_cmp_mpi;
  if((signed int)return_value_ecp_get_type == 1)
  {
    signed int count=0;
    do
    {

    __CPROVER_DUMP_L1:
      ;
      ret=mbedtls_mpi_fill_random(d, n_size, f_rng, p_rng);
      if(!(ret == 0))
        goto cleanup;

      do
      {
        ret=mbedtls_mpi_shift_r(d, 8ull * n_size - grp->nbits);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      count = count + 1;
      if(count >= 31)
        return -0x4D00;

      return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(d, 1ll);
      if(!(return_value_mbedtls_mpi_cmp_int >= 0))
        tmp_if_expr = (_Bool)1;

      else
      {
        return_value_mbedtls_mpi_cmp_mpi=mbedtls_mpi_cmp_mpi(d, &grp->N);
        tmp_if_expr = return_value_mbedtls_mpi_cmp_mpi >= 0 ? (_Bool)1 : (_Bool)0;
      }
    }
    while(tmp_if_expr);
  }

  else
    return -0x4F80;

cleanup:
  ;
  if(!(ret == 0))
    return ret;

  else
  {
    signed int return_value_mbedtls_ecp_mul=mbedtls_ecp_mul(grp, Q, d, G, f_rng, p_rng);
    return return_value_mbedtls_ecp_mul;
  }
}

// mbedtls_ecp_group_copy
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 385
signed int mbedtls_ecp_group_copy(mbedtls_ecp_group *dst, const mbedtls_ecp_group *src)
{
  signed int return_value_mbedtls_ecp_group_load=mbedtls_ecp_group_load(dst, src->id);
  return return_value_mbedtls_ecp_group_load;
}

// mbedtls_ecp_group_free
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 328
void mbedtls_ecp_group_free(mbedtls_ecp_group *grp)
{
  size_t i;
  if(!(grp == ((mbedtls_ecp_group *)NULL)))
  {
    if(!(grp->h == 1u))
    {
      mbedtls_mpi_free(&grp->P);
      mbedtls_mpi_free(&grp->A);
      mbedtls_mpi_free(&grp->B);
      mbedtls_ecp_point_free(&grp->G);
      mbedtls_mpi_free(&grp->N);
    }

    if(!(grp->T == ((mbedtls_ecp_point *)NULL)))
    {
      i = 0ull;
      for( ; !(i >= grp->T_size); i = i + 1ull)
        mbedtls_ecp_point_free(&grp->T[(signed long long int)i]);
      mbedtls_free((void *)grp->T);
    }

    mbedtls_zeroize$link5((void *)grp, sizeof(mbedtls_ecp_group) /*248ull*/ );
  }

}

// mbedtls_ecp_group_init
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 291
void mbedtls_ecp_group_init(mbedtls_ecp_group *grp)
{
  if(!(grp == ((mbedtls_ecp_group *)NULL)))
    memset((void *)grp, 0, sizeof(mbedtls_ecp_group) /*248ull*/ );

}

// mbedtls_ecp_group_load
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp_curves.c line 747
signed int mbedtls_ecp_group_load(mbedtls_ecp_group *grp, mbedtls_ecp_group_id id)
{
  mbedtls_ecp_group_free(grp);
  grp->id = id;
  signed int return_value_ecp_group_load;
  if((signed int)id == 3)
  {
    grp->modp = ecp_mod_p256;
    return_value_ecp_group_load=ecp_group_load(grp, secp256r1_p, sizeof(const mbedtls_mpi_uint [4ll]) /*32ull*/ , ((const mbedtls_mpi_uint *)NULL), 0ull, secp256r1_b, sizeof(const mbedtls_mpi_uint [4ll]) /*32ull*/ , secp256r1_gx, sizeof(const mbedtls_mpi_uint [4ll]) /*32ull*/ , secp256r1_gy, sizeof(const mbedtls_mpi_uint [4ll]) /*32ull*/ , secp256r1_n, sizeof(const mbedtls_mpi_uint [4ll]) /*32ull*/ );
    return return_value_ecp_group_load;
  }

  else
  {
    mbedtls_ecp_group_free(grp);
    return -0x4E80;
  }
}

// mbedtls_ecp_grp_id_list
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 184
const mbedtls_ecp_group_id * mbedtls_ecp_grp_id_list(void)
{
  static signed int init_done=0;
  if(init_done == 0)
  {
    size_t i=0ull;
    const mbedtls_ecp_curve_info *curve_info=mbedtls_ecp_curve_list();
    for( ; !((signed int)curve_info->grp_id == 0); curve_info = curve_info + 1ll)
    {
      size_t tmp_post=i;
      i = i + 1ull;
      ecp_supported_grp_id[(signed long long int)tmp_post] = curve_info->grp_id;
    }
    ecp_supported_grp_id[(signed long long int)i] = /*enum*/MBEDTLS_ECP_DP_NONE;
    init_done = 1;
  }

  return ecp_supported_grp_id;
}

// mbedtls_ecp_is_zero
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 408
signed int mbedtls_ecp_is_zero(mbedtls_ecp_point *mbedtls_ecp_is_zero$$pt)
{
  signed int return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(&mbedtls_ecp_is_zero$$pt->Z, 0ll);
  return (signed int)(return_value_mbedtls_mpi_cmp_int == 0);
}

// mbedtls_ecp_keypair_free
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 357
void mbedtls_ecp_keypair_free(mbedtls_ecp_keypair *mbedtls_ecp_keypair_free$$key)
{
  if(!(mbedtls_ecp_keypair_free$$key == ((mbedtls_ecp_keypair *)NULL)))
  {
    mbedtls_ecp_group_free(&mbedtls_ecp_keypair_free$$key->grp);
    mbedtls_mpi_free(&mbedtls_ecp_keypair_free$$key->d);
    mbedtls_ecp_point_free(&mbedtls_ecp_keypair_free$$key->Q);
  }

}

// mbedtls_ecp_keypair_init
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 302
void mbedtls_ecp_keypair_init(mbedtls_ecp_keypair *mbedtls_ecp_keypair_init$$key)
{
  if(!(mbedtls_ecp_keypair_init$$key == ((mbedtls_ecp_keypair *)NULL)))
  {
    mbedtls_ecp_group_init(&mbedtls_ecp_keypair_init$$key->grp);
    mbedtls_mpi_init(&mbedtls_ecp_keypair_init$$key->d);
    mbedtls_ecp_point_init(&mbedtls_ecp_keypair_init$$key->Q);
  }

}

// mbedtls_ecp_mul
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 1677
signed int mbedtls_ecp_mul(mbedtls_ecp_group *grp, mbedtls_ecp_point *R, const mbedtls_mpi *m, const mbedtls_ecp_point *P, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
  signed int ret=-0x4F80;
  signed int return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(&P->Z, 1ll);
  if(!(return_value_mbedtls_mpi_cmp_int == 0))
    return -0x4F80;

  else
  {
    ret=mbedtls_ecp_check_privkey(grp, m);
    _Bool tmp_if_expr;
    if(!(ret == 0))
      tmp_if_expr = (_Bool)1;

    else
    {
      ret=mbedtls_ecp_check_pubkey(grp, P);
      tmp_if_expr = ret != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr)
      return ret;

    else
    {
      ecp_curve_type return_value_ecp_get_type=ecp_get_type(grp);
      if((signed int)return_value_ecp_get_type == 1)
        ret=ecp_mul_comb(grp, R, m, P, f_rng, p_rng);

      return ret;
    }
  }
}

// mbedtls_ecp_mul_shortcuts
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 1777
static signed int mbedtls_ecp_mul_shortcuts(mbedtls_ecp_group *grp, mbedtls_ecp_point *R, const mbedtls_mpi *m, const mbedtls_ecp_point *P)
{
  signed int ret;
  signed int return_value_mbedtls_mpi_cmp_int$1=mbedtls_mpi_cmp_int(m, 1ll);
  signed int return_value_mbedtls_mpi_cmp_int$0;
  if(return_value_mbedtls_mpi_cmp_int$1 == 0)
    do
    {
      ret=mbedtls_ecp_copy(R, P);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);

  else
  {
    return_value_mbedtls_mpi_cmp_int$0=mbedtls_mpi_cmp_int(m, (mbedtls_mpi_sint)-1);
    if(return_value_mbedtls_mpi_cmp_int$0 == 0)
    {
      do
      {
        ret=mbedtls_ecp_copy(R, P);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      signed int return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(&R->Y, 0ll);
      if(!(return_value_mbedtls_mpi_cmp_int == 0))
        do
        {
          ret=mbedtls_mpi_sub_mpi(&R->Y, &grp->P, &R->Y);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);

    }

    else
      do
      {
        ret=mbedtls_ecp_mul(grp, R, m, P, ((signed int (*)(void *, unsigned char *, size_t))NULL), NULL);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
  }

cleanup:
  ;
  return ret;
}

// mbedtls_ecp_muladd
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 1807
signed int mbedtls_ecp_muladd(mbedtls_ecp_group *grp, mbedtls_ecp_point *R, const mbedtls_mpi *m, const mbedtls_ecp_point *P, const mbedtls_mpi *n, const mbedtls_ecp_point *Q)
{
  signed int ret;
  mbedtls_ecp_point mP;
  ecp_curve_type return_value_ecp_get_type=ecp_get_type(grp);
  if(!((signed int)return_value_ecp_get_type == 1))
    return -0x4E80;

  else
  {
    mbedtls_ecp_point_init(&mP);
    do
    {
      ret=mbedtls_ecp_mul_shortcuts(grp, &mP, m, P);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_ecp_mul_shortcuts(grp, R, n, Q);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=ecp_add_mixed(grp, R, &mP, R);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=ecp_normalize_jac(grp, R);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);

  cleanup:
    ;
    mbedtls_ecp_point_free(&mP);
    return ret;
  }
}

// mbedtls_ecp_point_cmp
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 416
signed int mbedtls_ecp_point_cmp(const mbedtls_ecp_point *P, const mbedtls_ecp_point *Q)
{
  signed int return_value_mbedtls_mpi_cmp_mpi$1=mbedtls_mpi_cmp_mpi(&P->X, &Q->X);
  signed int return_value_mbedtls_mpi_cmp_mpi$0;
  signed int return_value_mbedtls_mpi_cmp_mpi;
  if(return_value_mbedtls_mpi_cmp_mpi$1 == 0)
  {
    return_value_mbedtls_mpi_cmp_mpi$0=mbedtls_mpi_cmp_mpi(&P->Y, &Q->Y);
    if(return_value_mbedtls_mpi_cmp_mpi$0 == 0)
    {
      return_value_mbedtls_mpi_cmp_mpi=mbedtls_mpi_cmp_mpi(&P->Z, &Q->Z);
      if(return_value_mbedtls_mpi_cmp_mpi == 0)
        return 0;

    }

  }

  return -0x4F80;
}

// mbedtls_ecp_point_free
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 315
void mbedtls_ecp_point_free(mbedtls_ecp_point *mbedtls_ecp_point_free$$pt)
{
  if(!(mbedtls_ecp_point_free$$pt == ((mbedtls_ecp_point *)NULL)))
  {
    mbedtls_mpi_free(&mbedtls_ecp_point_free$$pt->X);
    mbedtls_mpi_free(&mbedtls_ecp_point_free$$pt->Y);
    mbedtls_mpi_free(&mbedtls_ecp_point_free$$pt->Z);
  }

}

// mbedtls_ecp_point_init
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 278
void mbedtls_ecp_point_init(mbedtls_ecp_point *mbedtls_ecp_point_init$$pt)
{
  if(!(mbedtls_ecp_point_init$$pt == ((mbedtls_ecp_point *)NULL)))
  {
    mbedtls_mpi_init(&mbedtls_ecp_point_init$$pt->X);
    mbedtls_mpi_init(&mbedtls_ecp_point_init$$pt->Y);
    mbedtls_mpi_init(&mbedtls_ecp_point_init$$pt->Z);
  }

}

// mbedtls_ecp_point_read_binary
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 504
signed int mbedtls_ecp_point_read_binary(const mbedtls_ecp_group *grp, mbedtls_ecp_point *mbedtls_ecp_point_read_binary$$pt, const unsigned char *buf, size_t ilen)
{
  signed int ret;
  size_t plen;
  signed int return_value_mbedtls_ecp_set_zero;
  if(!(ilen >= 1ull))
    return -0x4F80;

  else
  {
    if((signed int)*buf == 0x0)
    {
      if(ilen == 1ull)
      {
        return_value_mbedtls_ecp_set_zero=mbedtls_ecp_set_zero(mbedtls_ecp_point_read_binary$$pt);
        return return_value_mbedtls_ecp_set_zero;
      }

      else
        return -0x4F80;
    }

    plen=mbedtls_mpi_size(&grp->P);
    if(!((signed int)*buf == 0x4))
      return -0x4E80;

    else
      if(!(ilen == 2ull * plen + 1ull))
        return -0x4F80;

      else
      {
        do
        {
          ret=mbedtls_mpi_read_binary(&mbedtls_ecp_point_read_binary$$pt->X, buf + 1ll, plen);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        do
        {
          ret=mbedtls_mpi_read_binary(&mbedtls_ecp_point_read_binary$$pt->Y, buf + 1ll + (signed long long int)plen, plen);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        do
        {
          ret=mbedtls_mpi_lset(&mbedtls_ecp_point_read_binary$$pt->Z, 1ll);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);

      cleanup:
        ;
        return ret;
      }
  }
}

// mbedtls_ecp_point_read_string
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 432
signed int mbedtls_ecp_point_read_string(mbedtls_ecp_point *P, signed int radix, const char *x, const char *y)
{
  signed int ret;
  do
  {
    ret=mbedtls_mpi_read_string(&P->X, radix, x);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_read_string(&P->Y, radix, y);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_lset(&P->Z, 1ll);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);

cleanup:
  ;
  return ret;
}

// mbedtls_ecp_point_write_binary
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 448
signed int mbedtls_ecp_point_write_binary(const mbedtls_ecp_group *grp, const mbedtls_ecp_point *P, signed int format, size_t *olen, unsigned char *buf, size_t buflen)
{
  signed int ret=0;
  size_t plen;
  if(!(format == 0) && !(format == 1))
    return -0x4F80;

  else
  {
    signed int return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(&P->Z, 0ll);
    if(return_value_mbedtls_mpi_cmp_int == 0)
    {
      if(!(buflen >= 1ull))
        return -0x4F00;

      buf[0ll] = 0;
      *olen = 1ull;
      return 0;
    }

    else
    {
      plen=mbedtls_mpi_size(&grp->P);
      if(format == 0)
      {
        *olen = 2ull * plen + 1ull;
        if(!(buflen >= *olen))
          return -0x4F00;

        buf[0ll] = 4;
        do
        {
          ret=mbedtls_mpi_write_binary(&P->X, buf + 1ll, plen);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        do
        {
          ret=mbedtls_mpi_write_binary(&P->Y, buf + 1ll + (signed long long int)plen, plen);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
      }

      else
        if(format == 1)
        {
          *olen = plen + 1ull;
          if(!(buflen >= *olen))
            return -0x4F00;

          signed int return_value_mbedtls_mpi_get_bit=mbedtls_mpi_get_bit(&P->Y, 0ull);
          buf[0ll] = (unsigned char)(0x2 + return_value_mbedtls_mpi_get_bit);
          do
          {
            ret=mbedtls_mpi_write_binary(&P->X, buf + 1ll, plen);
            if(!(ret == 0))
              goto cleanup;

          }
          while((_Bool)0);
        }


    cleanup:
      ;
      return ret;
    }
  }
}

// mbedtls_ecp_self_test
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 2079
signed int mbedtls_ecp_self_test(signed int verbose)
{
  signed int ret;
  size_t i;
  mbedtls_ecp_group grp;
  mbedtls_ecp_point R;
  mbedtls_ecp_point P;
  mbedtls_mpi m;
  unsigned long int add_c_prev;
  unsigned long int dbl_c_prev;
  unsigned long int mul_c_prev;
  const char *exponents[6ll]={ "000000000000000000000000000000000000000000000001",
    "FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22830",
    "5EA6F389A38B8BC81E767753B15AA5569E1782E30ABE7D25",
    "400000000000000000000000000000000000000000000000",
    "7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
    "555555555555555555555555555555555555555555555555" };
  mbedtls_ecp_group_init(&grp);
  mbedtls_ecp_point_init(&R);
  mbedtls_ecp_point_init(&P);
  mbedtls_mpi_init(&m);
  do
  {
    const mbedtls_ecp_curve_info *return_value_mbedtls_ecp_curve_list=mbedtls_ecp_curve_list();
    ret=mbedtls_ecp_group_load(&grp, return_value_mbedtls_ecp_curve_list->grp_id);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  if(!(verbose == 0))
    printf("  ECP test #1 (constant op_count, base point G): ");

  do
  {
    ret=mbedtls_mpi_lset(&m, 2ll);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_ecp_mul(&grp, &P, &m, &grp.G, ((signed int (*)(void *, unsigned char *, size_t))NULL), NULL);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  add_count = 0ul;
  dbl_count = 0ul;
  mul_count = 0ul;
  do
  {
    ret=mbedtls_mpi_read_string(&m, 16, exponents[0ll]);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_ecp_mul(&grp, &R, &m, &grp.G, ((signed int (*)(void *, unsigned char *, size_t))NULL), NULL);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  i = 1ull;
  for( ; !(i >= 6ull); i = i + 1ull)
  {
    add_c_prev = add_count;
    dbl_c_prev = dbl_count;
    mul_c_prev = mul_count;
    add_count = 0ul;
    dbl_count = 0ul;
    mul_count = 0ul;
    do
    {
      ret=mbedtls_mpi_read_string(&m, 16, exponents[(signed long long int)i]);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_ecp_mul(&grp, &R, &m, &grp.G, ((signed int (*)(void *, unsigned char *, size_t))NULL), NULL);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    if(!(add_count == add_c_prev) || !(dbl_count == dbl_c_prev) || !(mul_count == mul_c_prev))
    {
      if(!(verbose == 0))
        printf("failed (%u)\n", (unsigned int)i);

      ret = 1;
      goto cleanup;
    }

  }
  if(!(verbose == 0))
    printf("passed\n");

  if(!(verbose == 0))
    printf("  ECP test #2 (constant op_count, other point): ");

  add_count = 0ul;
  dbl_count = 0ul;
  mul_count = 0ul;
  do
  {
    ret=mbedtls_mpi_read_string(&m, 16, exponents[0ll]);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_ecp_mul(&grp, &R, &m, &P, ((signed int (*)(void *, unsigned char *, size_t))NULL), NULL);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  i = 1ull;
  for( ; !(i >= 6ull); i = i + 1ull)
  {
    add_c_prev = add_count;
    dbl_c_prev = dbl_count;
    mul_c_prev = mul_count;
    add_count = 0ul;
    dbl_count = 0ul;
    mul_count = 0ul;
    do
    {
      ret=mbedtls_mpi_read_string(&m, 16, exponents[(signed long long int)i]);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_ecp_mul(&grp, &R, &m, &P, ((signed int (*)(void *, unsigned char *, size_t))NULL), NULL);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    if(!(add_count == add_c_prev) || !(dbl_count == dbl_c_prev) || !(mul_count == mul_c_prev))
    {
      if(!(verbose == 0))
        printf("failed (%u)\n", (unsigned int)i);

      ret = 1;
      goto cleanup;
    }

  }
  if(!(verbose == 0))
    printf("passed\n");


cleanup:
  ;
  if(!(verbose == 0) && !(ret >= 0))
    printf("Unexpected error, return code = %08X\n", ret);

  mbedtls_ecp_group_free(&grp);
  mbedtls_ecp_point_free(&R);
  mbedtls_ecp_point_free(&P);
  mbedtls_mpi_free(&m);
  if(!(verbose == 0))
    printf("\n");

  return ret;
}

// mbedtls_ecp_set_zero
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 393
signed int mbedtls_ecp_set_zero(mbedtls_ecp_point *mbedtls_ecp_set_zero$$pt)
{
  signed int ret;
  do
  {
    ret=mbedtls_mpi_lset(&mbedtls_ecp_set_zero$$pt->X, 1ll);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_lset(&mbedtls_ecp_set_zero$$pt->Y, 1ll);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_lset(&mbedtls_ecp_set_zero$$pt->Z, 0ll);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);

cleanup:
  ;
  return ret;
}

// mbedtls_ecp_tls_read_group
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 602
signed int mbedtls_ecp_tls_read_group(mbedtls_ecp_group *grp, const unsigned char **buf, size_t len)
{
  uint16_t tls_id;
  const mbedtls_ecp_curve_info *curve_info;
  if(!(len >= 3ull))
    return -0x4F80;

  else
  {
    const unsigned char *tmp_post=*buf;
    *buf = *buf + 1ll;
    if(!((signed int)*tmp_post == 3))
      return -0x4F80;

    else
    {
      const unsigned char *tmp_post$0=*buf;
      *buf = *buf + 1ll;
      tls_id = (uint16_t)*tmp_post$0;
      tls_id = tls_id << 8;
      const unsigned char *tmp_post$1=*buf;
      *buf = *buf + 1ll;
      tls_id = tls_id | (uint16_t)*tmp_post$1;
      curve_info=mbedtls_ecp_curve_info_from_tls_id(tls_id);
      if(curve_info == ((const mbedtls_ecp_curve_info *)NULL))
        return -0x4E80;

      else
      {
        signed int return_value_mbedtls_ecp_group_load=mbedtls_ecp_group_load(grp, curve_info->grp_id);
        return return_value_mbedtls_ecp_group_load;
      }
    }
  }
}

// mbedtls_ecp_tls_read_point
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 543
signed int mbedtls_ecp_tls_read_point(const mbedtls_ecp_group *grp, mbedtls_ecp_point *mbedtls_ecp_tls_read_point$$pt, const unsigned char **buf, size_t buf_len)
{
  unsigned char data_len;
  const unsigned char *buf_start;
  if(!(buf_len >= 2ull))
    return -0x4F80;

  else
  {
    const unsigned char *tmp_post=*buf;
    *buf = *buf + 1ll;
    data_len = *tmp_post;
    if(!(18446744073709551615ull + buf_len >= (unsigned long long int)data_len) || !((signed int)data_len >= 1))
      return -0x4F80;

    else
    {
      buf_start = *buf;
      *buf = *buf + (signed long long int)data_len;
      signed int return_value_mbedtls_ecp_point_read_binary=mbedtls_ecp_point_read_binary(grp, mbedtls_ecp_tls_read_point$$pt, buf_start, (size_t)data_len);
      return return_value_mbedtls_ecp_point_read_binary;
    }
  }
}

// mbedtls_ecp_tls_write_group
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 635
signed int mbedtls_ecp_tls_write_group(const mbedtls_ecp_group *grp, size_t *olen, unsigned char *buf, size_t blen)
{
  const mbedtls_ecp_curve_info *curve_info=mbedtls_ecp_curve_info_from_grp_id(grp->id);
  if(curve_info == ((const mbedtls_ecp_curve_info *)NULL))
    return -0x4F80;

  else
  {
    *olen = 3ull;
    if(!(blen >= *olen))
      return -0x4F00;

    else
    {
      unsigned char *tmp_post=buf;
      buf = buf + 1ll;
      *tmp_post = 3;
      buf[0ll] = (unsigned char)((signed int)curve_info->tls_id >> 8);
      buf[1ll] = (unsigned char)((signed int)curve_info->tls_id & 0xFF);
      return 0;
    }
  }
}

// mbedtls_ecp_tls_write_point
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 574
signed int mbedtls_ecp_tls_write_point(const mbedtls_ecp_group *grp, const mbedtls_ecp_point *mbedtls_ecp_tls_write_point$$pt, signed int format, size_t *olen, unsigned char *buf, size_t blen)
{
  signed int ret;
  if(!(blen >= 1ull))
    return -0x4F80;

  else
  {
    ret=mbedtls_ecp_point_write_binary(grp, mbedtls_ecp_tls_write_point$$pt, format, olen, buf + 1ll, blen - 1ull);
    if(!(ret == 0))
      return ret;

    else
    {
      buf[0ll] = (unsigned char)*olen;
      *olen = *olen + 1ull;
      return 0;
    }
  }
}

// mbedtls_entropy_add_source
// file ..\..\..\..\lib\third_party\mbedtls\library\entropy.c line 147
signed int mbedtls_entropy_add_source(mbedtls_entropy_context *ctx, mbedtls_entropy_f_source_ptr f_source, void *p_source, size_t threshold, signed int strong)
{
  signed int idx;
  signed int ret=0;
  idx = ctx->source_count;
  if(idx >= 20)
    ret = -0x3E;

  else
  {
    ctx->source[(signed long long int)idx].f_source = f_source;
    ctx->source[(signed long long int)idx].p_source = p_source;
    ctx->source[(signed long long int)idx].threshold = threshold;
    ctx->source[(signed long long int)idx].strong = strong;
    ctx->source_count = ctx->source_count + 1;
  }

exit:
  ;
  return ret;
}

// mbedtls_entropy_free
// file ..\..\..\..\lib\third_party\mbedtls\library\entropy.c line 126
void mbedtls_entropy_free(mbedtls_entropy_context *ctx)
{
  mbedtls_sha256_free(&ctx->accumulator);
  ctx->source_count = 0;
  mbedtls_zeroize$link6((void *)ctx->source, sizeof(mbedtls_entropy_source_state [20ll]) /*800ull*/ );
  ctx->accumulator_started = 0;
}

// mbedtls_entropy_func
// file ..\..\..\..\lib\third_party\mbedtls\library\entropy.c line 330
signed int mbedtls_entropy_func(void *data, unsigned char *output, size_t len)
{
  signed int ret;
  signed int count=0;
  signed int i;
  signed int done;
  mbedtls_entropy_context *ctx=(mbedtls_entropy_context *)data;
  unsigned char buf[32ll];
  if(len >= 33ull)
    return -0x3C;

  else
  {
    do
    {
      signed int tmp_post=count;
      count = count + 1;
      if(tmp_post >= 257)
      {
        ret = -0x3C;
        goto exit;
      }

      ret=entropy_gather_internal(ctx);
      if(!(ret == 0))
        goto exit;

      done = 1;
      i = 0;
      for( ; !(i >= ctx->source_count); i = i + 1)
        if(!(ctx->source[(signed long long int)i].size >= ctx->source[(signed long long int)i].threshold))
          done = 0;

    }
    while(done == 0);
    memset((void *)buf, 0, 32ull);
    ret=mbedtls_sha256_finish_ret(&ctx->accumulator, buf);
    if(ret == 0)
    {
      mbedtls_sha256_free(&ctx->accumulator);
      mbedtls_sha256_init(&ctx->accumulator);
      ret=mbedtls_sha256_starts_ret(&ctx->accumulator, 0);
      if(ret == 0)
      {
        ret=mbedtls_sha256_update_ret(&ctx->accumulator, buf, 32ull);
        if(ret == 0)
        {
          ret=mbedtls_sha256_ret(buf, 32ull, buf, 0);
          if(ret == 0)
          {
            i = 0;
            for( ; !(i >= ctx->source_count); i = i + 1)
              ctx->source[(signed long long int)i].size = 0ull;
            memcpy((void *)output, (const void *)buf, len);
            ret = 0;
          }

        }

      }

    }


  exit:
    ;
    mbedtls_zeroize$link6((void *)buf, sizeof(unsigned char [32ll]) /*32ull*/ );
    return ret;
  }
}

// mbedtls_entropy_gather
// file ..\..\..\..\lib\third_party\mbedtls\library\entropy.c line 311
signed int mbedtls_entropy_gather(mbedtls_entropy_context *ctx)
{
  signed int ret=entropy_gather_internal(ctx);
  return ret;
}

// mbedtls_entropy_init
// file ..\..\..\..\lib\third_party\mbedtls\library\entropy.c line 69
void mbedtls_entropy_init(mbedtls_entropy_context *ctx)
{
  ctx->source_count = 0;
  memset((void *)ctx->source, 0, sizeof(mbedtls_entropy_source_state [20ll]) /*800ull*/ );
  ctx->accumulator_started = 0;
  mbedtls_sha256_init(&ctx->accumulator);
  mbedtls_entropy_add_source(ctx, mbedtls_hardware_poll, NULL, 32ull, 1);
}

// mbedtls_entropy_self_test
// file ..\..\..\..\lib\third_party\mbedtls\library\entropy.c line 648
signed int mbedtls_entropy_self_test(signed int verbose)
{
  signed int ret=1;
  mbedtls_entropy_context ctx;
  unsigned char buf[32ll]={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  unsigned char acc[32ll]={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  size_t i;
  size_t j;
  if(!(verbose == 0))
    printf("  ENTROPY test: ");

  mbedtls_entropy_init(&ctx);
  ret=mbedtls_entropy_gather(&ctx);
  if(ret == 0)
  {
    ret=mbedtls_entropy_add_source(&ctx, entropy_dummy_source, NULL, 16ull, 0);
    if(ret == 0)
    {
      ret=mbedtls_entropy_update_manual(&ctx, buf, sizeof(unsigned char [32ll]) /*32ull*/ );
      if(ret == 0)
      {
        i = 0ull;
        for( ; !(i >= 8ull); i = i + 1ull)
        {
          ret=mbedtls_entropy_func((void *)&ctx, buf, sizeof(unsigned char [32ll]) /*32ull*/ );
          if(!(ret == 0))
            goto cleanup;

          j = 0ull;
          for( ; !(j >= sizeof(unsigned char [32ll]) /*32ull*/ ); j = j + 1ull)
            acc[(signed long long int)j] = acc[(signed long long int)j] | buf[(signed long long int)j];
        }
        j = 0ull;
        for( ; !(j >= sizeof(unsigned char [32ll]) /*32ull*/ ); j = j + 1ull)
          if((signed int)acc[(signed long long int)j] == 0)
          {
            ret = 1;
            goto cleanup;
          }

        ret=mbedtls_entropy_source_self_test(0);
      }

    }

  }


cleanup:
  ;
  mbedtls_entropy_free(&ctx);
  if(!(verbose == 0))
  {
    if(!(ret == 0))
      printf("failed\n");

    else
      printf("passed\n");
    printf("\n");
  }

  return (signed int)(ret != 0);
}

// mbedtls_entropy_source_self_test
// file ..\..\..\..\lib\third_party\mbedtls\library\entropy.c line 600
signed int mbedtls_entropy_source_self_test(signed int verbose)
{
  signed int ret=0;
  unsigned char buf0[(signed long long int)(sizeof(unsigned long long int) * 2ul) /*16ll*/ ];
  unsigned char buf1[(signed long long int)(sizeof(unsigned long long int) * 2ul) /*16ll*/ ];
  if(!(verbose == 0))
    printf("  ENTROPY_BIAS test: ");

  memset((void *)buf0, 0x0, sizeof(unsigned char [16ll]) /*16ull*/ );
  memset((void *)buf1, 0x0, sizeof(unsigned char [16ll]) /*16ull*/ );
  ret=mbedtls_entropy_source_self_test_gather(buf0, sizeof(unsigned char [16ll]) /*16ull*/ );
  signed int return_value_memcmp;
  if(ret == 0)
  {
    ret=mbedtls_entropy_source_self_test_gather(buf1, sizeof(unsigned char [16ll]) /*16ull*/ );
    if(ret == 0)
    {
      ret=mbedtls_entropy_source_self_test_check_bits(buf0, sizeof(unsigned char [16ll]) /*16ull*/ );
      if(ret == 0)
      {
        ret=mbedtls_entropy_source_self_test_check_bits(buf1, sizeof(unsigned char [16ll]) /*16ull*/ );
        if(ret == 0)
        {
          return_value_memcmp=memcmp((const void *)buf0, (const void *)buf1, sizeof(unsigned char [16ll]) /*16ull*/ );
          ret = (signed int)(return_value_memcmp == 0);
        }

      }

    }

  }


cleanup:
  ;
  if(!(verbose == 0))
  {
    if(!(ret == 0))
      printf("failed\n");

    else
      printf("passed\n");
    printf("\n");
  }

  return (signed int)(ret != 0);
}

// mbedtls_entropy_source_self_test_check_bits
// file ..\..\..\..\lib\third_party\mbedtls\library\entropy.c line 573
static signed int mbedtls_entropy_source_self_test_check_bits(const unsigned char *buf, size_t buf_len)
{
  unsigned char set=255;
  unsigned char unset=0;
  size_t i=0ull;
  for( ; !(i >= buf_len); i = i + 1ull)
  {
    set = set & buf[(signed long long int)i];
    unset = unset | buf[(signed long long int)i];
  }
  return (signed int)((signed int)set == 0xFF || (signed int)unset == 0x0);
}

// mbedtls_entropy_source_self_test_gather
// file ..\..\..\..\lib\third_party\mbedtls\library\entropy.c line 547
static signed int mbedtls_entropy_source_self_test_gather(unsigned char *buf, size_t buf_len)
{
  signed int ret=0;
  size_t entropy_len=0ull;
  size_t olen=0ull;
  size_t attempts=buf_len;
  for( ; attempts >= 1ull && !(entropy_len >= buf_len); attempts = attempts - 1ull)
  {
    ret=mbedtls_hardware_poll(NULL, buf + (signed long long int)entropy_len, buf_len - entropy_len, &olen);
    if(!(ret == 0))
      return ret;

    entropy_len = entropy_len + olen;
  }
  if(!(entropy_len >= buf_len))
    ret = 1;

  return ret;
}

// mbedtls_entropy_update_manual
// file ..\..\..\..\lib\third_party\mbedtls\library\entropy.c line 240
signed int mbedtls_entropy_update_manual(mbedtls_entropy_context *ctx, const unsigned char *data, size_t len)
{
  signed int ret=entropy_update(ctx, 20, data, len);
  return ret;
}

// mbedtls_gcm_auth_decrypt
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 472
signed int mbedtls_gcm_auth_decrypt(mbedtls_gcm_context *ctx, size_t length, const unsigned char *mbedtls_gcm_auth_decrypt$$iv, size_t mbedtls_gcm_auth_decrypt$$iv_len, const unsigned char *add, size_t mbedtls_gcm_auth_decrypt$$add_len, const unsigned char *mbedtls_gcm_auth_decrypt$$tag, size_t tag_len, const unsigned char *input, unsigned char *output)
{
  signed int ret;
  unsigned char check_tag[16ll];
  size_t i;
  signed int diff;
  ret=mbedtls_gcm_crypt_and_tag(ctx, 0, length, mbedtls_gcm_auth_decrypt$$iv, mbedtls_gcm_auth_decrypt$$iv_len, add, mbedtls_gcm_auth_decrypt$$add_len, input, output, tag_len, check_tag);
  if(!(ret == 0))
    return ret;

  else
  {
    diff = 0;
    i = 0ull;
    for( ; !(i >= tag_len); i = i + 1ull)
      diff = diff | (signed int)mbedtls_gcm_auth_decrypt$$tag[(signed long long int)i] ^ (signed int)check_tag[(signed long long int)i];
    if(!(diff == 0))
    {
      mbedtls_zeroize$link7((void *)output, length);
      return -0x12;
    }

    else
      return 0;
  }
}

// mbedtls_gcm_crypt_and_tag
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 446
signed int mbedtls_gcm_crypt_and_tag(mbedtls_gcm_context *ctx, signed int mode, size_t length, const unsigned char *mbedtls_gcm_crypt_and_tag$$iv, size_t mbedtls_gcm_crypt_and_tag$$iv_len, const unsigned char *add, size_t mbedtls_gcm_crypt_and_tag$$add_len, const unsigned char *input, unsigned char *output, size_t tag_len, unsigned char *mbedtls_gcm_crypt_and_tag$$tag)
{
  signed int ret=mbedtls_gcm_starts(ctx, mode, mbedtls_gcm_crypt_and_tag$$iv, mbedtls_gcm_crypt_and_tag$$iv_len, add, mbedtls_gcm_crypt_and_tag$$add_len);
  if(!(ret == 0))
    return ret;

  else
  {
    ret=mbedtls_gcm_update(ctx, length, input, output);
    if(!(ret == 0))
      return ret;

    else
    {
      ret=mbedtls_gcm_finish(ctx, mbedtls_gcm_crypt_and_tag$$tag, tag_len);
      if(!(ret == 0))
        return ret;

      else
        return 0;
    }
  }
}

// mbedtls_gcm_finish
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 411
signed int mbedtls_gcm_finish(mbedtls_gcm_context *ctx, unsigned char *mbedtls_gcm_finish$$tag, size_t tag_len)
{
  unsigned char work_buf[16ll];
  size_t i;
  uint64_t orig_len=ctx->len * 8ull;
  uint64_t orig_add_len=ctx->add_len * 8ull;
  if(tag_len >= 17ull || !(tag_len >= 4ull))
    return -0x14;

  else
  {
    memcpy((void *)mbedtls_gcm_finish$$tag, (const void *)ctx->base_ectr, tag_len);
    if(!(orig_add_len == 0ull) || !(orig_len == 0ull))
    {
      memset((void *)work_buf, 0x0, 16ull);
      work_buf[0ll] = (unsigned char)((orig_add_len >> 32) >> 24);
      work_buf[(signed long long int)(0 + 1)] = (unsigned char)((orig_add_len >> 32) >> 16);
      work_buf[(signed long long int)(0 + 2)] = (unsigned char)((orig_add_len >> 32) >> 8);
      work_buf[(signed long long int)(0 + 3)] = (unsigned char)(orig_add_len >> 32);
      work_buf[4ll] = (unsigned char)(orig_add_len >> 24);
      work_buf[(signed long long int)(4 + 1)] = (unsigned char)(orig_add_len >> 16);
      work_buf[(signed long long int)(4 + 2)] = (unsigned char)(orig_add_len >> 8);
      work_buf[(signed long long int)(4 + 3)] = (unsigned char)orig_add_len;
      work_buf[8ll] = (unsigned char)((orig_len >> 32) >> 24);
      work_buf[(signed long long int)(8 + 1)] = (unsigned char)((orig_len >> 32) >> 16);
      work_buf[(signed long long int)(8 + 2)] = (unsigned char)((orig_len >> 32) >> 8);
      work_buf[(signed long long int)(8 + 3)] = (unsigned char)(orig_len >> 32);
      work_buf[12ll] = (unsigned char)(orig_len >> 24);
      work_buf[(signed long long int)(12 + 1)] = (unsigned char)(orig_len >> 16);
      work_buf[(signed long long int)(12 + 2)] = (unsigned char)(orig_len >> 8);
      work_buf[(signed long long int)(12 + 3)] = (unsigned char)orig_len;
      i = 0ull;
      for( ; !(i >= 16ull); i = i + 1ull)
        ctx->buf[(signed long long int)i] = ctx->buf[(signed long long int)i] ^ work_buf[(signed long long int)i];
      gcm_mult(ctx, ctx->buf, ctx->buf);
      i = 0ull;
      for( ; !(i >= tag_len); i = i + 1ull)
        mbedtls_gcm_finish$$tag[(signed long long int)i] = mbedtls_gcm_finish$$tag[(signed long long int)i] ^ ctx->buf[(signed long long int)i];
    }

    return 0;
  }
}

// mbedtls_gcm_free
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 508
void mbedtls_gcm_free(mbedtls_gcm_context *ctx)
{
  mbedtls_cipher_free(&ctx->cipher_ctx);
  mbedtls_zeroize$link7((void *)ctx, sizeof(mbedtls_gcm_context) /*416ull*/ );
}

// mbedtls_gcm_init
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 91
void mbedtls_gcm_init(mbedtls_gcm_context *ctx)
{
  memset((void *)ctx, 0, sizeof(mbedtls_gcm_context) /*416ull*/ );
}

// mbedtls_gcm_self_test
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 744
signed int mbedtls_gcm_self_test(signed int verbose)
{
  mbedtls_gcm_context ctx;
  unsigned char buf[64ll];
  unsigned char tag_buf[16ll];
  signed int i;
  signed int j;
  signed int ret;
  mbedtls_cipher_id_t cipher=/*enum*/MBEDTLS_CIPHER_ID_AES;
  j = 0;
  signed int return_value_memcmp$0;
  signed int return_value_memcmp$2;
  signed int return_value_memcmp$4;
  signed int return_value_memcmp$6;
  for( ; !(j >= 3); j = j + 1)
  {
    signed int key_len=128 + 64 * j;
    i = 0;
    for( ; !(i >= 6); i = i + 1)
    {
      mbedtls_gcm_init(&ctx);
      if(!(verbose == 0))
        printf("  AES-GCM-%3d #%d (%s): ", key_len, i, (const void *)"enc");

      ret=mbedtls_gcm_setkey(&ctx, cipher, key[(signed long long int)key_index[(signed long long int)i]], (unsigned int)key_len);
      if(key_len == 192 && ret == -35)
      {
        printf("skipped\n");
        break;
      }

      else
        if(!(ret == 0))
          goto exit;

      ret=mbedtls_gcm_crypt_and_tag(&ctx, 1, pt_len[(signed long long int)i], iv[(signed long long int)iv_index[(signed long long int)i]], iv_len[(signed long long int)i], additional[(signed long long int)add_index[(signed long long int)i]], add_len[(signed long long int)i], pt[(signed long long int)pt_index[(signed long long int)i]], buf, 16ull, tag_buf);
      if(!(ret == 0))
        goto exit;

      signed int return_value_memcmp=memcmp((const void *)buf, (const void *)ct[(signed long long int)(j * 6 + i)], pt_len[(signed long long int)i]);
      _Bool tmp_if_expr;
      if(!(return_value_memcmp == 0))
        tmp_if_expr = (_Bool)1;

      else
      {
        return_value_memcmp$0=memcmp((const void *)tag_buf, (const void *)tag[(signed long long int)(j * 6 + i)], 16ull);
        tmp_if_expr = return_value_memcmp$0 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr)
      {
        ret = 1;
        goto exit;
      }

      mbedtls_gcm_free(&ctx);
      if(!(verbose == 0))
        printf("passed\n");

      mbedtls_gcm_init(&ctx);
      if(!(verbose == 0))
        printf("  AES-GCM-%3d #%d (%s): ", key_len, i, (const void *)"dec");

      ret=mbedtls_gcm_setkey(&ctx, cipher, key[(signed long long int)key_index[(signed long long int)i]], (unsigned int)key_len);
      if(!(ret == 0))
        goto exit;

      ret=mbedtls_gcm_crypt_and_tag(&ctx, 0, pt_len[(signed long long int)i], iv[(signed long long int)iv_index[(signed long long int)i]], iv_len[(signed long long int)i], additional[(signed long long int)add_index[(signed long long int)i]], add_len[(signed long long int)i], ct[(signed long long int)(j * 6 + i)], buf, 16ull, tag_buf);
      if(!(ret == 0))
        goto exit;

      signed int return_value_memcmp$1=memcmp((const void *)buf, (const void *)pt[(signed long long int)pt_index[(signed long long int)i]], pt_len[(signed long long int)i]);
      _Bool tmp_if_expr$0;
      if(!(return_value_memcmp$1 == 0))
        tmp_if_expr$0 = (_Bool)1;

      else
      {
        return_value_memcmp$2=memcmp((const void *)tag_buf, (const void *)tag[(signed long long int)(j * 6 + i)], 16ull);
        tmp_if_expr$0 = return_value_memcmp$2 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$0)
      {
        ret = 1;
        goto exit;
      }

      mbedtls_gcm_free(&ctx);
      if(!(verbose == 0))
        printf("passed\n");

      mbedtls_gcm_init(&ctx);
      if(!(verbose == 0))
        printf("  AES-GCM-%3d #%d split (%s): ", key_len, i, (const void *)"enc");

      ret=mbedtls_gcm_setkey(&ctx, cipher, key[(signed long long int)key_index[(signed long long int)i]], (unsigned int)key_len);
      if(!(ret == 0))
        goto exit;

      ret=mbedtls_gcm_starts(&ctx, 1, iv[(signed long long int)iv_index[(signed long long int)i]], iv_len[(signed long long int)i], additional[(signed long long int)add_index[(signed long long int)i]], add_len[(signed long long int)i]);
      if(!(ret == 0))
        goto exit;

      if(pt_len[(signed long long int)i] >= 33ull)
      {
        size_t mbedtls_gcm_self_test$$1$$1$$1$$1$$1$$5$$rest_len=pt_len[(signed long long int)i] - 32ull;
        ret=mbedtls_gcm_update(&ctx, 32ull, pt[(signed long long int)pt_index[(signed long long int)i]], buf);
        if(!(ret == 0))
          goto exit;

        ret=mbedtls_gcm_update(&ctx, mbedtls_gcm_self_test$$1$$1$$1$$1$$1$$5$$rest_len, pt[(signed long long int)pt_index[(signed long long int)i]] + 32ll, buf + 32ll);
        if(!(ret == 0))
          goto exit;

      }

      else
      {
        ret=mbedtls_gcm_update(&ctx, pt_len[(signed long long int)i], pt[(signed long long int)pt_index[(signed long long int)i]], buf);
        if(!(ret == 0))
          goto exit;

      }
      ret=mbedtls_gcm_finish(&ctx, tag_buf, 16ull);
      if(!(ret == 0))
        goto exit;

      signed int return_value_memcmp$3=memcmp((const void *)buf, (const void *)ct[(signed long long int)(j * 6 + i)], pt_len[(signed long long int)i]);
      _Bool tmp_if_expr$1;
      if(!(return_value_memcmp$3 == 0))
        tmp_if_expr$1 = (_Bool)1;

      else
      {
        return_value_memcmp$4=memcmp((const void *)tag_buf, (const void *)tag[(signed long long int)(j * 6 + i)], 16ull);
        tmp_if_expr$1 = return_value_memcmp$4 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$1)
      {
        ret = 1;
        goto exit;
      }

      mbedtls_gcm_free(&ctx);
      if(!(verbose == 0))
        printf("passed\n");

      mbedtls_gcm_init(&ctx);
      if(!(verbose == 0))
        printf("  AES-GCM-%3d #%d split (%s): ", key_len, i, (const void *)"dec");

      ret=mbedtls_gcm_setkey(&ctx, cipher, key[(signed long long int)key_index[(signed long long int)i]], (unsigned int)key_len);
      if(!(ret == 0))
        goto exit;

      ret=mbedtls_gcm_starts(&ctx, 0, iv[(signed long long int)iv_index[(signed long long int)i]], iv_len[(signed long long int)i], additional[(signed long long int)add_index[(signed long long int)i]], add_len[(signed long long int)i]);
      if(!(ret == 0))
        goto exit;

      if(pt_len[(signed long long int)i] >= 33ull)
      {
        size_t rest_len=pt_len[(signed long long int)i] - 32ull;
        ret=mbedtls_gcm_update(&ctx, 32ull, ct[(signed long long int)(j * 6 + i)], buf);
        if(!(ret == 0))
          goto exit;

        ret=mbedtls_gcm_update(&ctx, rest_len, ct[(signed long long int)(j * 6 + i)] + 32ll, buf + 32ll);
        if(!(ret == 0))
          goto exit;

      }

      else
      {
        ret=mbedtls_gcm_update(&ctx, pt_len[(signed long long int)i], ct[(signed long long int)(j * 6 + i)], buf);
        if(!(ret == 0))
          goto exit;

      }
      ret=mbedtls_gcm_finish(&ctx, tag_buf, 16ull);
      if(!(ret == 0))
        goto exit;

      signed int return_value_memcmp$5=memcmp((const void *)buf, (const void *)pt[(signed long long int)pt_index[(signed long long int)i]], pt_len[(signed long long int)i]);
      _Bool tmp_if_expr$2;
      if(!(return_value_memcmp$5 == 0))
        tmp_if_expr$2 = (_Bool)1;

      else
      {
        return_value_memcmp$6=memcmp((const void *)tag_buf, (const void *)tag[(signed long long int)(j * 6 + i)], 16ull);
        tmp_if_expr$2 = return_value_memcmp$6 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$2)
      {
        ret = 1;
        goto exit;
      }

      mbedtls_gcm_free(&ctx);
      if(!(verbose == 0))
        printf("passed\n");

    }
  }
  if(!(verbose == 0))
    printf("\n");

  ret = 0;

exit:
  ;
  if(!(ret == 0))
  {
    if(!(verbose == 0))
      printf("failed\n");

    mbedtls_gcm_free(&ctx);
  }

  return ret;
}

// mbedtls_gcm_setkey
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 164
signed int mbedtls_gcm_setkey(mbedtls_gcm_context *ctx, mbedtls_cipher_id_t cipher, const unsigned char *mbedtls_gcm_setkey$$key, unsigned int keybits)
{
  signed int ret;
  const mbedtls_cipher_info_t *cipher_info=mbedtls_cipher_info_from_values(cipher, (signed int)keybits, /*enum*/MBEDTLS_MODE_ECB);
  if(cipher_info == ((const mbedtls_cipher_info_t *)NULL))
    return -0x14;

  else
    if(!(cipher_info->block_size == 16u))
      return -0x14;

    else
    {
      mbedtls_cipher_free(&ctx->cipher_ctx);
      ret=mbedtls_cipher_setup(&ctx->cipher_ctx, cipher_info);
      if(!(ret == 0))
        return ret;

      else
      {
        ret=mbedtls_cipher_setkey(&ctx->cipher_ctx, mbedtls_gcm_setkey$$key, (signed int)keybits, /*enum*/MBEDTLS_ENCRYPT);
        if(!(ret == 0))
          return ret;

        else
        {
          ret=gcm_gen_table(ctx);
          if(!(ret == 0))
            return ret;

          else
            return 0;
        }
      }
    }
}

// mbedtls_gcm_starts
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 269
signed int mbedtls_gcm_starts(mbedtls_gcm_context *ctx, signed int mode, const unsigned char *mbedtls_gcm_starts$$iv, size_t mbedtls_gcm_starts$$iv_len, const unsigned char *add, size_t mbedtls_gcm_starts$$add_len)
{
  signed int ret;
  unsigned char work_buf[16ll];
  size_t i;
  const unsigned char *p;
  size_t use_len;
  size_t olen=0ull;
  if(mbedtls_gcm_starts$$iv_len == 0ull || !(mbedtls_gcm_starts$$add_len >> 61 == 0ull) || !(mbedtls_gcm_starts$$iv_len >> 61 == 0ull))
    return -0x14;

  else
  {
    memset((void *)ctx->y, 0x0, sizeof(unsigned char [16ll]) /*16ull*/ );
    memset((void *)ctx->buf, 0x0, sizeof(unsigned char [16ll]) /*16ull*/ );
    ctx->mode = mode;
    ctx->len = 0ull;
    ctx->add_len = 0ull;
    if(mbedtls_gcm_starts$$iv_len == 12ull)
    {
      memcpy((void *)ctx->y, (const void *)mbedtls_gcm_starts$$iv, mbedtls_gcm_starts$$iv_len);
      ctx->y[15ll] = 1;
    }

    else
    {
      memset((void *)work_buf, 0x0, 16ull);
      work_buf[12ll] = (unsigned char)(mbedtls_gcm_starts$$iv_len * 8ull >> 24);
      work_buf[(signed long long int)(12 + 1)] = (unsigned char)(mbedtls_gcm_starts$$iv_len * 8ull >> 16);
      work_buf[(signed long long int)(12 + 2)] = (unsigned char)(mbedtls_gcm_starts$$iv_len * 8ull >> 8);
      work_buf[(signed long long int)(12 + 3)] = (unsigned char)(mbedtls_gcm_starts$$iv_len * 8ull);
      p = mbedtls_gcm_starts$$iv;
      for( ; mbedtls_gcm_starts$$iv_len >= 1ull; p = p + (signed long long int)use_len)
      {
        use_len = mbedtls_gcm_starts$$iv_len < 16ull ? mbedtls_gcm_starts$$iv_len : 16ull;
        i = 0ull;
        for( ; !(i >= use_len); i = i + 1ull)
          ctx->y[(signed long long int)i] = ctx->y[(signed long long int)i] ^ p[(signed long long int)i];
        gcm_mult(ctx, ctx->y, ctx->y);
        mbedtls_gcm_starts$$iv_len = mbedtls_gcm_starts$$iv_len - use_len;
      }
      i = 0ull;
      for( ; !(i >= 16ull); i = i + 1ull)
        ctx->y[(signed long long int)i] = ctx->y[(signed long long int)i] ^ work_buf[(signed long long int)i];
      gcm_mult(ctx, ctx->y, ctx->y);
    }
    ret=mbedtls_cipher_update(&ctx->cipher_ctx, ctx->y, 16ull, ctx->base_ectr, &olen);
    if(!(ret == 0))
      return ret;

    else
    {
      ctx->add_len = mbedtls_gcm_starts$$add_len;
      p = add;
      for( ; mbedtls_gcm_starts$$add_len >= 1ull; p = p + (signed long long int)use_len)
      {
        use_len = mbedtls_gcm_starts$$add_len < 16ull ? mbedtls_gcm_starts$$add_len : 16ull;
        i = 0ull;
        for( ; !(i >= use_len); i = i + 1ull)
          ctx->buf[(signed long long int)i] = ctx->buf[(signed long long int)i] ^ p[(signed long long int)i];
        gcm_mult(ctx, ctx->buf, ctx->buf);
        mbedtls_gcm_starts$$add_len = mbedtls_gcm_starts$$add_len - use_len;
      }
      return 0;
    }
  }
}

// mbedtls_gcm_update
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 352
signed int mbedtls_gcm_update(mbedtls_gcm_context *ctx, size_t length, const unsigned char *input, unsigned char *output)
{
  signed int ret;
  unsigned char ectr[16ll];
  size_t i;
  const unsigned char *p;
  unsigned char *out_p=output;
  size_t use_len;
  size_t olen=0ull;
  if(!(input >= output) && !((size_t)(output - input) >= length))
    return -0x14;

  else
  {
    _Bool tmp_if_expr;
    if(!(ctx->len + length >= ctx->len))
      tmp_if_expr = (_Bool)1;

    else
      tmp_if_expr = (uint64_t)ctx->len + length > 0xFFFFFFFE0ull ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr)
      return -0x14;

    else
    {
      ctx->len = ctx->len + length;
      p = input;
      for( ; length >= 1ull; out_p = out_p + (signed long long int)use_len)
      {
        use_len = length < 16ull ? length : 16ull;
        i = 16ull;
        for( ; i >= 13ull; i = i - 1ull)
        {
          ctx->y[(signed long long int)(i - 1ull)] = ctx->y[(signed long long int)(i - 1ull)] + 1;
          if(!((signed int)ctx->y[-1ll + (signed long long int)i] == 0))
            break;

        }
        ret=mbedtls_cipher_update(&ctx->cipher_ctx, ctx->y, 16ull, ectr, &olen);
        if(!(ret == 0))
          return ret;

        i = 0ull;
        for( ; !(i >= use_len); i = i + 1ull)
        {
          if(ctx->mode == 0)
            ctx->buf[(signed long long int)i] = ctx->buf[(signed long long int)i] ^ p[(signed long long int)i];

          out_p[(signed long long int)i] = (unsigned char)((signed int)ectr[(signed long long int)i] ^ (signed int)p[(signed long long int)i]);
          if(ctx->mode == 1)
            ctx->buf[(signed long long int)i] = ctx->buf[(signed long long int)i] ^ out_p[(signed long long int)i];

        }
        gcm_mult(ctx, ctx->buf, ctx->buf);
        length = length - use_len;
        p = p + (signed long long int)use_len;
      }
      return 0;
    }
  }
}

// mbedtls_hardware_poll
// file ..\common\application_code\aws_entropy_hardware_poll.c line 33
signed int mbedtls_hardware_poll(void *data, unsigned char *output, size_t len, size_t *olen)
{
  signed int lStatus=-0x3C;
  HCRYPTPROV hProv=0ull;
  (void)data;
  BOOL return_value_CryptAcquireContextA=CryptAcquireContextA(&hProv, ((LPCSTR)NULL), ((LPCSTR)NULL), 1ul, 0xF0000000u);
  if(return_value_CryptAcquireContextA == 1)
  {
    BOOL return_value_CryptGenRandom=CryptGenRandom(hProv, (DWORD)len, output);
    if(return_value_CryptGenRandom == 1)
    {
      lStatus = 0;
      *olen = len;
    }

    CryptReleaseContext(hProv, 0ull);
  }

  return lStatus;
}

// mbedtls_hmac_drbg_free
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 332
void mbedtls_hmac_drbg_free(mbedtls_hmac_drbg_context *ctx)
{
  if(!(ctx == ((mbedtls_hmac_drbg_context *)NULL)))
  {
    mbedtls_md_free(&ctx->md_ctx);
    mbedtls_zeroize$link8((void *)ctx, sizeof(mbedtls_hmac_drbg_context) /*96ull*/ );
  }

}

// mbedtls_hmac_drbg_init
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 61
void mbedtls_hmac_drbg_init(mbedtls_hmac_drbg_context *ctx)
{
  memset((void *)ctx, 0, sizeof(mbedtls_hmac_drbg_context) /*96ull*/ );
}

// mbedtls_hmac_drbg_random
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 309
signed int mbedtls_hmac_drbg_random(void *p_rng, unsigned char *output, size_t out_len)
{
  signed int ret;
  mbedtls_hmac_drbg_context *ctx=(mbedtls_hmac_drbg_context *)p_rng;
  ret=mbedtls_hmac_drbg_random_with_add((void *)ctx, output, out_len, ((const unsigned char *)NULL), 0ull);
  return ret;
}

// mbedtls_hmac_drbg_random_with_add
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 249
signed int mbedtls_hmac_drbg_random_with_add(void *p_rng, unsigned char *output, size_t out_len, const unsigned char *mbedtls_hmac_drbg_random_with_add$$additional, size_t mbedtls_hmac_drbg_random_with_add$$add_len)
{
  signed int ret;
  mbedtls_hmac_drbg_context *ctx=(mbedtls_hmac_drbg_context *)p_rng;
  size_t md_len;
  unsigned char return_value_mbedtls_md_get_size=mbedtls_md_get_size(ctx->md_ctx.md_info);
  md_len = (size_t)return_value_mbedtls_md_get_size;
  size_t left=out_len;
  unsigned char *out=output;
  _Bool tmp_if_expr;
  if(out_len >= 1025ull)
    return -0x3;

  else
    if(mbedtls_hmac_drbg_random_with_add$$add_len >= 257ull)
      return -0x5;

    else
    {
      if(!(ctx->f_entropy == ((signed int (*)(void *, unsigned char *, size_t))NULL)))
      {
        if(ctx->prediction_resistance == 1)
          tmp_if_expr = (_Bool)1;

        else
          tmp_if_expr = ctx->reseed_counter > ctx->reseed_interval ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr)
        {
          ret=mbedtls_hmac_drbg_reseed(ctx, mbedtls_hmac_drbg_random_with_add$$additional, mbedtls_hmac_drbg_random_with_add$$add_len);
          if(!(ret == 0))
            return ret;

          mbedtls_hmac_drbg_random_with_add$$add_len = 0ull;
        }

      }

      if(!(mbedtls_hmac_drbg_random_with_add$$additional == ((const unsigned char *)NULL)) && !(mbedtls_hmac_drbg_random_with_add$$add_len == 0ull))
        mbedtls_hmac_drbg_update(ctx, mbedtls_hmac_drbg_random_with_add$$additional, mbedtls_hmac_drbg_random_with_add$$add_len);

      while(!(left == 0ull))
      {
        size_t use_len=left > md_len ? md_len : left;
        mbedtls_md_hmac_reset(&ctx->md_ctx);
        mbedtls_md_hmac_update(&ctx->md_ctx, ctx->V, md_len);
        mbedtls_md_hmac_finish(&ctx->md_ctx, ctx->V);
        memcpy((void *)out, (const void *)ctx->V, use_len);
        out = out + (signed long long int)use_len;
        left = left - use_len;
      }
      mbedtls_hmac_drbg_update(ctx, mbedtls_hmac_drbg_random_with_add$$additional, mbedtls_hmac_drbg_random_with_add$$add_len);
      ctx->reseed_counter = ctx->reseed_counter + 1;
      return 0;
    }
}

// mbedtls_hmac_drbg_reseed
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 126
signed int mbedtls_hmac_drbg_reseed(mbedtls_hmac_drbg_context *ctx, const unsigned char *mbedtls_hmac_drbg_reseed$$additional, size_t len)
{
  unsigned char seed[384ll];
  size_t seedlen;
  _Bool tmp_if_expr;
  if(len >= 257ull)
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ctx->entropy_len + len > 384ull ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return -0x5;

  else
  {
    memset((void *)seed, 0, 384ull);
    signed int return_value=ctx->f_entropy(ctx->p_entropy, seed, ctx->entropy_len);
    if(!(return_value == 0))
      return -0x9;

    else
    {
      seedlen = ctx->entropy_len;
      if(!(mbedtls_hmac_drbg_reseed$$additional == ((const unsigned char *)NULL)) && !(len == 0ull))
      {
        memcpy((void *)(seed + (signed long long int)seedlen), (const void *)mbedtls_hmac_drbg_reseed$$additional, len);
        seedlen = seedlen + len;
      }

      mbedtls_hmac_drbg_update(ctx, seed, seedlen);
      ctx->reseed_counter = 1;
      return 0;
    }
  }
}

// mbedtls_hmac_drbg_seed
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 167
signed int mbedtls_hmac_drbg_seed(mbedtls_hmac_drbg_context *ctx, const mbedtls_md_info_t *md_info, signed int (*f_entropy)(void *, unsigned char *, size_t), void *p_entropy, const unsigned char *custom, size_t len)
{
  signed int ret;
  size_t entropy_len;
  size_t md_size;
  ret=mbedtls_md_setup(&ctx->md_ctx, md_info, 1);
  if(!(ret == 0))
    return ret;

  else
  {
    unsigned char return_value_mbedtls_md_get_size=mbedtls_md_get_size(md_info);
    md_size = (size_t)return_value_mbedtls_md_get_size;
    mbedtls_md_hmac_starts(&ctx->md_ctx, ctx->V, md_size);
    memset((void *)ctx->V, 0x1, md_size);
    ctx->f_entropy = f_entropy;
    ctx->p_entropy = p_entropy;
    ctx->reseed_interval = 10000;
    entropy_len = (size_t)(md_size <= 20ull ? 16 : (md_size <= 28ull ? 24 : 32));
    ctx->entropy_len = (entropy_len * 3ull) / 2ull;
    ret=mbedtls_hmac_drbg_reseed(ctx, custom, len);
    if(!(ret == 0))
      return ret;

    else
    {
      ctx->entropy_len = entropy_len;
      return 0;
    }
  }
}

// mbedtls_hmac_drbg_seed_buf
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 101
signed int mbedtls_hmac_drbg_seed_buf(mbedtls_hmac_drbg_context *ctx, const mbedtls_md_info_t *md_info, const unsigned char *data, size_t data_len)
{
  signed int ret=mbedtls_md_setup(&ctx->md_ctx, md_info, 1);
  if(!(ret == 0))
    return ret;

  else
  {
    unsigned char return_value_mbedtls_md_get_size=mbedtls_md_get_size(md_info);
    mbedtls_md_hmac_starts(&ctx->md_ctx, ctx->V, (size_t)return_value_mbedtls_md_get_size);
    unsigned char return_value_mbedtls_md_get_size$0=mbedtls_md_get_size(md_info);
    memset((void *)ctx->V, 0x1, (size_t)return_value_mbedtls_md_get_size$0);
    mbedtls_hmac_drbg_update(ctx, data, data_len);
    return 0;
  }
}

// mbedtls_hmac_drbg_self_test
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 474
signed int mbedtls_hmac_drbg_self_test(signed int verbose)
{
  mbedtls_hmac_drbg_context ctx;
  unsigned char buf[80ll];
  const mbedtls_md_info_t *md_info=mbedtls_md_info_from_type(/*enum*/MBEDTLS_MD_SHA1);
  mbedtls_hmac_drbg_init(&ctx);
  if(!(verbose == 0))
    printf("  HMAC_DRBG (PR = True) : ");

  test_offset$link1 = 0ull;
  signed int return_value_mbedtls_hmac_drbg_seed=mbedtls_hmac_drbg_seed(&ctx, md_info, hmac_drbg_self_test_entropy, (void *)entropy_pr, ((const unsigned char *)NULL), 0ull);
  if(!(return_value_mbedtls_hmac_drbg_seed == 0))
  {
    if(!(verbose == 0))
      printf("failed\n");

    return 1;
  }

  else
  {
    mbedtls_hmac_drbg_set_prediction_resistance(&ctx, 1);
    signed int return_value_mbedtls_hmac_drbg_random=mbedtls_hmac_drbg_random((void *)&ctx, buf, 80ull);
    if(!(return_value_mbedtls_hmac_drbg_random == 0))
    {
      if(!(verbose == 0))
        printf("failed\n");

      return 1;
    }

    else
    {
      signed int return_value_mbedtls_hmac_drbg_random$0=mbedtls_hmac_drbg_random((void *)&ctx, buf, 80ull);
      if(!(return_value_mbedtls_hmac_drbg_random$0 == 0))
      {
        if(!(verbose == 0))
          printf("failed\n");

        return 1;
      }

      else
      {
        signed int return_value_memcmp=memcmp((const void *)buf, (const void *)result_pr$link1, 80ull);
        if(!(return_value_memcmp == 0))
        {
          if(!(verbose == 0))
            printf("failed\n");

          return 1;
        }

        else
        {
          mbedtls_hmac_drbg_free(&ctx);
          mbedtls_hmac_drbg_free(&ctx);
          if(!(verbose == 0))
            printf("passed\n");

          if(!(verbose == 0))
            printf("  HMAC_DRBG (PR = False) : ");

          mbedtls_hmac_drbg_init(&ctx);
          test_offset$link1 = 0ull;
          signed int return_value_mbedtls_hmac_drbg_seed$0=mbedtls_hmac_drbg_seed(&ctx, md_info, hmac_drbg_self_test_entropy, (void *)entropy_nopr, ((const unsigned char *)NULL), 0ull);
          if(!(return_value_mbedtls_hmac_drbg_seed$0 == 0))
          {
            if(!(verbose == 0))
              printf("failed\n");

            return 1;
          }

          else
          {
            signed int return_value_mbedtls_hmac_drbg_reseed=mbedtls_hmac_drbg_reseed(&ctx, ((const unsigned char *)NULL), 0ull);
            if(!(return_value_mbedtls_hmac_drbg_reseed == 0))
            {
              if(!(verbose == 0))
                printf("failed\n");

              return 1;
            }

            else
            {
              signed int return_value_mbedtls_hmac_drbg_random$1=mbedtls_hmac_drbg_random((void *)&ctx, buf, 80ull);
              if(!(return_value_mbedtls_hmac_drbg_random$1 == 0))
              {
                if(!(verbose == 0))
                  printf("failed\n");

                return 1;
              }

              else
              {
                signed int return_value_mbedtls_hmac_drbg_random$2=mbedtls_hmac_drbg_random((void *)&ctx, buf, 80ull);
                if(!(return_value_mbedtls_hmac_drbg_random$2 == 0))
                {
                  if(!(verbose == 0))
                    printf("failed\n");

                  return 1;
                }

                else
                {
                  signed int return_value_memcmp$0=memcmp((const void *)buf, (const void *)result_nopr$link1, 80ull);
                  if(!(return_value_memcmp$0 == 0))
                  {
                    if(!(verbose == 0))
                      printf("failed\n");

                    return 1;
                  }

                  else
                  {
                    mbedtls_hmac_drbg_free(&ctx);
                    mbedtls_hmac_drbg_free(&ctx);
                    if(!(verbose == 0))
                      printf("passed\n");

                    if(!(verbose == 0))
                      printf("\n");

                    return 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// mbedtls_hmac_drbg_set_entropy_len
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 232
void mbedtls_hmac_drbg_set_entropy_len(mbedtls_hmac_drbg_context *ctx, size_t len)
{
  ctx->entropy_len = len;
}

// mbedtls_hmac_drbg_set_prediction_resistance
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 223
void mbedtls_hmac_drbg_set_prediction_resistance(mbedtls_hmac_drbg_context *ctx, signed int resistance)
{
  ctx->prediction_resistance = resistance;
}

// mbedtls_hmac_drbg_set_reseed_interval
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 240
void mbedtls_hmac_drbg_set_reseed_interval(mbedtls_hmac_drbg_context *ctx, signed int interval)
{
  ctx->reseed_interval = interval;
}

// mbedtls_hmac_drbg_update
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 73
void mbedtls_hmac_drbg_update(mbedtls_hmac_drbg_context *ctx, const unsigned char *mbedtls_hmac_drbg_update$$additional, size_t mbedtls_hmac_drbg_update$$add_len)
{
  size_t md_len;
  unsigned char return_value_mbedtls_md_get_size=mbedtls_md_get_size(ctx->md_ctx.md_info);
  md_len = (size_t)return_value_mbedtls_md_get_size;
  unsigned char rounds=(unsigned char)(mbedtls_hmac_drbg_update$$additional != ((const unsigned char *)NULL) && mbedtls_hmac_drbg_update$$add_len != 0ull ? 2 : 1);
  unsigned char sep[1ll];
  unsigned char mbedtls_hmac_drbg_update$$1$$K[32ll];
  sep[0ll] = 0;
  for( ; !((signed int)sep[0ll] >= (signed int)rounds); sep[0ll] = sep[0ll] + 1)
  {
    mbedtls_md_hmac_reset(&ctx->md_ctx);
    mbedtls_md_hmac_update(&ctx->md_ctx, ctx->V, md_len);
    mbedtls_md_hmac_update(&ctx->md_ctx, sep, 1ull);
    if((signed int)rounds == 2)
      mbedtls_md_hmac_update(&ctx->md_ctx, mbedtls_hmac_drbg_update$$additional, mbedtls_hmac_drbg_update$$add_len);

    mbedtls_md_hmac_finish(&ctx->md_ctx, mbedtls_hmac_drbg_update$$1$$K);
    mbedtls_md_hmac_starts(&ctx->md_ctx, mbedtls_hmac_drbg_update$$1$$K, md_len);
    mbedtls_md_hmac_update(&ctx->md_ctx, ctx->V, md_len);
    mbedtls_md_hmac_finish(&ctx->md_ctx, ctx->V);
  }
}

// mbedtls_int_div_int
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1242
static mbedtls_mpi_uint mbedtls_int_div_int(mbedtls_mpi_uint u1, mbedtls_mpi_uint u0, mbedtls_mpi_uint d, mbedtls_mpi_uint *r)
{
  const mbedtls_mpi_uint radix=1ull << (sizeof(mbedtls_mpi_uint) /*8ull*/  << 2);
  const mbedtls_mpi_uint uint_halfword_mask=(1ull << (sizeof(mbedtls_mpi_uint) /*8ull*/  << 2)) - 1ull;
  mbedtls_mpi_uint d0;
  mbedtls_mpi_uint d1;
  mbedtls_mpi_uint q0;
  mbedtls_mpi_uint q1;
  mbedtls_mpi_uint rAX;
  mbedtls_mpi_uint r0;
  mbedtls_mpi_uint quotient;
  mbedtls_mpi_uint u0_msw;
  mbedtls_mpi_uint u0_lsw;
  size_t s;
  if(d == 0ull || u1 >= d)
  {
    if(!(r == ((mbedtls_mpi_uint *)NULL)))
      *r = (mbedtls_mpi_uint)~0;

    return (mbedtls_mpi_uint)~0;
  }

  else
  {
    s=mbedtls_clz(d);
    d = d << s;
    u1 = u1 << s;
    u1 = u1 | u0 >> (sizeof(mbedtls_mpi_uint) /*8ull*/  << 3) - s & (unsigned long long int)(-((mbedtls_mpi_sint)s) >> (sizeof(mbedtls_mpi_uint) /*8ull*/  << 3) - 1ull);
    u0 = u0 << s;
    d1 = d >> (sizeof(mbedtls_mpi_uint) /*8ull*/  << 2);
    d0 = d & uint_halfword_mask;
    u0_msw = u0 >> (sizeof(mbedtls_mpi_uint) /*8ull*/  << 2);
    u0_lsw = u0 & uint_halfword_mask;
    q1 = u1 / d1;
    r0 = u1 - d1 * q1;
    while(q1 >= radix || !(r0 * radix + u0_msw >= d0 * q1))
    {
      q1 = q1 - 1ull;
      r0 = r0 + d1;
      if(r0 >= radix)
        break;

    }
    rAX = u1 * radix + (u0_msw - q1 * d);
    q0 = rAX / d1;
    r0 = rAX - q0 * d1;
    while(q0 >= radix || !(r0 * radix + u0_lsw >= d0 * q0))
    {
      q0 = q0 - 1ull;
      r0 = r0 + d1;
      if(r0 >= radix)
        break;

    }
    if(!(r == ((mbedtls_mpi_uint *)NULL)))
      *r = (rAX * radix + u0_lsw) - q0 * d >> s;

    quotient = q1 * radix + q0;
    return quotient;
  }
}

// mbedtls_internal_aes_decrypt
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 829
signed int mbedtls_internal_aes_decrypt(mbedtls_aes_context *ctx, const unsigned char *input, unsigned char *output)
{
  signed int i;
  uint32_t *RK;
  uint32_t X0;
  uint32_t X1;
  uint32_t X2;
  uint32_t X3;
  uint32_t Y0;
  uint32_t Y1;
  uint32_t Y2;
  uint32_t Y3;
  RK = ctx->rk;
  X0 = (uint32_t)input[0ll] | (uint32_t)input[(signed long long int)(0 + 1)] << 8 | (uint32_t)input[(signed long long int)(0 + 2)] << 16 | (uint32_t)input[(signed long long int)(0 + 3)] << 24;
  uint32_t *tmp_post=RK;
  RK = RK + 1ll;
  X0 = X0 ^ *tmp_post;
  X1 = (uint32_t)input[4ll] | (uint32_t)input[(signed long long int)(4 + 1)] << 8 | (uint32_t)input[(signed long long int)(4 + 2)] << 16 | (uint32_t)input[(signed long long int)(4 + 3)] << 24;
  uint32_t *tmp_post$0=RK;
  RK = RK + 1ll;
  X1 = X1 ^ *tmp_post$0;
  X2 = (uint32_t)input[8ll] | (uint32_t)input[(signed long long int)(8 + 1)] << 8 | (uint32_t)input[(signed long long int)(8 + 2)] << 16 | (uint32_t)input[(signed long long int)(8 + 3)] << 24;
  uint32_t *tmp_post$1=RK;
  RK = RK + 1ll;
  X2 = X2 ^ *tmp_post$1;
  X3 = (uint32_t)input[12ll] | (uint32_t)input[(signed long long int)(12 + 1)] << 8 | (uint32_t)input[(signed long long int)(12 + 2)] << 16 | (uint32_t)input[(signed long long int)(12 + 3)] << 24;
  uint32_t *tmp_post$2=RK;
  RK = RK + 1ll;
  X3 = X3 ^ *tmp_post$2;
  i = (ctx->nr >> 1) - 1;
  for( ; i >= 1; i = i - 1)
  {
    uint32_t *tmp_post$3=RK;
    RK = RK + 1ll;
    Y0 = *tmp_post$3 ^ RT0[(signed long long int)(X0 & 255u)] ^ RT1[(signed long long int)(X3 >> 8 & 255u)] ^ RT2[(signed long long int)(X2 >> 16 & 255u)] ^ RT3[(signed long long int)(X1 >> 24 & 255u)];
    uint32_t *tmp_post$4=RK;
    RK = RK + 1ll;
    Y1 = *tmp_post$4 ^ RT0[(signed long long int)(X1 & 255u)] ^ RT1[(signed long long int)(X0 >> 8 & 255u)] ^ RT2[(signed long long int)(X3 >> 16 & 255u)] ^ RT3[(signed long long int)(X2 >> 24 & 255u)];
    uint32_t *tmp_post$5=RK;
    RK = RK + 1ll;
    Y2 = *tmp_post$5 ^ RT0[(signed long long int)(X2 & 255u)] ^ RT1[(signed long long int)(X1 >> 8 & 255u)] ^ RT2[(signed long long int)(X0 >> 16 & 255u)] ^ RT3[(signed long long int)(X3 >> 24 & 255u)];
    uint32_t *tmp_post$6=RK;
    RK = RK + 1ll;
    Y3 = *tmp_post$6 ^ RT0[(signed long long int)(X3 & 255u)] ^ RT1[(signed long long int)(X2 >> 8 & 255u)] ^ RT2[(signed long long int)(X1 >> 16 & 255u)] ^ RT3[(signed long long int)(X0 >> 24 & 255u)];
    uint32_t *tmp_post$7=RK;
    RK = RK + 1ll;
    X0 = *tmp_post$7 ^ RT0[(signed long long int)(Y0 & 255u)] ^ RT1[(signed long long int)(Y3 >> 8 & 255u)] ^ RT2[(signed long long int)(Y2 >> 16 & 255u)] ^ RT3[(signed long long int)(Y1 >> 24 & 255u)];
    uint32_t *tmp_post$8=RK;
    RK = RK + 1ll;
    X1 = *tmp_post$8 ^ RT0[(signed long long int)(Y1 & 255u)] ^ RT1[(signed long long int)(Y0 >> 8 & 255u)] ^ RT2[(signed long long int)(Y3 >> 16 & 255u)] ^ RT3[(signed long long int)(Y2 >> 24 & 255u)];
    uint32_t *tmp_post$9=RK;
    RK = RK + 1ll;
    X2 = *tmp_post$9 ^ RT0[(signed long long int)(Y2 & 255u)] ^ RT1[(signed long long int)(Y1 >> 8 & 255u)] ^ RT2[(signed long long int)(Y0 >> 16 & 255u)] ^ RT3[(signed long long int)(Y3 >> 24 & 255u)];
    uint32_t *tmp_post$10=RK;
    RK = RK + 1ll;
    X3 = *tmp_post$10 ^ RT0[(signed long long int)(Y3 & 255u)] ^ RT1[(signed long long int)(Y2 >> 8 & 255u)] ^ RT2[(signed long long int)(Y1 >> 16 & 255u)] ^ RT3[(signed long long int)(Y0 >> 24 & 255u)];
  }
  uint32_t *tmp_post$11=RK;
  RK = RK + 1ll;
  Y0 = *tmp_post$11 ^ RT0[(signed long long int)(X0 & 255u)] ^ RT1[(signed long long int)(X3 >> 8 & 255u)] ^ RT2[(signed long long int)(X2 >> 16 & 255u)] ^ RT3[(signed long long int)(X1 >> 24 & 255u)];
  uint32_t *tmp_post$12=RK;
  RK = RK + 1ll;
  Y1 = *tmp_post$12 ^ RT0[(signed long long int)(X1 & 255u)] ^ RT1[(signed long long int)(X0 >> 8 & 255u)] ^ RT2[(signed long long int)(X3 >> 16 & 255u)] ^ RT3[(signed long long int)(X2 >> 24 & 255u)];
  uint32_t *tmp_post$13=RK;
  RK = RK + 1ll;
  Y2 = *tmp_post$13 ^ RT0[(signed long long int)(X2 & 255u)] ^ RT1[(signed long long int)(X1 >> 8 & 255u)] ^ RT2[(signed long long int)(X0 >> 16 & 255u)] ^ RT3[(signed long long int)(X3 >> 24 & 255u)];
  uint32_t *tmp_post$14=RK;
  RK = RK + 1ll;
  Y3 = *tmp_post$14 ^ RT0[(signed long long int)(X3 & 255u)] ^ RT1[(signed long long int)(X2 >> 8 & 255u)] ^ RT2[(signed long long int)(X1 >> 16 & 255u)] ^ RT3[(signed long long int)(X0 >> 24 & 255u)];
  uint32_t *tmp_post$15=RK;
  RK = RK + 1ll;
  X0 = *tmp_post$15 ^ (uint32_t)RSb[(signed long long int)(Y0 & 255u)] ^ (uint32_t)RSb[(signed long long int)(Y3 >> 8 & 255u)] << 8 ^ (uint32_t)RSb[(signed long long int)(Y2 >> 16 & 255u)] << 16 ^ (uint32_t)RSb[(signed long long int)(Y1 >> 24 & 255u)] << 24;
  uint32_t *tmp_post$16=RK;
  RK = RK + 1ll;
  X1 = *tmp_post$16 ^ (uint32_t)RSb[(signed long long int)(Y1 & 255u)] ^ (uint32_t)RSb[(signed long long int)(Y0 >> 8 & 255u)] << 8 ^ (uint32_t)RSb[(signed long long int)(Y3 >> 16 & 255u)] << 16 ^ (uint32_t)RSb[(signed long long int)(Y2 >> 24 & 255u)] << 24;
  uint32_t *tmp_post$17=RK;
  RK = RK + 1ll;
  X2 = *tmp_post$17 ^ (uint32_t)RSb[(signed long long int)(Y2 & 255u)] ^ (uint32_t)RSb[(signed long long int)(Y1 >> 8 & 255u)] << 8 ^ (uint32_t)RSb[(signed long long int)(Y0 >> 16 & 255u)] << 16 ^ (uint32_t)RSb[(signed long long int)(Y3 >> 24 & 255u)] << 24;
  uint32_t *tmp_post$18=RK;
  RK = RK + 1ll;
  X3 = *tmp_post$18 ^ (uint32_t)RSb[(signed long long int)(Y3 & 255u)] ^ (uint32_t)RSb[(signed long long int)(Y2 >> 8 & 255u)] << 8 ^ (uint32_t)RSb[(signed long long int)(Y1 >> 16 & 255u)] << 16 ^ (uint32_t)RSb[(signed long long int)(Y0 >> 24 & 255u)] << 24;
  output[0ll] = (unsigned char)(X0 & 255u);
  output[(signed long long int)(0 + 1)] = (unsigned char)(X0 >> 8 & 255u);
  output[(signed long long int)(0 + 2)] = (unsigned char)(X0 >> 16 & 255u);
  output[(signed long long int)(0 + 3)] = (unsigned char)(X0 >> 24 & 255u);
  output[4ll] = (unsigned char)(X1 & 255u);
  output[(signed long long int)(4 + 1)] = (unsigned char)(X1 >> 8 & 255u);
  output[(signed long long int)(4 + 2)] = (unsigned char)(X1 >> 16 & 255u);
  output[(signed long long int)(4 + 3)] = (unsigned char)(X1 >> 24 & 255u);
  output[8ll] = (unsigned char)(X2 & 255u);
  output[(signed long long int)(8 + 1)] = (unsigned char)(X2 >> 8 & 255u);
  output[(signed long long int)(8 + 2)] = (unsigned char)(X2 >> 16 & 255u);
  output[(signed long long int)(8 + 3)] = (unsigned char)(X2 >> 24 & 255u);
  output[12ll] = (unsigned char)(X3 & 255u);
  output[(signed long long int)(12 + 1)] = (unsigned char)(X3 >> 8 & 255u);
  output[(signed long long int)(12 + 2)] = (unsigned char)(X3 >> 16 & 255u);
  output[(signed long long int)(12 + 3)] = (unsigned char)(X3 >> 24 & 255u);
  return 0;
}

// mbedtls_internal_aes_encrypt
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 761
signed int mbedtls_internal_aes_encrypt(mbedtls_aes_context *ctx, const unsigned char *input, unsigned char *output)
{
  signed int i;
  uint32_t *RK;
  uint32_t X0;
  uint32_t X1;
  uint32_t X2;
  uint32_t X3;
  uint32_t Y0;
  uint32_t Y1;
  uint32_t Y2;
  uint32_t Y3;
  RK = ctx->rk;
  X0 = (uint32_t)input[0ll] | (uint32_t)input[(signed long long int)(0 + 1)] << 8 | (uint32_t)input[(signed long long int)(0 + 2)] << 16 | (uint32_t)input[(signed long long int)(0 + 3)] << 24;
  uint32_t *tmp_post=RK;
  RK = RK + 1ll;
  X0 = X0 ^ *tmp_post;
  X1 = (uint32_t)input[4ll] | (uint32_t)input[(signed long long int)(4 + 1)] << 8 | (uint32_t)input[(signed long long int)(4 + 2)] << 16 | (uint32_t)input[(signed long long int)(4 + 3)] << 24;
  uint32_t *tmp_post$0=RK;
  RK = RK + 1ll;
  X1 = X1 ^ *tmp_post$0;
  X2 = (uint32_t)input[8ll] | (uint32_t)input[(signed long long int)(8 + 1)] << 8 | (uint32_t)input[(signed long long int)(8 + 2)] << 16 | (uint32_t)input[(signed long long int)(8 + 3)] << 24;
  uint32_t *tmp_post$1=RK;
  RK = RK + 1ll;
  X2 = X2 ^ *tmp_post$1;
  X3 = (uint32_t)input[12ll] | (uint32_t)input[(signed long long int)(12 + 1)] << 8 | (uint32_t)input[(signed long long int)(12 + 2)] << 16 | (uint32_t)input[(signed long long int)(12 + 3)] << 24;
  uint32_t *tmp_post$2=RK;
  RK = RK + 1ll;
  X3 = X3 ^ *tmp_post$2;
  i = (ctx->nr >> 1) - 1;
  for( ; i >= 1; i = i - 1)
  {
    uint32_t *tmp_post$3=RK;
    RK = RK + 1ll;
    Y0 = *tmp_post$3 ^ FT0[(signed long long int)(X0 & 255u)] ^ FT1[(signed long long int)(X1 >> 8 & 255u)] ^ FT2[(signed long long int)(X2 >> 16 & 255u)] ^ FT3[(signed long long int)(X3 >> 24 & 255u)];
    uint32_t *tmp_post$4=RK;
    RK = RK + 1ll;
    Y1 = *tmp_post$4 ^ FT0[(signed long long int)(X1 & 255u)] ^ FT1[(signed long long int)(X2 >> 8 & 255u)] ^ FT2[(signed long long int)(X3 >> 16 & 255u)] ^ FT3[(signed long long int)(X0 >> 24 & 255u)];
    uint32_t *tmp_post$5=RK;
    RK = RK + 1ll;
    Y2 = *tmp_post$5 ^ FT0[(signed long long int)(X2 & 255u)] ^ FT1[(signed long long int)(X3 >> 8 & 255u)] ^ FT2[(signed long long int)(X0 >> 16 & 255u)] ^ FT3[(signed long long int)(X1 >> 24 & 255u)];
    uint32_t *tmp_post$6=RK;
    RK = RK + 1ll;
    Y3 = *tmp_post$6 ^ FT0[(signed long long int)(X3 & 255u)] ^ FT1[(signed long long int)(X0 >> 8 & 255u)] ^ FT2[(signed long long int)(X1 >> 16 & 255u)] ^ FT3[(signed long long int)(X2 >> 24 & 255u)];
    uint32_t *tmp_post$7=RK;
    RK = RK + 1ll;
    X0 = *tmp_post$7 ^ FT0[(signed long long int)(Y0 & 255u)] ^ FT1[(signed long long int)(Y1 >> 8 & 255u)] ^ FT2[(signed long long int)(Y2 >> 16 & 255u)] ^ FT3[(signed long long int)(Y3 >> 24 & 255u)];
    uint32_t *tmp_post$8=RK;
    RK = RK + 1ll;
    X1 = *tmp_post$8 ^ FT0[(signed long long int)(Y1 & 255u)] ^ FT1[(signed long long int)(Y2 >> 8 & 255u)] ^ FT2[(signed long long int)(Y3 >> 16 & 255u)] ^ FT3[(signed long long int)(Y0 >> 24 & 255u)];
    uint32_t *tmp_post$9=RK;
    RK = RK + 1ll;
    X2 = *tmp_post$9 ^ FT0[(signed long long int)(Y2 & 255u)] ^ FT1[(signed long long int)(Y3 >> 8 & 255u)] ^ FT2[(signed long long int)(Y0 >> 16 & 255u)] ^ FT3[(signed long long int)(Y1 >> 24 & 255u)];
    uint32_t *tmp_post$10=RK;
    RK = RK + 1ll;
    X3 = *tmp_post$10 ^ FT0[(signed long long int)(Y3 & 255u)] ^ FT1[(signed long long int)(Y0 >> 8 & 255u)] ^ FT2[(signed long long int)(Y1 >> 16 & 255u)] ^ FT3[(signed long long int)(Y2 >> 24 & 255u)];
  }
  uint32_t *tmp_post$11=RK;
  RK = RK + 1ll;
  Y0 = *tmp_post$11 ^ FT0[(signed long long int)(X0 & 255u)] ^ FT1[(signed long long int)(X1 >> 8 & 255u)] ^ FT2[(signed long long int)(X2 >> 16 & 255u)] ^ FT3[(signed long long int)(X3 >> 24 & 255u)];
  uint32_t *tmp_post$12=RK;
  RK = RK + 1ll;
  Y1 = *tmp_post$12 ^ FT0[(signed long long int)(X1 & 255u)] ^ FT1[(signed long long int)(X2 >> 8 & 255u)] ^ FT2[(signed long long int)(X3 >> 16 & 255u)] ^ FT3[(signed long long int)(X0 >> 24 & 255u)];
  uint32_t *tmp_post$13=RK;
  RK = RK + 1ll;
  Y2 = *tmp_post$13 ^ FT0[(signed long long int)(X2 & 255u)] ^ FT1[(signed long long int)(X3 >> 8 & 255u)] ^ FT2[(signed long long int)(X0 >> 16 & 255u)] ^ FT3[(signed long long int)(X1 >> 24 & 255u)];
  uint32_t *tmp_post$14=RK;
  RK = RK + 1ll;
  Y3 = *tmp_post$14 ^ FT0[(signed long long int)(X3 & 255u)] ^ FT1[(signed long long int)(X0 >> 8 & 255u)] ^ FT2[(signed long long int)(X1 >> 16 & 255u)] ^ FT3[(signed long long int)(X2 >> 24 & 255u)];
  uint32_t *tmp_post$15=RK;
  RK = RK + 1ll;
  X0 = *tmp_post$15 ^ (uint32_t)FSb[(signed long long int)(Y0 & 255u)] ^ (uint32_t)FSb[(signed long long int)(Y1 >> 8 & 255u)] << 8 ^ (uint32_t)FSb[(signed long long int)(Y2 >> 16 & 255u)] << 16 ^ (uint32_t)FSb[(signed long long int)(Y3 >> 24 & 255u)] << 24;
  uint32_t *tmp_post$16=RK;
  RK = RK + 1ll;
  X1 = *tmp_post$16 ^ (uint32_t)FSb[(signed long long int)(Y1 & 255u)] ^ (uint32_t)FSb[(signed long long int)(Y2 >> 8 & 255u)] << 8 ^ (uint32_t)FSb[(signed long long int)(Y3 >> 16 & 255u)] << 16 ^ (uint32_t)FSb[(signed long long int)(Y0 >> 24 & 255u)] << 24;
  uint32_t *tmp_post$17=RK;
  RK = RK + 1ll;
  X2 = *tmp_post$17 ^ (uint32_t)FSb[(signed long long int)(Y2 & 255u)] ^ (uint32_t)FSb[(signed long long int)(Y3 >> 8 & 255u)] << 8 ^ (uint32_t)FSb[(signed long long int)(Y0 >> 16 & 255u)] << 16 ^ (uint32_t)FSb[(signed long long int)(Y1 >> 24 & 255u)] << 24;
  uint32_t *tmp_post$18=RK;
  RK = RK + 1ll;
  X3 = *tmp_post$18 ^ (uint32_t)FSb[(signed long long int)(Y3 & 255u)] ^ (uint32_t)FSb[(signed long long int)(Y0 >> 8 & 255u)] << 8 ^ (uint32_t)FSb[(signed long long int)(Y1 >> 16 & 255u)] << 16 ^ (uint32_t)FSb[(signed long long int)(Y2 >> 24 & 255u)] << 24;
  output[0ll] = (unsigned char)(X0 & 255u);
  output[(signed long long int)(0 + 1)] = (unsigned char)(X0 >> 8 & 255u);
  output[(signed long long int)(0 + 2)] = (unsigned char)(X0 >> 16 & 255u);
  output[(signed long long int)(0 + 3)] = (unsigned char)(X0 >> 24 & 255u);
  output[4ll] = (unsigned char)(X1 & 255u);
  output[(signed long long int)(4 + 1)] = (unsigned char)(X1 >> 8 & 255u);
  output[(signed long long int)(4 + 2)] = (unsigned char)(X1 >> 16 & 255u);
  output[(signed long long int)(4 + 3)] = (unsigned char)(X1 >> 24 & 255u);
  output[8ll] = (unsigned char)(X2 & 255u);
  output[(signed long long int)(8 + 1)] = (unsigned char)(X2 >> 8 & 255u);
  output[(signed long long int)(8 + 2)] = (unsigned char)(X2 >> 16 & 255u);
  output[(signed long long int)(8 + 3)] = (unsigned char)(X2 >> 24 & 255u);
  output[12ll] = (unsigned char)(X3 & 255u);
  output[(signed long long int)(12 + 1)] = (unsigned char)(X3 >> 8 & 255u);
  output[(signed long long int)(12 + 2)] = (unsigned char)(X3 >> 16 & 255u);
  output[(signed long long int)(12 + 3)] = (unsigned char)(X3 >> 24 & 255u);
  return 0;
}

// mbedtls_internal_sha1_process
// file ..\..\..\..\lib\third_party\mbedtls\library\sha1.c line 122
signed int mbedtls_internal_sha1_process(mbedtls_sha1_context *ctx, const unsigned char *data)
{
  uint32_t temp;
  uint32_t W[16ll];
  uint32_t A;
  uint32_t B;
  uint32_t C;
  uint32_t D;
  uint32_t E;
  W[0ll] = (uint32_t)data[0ll] << 24 | (uint32_t)data[(signed long long int)(0 + 1)] << 16 | (uint32_t)data[(signed long long int)(0 + 2)] << 8 | (uint32_t)data[(signed long long int)(0 + 3)];
  W[1ll] = (uint32_t)data[4ll] << 24 | (uint32_t)data[(signed long long int)(4 + 1)] << 16 | (uint32_t)data[(signed long long int)(4 + 2)] << 8 | (uint32_t)data[(signed long long int)(4 + 3)];
  W[2ll] = (uint32_t)data[8ll] << 24 | (uint32_t)data[(signed long long int)(8 + 1)] << 16 | (uint32_t)data[(signed long long int)(8 + 2)] << 8 | (uint32_t)data[(signed long long int)(8 + 3)];
  W[3ll] = (uint32_t)data[12ll] << 24 | (uint32_t)data[(signed long long int)(12 + 1)] << 16 | (uint32_t)data[(signed long long int)(12 + 2)] << 8 | (uint32_t)data[(signed long long int)(12 + 3)];
  W[4ll] = (uint32_t)data[16ll] << 24 | (uint32_t)data[(signed long long int)(16 + 1)] << 16 | (uint32_t)data[(signed long long int)(16 + 2)] << 8 | (uint32_t)data[(signed long long int)(16 + 3)];
  W[5ll] = (uint32_t)data[20ll] << 24 | (uint32_t)data[(signed long long int)(20 + 1)] << 16 | (uint32_t)data[(signed long long int)(20 + 2)] << 8 | (uint32_t)data[(signed long long int)(20 + 3)];
  W[6ll] = (uint32_t)data[24ll] << 24 | (uint32_t)data[(signed long long int)(24 + 1)] << 16 | (uint32_t)data[(signed long long int)(24 + 2)] << 8 | (uint32_t)data[(signed long long int)(24 + 3)];
  W[7ll] = (uint32_t)data[28ll] << 24 | (uint32_t)data[(signed long long int)(28 + 1)] << 16 | (uint32_t)data[(signed long long int)(28 + 2)] << 8 | (uint32_t)data[(signed long long int)(28 + 3)];
  W[8ll] = (uint32_t)data[32ll] << 24 | (uint32_t)data[(signed long long int)(32 + 1)] << 16 | (uint32_t)data[(signed long long int)(32 + 2)] << 8 | (uint32_t)data[(signed long long int)(32 + 3)];
  W[9ll] = (uint32_t)data[36ll] << 24 | (uint32_t)data[(signed long long int)(36 + 1)] << 16 | (uint32_t)data[(signed long long int)(36 + 2)] << 8 | (uint32_t)data[(signed long long int)(36 + 3)];
  W[10ll] = (uint32_t)data[40ll] << 24 | (uint32_t)data[(signed long long int)(40 + 1)] << 16 | (uint32_t)data[(signed long long int)(40 + 2)] << 8 | (uint32_t)data[(signed long long int)(40 + 3)];
  W[11ll] = (uint32_t)data[44ll] << 24 | (uint32_t)data[(signed long long int)(44 + 1)] << 16 | (uint32_t)data[(signed long long int)(44 + 2)] << 8 | (uint32_t)data[(signed long long int)(44 + 3)];
  W[12ll] = (uint32_t)data[48ll] << 24 | (uint32_t)data[(signed long long int)(48 + 1)] << 16 | (uint32_t)data[(signed long long int)(48 + 2)] << 8 | (uint32_t)data[(signed long long int)(48 + 3)];
  W[13ll] = (uint32_t)data[52ll] << 24 | (uint32_t)data[(signed long long int)(52 + 1)] << 16 | (uint32_t)data[(signed long long int)(52 + 2)] << 8 | (uint32_t)data[(signed long long int)(52 + 3)];
  W[14ll] = (uint32_t)data[56ll] << 24 | (uint32_t)data[(signed long long int)(56 + 1)] << 16 | (uint32_t)data[(signed long long int)(56 + 2)] << 8 | (uint32_t)data[(signed long long int)(56 + 3)];
  W[15ll] = (uint32_t)data[60ll] << 24 | (uint32_t)data[(signed long long int)(60 + 1)] << 16 | (uint32_t)data[(signed long long int)(60 + 2)] << 8 | (uint32_t)data[(signed long long int)(60 + 3)];
  A = ctx->state[0ll];
  B = ctx->state[1ll];
  C = ctx->state[2ll];
  D = ctx->state[3ll];
  E = ctx->state[4ll];
  E = E + (A << 5 | (A & 0xFFFFFFFFu) >> 32 - 5) + (D ^ B & (C ^ D)) + 1518500249u + W[0ll];
  B = B << 30 | (B & 0xFFFFFFFFu) >> 32 - 30;
  D = D + (E << 5 | (E & 0xFFFFFFFFu) >> 32 - 5) + (C ^ A & (B ^ C)) + 1518500249u + W[1ll];
  A = A << 30 | (A & 0xFFFFFFFFu) >> 32 - 30;
  C = C + (D << 5 | (D & 0xFFFFFFFFu) >> 32 - 5) + (B ^ E & (A ^ B)) + 1518500249u + W[2ll];
  E = E << 30 | (E & 0xFFFFFFFFu) >> 32 - 30;
  B = B + (C << 5 | (C & 0xFFFFFFFFu) >> 32 - 5) + (A ^ D & (E ^ A)) + 1518500249u + W[3ll];
  D = D << 30 | (D & 0xFFFFFFFFu) >> 32 - 30;
  A = A + (B << 5 | (B & 0xFFFFFFFFu) >> 32 - 5) + (E ^ C & (D ^ E)) + 1518500249u + W[4ll];
  C = C << 30 | (C & 0xFFFFFFFFu) >> 32 - 30;
  E = E + (A << 5 | (A & 0xFFFFFFFFu) >> 32 - 5) + (D ^ B & (C ^ D)) + 1518500249u + W[5ll];
  B = B << 30 | (B & 0xFFFFFFFFu) >> 32 - 30;
  D = D + (E << 5 | (E & 0xFFFFFFFFu) >> 32 - 5) + (C ^ A & (B ^ C)) + 1518500249u + W[6ll];
  A = A << 30 | (A & 0xFFFFFFFFu) >> 32 - 30;
  C = C + (D << 5 | (D & 0xFFFFFFFFu) >> 32 - 5) + (B ^ E & (A ^ B)) + 1518500249u + W[7ll];
  E = E << 30 | (E & 0xFFFFFFFFu) >> 32 - 30;
  B = B + (C << 5 | (C & 0xFFFFFFFFu) >> 32 - 5) + (A ^ D & (E ^ A)) + 1518500249u + W[8ll];
  D = D << 30 | (D & 0xFFFFFFFFu) >> 32 - 30;
  A = A + (B << 5 | (B & 0xFFFFFFFFu) >> 32 - 5) + (E ^ C & (D ^ E)) + 1518500249u + W[9ll];
  C = C << 30 | (C & 0xFFFFFFFFu) >> 32 - 30;
  E = E + (A << 5 | (A & 0xFFFFFFFFu) >> 32 - 5) + (D ^ B & (C ^ D)) + 1518500249u + W[10ll];
  B = B << 30 | (B & 0xFFFFFFFFu) >> 32 - 30;
  D = D + (E << 5 | (E & 0xFFFFFFFFu) >> 32 - 5) + (C ^ A & (B ^ C)) + 1518500249u + W[11ll];
  A = A << 30 | (A & 0xFFFFFFFFu) >> 32 - 30;
  C = C + (D << 5 | (D & 0xFFFFFFFFu) >> 32 - 5) + (B ^ E & (A ^ B)) + 1518500249u + W[12ll];
  E = E << 30 | (E & 0xFFFFFFFFu) >> 32 - 30;
  B = B + (C << 5 | (C & 0xFFFFFFFFu) >> 32 - 5) + (A ^ D & (E ^ A)) + 1518500249u + W[13ll];
  D = D << 30 | (D & 0xFFFFFFFFu) >> 32 - 30;
  A = A + (B << 5 | (B & 0xFFFFFFFFu) >> 32 - 5) + (E ^ C & (D ^ E)) + 1518500249u + W[14ll];
  C = C << 30 | (C & 0xFFFFFFFFu) >> 32 - 30;
  E = E + (A << 5 | (A & 0xFFFFFFFFu) >> 32 - 5) + (D ^ B & (C ^ D)) + 1518500249u + W[15ll];
  B = B << 30 | (B & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(16 - 3 & 0xF)] ^ W[(signed long long int)(16 - 8 & 0xF)] ^ W[(signed long long int)(16 - 14 & 0xF)] ^ W[(signed long long int)(16 & 0xF)];
  W[(signed long long int)(16 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  D = D + (E << 5 | (E & 0xFFFFFFFFu) >> 32 - 5) + (C ^ A & (B ^ C)) + 1518500249u + W[(signed long long int)(16 & 0xF)];
  A = A << 30 | (A & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(17 - 3 & 0xF)] ^ W[(signed long long int)(17 - 8 & 0xF)] ^ W[(signed long long int)(17 - 14 & 0xF)] ^ W[(signed long long int)(17 & 0xF)];
  W[(signed long long int)(17 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  C = C + (D << 5 | (D & 0xFFFFFFFFu) >> 32 - 5) + (B ^ E & (A ^ B)) + 1518500249u + W[(signed long long int)(17 & 0xF)];
  E = E << 30 | (E & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(18 - 3 & 0xF)] ^ W[(signed long long int)(18 - 8 & 0xF)] ^ W[(signed long long int)(18 - 14 & 0xF)] ^ W[(signed long long int)(18 & 0xF)];
  W[(signed long long int)(18 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  B = B + (C << 5 | (C & 0xFFFFFFFFu) >> 32 - 5) + (A ^ D & (E ^ A)) + 1518500249u + W[(signed long long int)(18 & 0xF)];
  D = D << 30 | (D & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(19 - 3 & 0xF)] ^ W[(signed long long int)(19 - 8 & 0xF)] ^ W[(signed long long int)(19 - 14 & 0xF)] ^ W[(signed long long int)(19 & 0xF)];
  W[(signed long long int)(19 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  A = A + (B << 5 | (B & 0xFFFFFFFFu) >> 32 - 5) + (E ^ C & (D ^ E)) + 1518500249u + W[(signed long long int)(19 & 0xF)];
  C = C << 30 | (C & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(20 - 3 & 0xF)] ^ W[(signed long long int)(20 - 8 & 0xF)] ^ W[(signed long long int)(20 - 14 & 0xF)] ^ W[(signed long long int)(20 & 0xF)];
  W[(signed long long int)(20 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  E = E + (A << 5 | (A & 0xFFFFFFFFu) >> 32 - 5) + (B ^ C ^ D) + 1859775393u + W[(signed long long int)(20 & 0xF)];
  B = B << 30 | (B & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(21 - 3 & 0xF)] ^ W[(signed long long int)(21 - 8 & 0xF)] ^ W[(signed long long int)(21 - 14 & 0xF)] ^ W[(signed long long int)(21 & 0xF)];
  W[(signed long long int)(21 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  D = D + (E << 5 | (E & 0xFFFFFFFFu) >> 32 - 5) + (A ^ B ^ C) + 1859775393u + W[(signed long long int)(21 & 0xF)];
  A = A << 30 | (A & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(22 - 3 & 0xF)] ^ W[(signed long long int)(22 - 8 & 0xF)] ^ W[(signed long long int)(22 - 14 & 0xF)] ^ W[(signed long long int)(22 & 0xF)];
  W[(signed long long int)(22 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  C = C + (D << 5 | (D & 0xFFFFFFFFu) >> 32 - 5) + (E ^ A ^ B) + 1859775393u + W[(signed long long int)(22 & 0xF)];
  E = E << 30 | (E & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(23 - 3 & 0xF)] ^ W[(signed long long int)(23 - 8 & 0xF)] ^ W[(signed long long int)(23 - 14 & 0xF)] ^ W[(signed long long int)(23 & 0xF)];
  W[(signed long long int)(23 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  B = B + (C << 5 | (C & 0xFFFFFFFFu) >> 32 - 5) + (D ^ E ^ A) + 1859775393u + W[(signed long long int)(23 & 0xF)];
  D = D << 30 | (D & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(24 - 3 & 0xF)] ^ W[(signed long long int)(24 - 8 & 0xF)] ^ W[(signed long long int)(24 - 14 & 0xF)] ^ W[(signed long long int)(24 & 0xF)];
  W[(signed long long int)(24 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  A = A + (B << 5 | (B & 0xFFFFFFFFu) >> 32 - 5) + (C ^ D ^ E) + 1859775393u + W[(signed long long int)(24 & 0xF)];
  C = C << 30 | (C & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(25 - 3 & 0xF)] ^ W[(signed long long int)(25 - 8 & 0xF)] ^ W[(signed long long int)(25 - 14 & 0xF)] ^ W[(signed long long int)(25 & 0xF)];
  W[(signed long long int)(25 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  E = E + (A << 5 | (A & 0xFFFFFFFFu) >> 32 - 5) + (B ^ C ^ D) + 1859775393u + W[(signed long long int)(25 & 0xF)];
  B = B << 30 | (B & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(26 - 3 & 0xF)] ^ W[(signed long long int)(26 - 8 & 0xF)] ^ W[(signed long long int)(26 - 14 & 0xF)] ^ W[(signed long long int)(26 & 0xF)];
  W[(signed long long int)(26 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  D = D + (E << 5 | (E & 0xFFFFFFFFu) >> 32 - 5) + (A ^ B ^ C) + 1859775393u + W[(signed long long int)(26 & 0xF)];
  A = A << 30 | (A & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(27 - 3 & 0xF)] ^ W[(signed long long int)(27 - 8 & 0xF)] ^ W[(signed long long int)(27 - 14 & 0xF)] ^ W[(signed long long int)(27 & 0xF)];
  W[(signed long long int)(27 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  C = C + (D << 5 | (D & 0xFFFFFFFFu) >> 32 - 5) + (E ^ A ^ B) + 1859775393u + W[(signed long long int)(27 & 0xF)];
  E = E << 30 | (E & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(28 - 3 & 0xF)] ^ W[(signed long long int)(28 - 8 & 0xF)] ^ W[(signed long long int)(28 - 14 & 0xF)] ^ W[(signed long long int)(28 & 0xF)];
  W[(signed long long int)(28 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  B = B + (C << 5 | (C & 0xFFFFFFFFu) >> 32 - 5) + (D ^ E ^ A) + 1859775393u + W[(signed long long int)(28 & 0xF)];
  D = D << 30 | (D & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(29 - 3 & 0xF)] ^ W[(signed long long int)(29 - 8 & 0xF)] ^ W[(signed long long int)(29 - 14 & 0xF)] ^ W[(signed long long int)(29 & 0xF)];
  W[(signed long long int)(29 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  A = A + (B << 5 | (B & 0xFFFFFFFFu) >> 32 - 5) + (C ^ D ^ E) + 1859775393u + W[(signed long long int)(29 & 0xF)];
  C = C << 30 | (C & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(30 - 3 & 0xF)] ^ W[(signed long long int)(30 - 8 & 0xF)] ^ W[(signed long long int)(30 - 14 & 0xF)] ^ W[(signed long long int)(30 & 0xF)];
  W[(signed long long int)(30 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  E = E + (A << 5 | (A & 0xFFFFFFFFu) >> 32 - 5) + (B ^ C ^ D) + 1859775393u + W[(signed long long int)(30 & 0xF)];
  B = B << 30 | (B & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(31 - 3 & 0xF)] ^ W[(signed long long int)(31 - 8 & 0xF)] ^ W[(signed long long int)(31 - 14 & 0xF)] ^ W[(signed long long int)(31 & 0xF)];
  W[(signed long long int)(31 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  D = D + (E << 5 | (E & 0xFFFFFFFFu) >> 32 - 5) + (A ^ B ^ C) + 1859775393u + W[(signed long long int)(31 & 0xF)];
  A = A << 30 | (A & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(32 - 3 & 0xF)] ^ W[(signed long long int)(32 - 8 & 0xF)] ^ W[(signed long long int)(32 - 14 & 0xF)] ^ W[(signed long long int)(32 & 0xF)];
  W[(signed long long int)(32 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  C = C + (D << 5 | (D & 0xFFFFFFFFu) >> 32 - 5) + (E ^ A ^ B) + 1859775393u + W[(signed long long int)(32 & 0xF)];
  E = E << 30 | (E & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(33 - 3 & 0xF)] ^ W[(signed long long int)(33 - 8 & 0xF)] ^ W[(signed long long int)(33 - 14 & 0xF)] ^ W[(signed long long int)(33 & 0xF)];
  W[(signed long long int)(33 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  B = B + (C << 5 | (C & 0xFFFFFFFFu) >> 32 - 5) + (D ^ E ^ A) + 1859775393u + W[(signed long long int)(33 & 0xF)];
  D = D << 30 | (D & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(34 - 3 & 0xF)] ^ W[(signed long long int)(34 - 8 & 0xF)] ^ W[(signed long long int)(34 - 14 & 0xF)] ^ W[(signed long long int)(34 & 0xF)];
  W[(signed long long int)(34 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  A = A + (B << 5 | (B & 0xFFFFFFFFu) >> 32 - 5) + (C ^ D ^ E) + 1859775393u + W[(signed long long int)(34 & 0xF)];
  C = C << 30 | (C & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(35 - 3 & 0xF)] ^ W[(signed long long int)(35 - 8 & 0xF)] ^ W[(signed long long int)(35 - 14 & 0xF)] ^ W[(signed long long int)(35 & 0xF)];
  W[(signed long long int)(35 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  E = E + (A << 5 | (A & 0xFFFFFFFFu) >> 32 - 5) + (B ^ C ^ D) + 1859775393u + W[(signed long long int)(35 & 0xF)];
  B = B << 30 | (B & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(36 - 3 & 0xF)] ^ W[(signed long long int)(36 - 8 & 0xF)] ^ W[(signed long long int)(36 - 14 & 0xF)] ^ W[(signed long long int)(36 & 0xF)];
  W[(signed long long int)(36 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  D = D + (E << 5 | (E & 0xFFFFFFFFu) >> 32 - 5) + (A ^ B ^ C) + 1859775393u + W[(signed long long int)(36 & 0xF)];
  A = A << 30 | (A & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(37 - 3 & 0xF)] ^ W[(signed long long int)(37 - 8 & 0xF)] ^ W[(signed long long int)(37 - 14 & 0xF)] ^ W[(signed long long int)(37 & 0xF)];
  W[(signed long long int)(37 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  C = C + (D << 5 | (D & 0xFFFFFFFFu) >> 32 - 5) + (E ^ A ^ B) + 1859775393u + W[(signed long long int)(37 & 0xF)];
  E = E << 30 | (E & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(38 - 3 & 0xF)] ^ W[(signed long long int)(38 - 8 & 0xF)] ^ W[(signed long long int)(38 - 14 & 0xF)] ^ W[(signed long long int)(38 & 0xF)];
  W[(signed long long int)(38 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  B = B + (C << 5 | (C & 0xFFFFFFFFu) >> 32 - 5) + (D ^ E ^ A) + 1859775393u + W[(signed long long int)(38 & 0xF)];
  D = D << 30 | (D & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(39 - 3 & 0xF)] ^ W[(signed long long int)(39 - 8 & 0xF)] ^ W[(signed long long int)(39 - 14 & 0xF)] ^ W[(signed long long int)(39 & 0xF)];
  W[(signed long long int)(39 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  A = A + (B << 5 | (B & 0xFFFFFFFFu) >> 32 - 5) + (C ^ D ^ E) + 1859775393u + W[(signed long long int)(39 & 0xF)];
  C = C << 30 | (C & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(40 - 3 & 0xF)] ^ W[(signed long long int)(40 - 8 & 0xF)] ^ W[(signed long long int)(40 - 14 & 0xF)] ^ W[(signed long long int)(40 & 0xF)];
  W[(signed long long int)(40 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  E = E + (A << 5 | (A & 0xFFFFFFFFu) >> 32 - 5) + (B & C | D & (B | C)) + 0x8F1BBCDCu + W[(signed long long int)(40 & 0xF)];
  B = B << 30 | (B & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(41 - 3 & 0xF)] ^ W[(signed long long int)(41 - 8 & 0xF)] ^ W[(signed long long int)(41 - 14 & 0xF)] ^ W[(signed long long int)(41 & 0xF)];
  W[(signed long long int)(41 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  D = D + (E << 5 | (E & 0xFFFFFFFFu) >> 32 - 5) + (A & B | C & (A | B)) + 0x8F1BBCDCu + W[(signed long long int)(41 & 0xF)];
  A = A << 30 | (A & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(42 - 3 & 0xF)] ^ W[(signed long long int)(42 - 8 & 0xF)] ^ W[(signed long long int)(42 - 14 & 0xF)] ^ W[(signed long long int)(42 & 0xF)];
  W[(signed long long int)(42 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  C = C + (D << 5 | (D & 0xFFFFFFFFu) >> 32 - 5) + (E & A | B & (E | A)) + 0x8F1BBCDCu + W[(signed long long int)(42 & 0xF)];
  E = E << 30 | (E & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(43 - 3 & 0xF)] ^ W[(signed long long int)(43 - 8 & 0xF)] ^ W[(signed long long int)(43 - 14 & 0xF)] ^ W[(signed long long int)(43 & 0xF)];
  W[(signed long long int)(43 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  B = B + (C << 5 | (C & 0xFFFFFFFFu) >> 32 - 5) + (D & E | A & (D | E)) + 0x8F1BBCDCu + W[(signed long long int)(43 & 0xF)];
  D = D << 30 | (D & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(44 - 3 & 0xF)] ^ W[(signed long long int)(44 - 8 & 0xF)] ^ W[(signed long long int)(44 - 14 & 0xF)] ^ W[(signed long long int)(44 & 0xF)];
  W[(signed long long int)(44 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  A = A + (B << 5 | (B & 0xFFFFFFFFu) >> 32 - 5) + (C & D | E & (C | D)) + 0x8F1BBCDCu + W[(signed long long int)(44 & 0xF)];
  C = C << 30 | (C & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(45 - 3 & 0xF)] ^ W[(signed long long int)(45 - 8 & 0xF)] ^ W[(signed long long int)(45 - 14 & 0xF)] ^ W[(signed long long int)(45 & 0xF)];
  W[(signed long long int)(45 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  E = E + (A << 5 | (A & 0xFFFFFFFFu) >> 32 - 5) + (B & C | D & (B | C)) + 0x8F1BBCDCu + W[(signed long long int)(45 & 0xF)];
  B = B << 30 | (B & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(46 - 3 & 0xF)] ^ W[(signed long long int)(46 - 8 & 0xF)] ^ W[(signed long long int)(46 - 14 & 0xF)] ^ W[(signed long long int)(46 & 0xF)];
  W[(signed long long int)(46 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  D = D + (E << 5 | (E & 0xFFFFFFFFu) >> 32 - 5) + (A & B | C & (A | B)) + 0x8F1BBCDCu + W[(signed long long int)(46 & 0xF)];
  A = A << 30 | (A & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(47 - 3 & 0xF)] ^ W[(signed long long int)(47 - 8 & 0xF)] ^ W[(signed long long int)(47 - 14 & 0xF)] ^ W[(signed long long int)(47 & 0xF)];
  W[(signed long long int)(47 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  C = C + (D << 5 | (D & 0xFFFFFFFFu) >> 32 - 5) + (E & A | B & (E | A)) + 0x8F1BBCDCu + W[(signed long long int)(47 & 0xF)];
  E = E << 30 | (E & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(48 - 3 & 0xF)] ^ W[(signed long long int)(48 - 8 & 0xF)] ^ W[(signed long long int)(48 - 14 & 0xF)] ^ W[(signed long long int)(48 & 0xF)];
  W[(signed long long int)(48 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  B = B + (C << 5 | (C & 0xFFFFFFFFu) >> 32 - 5) + (D & E | A & (D | E)) + 0x8F1BBCDCu + W[(signed long long int)(48 & 0xF)];
  D = D << 30 | (D & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(49 - 3 & 0xF)] ^ W[(signed long long int)(49 - 8 & 0xF)] ^ W[(signed long long int)(49 - 14 & 0xF)] ^ W[(signed long long int)(49 & 0xF)];
  W[(signed long long int)(49 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  A = A + (B << 5 | (B & 0xFFFFFFFFu) >> 32 - 5) + (C & D | E & (C | D)) + 0x8F1BBCDCu + W[(signed long long int)(49 & 0xF)];
  C = C << 30 | (C & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(50 - 3 & 0xF)] ^ W[(signed long long int)(50 - 8 & 0xF)] ^ W[(signed long long int)(50 - 14 & 0xF)] ^ W[(signed long long int)(50 & 0xF)];
  W[(signed long long int)(50 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  E = E + (A << 5 | (A & 0xFFFFFFFFu) >> 32 - 5) + (B & C | D & (B | C)) + 0x8F1BBCDCu + W[(signed long long int)(50 & 0xF)];
  B = B << 30 | (B & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(51 - 3 & 0xF)] ^ W[(signed long long int)(51 - 8 & 0xF)] ^ W[(signed long long int)(51 - 14 & 0xF)] ^ W[(signed long long int)(51 & 0xF)];
  W[(signed long long int)(51 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  D = D + (E << 5 | (E & 0xFFFFFFFFu) >> 32 - 5) + (A & B | C & (A | B)) + 0x8F1BBCDCu + W[(signed long long int)(51 & 0xF)];
  A = A << 30 | (A & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(52 - 3 & 0xF)] ^ W[(signed long long int)(52 - 8 & 0xF)] ^ W[(signed long long int)(52 - 14 & 0xF)] ^ W[(signed long long int)(52 & 0xF)];
  W[(signed long long int)(52 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  C = C + (D << 5 | (D & 0xFFFFFFFFu) >> 32 - 5) + (E & A | B & (E | A)) + 0x8F1BBCDCu + W[(signed long long int)(52 & 0xF)];
  E = E << 30 | (E & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(53 - 3 & 0xF)] ^ W[(signed long long int)(53 - 8 & 0xF)] ^ W[(signed long long int)(53 - 14 & 0xF)] ^ W[(signed long long int)(53 & 0xF)];
  W[(signed long long int)(53 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  B = B + (C << 5 | (C & 0xFFFFFFFFu) >> 32 - 5) + (D & E | A & (D | E)) + 0x8F1BBCDCu + W[(signed long long int)(53 & 0xF)];
  D = D << 30 | (D & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(54 - 3 & 0xF)] ^ W[(signed long long int)(54 - 8 & 0xF)] ^ W[(signed long long int)(54 - 14 & 0xF)] ^ W[(signed long long int)(54 & 0xF)];
  W[(signed long long int)(54 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  A = A + (B << 5 | (B & 0xFFFFFFFFu) >> 32 - 5) + (C & D | E & (C | D)) + 0x8F1BBCDCu + W[(signed long long int)(54 & 0xF)];
  C = C << 30 | (C & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(55 - 3 & 0xF)] ^ W[(signed long long int)(55 - 8 & 0xF)] ^ W[(signed long long int)(55 - 14 & 0xF)] ^ W[(signed long long int)(55 & 0xF)];
  W[(signed long long int)(55 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  E = E + (A << 5 | (A & 0xFFFFFFFFu) >> 32 - 5) + (B & C | D & (B | C)) + 0x8F1BBCDCu + W[(signed long long int)(55 & 0xF)];
  B = B << 30 | (B & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(56 - 3 & 0xF)] ^ W[(signed long long int)(56 - 8 & 0xF)] ^ W[(signed long long int)(56 - 14 & 0xF)] ^ W[(signed long long int)(56 & 0xF)];
  W[(signed long long int)(56 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  D = D + (E << 5 | (E & 0xFFFFFFFFu) >> 32 - 5) + (A & B | C & (A | B)) + 0x8F1BBCDCu + W[(signed long long int)(56 & 0xF)];
  A = A << 30 | (A & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(57 - 3 & 0xF)] ^ W[(signed long long int)(57 - 8 & 0xF)] ^ W[(signed long long int)(57 - 14 & 0xF)] ^ W[(signed long long int)(57 & 0xF)];
  W[(signed long long int)(57 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  C = C + (D << 5 | (D & 0xFFFFFFFFu) >> 32 - 5) + (E & A | B & (E | A)) + 0x8F1BBCDCu + W[(signed long long int)(57 & 0xF)];
  E = E << 30 | (E & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(58 - 3 & 0xF)] ^ W[(signed long long int)(58 - 8 & 0xF)] ^ W[(signed long long int)(58 - 14 & 0xF)] ^ W[(signed long long int)(58 & 0xF)];
  W[(signed long long int)(58 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  B = B + (C << 5 | (C & 0xFFFFFFFFu) >> 32 - 5) + (D & E | A & (D | E)) + 0x8F1BBCDCu + W[(signed long long int)(58 & 0xF)];
  D = D << 30 | (D & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(59 - 3 & 0xF)] ^ W[(signed long long int)(59 - 8 & 0xF)] ^ W[(signed long long int)(59 - 14 & 0xF)] ^ W[(signed long long int)(59 & 0xF)];
  W[(signed long long int)(59 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  A = A + (B << 5 | (B & 0xFFFFFFFFu) >> 32 - 5) + (C & D | E & (C | D)) + 0x8F1BBCDCu + W[(signed long long int)(59 & 0xF)];
  C = C << 30 | (C & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(60 - 3 & 0xF)] ^ W[(signed long long int)(60 - 8 & 0xF)] ^ W[(signed long long int)(60 - 14 & 0xF)] ^ W[(signed long long int)(60 & 0xF)];
  W[(signed long long int)(60 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  E = E + (A << 5 | (A & 0xFFFFFFFFu) >> 32 - 5) + (B ^ C ^ D) + 0xCA62C1D6u + W[(signed long long int)(60 & 0xF)];
  B = B << 30 | (B & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(61 - 3 & 0xF)] ^ W[(signed long long int)(61 - 8 & 0xF)] ^ W[(signed long long int)(61 - 14 & 0xF)] ^ W[(signed long long int)(61 & 0xF)];
  W[(signed long long int)(61 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  D = D + (E << 5 | (E & 0xFFFFFFFFu) >> 32 - 5) + (A ^ B ^ C) + 0xCA62C1D6u + W[(signed long long int)(61 & 0xF)];
  A = A << 30 | (A & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(62 - 3 & 0xF)] ^ W[(signed long long int)(62 - 8 & 0xF)] ^ W[(signed long long int)(62 - 14 & 0xF)] ^ W[(signed long long int)(62 & 0xF)];
  W[(signed long long int)(62 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  C = C + (D << 5 | (D & 0xFFFFFFFFu) >> 32 - 5) + (E ^ A ^ B) + 0xCA62C1D6u + W[(signed long long int)(62 & 0xF)];
  E = E << 30 | (E & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(63 - 3 & 0xF)] ^ W[(signed long long int)(63 - 8 & 0xF)] ^ W[(signed long long int)(63 - 14 & 0xF)] ^ W[(signed long long int)(63 & 0xF)];
  W[(signed long long int)(63 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  B = B + (C << 5 | (C & 0xFFFFFFFFu) >> 32 - 5) + (D ^ E ^ A) + 0xCA62C1D6u + W[(signed long long int)(63 & 0xF)];
  D = D << 30 | (D & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(64 - 3 & 0xF)] ^ W[(signed long long int)(64 - 8 & 0xF)] ^ W[(signed long long int)(64 - 14 & 0xF)] ^ W[(signed long long int)(64 & 0xF)];
  W[(signed long long int)(64 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  A = A + (B << 5 | (B & 0xFFFFFFFFu) >> 32 - 5) + (C ^ D ^ E) + 0xCA62C1D6u + W[(signed long long int)(64 & 0xF)];
  C = C << 30 | (C & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(65 - 3 & 0xF)] ^ W[(signed long long int)(65 - 8 & 0xF)] ^ W[(signed long long int)(65 - 14 & 0xF)] ^ W[(signed long long int)(65 & 0xF)];
  W[(signed long long int)(65 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  E = E + (A << 5 | (A & 0xFFFFFFFFu) >> 32 - 5) + (B ^ C ^ D) + 0xCA62C1D6u + W[(signed long long int)(65 & 0xF)];
  B = B << 30 | (B & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(66 - 3 & 0xF)] ^ W[(signed long long int)(66 - 8 & 0xF)] ^ W[(signed long long int)(66 - 14 & 0xF)] ^ W[(signed long long int)(66 & 0xF)];
  W[(signed long long int)(66 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  D = D + (E << 5 | (E & 0xFFFFFFFFu) >> 32 - 5) + (A ^ B ^ C) + 0xCA62C1D6u + W[(signed long long int)(66 & 0xF)];
  A = A << 30 | (A & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(67 - 3 & 0xF)] ^ W[(signed long long int)(67 - 8 & 0xF)] ^ W[(signed long long int)(67 - 14 & 0xF)] ^ W[(signed long long int)(67 & 0xF)];
  W[(signed long long int)(67 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  C = C + (D << 5 | (D & 0xFFFFFFFFu) >> 32 - 5) + (E ^ A ^ B) + 0xCA62C1D6u + W[(signed long long int)(67 & 0xF)];
  E = E << 30 | (E & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(68 - 3 & 0xF)] ^ W[(signed long long int)(68 - 8 & 0xF)] ^ W[(signed long long int)(68 - 14 & 0xF)] ^ W[(signed long long int)(68 & 0xF)];
  W[(signed long long int)(68 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  B = B + (C << 5 | (C & 0xFFFFFFFFu) >> 32 - 5) + (D ^ E ^ A) + 0xCA62C1D6u + W[(signed long long int)(68 & 0xF)];
  D = D << 30 | (D & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(69 - 3 & 0xF)] ^ W[(signed long long int)(69 - 8 & 0xF)] ^ W[(signed long long int)(69 - 14 & 0xF)] ^ W[(signed long long int)(69 & 0xF)];
  W[(signed long long int)(69 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  A = A + (B << 5 | (B & 0xFFFFFFFFu) >> 32 - 5) + (C ^ D ^ E) + 0xCA62C1D6u + W[(signed long long int)(69 & 0xF)];
  C = C << 30 | (C & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(70 - 3 & 0xF)] ^ W[(signed long long int)(70 - 8 & 0xF)] ^ W[(signed long long int)(70 - 14 & 0xF)] ^ W[(signed long long int)(70 & 0xF)];
  W[(signed long long int)(70 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  E = E + (A << 5 | (A & 0xFFFFFFFFu) >> 32 - 5) + (B ^ C ^ D) + 0xCA62C1D6u + W[(signed long long int)(70 & 0xF)];
  B = B << 30 | (B & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(71 - 3 & 0xF)] ^ W[(signed long long int)(71 - 8 & 0xF)] ^ W[(signed long long int)(71 - 14 & 0xF)] ^ W[(signed long long int)(71 & 0xF)];
  W[(signed long long int)(71 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  D = D + (E << 5 | (E & 0xFFFFFFFFu) >> 32 - 5) + (A ^ B ^ C) + 0xCA62C1D6u + W[(signed long long int)(71 & 0xF)];
  A = A << 30 | (A & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(72 - 3 & 0xF)] ^ W[(signed long long int)(72 - 8 & 0xF)] ^ W[(signed long long int)(72 - 14 & 0xF)] ^ W[(signed long long int)(72 & 0xF)];
  W[(signed long long int)(72 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  C = C + (D << 5 | (D & 0xFFFFFFFFu) >> 32 - 5) + (E ^ A ^ B) + 0xCA62C1D6u + W[(signed long long int)(72 & 0xF)];
  E = E << 30 | (E & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(73 - 3 & 0xF)] ^ W[(signed long long int)(73 - 8 & 0xF)] ^ W[(signed long long int)(73 - 14 & 0xF)] ^ W[(signed long long int)(73 & 0xF)];
  W[(signed long long int)(73 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  B = B + (C << 5 | (C & 0xFFFFFFFFu) >> 32 - 5) + (D ^ E ^ A) + 0xCA62C1D6u + W[(signed long long int)(73 & 0xF)];
  D = D << 30 | (D & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(74 - 3 & 0xF)] ^ W[(signed long long int)(74 - 8 & 0xF)] ^ W[(signed long long int)(74 - 14 & 0xF)] ^ W[(signed long long int)(74 & 0xF)];
  W[(signed long long int)(74 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  A = A + (B << 5 | (B & 0xFFFFFFFFu) >> 32 - 5) + (C ^ D ^ E) + 0xCA62C1D6u + W[(signed long long int)(74 & 0xF)];
  C = C << 30 | (C & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(75 - 3 & 0xF)] ^ W[(signed long long int)(75 - 8 & 0xF)] ^ W[(signed long long int)(75 - 14 & 0xF)] ^ W[(signed long long int)(75 & 0xF)];
  W[(signed long long int)(75 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  E = E + (A << 5 | (A & 0xFFFFFFFFu) >> 32 - 5) + (B ^ C ^ D) + 0xCA62C1D6u + W[(signed long long int)(75 & 0xF)];
  B = B << 30 | (B & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(76 - 3 & 0xF)] ^ W[(signed long long int)(76 - 8 & 0xF)] ^ W[(signed long long int)(76 - 14 & 0xF)] ^ W[(signed long long int)(76 & 0xF)];
  W[(signed long long int)(76 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  D = D + (E << 5 | (E & 0xFFFFFFFFu) >> 32 - 5) + (A ^ B ^ C) + 0xCA62C1D6u + W[(signed long long int)(76 & 0xF)];
  A = A << 30 | (A & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(77 - 3 & 0xF)] ^ W[(signed long long int)(77 - 8 & 0xF)] ^ W[(signed long long int)(77 - 14 & 0xF)] ^ W[(signed long long int)(77 & 0xF)];
  W[(signed long long int)(77 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  C = C + (D << 5 | (D & 0xFFFFFFFFu) >> 32 - 5) + (E ^ A ^ B) + 0xCA62C1D6u + W[(signed long long int)(77 & 0xF)];
  E = E << 30 | (E & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(78 - 3 & 0xF)] ^ W[(signed long long int)(78 - 8 & 0xF)] ^ W[(signed long long int)(78 - 14 & 0xF)] ^ W[(signed long long int)(78 & 0xF)];
  W[(signed long long int)(78 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  B = B + (C << 5 | (C & 0xFFFFFFFFu) >> 32 - 5) + (D ^ E ^ A) + 0xCA62C1D6u + W[(signed long long int)(78 & 0xF)];
  D = D << 30 | (D & 0xFFFFFFFFu) >> 32 - 30;
  temp = W[(signed long long int)(79 - 3 & 0xF)] ^ W[(signed long long int)(79 - 8 & 0xF)] ^ W[(signed long long int)(79 - 14 & 0xF)] ^ W[(signed long long int)(79 & 0xF)];
  W[(signed long long int)(79 & 0xF)] = temp << 1 | (temp & 0xFFFFFFFFu) >> 32 - 1;
  A = A + (B << 5 | (B & 0xFFFFFFFFu) >> 32 - 5) + (C ^ D ^ E) + 0xCA62C1D6u + W[(signed long long int)(79 & 0xF)];
  C = C << 30 | (C & 0xFFFFFFFFu) >> 32 - 30;
  ctx->state[0ll] = ctx->state[0ll] + A;
  ctx->state[1ll] = ctx->state[1ll] + B;
  ctx->state[2ll] = ctx->state[2ll] + C;
  ctx->state[3ll] = ctx->state[3ll] + D;
  ctx->state[4ll] = ctx->state[4ll] + E;
  return 0;
}

// mbedtls_internal_sha256_process
// file ..\..\..\..\lib\third_party\mbedtls\library\sha256.c line 192
signed int mbedtls_internal_sha256_process(mbedtls_sha256_context *ctx, const unsigned char *data)
{
  uint32_t temp1;
  uint32_t temp2;
  uint32_t W[64ll];
  uint32_t A[8ll];
  unsigned int i=0u;
  for( ; !(i >= 8u); i = i + 1u)
    A[(signed long long int)i] = ctx->state[(signed long long int)i];
  i = 0u;
  for( ; !(i >= 16u); i = i + 1u)
    do
      W[(signed long long int)i] = (uint32_t)data[(signed long long int)(4u * i)] << 24 | (uint32_t)data[(signed long long int)(4u * i + 1u)] << 16 | (uint32_t)data[(signed long long int)(4u * i + 2u)] << 8 | (uint32_t)data[(signed long long int)(4u * i + 3u)];
    while((_Bool)0);
  i = 0u;
  for( ; !(i >= 16u); i = i + 8u)
  {
    temp1 = A[7ll] + (((A[4ll] & 0xFFFFFFFFu) >> 6 | A[4ll] << 32 - 6) ^ ((A[4ll] & 0xFFFFFFFFu) >> 11 | A[4ll] << 32 - 11) ^ ((A[4ll] & 0xFFFFFFFFu) >> 25 | A[4ll] << 32 - 25)) + (A[6ll] ^ A[4ll] & (A[5ll] ^ A[6ll])) + K[(signed long long int)(i + 0u)] + W[(signed long long int)(i + 0u)];
    temp2 = (((A[0ll] & 0xFFFFFFFFu) >> 2 | A[0ll] << 32 - 2) ^ ((A[0ll] & 0xFFFFFFFFu) >> 13 | A[0ll] << 32 - 13) ^ ((A[0ll] & 0xFFFFFFFFu) >> 22 | A[0ll] << 32 - 22)) + (A[0ll] & A[1ll] | A[2ll] & (A[0ll] | A[1ll]));
    A[3ll] = A[3ll] + temp1;
    A[7ll] = temp1 + temp2;
    temp1 = A[6ll] + (((A[3ll] & 0xFFFFFFFFu) >> 6 | A[3ll] << 32 - 6) ^ ((A[3ll] & 0xFFFFFFFFu) >> 11 | A[3ll] << 32 - 11) ^ ((A[3ll] & 0xFFFFFFFFu) >> 25 | A[3ll] << 32 - 25)) + (A[5ll] ^ A[3ll] & (A[4ll] ^ A[5ll])) + K[(signed long long int)(i + 1u)] + W[(signed long long int)(i + 1u)];
    temp2 = (((A[7ll] & 0xFFFFFFFFu) >> 2 | A[7ll] << 32 - 2) ^ ((A[7ll] & 0xFFFFFFFFu) >> 13 | A[7ll] << 32 - 13) ^ ((A[7ll] & 0xFFFFFFFFu) >> 22 | A[7ll] << 32 - 22)) + (A[7ll] & A[0ll] | A[1ll] & (A[7ll] | A[0ll]));
    A[2ll] = A[2ll] + temp1;
    A[6ll] = temp1 + temp2;
    temp1 = A[5ll] + (((A[2ll] & 0xFFFFFFFFu) >> 6 | A[2ll] << 32 - 6) ^ ((A[2ll] & 0xFFFFFFFFu) >> 11 | A[2ll] << 32 - 11) ^ ((A[2ll] & 0xFFFFFFFFu) >> 25 | A[2ll] << 32 - 25)) + (A[4ll] ^ A[2ll] & (A[3ll] ^ A[4ll])) + K[(signed long long int)(i + 2u)] + W[(signed long long int)(i + 2u)];
    temp2 = (((A[6ll] & 0xFFFFFFFFu) >> 2 | A[6ll] << 32 - 2) ^ ((A[6ll] & 0xFFFFFFFFu) >> 13 | A[6ll] << 32 - 13) ^ ((A[6ll] & 0xFFFFFFFFu) >> 22 | A[6ll] << 32 - 22)) + (A[6ll] & A[7ll] | A[0ll] & (A[6ll] | A[7ll]));
    A[1ll] = A[1ll] + temp1;
    A[5ll] = temp1 + temp2;
    temp1 = A[4ll] + (((A[1ll] & 0xFFFFFFFFu) >> 6 | A[1ll] << 32 - 6) ^ ((A[1ll] & 0xFFFFFFFFu) >> 11 | A[1ll] << 32 - 11) ^ ((A[1ll] & 0xFFFFFFFFu) >> 25 | A[1ll] << 32 - 25)) + (A[3ll] ^ A[1ll] & (A[2ll] ^ A[3ll])) + K[(signed long long int)(i + 3u)] + W[(signed long long int)(i + 3u)];
    temp2 = (((A[5ll] & 0xFFFFFFFFu) >> 2 | A[5ll] << 32 - 2) ^ ((A[5ll] & 0xFFFFFFFFu) >> 13 | A[5ll] << 32 - 13) ^ ((A[5ll] & 0xFFFFFFFFu) >> 22 | A[5ll] << 32 - 22)) + (A[5ll] & A[6ll] | A[7ll] & (A[5ll] | A[6ll]));
    A[0ll] = A[0ll] + temp1;
    A[4ll] = temp1 + temp2;
    temp1 = A[3ll] + (((A[0ll] & 0xFFFFFFFFu) >> 6 | A[0ll] << 32 - 6) ^ ((A[0ll] & 0xFFFFFFFFu) >> 11 | A[0ll] << 32 - 11) ^ ((A[0ll] & 0xFFFFFFFFu) >> 25 | A[0ll] << 32 - 25)) + (A[2ll] ^ A[0ll] & (A[1ll] ^ A[2ll])) + K[(signed long long int)(i + 4u)] + W[(signed long long int)(i + 4u)];
    temp2 = (((A[4ll] & 0xFFFFFFFFu) >> 2 | A[4ll] << 32 - 2) ^ ((A[4ll] & 0xFFFFFFFFu) >> 13 | A[4ll] << 32 - 13) ^ ((A[4ll] & 0xFFFFFFFFu) >> 22 | A[4ll] << 32 - 22)) + (A[4ll] & A[5ll] | A[6ll] & (A[4ll] | A[5ll]));
    A[7ll] = A[7ll] + temp1;
    A[3ll] = temp1 + temp2;
    temp1 = A[2ll] + (((A[7ll] & 0xFFFFFFFFu) >> 6 | A[7ll] << 32 - 6) ^ ((A[7ll] & 0xFFFFFFFFu) >> 11 | A[7ll] << 32 - 11) ^ ((A[7ll] & 0xFFFFFFFFu) >> 25 | A[7ll] << 32 - 25)) + (A[1ll] ^ A[7ll] & (A[0ll] ^ A[1ll])) + K[(signed long long int)(i + 5u)] + W[(signed long long int)(i + 5u)];
    temp2 = (((A[3ll] & 0xFFFFFFFFu) >> 2 | A[3ll] << 32 - 2) ^ ((A[3ll] & 0xFFFFFFFFu) >> 13 | A[3ll] << 32 - 13) ^ ((A[3ll] & 0xFFFFFFFFu) >> 22 | A[3ll] << 32 - 22)) + (A[3ll] & A[4ll] | A[5ll] & (A[3ll] | A[4ll]));
    A[6ll] = A[6ll] + temp1;
    A[2ll] = temp1 + temp2;
    temp1 = A[1ll] + (((A[6ll] & 0xFFFFFFFFu) >> 6 | A[6ll] << 32 - 6) ^ ((A[6ll] & 0xFFFFFFFFu) >> 11 | A[6ll] << 32 - 11) ^ ((A[6ll] & 0xFFFFFFFFu) >> 25 | A[6ll] << 32 - 25)) + (A[0ll] ^ A[6ll] & (A[7ll] ^ A[0ll])) + K[(signed long long int)(i + 6u)] + W[(signed long long int)(i + 6u)];
    temp2 = (((A[2ll] & 0xFFFFFFFFu) >> 2 | A[2ll] << 32 - 2) ^ ((A[2ll] & 0xFFFFFFFFu) >> 13 | A[2ll] << 32 - 13) ^ ((A[2ll] & 0xFFFFFFFFu) >> 22 | A[2ll] << 32 - 22)) + (A[2ll] & A[3ll] | A[4ll] & (A[2ll] | A[3ll]));
    A[5ll] = A[5ll] + temp1;
    A[1ll] = temp1 + temp2;
    temp1 = A[0ll] + (((A[5ll] & 0xFFFFFFFFu) >> 6 | A[5ll] << 32 - 6) ^ ((A[5ll] & 0xFFFFFFFFu) >> 11 | A[5ll] << 32 - 11) ^ ((A[5ll] & 0xFFFFFFFFu) >> 25 | A[5ll] << 32 - 25)) + (A[7ll] ^ A[5ll] & (A[6ll] ^ A[7ll])) + K[(signed long long int)(i + 7u)] + W[(signed long long int)(i + 7u)];
    temp2 = (((A[1ll] & 0xFFFFFFFFu) >> 2 | A[1ll] << 32 - 2) ^ ((A[1ll] & 0xFFFFFFFFu) >> 13 | A[1ll] << 32 - 13) ^ ((A[1ll] & 0xFFFFFFFFu) >> 22 | A[1ll] << 32 - 22)) + (A[1ll] & A[2ll] | A[3ll] & (A[1ll] | A[2ll]));
    A[4ll] = A[4ll] + temp1;
    A[0ll] = temp1 + temp2;
  }
  i = 16u;
  for( ; !(i >= 64u); i = i + 8u)
  {
    W[(signed long long int)(i + 0u)] = (((W[(signed long long int)((i + 0u) - 2u)] & 0xFFFFFFFFu) >> 17 | W[(signed long long int)((i + 0u) - 2u)] << 32 - 17) ^ ((W[(signed long long int)((i + 0u) - 2u)] & 0xFFFFFFFFu) >> 19 | W[(signed long long int)((i + 0u) - 2u)] << 32 - 19) ^ (W[(signed long long int)((i + 0u) - 2u)] & 0xFFFFFFFFu) >> 10) + W[(signed long long int)((i + 0u) - 7u)] + (((W[(signed long long int)((i + 0u) - 15u)] & 0xFFFFFFFFu) >> 7 | W[(signed long long int)((i + 0u) - 15u)] << 32 - 7) ^ ((W[(signed long long int)((i + 0u) - 15u)] & 0xFFFFFFFFu) >> 18 | W[(signed long long int)((i + 0u) - 15u)] << 32 - 18) ^ (W[(signed long long int)((i + 0u) - 15u)] & 0xFFFFFFFFu) >> 3) + W[(signed long long int)((i + 0u) - 16u)];
    temp1 = A[7ll] + (((A[4ll] & 0xFFFFFFFFu) >> 6 | A[4ll] << 32 - 6) ^ ((A[4ll] & 0xFFFFFFFFu) >> 11 | A[4ll] << 32 - 11) ^ ((A[4ll] & 0xFFFFFFFFu) >> 25 | A[4ll] << 32 - 25)) + (A[6ll] ^ A[4ll] & (A[5ll] ^ A[6ll])) + K[(signed long long int)(i + 0u)] + W[(signed long long int)(i + 0u)];
    temp2 = (((A[0ll] & 0xFFFFFFFFu) >> 2 | A[0ll] << 32 - 2) ^ ((A[0ll] & 0xFFFFFFFFu) >> 13 | A[0ll] << 32 - 13) ^ ((A[0ll] & 0xFFFFFFFFu) >> 22 | A[0ll] << 32 - 22)) + (A[0ll] & A[1ll] | A[2ll] & (A[0ll] | A[1ll]));
    A[3ll] = A[3ll] + temp1;
    A[7ll] = temp1 + temp2;
    W[(signed long long int)(i + 1u)] = (((W[(signed long long int)((i + 1u) - 2u)] & 0xFFFFFFFFu) >> 17 | W[(signed long long int)((i + 1u) - 2u)] << 32 - 17) ^ ((W[(signed long long int)((i + 1u) - 2u)] & 0xFFFFFFFFu) >> 19 | W[(signed long long int)((i + 1u) - 2u)] << 32 - 19) ^ (W[(signed long long int)((i + 1u) - 2u)] & 0xFFFFFFFFu) >> 10) + W[(signed long long int)((i + 1u) - 7u)] + (((W[(signed long long int)((i + 1u) - 15u)] & 0xFFFFFFFFu) >> 7 | W[(signed long long int)((i + 1u) - 15u)] << 32 - 7) ^ ((W[(signed long long int)((i + 1u) - 15u)] & 0xFFFFFFFFu) >> 18 | W[(signed long long int)((i + 1u) - 15u)] << 32 - 18) ^ (W[(signed long long int)((i + 1u) - 15u)] & 0xFFFFFFFFu) >> 3) + W[(signed long long int)((i + 1u) - 16u)];
    temp1 = A[6ll] + (((A[3ll] & 0xFFFFFFFFu) >> 6 | A[3ll] << 32 - 6) ^ ((A[3ll] & 0xFFFFFFFFu) >> 11 | A[3ll] << 32 - 11) ^ ((A[3ll] & 0xFFFFFFFFu) >> 25 | A[3ll] << 32 - 25)) + (A[5ll] ^ A[3ll] & (A[4ll] ^ A[5ll])) + K[(signed long long int)(i + 1u)] + W[(signed long long int)(i + 1u)];
    temp2 = (((A[7ll] & 0xFFFFFFFFu) >> 2 | A[7ll] << 32 - 2) ^ ((A[7ll] & 0xFFFFFFFFu) >> 13 | A[7ll] << 32 - 13) ^ ((A[7ll] & 0xFFFFFFFFu) >> 22 | A[7ll] << 32 - 22)) + (A[7ll] & A[0ll] | A[1ll] & (A[7ll] | A[0ll]));
    A[2ll] = A[2ll] + temp1;
    A[6ll] = temp1 + temp2;
    W[(signed long long int)(i + 2u)] = (((W[(signed long long int)((i + 2u) - 2u)] & 0xFFFFFFFFu) >> 17 | W[(signed long long int)((i + 2u) - 2u)] << 32 - 17) ^ ((W[(signed long long int)((i + 2u) - 2u)] & 0xFFFFFFFFu) >> 19 | W[(signed long long int)((i + 2u) - 2u)] << 32 - 19) ^ (W[(signed long long int)((i + 2u) - 2u)] & 0xFFFFFFFFu) >> 10) + W[(signed long long int)((i + 2u) - 7u)] + (((W[(signed long long int)((i + 2u) - 15u)] & 0xFFFFFFFFu) >> 7 | W[(signed long long int)((i + 2u) - 15u)] << 32 - 7) ^ ((W[(signed long long int)((i + 2u) - 15u)] & 0xFFFFFFFFu) >> 18 | W[(signed long long int)((i + 2u) - 15u)] << 32 - 18) ^ (W[(signed long long int)((i + 2u) - 15u)] & 0xFFFFFFFFu) >> 3) + W[(signed long long int)((i + 2u) - 16u)];
    temp1 = A[5ll] + (((A[2ll] & 0xFFFFFFFFu) >> 6 | A[2ll] << 32 - 6) ^ ((A[2ll] & 0xFFFFFFFFu) >> 11 | A[2ll] << 32 - 11) ^ ((A[2ll] & 0xFFFFFFFFu) >> 25 | A[2ll] << 32 - 25)) + (A[4ll] ^ A[2ll] & (A[3ll] ^ A[4ll])) + K[(signed long long int)(i + 2u)] + W[(signed long long int)(i + 2u)];
    temp2 = (((A[6ll] & 0xFFFFFFFFu) >> 2 | A[6ll] << 32 - 2) ^ ((A[6ll] & 0xFFFFFFFFu) >> 13 | A[6ll] << 32 - 13) ^ ((A[6ll] & 0xFFFFFFFFu) >> 22 | A[6ll] << 32 - 22)) + (A[6ll] & A[7ll] | A[0ll] & (A[6ll] | A[7ll]));
    A[1ll] = A[1ll] + temp1;
    A[5ll] = temp1 + temp2;
    W[(signed long long int)(i + 3u)] = (((W[(signed long long int)((i + 3u) - 2u)] & 0xFFFFFFFFu) >> 17 | W[(signed long long int)((i + 3u) - 2u)] << 32 - 17) ^ ((W[(signed long long int)((i + 3u) - 2u)] & 0xFFFFFFFFu) >> 19 | W[(signed long long int)((i + 3u) - 2u)] << 32 - 19) ^ (W[(signed long long int)((i + 3u) - 2u)] & 0xFFFFFFFFu) >> 10) + W[(signed long long int)((i + 3u) - 7u)] + (((W[(signed long long int)((i + 3u) - 15u)] & 0xFFFFFFFFu) >> 7 | W[(signed long long int)((i + 3u) - 15u)] << 32 - 7) ^ ((W[(signed long long int)((i + 3u) - 15u)] & 0xFFFFFFFFu) >> 18 | W[(signed long long int)((i + 3u) - 15u)] << 32 - 18) ^ (W[(signed long long int)((i + 3u) - 15u)] & 0xFFFFFFFFu) >> 3) + W[(signed long long int)((i + 3u) - 16u)];
    temp1 = A[4ll] + (((A[1ll] & 0xFFFFFFFFu) >> 6 | A[1ll] << 32 - 6) ^ ((A[1ll] & 0xFFFFFFFFu) >> 11 | A[1ll] << 32 - 11) ^ ((A[1ll] & 0xFFFFFFFFu) >> 25 | A[1ll] << 32 - 25)) + (A[3ll] ^ A[1ll] & (A[2ll] ^ A[3ll])) + K[(signed long long int)(i + 3u)] + W[(signed long long int)(i + 3u)];
    temp2 = (((A[5ll] & 0xFFFFFFFFu) >> 2 | A[5ll] << 32 - 2) ^ ((A[5ll] & 0xFFFFFFFFu) >> 13 | A[5ll] << 32 - 13) ^ ((A[5ll] & 0xFFFFFFFFu) >> 22 | A[5ll] << 32 - 22)) + (A[5ll] & A[6ll] | A[7ll] & (A[5ll] | A[6ll]));
    A[0ll] = A[0ll] + temp1;
    A[4ll] = temp1 + temp2;
    W[(signed long long int)(i + 4u)] = (((W[(signed long long int)((i + 4u) - 2u)] & 0xFFFFFFFFu) >> 17 | W[(signed long long int)((i + 4u) - 2u)] << 32 - 17) ^ ((W[(signed long long int)((i + 4u) - 2u)] & 0xFFFFFFFFu) >> 19 | W[(signed long long int)((i + 4u) - 2u)] << 32 - 19) ^ (W[(signed long long int)((i + 4u) - 2u)] & 0xFFFFFFFFu) >> 10) + W[(signed long long int)((i + 4u) - 7u)] + (((W[(signed long long int)((i + 4u) - 15u)] & 0xFFFFFFFFu) >> 7 | W[(signed long long int)((i + 4u) - 15u)] << 32 - 7) ^ ((W[(signed long long int)((i + 4u) - 15u)] & 0xFFFFFFFFu) >> 18 | W[(signed long long int)((i + 4u) - 15u)] << 32 - 18) ^ (W[(signed long long int)((i + 4u) - 15u)] & 0xFFFFFFFFu) >> 3) + W[(signed long long int)((i + 4u) - 16u)];
    temp1 = A[3ll] + (((A[0ll] & 0xFFFFFFFFu) >> 6 | A[0ll] << 32 - 6) ^ ((A[0ll] & 0xFFFFFFFFu) >> 11 | A[0ll] << 32 - 11) ^ ((A[0ll] & 0xFFFFFFFFu) >> 25 | A[0ll] << 32 - 25)) + (A[2ll] ^ A[0ll] & (A[1ll] ^ A[2ll])) + K[(signed long long int)(i + 4u)] + W[(signed long long int)(i + 4u)];
    temp2 = (((A[4ll] & 0xFFFFFFFFu) >> 2 | A[4ll] << 32 - 2) ^ ((A[4ll] & 0xFFFFFFFFu) >> 13 | A[4ll] << 32 - 13) ^ ((A[4ll] & 0xFFFFFFFFu) >> 22 | A[4ll] << 32 - 22)) + (A[4ll] & A[5ll] | A[6ll] & (A[4ll] | A[5ll]));
    A[7ll] = A[7ll] + temp1;
    A[3ll] = temp1 + temp2;
    W[(signed long long int)(i + 5u)] = (((W[(signed long long int)((i + 5u) - 2u)] & 0xFFFFFFFFu) >> 17 | W[(signed long long int)((i + 5u) - 2u)] << 32 - 17) ^ ((W[(signed long long int)((i + 5u) - 2u)] & 0xFFFFFFFFu) >> 19 | W[(signed long long int)((i + 5u) - 2u)] << 32 - 19) ^ (W[(signed long long int)((i + 5u) - 2u)] & 0xFFFFFFFFu) >> 10) + W[(signed long long int)((i + 5u) - 7u)] + (((W[(signed long long int)((i + 5u) - 15u)] & 0xFFFFFFFFu) >> 7 | W[(signed long long int)((i + 5u) - 15u)] << 32 - 7) ^ ((W[(signed long long int)((i + 5u) - 15u)] & 0xFFFFFFFFu) >> 18 | W[(signed long long int)((i + 5u) - 15u)] << 32 - 18) ^ (W[(signed long long int)((i + 5u) - 15u)] & 0xFFFFFFFFu) >> 3) + W[(signed long long int)((i + 5u) - 16u)];
    temp1 = A[2ll] + (((A[7ll] & 0xFFFFFFFFu) >> 6 | A[7ll] << 32 - 6) ^ ((A[7ll] & 0xFFFFFFFFu) >> 11 | A[7ll] << 32 - 11) ^ ((A[7ll] & 0xFFFFFFFFu) >> 25 | A[7ll] << 32 - 25)) + (A[1ll] ^ A[7ll] & (A[0ll] ^ A[1ll])) + K[(signed long long int)(i + 5u)] + W[(signed long long int)(i + 5u)];
    temp2 = (((A[3ll] & 0xFFFFFFFFu) >> 2 | A[3ll] << 32 - 2) ^ ((A[3ll] & 0xFFFFFFFFu) >> 13 | A[3ll] << 32 - 13) ^ ((A[3ll] & 0xFFFFFFFFu) >> 22 | A[3ll] << 32 - 22)) + (A[3ll] & A[4ll] | A[5ll] & (A[3ll] | A[4ll]));
    A[6ll] = A[6ll] + temp1;
    A[2ll] = temp1 + temp2;
    W[(signed long long int)(i + 6u)] = (((W[(signed long long int)((i + 6u) - 2u)] & 0xFFFFFFFFu) >> 17 | W[(signed long long int)((i + 6u) - 2u)] << 32 - 17) ^ ((W[(signed long long int)((i + 6u) - 2u)] & 0xFFFFFFFFu) >> 19 | W[(signed long long int)((i + 6u) - 2u)] << 32 - 19) ^ (W[(signed long long int)((i + 6u) - 2u)] & 0xFFFFFFFFu) >> 10) + W[(signed long long int)((i + 6u) - 7u)] + (((W[(signed long long int)((i + 6u) - 15u)] & 0xFFFFFFFFu) >> 7 | W[(signed long long int)((i + 6u) - 15u)] << 32 - 7) ^ ((W[(signed long long int)((i + 6u) - 15u)] & 0xFFFFFFFFu) >> 18 | W[(signed long long int)((i + 6u) - 15u)] << 32 - 18) ^ (W[(signed long long int)((i + 6u) - 15u)] & 0xFFFFFFFFu) >> 3) + W[(signed long long int)((i + 6u) - 16u)];
    temp1 = A[1ll] + (((A[6ll] & 0xFFFFFFFFu) >> 6 | A[6ll] << 32 - 6) ^ ((A[6ll] & 0xFFFFFFFFu) >> 11 | A[6ll] << 32 - 11) ^ ((A[6ll] & 0xFFFFFFFFu) >> 25 | A[6ll] << 32 - 25)) + (A[0ll] ^ A[6ll] & (A[7ll] ^ A[0ll])) + K[(signed long long int)(i + 6u)] + W[(signed long long int)(i + 6u)];
    temp2 = (((A[2ll] & 0xFFFFFFFFu) >> 2 | A[2ll] << 32 - 2) ^ ((A[2ll] & 0xFFFFFFFFu) >> 13 | A[2ll] << 32 - 13) ^ ((A[2ll] & 0xFFFFFFFFu) >> 22 | A[2ll] << 32 - 22)) + (A[2ll] & A[3ll] | A[4ll] & (A[2ll] | A[3ll]));
    A[5ll] = A[5ll] + temp1;
    A[1ll] = temp1 + temp2;
    W[(signed long long int)(i + 7u)] = (((W[(signed long long int)((i + 7u) - 2u)] & 0xFFFFFFFFu) >> 17 | W[(signed long long int)((i + 7u) - 2u)] << 32 - 17) ^ ((W[(signed long long int)((i + 7u) - 2u)] & 0xFFFFFFFFu) >> 19 | W[(signed long long int)((i + 7u) - 2u)] << 32 - 19) ^ (W[(signed long long int)((i + 7u) - 2u)] & 0xFFFFFFFFu) >> 10) + W[(signed long long int)((i + 7u) - 7u)] + (((W[(signed long long int)((i + 7u) - 15u)] & 0xFFFFFFFFu) >> 7 | W[(signed long long int)((i + 7u) - 15u)] << 32 - 7) ^ ((W[(signed long long int)((i + 7u) - 15u)] & 0xFFFFFFFFu) >> 18 | W[(signed long long int)((i + 7u) - 15u)] << 32 - 18) ^ (W[(signed long long int)((i + 7u) - 15u)] & 0xFFFFFFFFu) >> 3) + W[(signed long long int)((i + 7u) - 16u)];
    temp1 = A[0ll] + (((A[5ll] & 0xFFFFFFFFu) >> 6 | A[5ll] << 32 - 6) ^ ((A[5ll] & 0xFFFFFFFFu) >> 11 | A[5ll] << 32 - 11) ^ ((A[5ll] & 0xFFFFFFFFu) >> 25 | A[5ll] << 32 - 25)) + (A[7ll] ^ A[5ll] & (A[6ll] ^ A[7ll])) + K[(signed long long int)(i + 7u)] + W[(signed long long int)(i + 7u)];
    temp2 = (((A[1ll] & 0xFFFFFFFFu) >> 2 | A[1ll] << 32 - 2) ^ ((A[1ll] & 0xFFFFFFFFu) >> 13 | A[1ll] << 32 - 13) ^ ((A[1ll] & 0xFFFFFFFFu) >> 22 | A[1ll] << 32 - 22)) + (A[1ll] & A[2ll] | A[3ll] & (A[1ll] | A[2ll]));
    A[4ll] = A[4ll] + temp1;
    A[0ll] = temp1 + temp2;
  }
  i = 0u;
  for( ; !(i >= 8u); i = i + 1u)
    ctx->state[(signed long long int)i] = ctx->state[(signed long long int)i] + A[(signed long long int)i];
  return 0;
}

// mbedtls_md
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 272
signed int mbedtls_md(const mbedtls_md_info_t *md_info, const unsigned char *input, size_t ilen, unsigned char *output)
{
  if(md_info == ((const mbedtls_md_info_t *)NULL))
    return -0x5100;

  else
  {
    signed int return_value=md_info->digest_func(input, ilen, output);
    return return_value;
  }
}

// mbedtls_md_clone
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 203
signed int mbedtls_md_clone(mbedtls_md_context_t *dst, const mbedtls_md_context_t *src)
{
  _Bool tmp_if_expr;
  if(dst == ((mbedtls_md_context_t *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = dst->md_info == ((const mbedtls_md_info_t *)NULL) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$0;
  if(src == ((const mbedtls_md_context_t *)NULL) || tmp_if_expr)
    tmp_if_expr$0 = (_Bool)1;

  else
    tmp_if_expr$0 = src->md_info == ((const mbedtls_md_info_t *)NULL) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$1;
  if(tmp_if_expr$0)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = dst->md_info != src->md_info ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return -0x5100;

  else
  {
    dst->md_info->clone_func(dst->md_ctx, src->md_ctx);
    return 0;
  }
}

// mbedtls_md_finish
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 264
signed int mbedtls_md_finish(mbedtls_md_context_t *ctx, unsigned char *output)
{
  _Bool tmp_if_expr;
  if(ctx == ((mbedtls_md_context_t *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ctx->md_info == ((const mbedtls_md_info_t *)NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return -0x5100;

  else
  {
    signed int return_value=ctx->md_info->finish_func(ctx->md_ctx, output);
    return return_value;
  }
}

// mbedtls_md_free
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 186
void mbedtls_md_free(mbedtls_md_context_t *ctx)
{
  _Bool tmp_if_expr;
  if(ctx == ((mbedtls_md_context_t *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ctx->md_info == ((const mbedtls_md_info_t *)NULL) ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr)
  {
    if(!(ctx->md_ctx == NULL))
      ctx->md_info->ctx_free_func(ctx->md_ctx);

    if(!(ctx->hmac_ctx == NULL))
    {
      mbedtls_zeroize$link9(ctx->hmac_ctx, (size_t)(2 * ctx->md_info->block_size));
      mbedtls_free(ctx->hmac_ctx);
    }

    mbedtls_zeroize$link9((void *)ctx, sizeof(mbedtls_md_context_t) /*24ull*/ );
  }

}

// mbedtls_md_get_name
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 470
const char * mbedtls_md_get_name(const mbedtls_md_info_t *md_info)
{
  if(md_info == ((const mbedtls_md_info_t *)NULL))
    return ((const char *)NULL);

  else
    return md_info->name;
}

// mbedtls_md_get_size
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 454
unsigned char mbedtls_md_get_size(const mbedtls_md_info_t *md_info)
{
  if(md_info == ((const mbedtls_md_info_t *)NULL))
    return 0;

  else
    return (unsigned char)md_info->size;
}

// mbedtls_md_get_type
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 462
mbedtls_md_type_t mbedtls_md_get_type(const mbedtls_md_info_t *md_info)
{
  if(md_info == ((const mbedtls_md_info_t *)NULL))
    return /*enum*/MBEDTLS_MD_NONE;

  else
    return md_info->type;
}

// mbedtls_md_hmac
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 417
signed int mbedtls_md_hmac(const mbedtls_md_info_t *md_info, const unsigned char *mbedtls_md_hmac$$key, size_t keylen, const unsigned char *input, size_t ilen, unsigned char *output)
{
  mbedtls_md_context_t ctx;
  signed int ret;
  if(md_info == ((const mbedtls_md_info_t *)NULL))
    return -0x5100;

  else
  {
    mbedtls_md_init(&ctx);
    ret=mbedtls_md_setup(&ctx, md_info, 1);
    if(ret == 0)
    {
      ret=mbedtls_md_hmac_starts(&ctx, mbedtls_md_hmac$$key, keylen);
      if(ret == 0)
      {
        ret=mbedtls_md_hmac_update(&ctx, input, ilen);
        if(ret == 0)
          ret=mbedtls_md_hmac_finish(&ctx, output);

      }

    }


  cleanup:
    ;
    mbedtls_md_free(&ctx);
    return ret;
  }
}

// mbedtls_md_hmac_finish
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 377
signed int mbedtls_md_hmac_finish(mbedtls_md_context_t *ctx, unsigned char *output)
{
  signed int ret;
  unsigned char tmp[32ll];
  unsigned char *opad;
  _Bool tmp_if_expr;
  if(ctx == ((mbedtls_md_context_t *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ctx->md_info == ((const mbedtls_md_info_t *)NULL) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$0;
  if(tmp_if_expr)
    tmp_if_expr$0 = (_Bool)1;

  else
    tmp_if_expr$0 = ctx->hmac_ctx == NULL ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$0)
    return -0x5100;

  else
  {
    opad = (unsigned char *)ctx->hmac_ctx + (signed long long int)ctx->md_info->block_size;
    ret=ctx->md_info->finish_func(ctx->md_ctx, tmp);
    if(!(ret == 0))
      return ret;

    else
    {
      ret=ctx->md_info->starts_func(ctx->md_ctx);
      if(!(ret == 0))
        return ret;

      else
      {
        ret=ctx->md_info->update_func(ctx->md_ctx, opad, (size_t)ctx->md_info->block_size);
        if(!(ret == 0))
          return ret;

        else
        {
          ret=ctx->md_info->update_func(ctx->md_ctx, tmp, (size_t)ctx->md_info->size);
          if(!(ret == 0))
            return ret;

          else
          {
            signed int return_value=ctx->md_info->finish_func(ctx->md_ctx, output);
            return return_value;
          }
        }
      }
    }
  }
}

// mbedtls_md_hmac_reset
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 401
signed int mbedtls_md_hmac_reset(mbedtls_md_context_t *ctx)
{
  signed int ret;
  unsigned char *ipad;
  _Bool tmp_if_expr;
  if(ctx == ((mbedtls_md_context_t *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ctx->md_info == ((const mbedtls_md_info_t *)NULL) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$0;
  if(tmp_if_expr)
    tmp_if_expr$0 = (_Bool)1;

  else
    tmp_if_expr$0 = ctx->hmac_ctx == NULL ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$0)
    return -0x5100;

  else
  {
    ipad = (unsigned char *)ctx->hmac_ctx;
    ret=ctx->md_info->starts_func(ctx->md_ctx);
    if(!(ret == 0))
      return ret;

    else
    {
      signed int return_value=ctx->md_info->update_func(ctx->md_ctx, ipad, (size_t)ctx->md_info->block_size);
      return return_value;
    }
  }
}

// mbedtls_md_hmac_starts
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 322
signed int mbedtls_md_hmac_starts(mbedtls_md_context_t *ctx, const unsigned char *mbedtls_md_hmac_starts$$key, size_t keylen)
{
  signed int ret;
  unsigned char sum[32ll];
  unsigned char *ipad;
  unsigned char *opad;
  size_t i;
  _Bool tmp_if_expr;
  if(ctx == ((mbedtls_md_context_t *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ctx->md_info == ((const mbedtls_md_info_t *)NULL) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$0;
  if(tmp_if_expr)
    tmp_if_expr$0 = (_Bool)1;

  else
    tmp_if_expr$0 = ctx->hmac_ctx == NULL ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$0)
    return -0x5100;

  else
  {
    if(!((size_t)ctx->md_info->block_size >= keylen))
    {
      ret=ctx->md_info->starts_func(ctx->md_ctx);
      ret=ctx->md_info->update_func(ctx->md_ctx, mbedtls_md_hmac_starts$$key, keylen);
      ret=ctx->md_info->finish_func(ctx->md_ctx, sum);
      keylen = (size_t)ctx->md_info->size;
      mbedtls_md_hmac_starts$$key = sum;
    }

    ipad = (unsigned char *)ctx->hmac_ctx;
    opad = (unsigned char *)ctx->hmac_ctx + (signed long long int)ctx->md_info->block_size;
    memset((void *)ipad, 0x36, (size_t)ctx->md_info->block_size);
    memset((void *)opad, 0x5C, (size_t)ctx->md_info->block_size);
    i = 0ull;
    for( ; !(i >= keylen); i = i + 1ull)
    {
      ipad[(signed long long int)i] = (unsigned char)((signed int)ipad[(signed long long int)i] ^ (signed int)mbedtls_md_hmac_starts$$key[(signed long long int)i]);
      opad[(signed long long int)i] = (unsigned char)((signed int)opad[(signed long long int)i] ^ (signed int)mbedtls_md_hmac_starts$$key[(signed long long int)i]);
    }
    ret=ctx->md_info->starts_func(ctx->md_ctx);
    if(ret == 0)
      ret=ctx->md_info->update_func(ctx->md_ctx, ipad, (size_t)ctx->md_info->block_size);


  cleanup:
    ;
    mbedtls_zeroize$link9((void *)sum, sizeof(unsigned char [32ll]) /*32ull*/ );
    return ret;
  }
}

// mbedtls_md_hmac_update
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 369
signed int mbedtls_md_hmac_update(mbedtls_md_context_t *ctx, const unsigned char *input, size_t ilen)
{
  _Bool tmp_if_expr;
  if(ctx == ((mbedtls_md_context_t *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ctx->md_info == ((const mbedtls_md_info_t *)NULL) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$0;
  if(tmp_if_expr)
    tmp_if_expr$0 = (_Bool)1;

  else
    tmp_if_expr$0 = ctx->hmac_ctx == NULL ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$0)
    return -0x5100;

  else
  {
    signed int return_value=ctx->md_info->update_func(ctx->md_ctx, input, ilen);
    return return_value;
  }
}

// mbedtls_md_info_from_string
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 99
const mbedtls_md_info_t * mbedtls_md_info_from_string(const char *md_name)
{
  signed int return_value_strcmp$0;
  const mbedtls_md_info_t *return_value_mbedtls_md_info_from_type;
  const mbedtls_md_info_t *return_value_mbedtls_md_info_from_type$0;
  const mbedtls_md_info_t *return_value_mbedtls_md_info_from_type$1;
  if(md_name == ((const char *)NULL))
    return ((const mbedtls_md_info_t *)NULL);

  else
  {
    signed int return_value_strcmp=strcmp("SHA1", md_name);
    _Bool tmp_if_expr;
    if(return_value_strcmp == 0)
      tmp_if_expr = (_Bool)1;

    else
    {
      return_value_strcmp$0=strcmp("SHA", md_name);
      tmp_if_expr = !(return_value_strcmp$0 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr)
    {
      return_value_mbedtls_md_info_from_type=mbedtls_md_info_from_type(/*enum*/MBEDTLS_MD_SHA1);
      return return_value_mbedtls_md_info_from_type;
    }

    else
    {
      signed int return_value_strcmp$1=strcmp("SHA224", md_name);
      if(return_value_strcmp$1 == 0)
      {
        return_value_mbedtls_md_info_from_type$0=mbedtls_md_info_from_type(/*enum*/MBEDTLS_MD_SHA224);
        return return_value_mbedtls_md_info_from_type$0;
      }

      else
      {
        signed int return_value_strcmp$2=strcmp("SHA256", md_name);
        if(return_value_strcmp$2 == 0)
        {
          return_value_mbedtls_md_info_from_type$1=mbedtls_md_info_from_type(/*enum*/MBEDTLS_MD_SHA256);
          return return_value_mbedtls_md_info_from_type$1;
        }

        else
          return ((const mbedtls_md_info_t *)NULL);
      }
    }
  }
}

// mbedtls_md_info_from_type
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 140
const mbedtls_md_info_t * mbedtls_md_info_from_type(mbedtls_md_type_t md_type)
{
  switch((signed int)md_type)
  {
    case 4:
      return &mbedtls_sha1_info;
    case 5:
      return &mbedtls_sha224_info;
    case 6:
      return &mbedtls_sha256_info;
    default:
      return ((const mbedtls_md_info_t *)NULL);
  }
}

// mbedtls_md_init
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 181
void mbedtls_md_init(mbedtls_md_context_t *ctx)
{
  memset((void *)ctx, 0, sizeof(mbedtls_md_context_t) /*24ull*/ );
}

// mbedtls_md_list
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 94
const signed int * mbedtls_md_list(void)
{
  return supported_digests;
}

// mbedtls_md_process
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 446
signed int mbedtls_md_process(mbedtls_md_context_t *ctx, const unsigned char *data)
{
  _Bool tmp_if_expr;
  if(ctx == ((mbedtls_md_context_t *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ctx->md_info == ((const mbedtls_md_info_t *)NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return -0x5100;

  else
  {
    signed int return_value=ctx->md_info->process_func(ctx->md_ctx, data);
    return return_value;
  }
}

// mbedtls_md_setup
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 225
signed int mbedtls_md_setup(mbedtls_md_context_t *ctx, const mbedtls_md_info_t *md_info, signed int hmac)
{
  if(ctx == ((mbedtls_md_context_t *)NULL) || md_info == ((const mbedtls_md_info_t *)NULL))
    return -0x5100;

  else
  {
    ctx->md_ctx=md_info->ctx_alloc_func();
    if(ctx->md_ctx == NULL)
      return -0x5180;

    else
    {
      if(!(hmac == 0))
      {
        ctx->hmac_ctx=mbedtls_calloc(2ull, (size_t)md_info->block_size);
        if(ctx->hmac_ctx == NULL)
        {
          md_info->ctx_free_func(ctx->md_ctx);
          return -0x5180;
        }

      }

      ctx->md_info = md_info;
      return 0;
    }
  }
}

// mbedtls_md_starts
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 248
signed int mbedtls_md_starts(mbedtls_md_context_t *ctx)
{
  _Bool tmp_if_expr;
  if(ctx == ((mbedtls_md_context_t *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ctx->md_info == ((const mbedtls_md_info_t *)NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return -0x5100;

  else
  {
    signed int return_value=ctx->md_info->starts_func(ctx->md_ctx);
    return return_value;
  }
}

// mbedtls_md_update
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 256
signed int mbedtls_md_update(mbedtls_md_context_t *ctx, const unsigned char *input, size_t ilen)
{
  _Bool tmp_if_expr;
  if(ctx == ((mbedtls_md_context_t *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ctx->md_info == ((const mbedtls_md_info_t *)NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return -0x5100;

  else
  {
    signed int return_value=ctx->md_info->update_func(ctx->md_ctx, input, ilen);
    return return_value;
  }
}

// mbedtls_mpi_add_abs
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 902
signed int mbedtls_mpi_add_abs(mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B)
{
  signed int ret;
  size_t i;
  size_t j;
  mbedtls_mpi_uint *o;
  mbedtls_mpi_uint *p;
  mbedtls_mpi_uint c;
  mbedtls_mpi_uint tmp;
  if(X == B)
  {
    const mbedtls_mpi *T=A;
    A = X;
    B = T;
  }

  if(!(X == A))
    do
    {
      ret=mbedtls_mpi_copy(X, A);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);

  X->s = 1;
  j = B->n;
  for( ; j >= 1ull; j = j - 1ull)
    if(!(B->p[-1ll + (signed long long int)j] == 0ull))
      break;

  do
  {
    ret=mbedtls_mpi_grow(X, j);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  o = B->p;
  p = X->p;
  c = 0ull;
  i = 0ull;
  for( ; !(i >= j); p = p + 1ll)
  {
    tmp = *o;
    *p = *p + c;
    c = (mbedtls_mpi_uint)(*p < c);
    *p = *p + tmp;
    c = c + (mbedtls_mpi_uint)(*p < tmp);
    i = i + 1ull;
    o = o + 1ll;
  }
  for( ; !(c == 0ull); p = p + 1ll)
  {
    if(i >= X->n)
    {
      do
      {
        ret=mbedtls_mpi_grow(X, i + 1ull);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      p = X->p + (signed long long int)i;
    }

    *p = *p + c;
    c = (mbedtls_mpi_uint)(*p < c);
    i = i + 1ull;
  }

cleanup:
  ;
  return ret;
}

// mbedtls_mpi_add_int
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1084
signed int mbedtls_mpi_add_int(mbedtls_mpi *X, const mbedtls_mpi *A, mbedtls_mpi_sint b)
{
  mbedtls_mpi _B;
  mbedtls_mpi_uint p[1ll];
  p[0ll] = (mbedtls_mpi_uint)(b < 0ll ? -b : b);
  _B.s = b < 0ll ? -1 : 1;
  _B.n = 1ull;
  _B.p = p;
  signed int return_value_mbedtls_mpi_add_mpi=mbedtls_mpi_add_mpi(X, A, &_B);
  return return_value_mbedtls_mpi_add_mpi;
}

// mbedtls_mpi_add_mpi
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1022
signed int mbedtls_mpi_add_mpi(mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B)
{
  signed int ret;
  signed int s=A->s;
  if(!(A->s * B->s >= 0))
  {
    signed int return_value_mbedtls_mpi_cmp_abs=mbedtls_mpi_cmp_abs(A, B);
    if(return_value_mbedtls_mpi_cmp_abs >= 0)
    {
      do
      {
        ret=mbedtls_mpi_sub_abs(X, A, B);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      X->s = s;
    }

    else
    {
      do
      {
        ret=mbedtls_mpi_sub_abs(X, B, A);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      X->s = -s;
    }
  }

  else
  {
    do
    {
      ret=mbedtls_mpi_add_abs(X, A, B);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    X->s = s;
  }

cleanup:
  ;
  return ret;
}

// mbedtls_mpi_bitlen
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 391
size_t mbedtls_mpi_bitlen(const mbedtls_mpi *X)
{
  size_t i;
  size_t j;
  if(X->n == 0ull)
    return 0ull;

  else
  {
    i = X->n - 1ull;
    for( ; i >= 1ull; i = i - 1ull)
      if(!(X->p[(signed long long int)i] == 0ull))
        break;

    size_t return_value_mbedtls_clz=mbedtls_clz(X->p[(signed long long int)i]);
    j = (sizeof(mbedtls_mpi_uint) /*8ull*/  << 3) - return_value_mbedtls_clz;
    return i * (sizeof(mbedtls_mpi_uint) /*8ull*/  << 3) + j;
  }
}

// mbedtls_mpi_cmp_abs
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 823
signed int mbedtls_mpi_cmp_abs(const mbedtls_mpi *X, const mbedtls_mpi *Y)
{
  size_t i;
  size_t j;
  i = X->n;
  for( ; i >= 1ull; i = i - 1ull)
    if(!(X->p[-1ll + (signed long long int)i] == 0ull))
      break;

  j = Y->n;
  for( ; j >= 1ull; j = j - 1ull)
    if(!(Y->p[-1ll + (signed long long int)j] == 0ull))
      break;

  if(i == 0ull && j == 0ull)
    return 0;

  else
    if(!(j >= i))
      return 1;

    else
      if(!(i >= j))
        return -1;

      else
      {
        for( ; i >= 1ull; i = i - 1ull)
        {
          if(!(Y->p[-1ll + (signed long long int)i] >= X->p[-1ll + (signed long long int)i]))
            return 1;

          if(!(X->p[-1ll + (signed long long int)i] >= Y->p[-1ll + (signed long long int)i]))
            return -1;

        }
        return 0;
      }
}

// mbedtls_mpi_cmp_int
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 886
signed int mbedtls_mpi_cmp_int(const mbedtls_mpi *X, mbedtls_mpi_sint z)
{
  mbedtls_mpi Y;
  mbedtls_mpi_uint p[1ll];
  p[0ll] = (mbedtls_mpi_uint)(z < 0ll ? -z : z);
  Y.s = z < 0ll ? -1 : 1;
  Y.n = 1ull;
  Y.p = p;
  signed int return_value_mbedtls_mpi_cmp_mpi=mbedtls_mpi_cmp_mpi(X, &Y);
  return return_value_mbedtls_mpi_cmp_mpi;
}

// mbedtls_mpi_cmp_mpi
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 853
signed int mbedtls_mpi_cmp_mpi(const mbedtls_mpi *X, const mbedtls_mpi *Y)
{
  size_t i;
  size_t j;
  i = X->n;
  for( ; i >= 1ull; i = i - 1ull)
    if(!(X->p[-1ll + (signed long long int)i] == 0ull))
      break;

  j = Y->n;
  for( ; j >= 1ull; j = j - 1ull)
    if(!(Y->p[-1ll + (signed long long int)j] == 0ull))
      break;

  if(i == 0ull && j == 0ull)
    return 0;

  else
    if(!(j >= i))
      return X->s;

    else
      if(!(i >= j))
        return -Y->s;

      else
      {
        if(X->s >= 1)
        {
          if(!(Y->s >= 0))
            return 1;

        }

        if(Y->s >= 1)
        {
          if(!(X->s >= 0))
            return -1;

        }

        for( ; i >= 1ull; i = i - 1ull)
        {
          if(!(Y->p[-1ll + (signed long long int)i] >= X->p[-1ll + (signed long long int)i]))
            return X->s;

          if(!(X->p[-1ll + (signed long long int)i] >= Y->p[-1ll + (signed long long int)i]))
            return -X->s;

        }
        return 0;
      }
}

// mbedtls_mpi_copy
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 185
signed int mbedtls_mpi_copy(mbedtls_mpi *X, const mbedtls_mpi *Y)
{
  signed int ret=0;
  size_t i;
  if(X == Y)
    return 0;

  else
    if(Y->p == ((mbedtls_mpi_uint *)NULL))
    {
      mbedtls_mpi_free(X);
      return 0;
    }

    else
    {
      i = Y->n - 1ull;
      for( ; i >= 1ull; i = i - 1ull)
        if(!(Y->p[(signed long long int)i] == 0ull))
          break;

      i = i + 1ull;
      X->s = Y->s;
      if(!(X->n >= i))
        do
        {
          ret=mbedtls_mpi_grow(X, i);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);

      else
        memset((void *)(X->p + (signed long long int)i), 0, (X->n - i) * sizeof(mbedtls_mpi_uint) /*8ull*/ );
      memcpy((void *)X->p, (const void *)Y->p, i * sizeof(mbedtls_mpi_uint) /*8ull*/ );

    cleanup:
      ;
      return ret;
    }
}

// mbedtls_mpi_div_int
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1452
signed int mbedtls_mpi_div_int(mbedtls_mpi *Q, mbedtls_mpi *R, const mbedtls_mpi *A, mbedtls_mpi_sint b)
{
  mbedtls_mpi _B;
  mbedtls_mpi_uint p[1ll];
  p[0ll] = (mbedtls_mpi_uint)(b < 0ll ? -b : b);
  _B.s = b < 0ll ? -1 : 1;
  _B.n = 1ull;
  _B.p = p;
  signed int return_value_mbedtls_mpi_div_mpi=mbedtls_mpi_div_mpi(Q, R, A, &_B);
  return return_value_mbedtls_mpi_div_mpi;
}

// mbedtls_mpi_div_mpi
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1337
signed int mbedtls_mpi_div_mpi(mbedtls_mpi *Q, mbedtls_mpi *R, const mbedtls_mpi *A, const mbedtls_mpi *B)
{
  signed int ret;
  size_t i;
  size_t n;
  size_t t;
  size_t k;
  mbedtls_mpi X;
  mbedtls_mpi Y;
  mbedtls_mpi Z;
  mbedtls_mpi T1;
  mbedtls_mpi T2;
  signed int return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(B, 0ll);
  signed int return_value_mbedtls_mpi_cmp_mpi;
  signed int return_value_mbedtls_mpi_cmp_mpi$0;
  if(return_value_mbedtls_mpi_cmp_int == 0)
    return -0xC;

  else
  {
    mbedtls_mpi_init(&X);
    mbedtls_mpi_init(&Y);
    mbedtls_mpi_init(&Z);
    mbedtls_mpi_init(&T1);
    mbedtls_mpi_init(&T2);
    signed int return_value_mbedtls_mpi_cmp_abs=mbedtls_mpi_cmp_abs(A, B);
    if(!(return_value_mbedtls_mpi_cmp_abs >= 0))
    {
      if(!(Q == ((mbedtls_mpi *)NULL)))
        do
        {
          ret=mbedtls_mpi_lset(Q, 0ll);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);

      if(!(R == ((mbedtls_mpi *)NULL)))
        do
        {
          ret=mbedtls_mpi_copy(R, A);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);

      return 0;
    }

    else
    {
      do
      {
        ret=mbedtls_mpi_copy(&X, A);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_copy(&Y, B);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      Y.s = 1;
      X.s = Y.s;
      do
      {
        ret=mbedtls_mpi_grow(&Z, A->n + 2ull);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_lset(&Z, 0ll);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_grow(&T1, 2ull);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_grow(&T2, 3ull);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      size_t return_value_mbedtls_mpi_bitlen=mbedtls_mpi_bitlen(&Y);
      k = return_value_mbedtls_mpi_bitlen % (sizeof(mbedtls_mpi_uint) /*8ull*/  << 3);
      if(!(k >= 63ull))
      {
        k = ((sizeof(mbedtls_mpi_uint) /*8ull*/  << 3) - 1ull) - k;
        do
        {
          ret=mbedtls_mpi_shift_l(&X, k);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        do
        {
          ret=mbedtls_mpi_shift_l(&Y, k);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
      }

      else
        k = 0ull;
      n = X.n - 1ull;
      t = Y.n - 1ull;
      do
      {
        ret=mbedtls_mpi_shift_l(&Y, (sizeof(mbedtls_mpi_uint) /*8ull*/  << 3) * (n - t));
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        return_value_mbedtls_mpi_cmp_mpi=mbedtls_mpi_cmp_mpi(&X, &Y);
        if(!(return_value_mbedtls_mpi_cmp_mpi >= 0))
          break;

        Z.p[(signed long long int)(n - t)] = Z.p[(signed long long int)(n - t)] + 1ull;
        do
        {
          ret=mbedtls_mpi_sub_mpi(&X, &X, &Y);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
      }
      while((_Bool)1);
      do
      {
        ret=mbedtls_mpi_shift_r(&Y, (sizeof(mbedtls_mpi_uint) /*8ull*/  << 3) * (n - t));
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      i = n;
      for( ; !(t >= i); i = i - 1ull)
      {
        if(X.p[(signed long long int)i] >= Y.p[(signed long long int)t])
          Z.p[(signed long long int)((i - t) - 1ull)] = (mbedtls_mpi_uint)~0;

        else
          Z.p[(signed long long int)((i - t) - 1ull)]=mbedtls_int_div_int(X.p[(signed long long int)i], X.p[(signed long long int)(i - 1ull)], Y.p[(signed long long int)t], ((mbedtls_mpi_uint *)NULL));
        Z.p[(signed long long int)((i - t) - 1ull)] = Z.p[(signed long long int)((i - t) - 1ull)] + 1ull;
        do
        {
          Z.p[(signed long long int)((i - t) - 1ull)] = Z.p[(signed long long int)((i - t) - 1ull)] - 1ull;
          do
          {
            ret=mbedtls_mpi_lset(&T1, 0ll);
            if(!(ret == 0))
              goto cleanup;

          }
          while((_Bool)0);
          unsigned long long int tmp_if_expr;
          if(!(t >= 1ull))
            tmp_if_expr = 0ull;

          else
            tmp_if_expr = Y.p[(signed long long int)(t - 1ull)];
          T1.p[0ll] = tmp_if_expr;
          T1.p[1ll] = Y.p[(signed long long int)t];
          do
          {
            ret=mbedtls_mpi_mul_int(&T1, &T1, Z.p[(signed long long int)((i - t) - 1ull)]);
            if(!(ret == 0))
              goto cleanup;

          }
          while((_Bool)0);
          do
          {
            ret=mbedtls_mpi_lset(&T2, 0ll);
            if(!(ret == 0))
              goto cleanup;

          }
          while((_Bool)0);
          unsigned long long int tmp_if_expr$0;
          if(!(i >= 2ull))
            tmp_if_expr$0 = 0ull;

          else
            tmp_if_expr$0 = X.p[(signed long long int)(i - 2ull)];
          T2.p[0ll] = tmp_if_expr$0;
          unsigned long long int tmp_if_expr$1;
          if(!(i >= 1ull))
            tmp_if_expr$1 = 0ull;

          else
            tmp_if_expr$1 = X.p[(signed long long int)(i - 1ull)];
          T2.p[1ll] = tmp_if_expr$1;
          T2.p[2ll] = X.p[(signed long long int)i];
          return_value_mbedtls_mpi_cmp_mpi$0=mbedtls_mpi_cmp_mpi(&T1, &T2);
        }
        while(return_value_mbedtls_mpi_cmp_mpi$0 >= 1);
        do
        {
          ret=mbedtls_mpi_mul_int(&T1, &Y, Z.p[(signed long long int)((i - t) - 1ull)]);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        do
        {
          ret=mbedtls_mpi_shift_l(&T1, (sizeof(mbedtls_mpi_uint) /*8ull*/  << 3) * ((i - t) - 1ull));
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        do
        {
          ret=mbedtls_mpi_sub_mpi(&X, &X, &T1);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        signed int return_value_mbedtls_mpi_cmp_int$0=mbedtls_mpi_cmp_int(&X, 0ll);
        if(!(return_value_mbedtls_mpi_cmp_int$0 >= 0))
        {
          do
          {
            ret=mbedtls_mpi_copy(&T1, &Y);
            if(!(ret == 0))
              goto cleanup;

          }
          while((_Bool)0);
          do
          {
            ret=mbedtls_mpi_shift_l(&T1, (sizeof(mbedtls_mpi_uint) /*8ull*/  << 3) * ((i - t) - 1ull));
            if(!(ret == 0))
              goto cleanup;

          }
          while((_Bool)0);
          do
          {
            ret=mbedtls_mpi_add_mpi(&X, &X, &T1);
            if(!(ret == 0))
              goto cleanup;

          }
          while((_Bool)0);
          Z.p[(signed long long int)((i - t) - 1ull)] = Z.p[(signed long long int)((i - t) - 1ull)] - 1ull;
        }

      }
      if(!(Q == ((mbedtls_mpi *)NULL)))
      {
        do
        {
          ret=mbedtls_mpi_copy(Q, &Z);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        Q->s = A->s * B->s;
      }

      if(!(R == ((mbedtls_mpi *)NULL)))
      {
        do
        {
          ret=mbedtls_mpi_shift_r(&X, k);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        X.s = A->s;
        do
        {
          ret=mbedtls_mpi_copy(R, &X);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        signed int return_value_mbedtls_mpi_cmp_int$1=mbedtls_mpi_cmp_int(R, 0ll);
        if(return_value_mbedtls_mpi_cmp_int$1 == 0)
          R->s = 1;

      }


    cleanup:
      ;
      mbedtls_mpi_free(&X);
      mbedtls_mpi_free(&Y);
      mbedtls_mpi_free(&Z);
      mbedtls_mpi_free(&T1);
      mbedtls_mpi_free(&T2);
      return ret;
    }
  }
}

// mbedtls_mpi_exp_mod
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1622
signed int mbedtls_mpi_exp_mod(mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *E, const mbedtls_mpi *N, mbedtls_mpi *_RR)
{
  signed int ret;
  size_t wbits;
  size_t wsize;
  size_t one=1ull;
  size_t i;
  size_t j;
  size_t nblimbs;
  size_t bufsize;
  size_t nbits;
  mbedtls_mpi_uint ei;
  mbedtls_mpi_uint mm;
  mbedtls_mpi_uint state;
  mbedtls_mpi RR;
  mbedtls_mpi T;
  mbedtls_mpi W[128ll];
  mbedtls_mpi Apos;
  signed int neg;
  signed int return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(N, 0ll);
  _Bool tmp_if_expr;
  if(!(return_value_mbedtls_mpi_cmp_int >= 1))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = (N->p[0ll] & 1ull) == 0ull ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return -0x4;

  else
  {
    signed int return_value_mbedtls_mpi_cmp_int$0=mbedtls_mpi_cmp_int(E, 0ll);
    if(!(return_value_mbedtls_mpi_cmp_int$0 >= 0))
      return -0x4;

    else
    {
      mpi_montg_init(&mm, N);
      mbedtls_mpi_init(&RR);
      mbedtls_mpi_init(&T);
      mbedtls_mpi_init(&Apos);
      memset((void *)W, 0, sizeof(mbedtls_mpi [128ll]) /*3072ull*/ );
      i=mbedtls_mpi_bitlen(E);
      wsize = (size_t)(i > 671ull ? 6 : (i > 239ull ? 5 : (i > 79ull ? 4 : (i > 23ull ? 3 : 1))));
      if(wsize >= 7ull)
        wsize = 6ull;

      j = N->n + 1ull;
      do
      {
        ret=mbedtls_mpi_grow(X, j);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_grow(&W[1ll], j);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_grow(&T, j * 2ull);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      neg = (signed int)(A->s == -1);
      if(!(neg == 0))
      {
        do
        {
          ret=mbedtls_mpi_copy(&Apos, A);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        Apos.s = 1;
        A = &Apos;
      }

      _Bool tmp_if_expr$0;
      if(_RR == ((mbedtls_mpi *)NULL))
        tmp_if_expr$0 = (_Bool)1;

      else
        tmp_if_expr$0 = _RR->p == ((mbedtls_mpi_uint *)NULL) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$0)
      {
        do
        {
          ret=mbedtls_mpi_lset(&RR, 1ll);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        do
        {
          ret=mbedtls_mpi_shift_l(&RR, N->n * 2ull * (sizeof(mbedtls_mpi_uint) /*8ull*/  << 3));
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        do
        {
          ret=mbedtls_mpi_mod_mpi(&RR, &RR, N);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        if(!(_RR == ((mbedtls_mpi *)NULL)))
          memcpy((void *)_RR, (const void *)&RR, sizeof(mbedtls_mpi) /*24ull*/ );

      }

      else
        memcpy((void *)&RR, (const void *)_RR, sizeof(mbedtls_mpi) /*24ull*/ );
      signed int return_value_mbedtls_mpi_cmp_mpi=mbedtls_mpi_cmp_mpi(A, N);
      if(return_value_mbedtls_mpi_cmp_mpi >= 0)
        do
        {
          ret=mbedtls_mpi_mod_mpi(&W[1ll], A, N);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);

      else
        do
        {
          ret=mbedtls_mpi_copy(&W[1ll], A);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
      do
      {
        ret=mpi_montmul(&W[1ll], &RR, N, mm, &T);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_copy(X, &RR);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mpi_montred(X, N, mm, &T);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      if(wsize >= 2ull)
      {
        j = one << wsize - 1ull;
        do
        {
          ret=mbedtls_mpi_grow(&W[(signed long long int)j], N->n + 1ull);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        do
        {
          ret=mbedtls_mpi_copy(&W[(signed long long int)j], &W[1ll]);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        i = 0ull;
        for( ; !(i >= 18446744073709551615ull + wsize); i = i + 1ull)
          do
          {
            ret=mpi_montmul(&W[(signed long long int)j], &W[(signed long long int)j], N, mm, &T);
            if(!(ret == 0))
              goto cleanup;

          }
          while((_Bool)0);
        i = j + 1ull;
        for( ; !(i >= one << wsize); i = i + 1ull)
        {
          do
          {
            ret=mbedtls_mpi_grow(&W[(signed long long int)i], N->n + 1ull);
            if(!(ret == 0))
              goto cleanup;

          }
          while((_Bool)0);
          do
          {
            ret=mbedtls_mpi_copy(&W[(signed long long int)i], &W[(signed long long int)(i - 1ull)]);
            if(!(ret == 0))
              goto cleanup;

          }
          while((_Bool)0);
          do
          {
            ret=mpi_montmul(&W[(signed long long int)i], &W[1ll], N, mm, &T);
            if(!(ret == 0))
              goto cleanup;

          }
          while((_Bool)0);
        }
      }

      nblimbs = E->n;
      bufsize = 0ull;
      nbits = 0ull;
      wbits = 0ull;
      state = 0ull;
      while((_Bool)1)
      {
        if(bufsize == 0ull)
        {
          if(nblimbs == 0ull)
            break;

          nblimbs = nblimbs - 1ull;
          bufsize = sizeof(mbedtls_mpi_uint) /*8ull*/  << 3;
        }

        bufsize = bufsize - 1ull;
        ei = E->p[(signed long long int)nblimbs] >> bufsize & 1ull;
        if(!(ei == 0ull) || !(state == 0ull))
        {
          if(ei == 0ull && state == 1ull)
            do
            {
              ret=mpi_montmul(X, X, N, mm, &T);
              if(!(ret == 0))
                goto cleanup;

            }
            while((_Bool)0);

          else
          {
            state = 2ull;
            nbits = nbits + 1ull;
            wbits = wbits | ei << wsize - nbits;
            if(nbits == wsize)
            {
              i = 0ull;
              for( ; !(i >= wsize); i = i + 1ull)
                do
                {
                  ret=mpi_montmul(X, X, N, mm, &T);
                  if(!(ret == 0))
                    goto cleanup;

                }
                while((_Bool)0);
              do
              {
                ret=mpi_montmul(X, &W[(signed long long int)wbits], N, mm, &T);
                if(!(ret == 0))
                  goto cleanup;

              }
              while((_Bool)0);
              state = state - 1ull;
              nbits = 0ull;
              wbits = 0ull;
            }

          }
        }

      }
      i = 0ull;
      for( ; !(i >= nbits); i = i + 1ull)
      {
        do
        {
          ret=mpi_montmul(X, X, N, mm, &T);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        wbits = wbits << 1;
        if(!((one << wsize & wbits) == 0ull))
          do
          {
            ret=mpi_montmul(X, &W[1ll], N, mm, &T);
            if(!(ret == 0))
              goto cleanup;

          }
          while((_Bool)0);

      }
      do
      {
        ret=mpi_montred(X, N, mm, &T);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      if(!(neg == 0))
      {
        if(!(E->n == 0ull))
        {
          if(!((1ull & *E->p) == 0ull))
          {
            X->s = -1;
            do
            {
              ret=mbedtls_mpi_add_mpi(X, N, X);
              if(!(ret == 0))
                goto cleanup;

            }
            while((_Bool)0);
          }

        }

      }


    cleanup:
      ;
      i = one << wsize - 1ull;
      for( ; !(i >= one << wsize); i = i + 1ull)
        mbedtls_mpi_free(&W[(signed long long int)i]);
      mbedtls_mpi_free(&W[1ll]);
      mbedtls_mpi_free(&T);
      mbedtls_mpi_free(&Apos);
      _Bool tmp_if_expr$1;
      if(_RR == ((mbedtls_mpi *)NULL))
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = _RR->p == ((mbedtls_mpi_uint *)NULL) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
        mbedtls_mpi_free(&RR);

      return ret;
    }
  }
}

// mbedtls_mpi_fill_random
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1886
signed int mbedtls_mpi_fill_random(mbedtls_mpi *X, size_t size, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
  signed int ret;
  unsigned char buf[1024ll];
  if(size >= 1025ull)
    return -0x4;

  else
  {
    ret=f_rng(p_rng, buf, size);
    if(ret == 0)
      ret=mbedtls_mpi_read_binary(X, buf, size);


  cleanup:
    ;
    mbedtls_zeroize$link2((void *)buf, sizeof(unsigned char [1024ll]) /*1024ull*/ );
    return ret;
  }
}

// mbedtls_mpi_free
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 100
void mbedtls_mpi_free(mbedtls_mpi *X)
{
  if(!(X == ((mbedtls_mpi *)NULL)))
  {
    if(!(X->p == ((mbedtls_mpi_uint *)NULL)))
    {
      mbedtls_mpi_zeroize(X->p, X->n);
      mbedtls_free((void *)X->p);
    }

    X->s = 1;
    X->n = 0ull;
    X->p = ((mbedtls_mpi_uint *)NULL);
  }

}

// mbedtls_mpi_gcd
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1830
signed int mbedtls_mpi_gcd(mbedtls_mpi *G, const mbedtls_mpi *A, const mbedtls_mpi *B)
{
  signed int ret;
  size_t lz;
  size_t lzt;
  mbedtls_mpi TG;
  mbedtls_mpi TA;
  mbedtls_mpi TB;
  mbedtls_mpi_init(&TG);
  mbedtls_mpi_init(&TA);
  mbedtls_mpi_init(&TB);
  do
  {
    ret=mbedtls_mpi_copy(&TA, A);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_copy(&TB, B);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  lz=mbedtls_mpi_lsb(&TA);
  lzt=mbedtls_mpi_lsb(&TB);
  if(!(lzt >= lz))
    lz = lzt;

  do
  {
    ret=mbedtls_mpi_shift_r(&TA, lz);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_shift_r(&TB, lz);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  TB.s = 1;
  TA.s = TB.s;
  signed int return_value_mbedtls_mpi_cmp_int;
  do
  {
    return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(&TA, 0ll);
    if(return_value_mbedtls_mpi_cmp_int == 0)
      break;

    do
    {
      size_t return_value_mbedtls_mpi_lsb=mbedtls_mpi_lsb(&TA);
      ret=mbedtls_mpi_shift_r(&TA, return_value_mbedtls_mpi_lsb);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      size_t return_value_mbedtls_mpi_lsb$0=mbedtls_mpi_lsb(&TB);
      ret=mbedtls_mpi_shift_r(&TB, return_value_mbedtls_mpi_lsb$0);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    signed int return_value_mbedtls_mpi_cmp_mpi=mbedtls_mpi_cmp_mpi(&TA, &TB);
    if(return_value_mbedtls_mpi_cmp_mpi >= 0)
    {
      do
      {
        ret=mbedtls_mpi_sub_abs(&TA, &TA, &TB);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_shift_r(&TA, 1ull);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
    }

    else
    {
      do
      {
        ret=mbedtls_mpi_sub_abs(&TB, &TB, &TA);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_shift_r(&TB, 1ull);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
    }
  }
  while((_Bool)1);
  do
  {
    ret=mbedtls_mpi_shift_l(&TB, lz);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_copy(G, &TB);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);

cleanup:
  ;
  mbedtls_mpi_free(&TG);
  mbedtls_mpi_free(&TA);
  mbedtls_mpi_free(&TB);
  return ret;
}

// mbedtls_mpi_gen_prime
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 2198
signed int mbedtls_mpi_gen_prime(mbedtls_mpi *X, size_t nbits, signed int dh_flag, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
  signed int ret;
  size_t k;
  size_t n;
  mbedtls_mpi_uint r;
  mbedtls_mpi Y;
  if(nbits >= 8193ull || !(nbits >= 3ull))
    return -0x4;

  else
  {
    mbedtls_mpi_init(&Y);
    n = nbits / (sizeof(mbedtls_mpi_uint) /*8ull*/  << 3) + (unsigned long long int)(nbits % (sizeof(mbedtls_mpi_uint) /*8ull*/  << 3) != 0ull);
    do
    {
      ret=mbedtls_mpi_fill_random(X, n * sizeof(mbedtls_mpi_uint) /*8ull*/ , f_rng, p_rng);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    k=mbedtls_mpi_bitlen(X);
    if(!(nbits >= k))
      do
      {
        ret=mbedtls_mpi_shift_r(X, (k - nbits) + 1ull);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);

    mbedtls_mpi_set_bit(X, nbits - 1ull, 1);
    X->p[0ll] = X->p[0ll] | 1ull;
    if(dh_flag == 0)
      do
      {
        ret=mbedtls_mpi_is_prime(X, f_rng, p_rng);
        if(ret == 0)
          break;

        if(!(ret == -14))
          goto cleanup;

        do
        {
          ret=mbedtls_mpi_add_int(X, X, 2ll);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
      }
      while((_Bool)1);

    else
    {
      X->p[0ll] = X->p[0ll] | 2ull;
      do
      {
        ret=mbedtls_mpi_mod_int(&r, X, 3ll);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      if(r == 0ull)
        do
        {
          ret=mbedtls_mpi_add_int(X, X, 8ll);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);

      else
        if(r == 1ull)
          do
          {
            ret=mbedtls_mpi_add_int(X, X, 4ll);
            if(!(ret == 0))
              goto cleanup;

          }
          while((_Bool)0);

      do
      {
        ret=mbedtls_mpi_copy(&Y, X);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_shift_r(&Y, 1ull);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      while((_Bool)1)
      {
        ret=mpi_check_small_factors(X);
        if(ret == 0)
        {
          ret=mpi_check_small_factors(&Y);
          if(ret == 0)
          {
            ret=mpi_miller_rabin(X, f_rng, p_rng);
            if(ret == 0)
            {
              ret=mpi_miller_rabin(&Y, f_rng, p_rng);
              if(ret == 0)
                break;

            }

          }

        }

        if(!(ret == -14))
          goto cleanup;

        do
        {
          ret=mbedtls_mpi_add_int(X, X, 12ll);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        do
        {
          ret=mbedtls_mpi_add_int(&Y, &Y, 6ll);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
      }
    }

  cleanup:
    ;
    mbedtls_mpi_free(&Y);
    return ret;
  }
}

// mbedtls_mpi_get_bit
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 319
signed int mbedtls_mpi_get_bit(const mbedtls_mpi *X, size_t pos)
{
  if(pos >= 64ull * X->n)
    return 0;

  else
    return (signed int)(X->p[(signed long long int)(pos / (sizeof(mbedtls_mpi_uint) /*8ull*/  << 3))] >> pos % (sizeof(mbedtls_mpi_uint) /*8ull*/  << 3) & 1ull);
}

// mbedtls_mpi_grow
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 119
signed int mbedtls_mpi_grow(mbedtls_mpi *X, size_t nblimbs)
{
  mbedtls_mpi_uint *p;
  if(nblimbs >= 10001ull)
    return -0x10;

  else
  {
    if(!(X->n >= nblimbs))
    {
      void *return_value=mbedtls_calloc(nblimbs, sizeof(mbedtls_mpi_uint) /*8ull*/ );
      p = (mbedtls_mpi_uint *)return_value;
      if(p == ((mbedtls_mpi_uint *)NULL))
        return -0x10;

      if(!(X->p == ((mbedtls_mpi_uint *)NULL)))
      {
        memcpy((void *)p, (const void *)X->p, X->n * sizeof(mbedtls_mpi_uint) /*8ull*/ );
        mbedtls_mpi_zeroize(X->p, X->n);
        mbedtls_free((void *)X->p);
      }

      X->n = nblimbs;
      X->p = p;
    }

    return 0;
  }
}

// mbedtls_mpi_init
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 87
void mbedtls_mpi_init(mbedtls_mpi *X)
{
  if(!(X == ((mbedtls_mpi *)NULL)))
  {
    X->s = 1;
    X->n = 0ull;
    X->p = ((mbedtls_mpi_uint *)NULL);
  }

}

// mbedtls_mpi_inv_mod
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1907
signed int mbedtls_mpi_inv_mod(mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *N)
{
  signed int ret;
  mbedtls_mpi G;
  mbedtls_mpi TA;
  mbedtls_mpi TU;
  mbedtls_mpi U1;
  mbedtls_mpi U2;
  mbedtls_mpi TB;
  mbedtls_mpi TV;
  mbedtls_mpi V1;
  mbedtls_mpi V2;
  signed int return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(N, 1ll);
  signed int return_value_mbedtls_mpi_cmp_int$1;
  signed int return_value_mbedtls_mpi_cmp_int$2;
  signed int return_value_mbedtls_mpi_cmp_mpi$0;
  if(!(return_value_mbedtls_mpi_cmp_int >= 1))
    return -0x4;

  else
  {
    mbedtls_mpi_init(&TA);
    mbedtls_mpi_init(&TU);
    mbedtls_mpi_init(&U1);
    mbedtls_mpi_init(&U2);
    mbedtls_mpi_init(&G);
    mbedtls_mpi_init(&TB);
    mbedtls_mpi_init(&TV);
    mbedtls_mpi_init(&V1);
    mbedtls_mpi_init(&V2);
    do
    {
      ret=mbedtls_mpi_gcd(&G, A, N);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    signed int return_value_mbedtls_mpi_cmp_int$0=mbedtls_mpi_cmp_int(&G, 1ll);
    if(!(return_value_mbedtls_mpi_cmp_int$0 == 0))
      ret = -0xE;

    else
    {
      do
      {
        ret=mbedtls_mpi_mod_mpi(&TA, A, N);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_copy(&TU, &TA);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_copy(&TB, N);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_copy(&TV, N);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_lset(&U1, 1ll);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_lset(&U2, 0ll);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_lset(&V1, 0ll);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_lset(&V2, 1ll);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);

    __CPROVER_DUMP_L12:
      ;
      while((_Bool)1)
      {
        if((1ull & *TU.p) == 0ull)
        {
          do
          {
            ret=mbedtls_mpi_shift_r(&TU, 1ull);
            if(!(ret == 0))
              goto cleanup;

          }
          while((_Bool)0);
          _Bool tmp_if_expr;
          if(!((1ull & *U1.p) == 0ull))
            tmp_if_expr = (_Bool)1;

          else
            tmp_if_expr = (U2.p[0ll] & 1ull) != 0ull ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr)
          {
            do
            {
              ret=mbedtls_mpi_add_mpi(&U1, &U1, &TB);
              if(!(ret == 0))
                goto cleanup;

            }
            while((_Bool)0);
            do
            {
              ret=mbedtls_mpi_sub_mpi(&U2, &U2, &TA);
              if(!(ret == 0))
                goto cleanup;

            }
            while((_Bool)0);
          }

          do
          {
            ret=mbedtls_mpi_shift_r(&U1, 1ull);
            if(!(ret == 0))
              goto cleanup;

          }
          while((_Bool)0);
          do
          {
            ret=mbedtls_mpi_shift_r(&U2, 1ull);
            if(!(ret == 0))
              goto cleanup;

          }
          while((_Bool)0);
          goto __CPROVER_DUMP_L12;
        }

        while((1ull & *TV.p) == 0ull)
        {
          do
          {
            ret=mbedtls_mpi_shift_r(&TV, 1ull);
            if(!(ret == 0))
              goto cleanup;

          }
          while((_Bool)0);
          _Bool tmp_if_expr$0;
          if(!((1ull & *V1.p) == 0ull))
            tmp_if_expr$0 = (_Bool)1;

          else
            tmp_if_expr$0 = (V2.p[0ll] & 1ull) != 0ull ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$0)
          {
            do
            {
              ret=mbedtls_mpi_add_mpi(&V1, &V1, &TB);
              if(!(ret == 0))
                goto cleanup;

            }
            while((_Bool)0);
            do
            {
              ret=mbedtls_mpi_sub_mpi(&V2, &V2, &TA);
              if(!(ret == 0))
                goto cleanup;

            }
            while((_Bool)0);
          }

          do
          {
            ret=mbedtls_mpi_shift_r(&V1, 1ull);
            if(!(ret == 0))
              goto cleanup;

          }
          while((_Bool)0);
          do
          {
            ret=mbedtls_mpi_shift_r(&V2, 1ull);
            if(!(ret == 0))
              goto cleanup;

          }
          while((_Bool)0);
        }
        signed int return_value_mbedtls_mpi_cmp_mpi=mbedtls_mpi_cmp_mpi(&TU, &TV);
        if(return_value_mbedtls_mpi_cmp_mpi >= 0)
        {
          do
          {
            ret=mbedtls_mpi_sub_mpi(&TU, &TU, &TV);
            if(!(ret == 0))
              goto cleanup;

          }
          while((_Bool)0);
          do
          {
            ret=mbedtls_mpi_sub_mpi(&U1, &U1, &V1);
            if(!(ret == 0))
              goto cleanup;

          }
          while((_Bool)0);
          do
          {
            ret=mbedtls_mpi_sub_mpi(&U2, &U2, &V2);
            if(!(ret == 0))
              goto cleanup;

          }
          while((_Bool)0);
        }

        else
        {
          do
          {
            ret=mbedtls_mpi_sub_mpi(&TV, &TV, &TU);
            if(!(ret == 0))
              goto cleanup;

          }
          while((_Bool)0);
          do
          {
            ret=mbedtls_mpi_sub_mpi(&V1, &V1, &U1);
            if(!(ret == 0))
              goto cleanup;

          }
          while((_Bool)0);
          do
          {
            ret=mbedtls_mpi_sub_mpi(&V2, &V2, &U2);
            if(!(ret == 0))
              goto cleanup;

          }
          while((_Bool)0);
        }
        return_value_mbedtls_mpi_cmp_int$1=mbedtls_mpi_cmp_int(&TU, 0ll);
        if(return_value_mbedtls_mpi_cmp_int$1 == 0)
          break;

      }
      do
      {
        return_value_mbedtls_mpi_cmp_int$2=mbedtls_mpi_cmp_int(&V1, 0ll);
        if(return_value_mbedtls_mpi_cmp_int$2 >= 0)
          break;

        do
        {
          ret=mbedtls_mpi_add_mpi(&V1, &V1, N);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
      }
      while((_Bool)1);
      do
      {
        return_value_mbedtls_mpi_cmp_mpi$0=mbedtls_mpi_cmp_mpi(&V1, N);
        if(!(return_value_mbedtls_mpi_cmp_mpi$0 >= 0))
          break;

        do
        {
          ret=mbedtls_mpi_sub_mpi(&V1, &V1, N);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
      }
      while((_Bool)1);
      do
      {
        ret=mbedtls_mpi_copy(X, &V1);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
    }

  cleanup:
    ;
    mbedtls_mpi_free(&TA);
    mbedtls_mpi_free(&TU);
    mbedtls_mpi_free(&U1);
    mbedtls_mpi_free(&U2);
    mbedtls_mpi_free(&G);
    mbedtls_mpi_free(&TB);
    mbedtls_mpi_free(&TV);
    mbedtls_mpi_free(&V1);
    mbedtls_mpi_free(&V2);
    return ret;
  }
}

// mbedtls_mpi_is_prime
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 2166
signed int mbedtls_mpi_is_prime(const mbedtls_mpi *X, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
  signed int ret;
  mbedtls_mpi XX;
  XX.s = 1;
  XX.n = X->n;
  XX.p = X->p;
  signed int return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(&XX, 0ll);
  _Bool tmp_if_expr;
  signed int return_value_mbedtls_mpi_cmp_int$0;
  if(return_value_mbedtls_mpi_cmp_int == 0)
    tmp_if_expr = (_Bool)1;

  else
  {
    return_value_mbedtls_mpi_cmp_int$0=mbedtls_mpi_cmp_int(&XX, 1ll);
    tmp_if_expr = return_value_mbedtls_mpi_cmp_int$0 == 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr)
    return -0xE;

  else
  {
    signed int return_value_mbedtls_mpi_cmp_int$1=mbedtls_mpi_cmp_int(&XX, 2ll);
    if(return_value_mbedtls_mpi_cmp_int$1 == 0)
      return 0;

    else
    {
      ret=mpi_check_small_factors(&XX);
      if(!(ret == 0))
      {
        if(ret == 1)
          return 0;

        return ret;
      }

      else
      {
        signed int return_value_mpi_miller_rabin=mpi_miller_rabin(&XX, f_rng, p_rng);
        return return_value_mpi_miller_rabin;
      }
    }
  }
}

// mbedtls_mpi_lsb
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 358
size_t mbedtls_mpi_lsb(const mbedtls_mpi *X)
{
  size_t i;
  size_t j;
  size_t count=0ull;
  i = 0ull;
  for( ; !(i >= X->n); i = i + 1ull)
  {
    j = 0ull;
    for( ; !(j >= 64ull); count = count + 1ull)
    {
      if(!((1ull & X->p[(signed long long int)i] >> j) == 0ull))
        return count;

      j = j + 1ull;
    }
  }
  return 0ull;
}

// mbedtls_mpi_lset
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 301
signed int mbedtls_mpi_lset(mbedtls_mpi *X, mbedtls_mpi_sint z)
{
  signed int ret;
  do
  {
    ret=mbedtls_mpi_grow(X, 1ull);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  memset((void *)X->p, 0, X->n * sizeof(mbedtls_mpi_uint) /*8ull*/ );
  X->p[0ll] = (mbedtls_mpi_uint)(z < 0ll ? -z : z);
  X->s = z < 0ll ? -1 : 1;

cleanup:
  ;
  return ret;
}

// mbedtls_mpi_mod_int
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1491
signed int mbedtls_mpi_mod_int(mbedtls_mpi_uint *r, const mbedtls_mpi *A, mbedtls_mpi_sint b)
{
  size_t i;
  mbedtls_mpi_uint x;
  mbedtls_mpi_uint y;
  mbedtls_mpi_uint z;
  if(b == 0ll)
    return -0xC;

  else
    if(!(b >= 0ll))
      return -0xA;

    else
      if(b == 1ll)
      {
        *r = 0ull;
        return 0;
      }

      else
        if(b == 2ll)
        {
          *r = A->p[0ll] & 1ull;
          return 0;
        }

        else
        {
          i = A->n;
          y = 0ull;
          for( ; i >= 1ull; i = i - 1ull)
          {
            x = A->p[(signed long long int)(i - 1ull)];
            y = y << (sizeof(mbedtls_mpi_uint) /*8ull*/  << 2) | x >> (sizeof(mbedtls_mpi_uint) /*8ull*/  << 2);
            z = y / (unsigned long long int)b;
            y = y - z * (unsigned long long int)b;
            x = x << (sizeof(mbedtls_mpi_uint) /*8ull*/  << 2);
            y = y << (sizeof(mbedtls_mpi_uint) /*8ull*/  << 2) | x >> (sizeof(mbedtls_mpi_uint) /*8ull*/  << 2);
            z = y / (unsigned long long int)b;
            y = y - z * (unsigned long long int)b;
          }
          if(!(A->s >= 0))
          {
            if(!(y == 0ull))
              y = (unsigned long long int)b - y;

          }

          *r = y;
          return 0;
        }
}

// mbedtls_mpi_mod_mpi
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1468
signed int mbedtls_mpi_mod_mpi(mbedtls_mpi *R, const mbedtls_mpi *A, const mbedtls_mpi *B)
{
  signed int ret;
  signed int return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(B, 0ll);
  signed int return_value_mbedtls_mpi_cmp_int$0;
  signed int return_value_mbedtls_mpi_cmp_mpi;
  if(!(return_value_mbedtls_mpi_cmp_int >= 0))
    return -0xA;

  else
  {
    do
    {
      ret=mbedtls_mpi_div_mpi(((mbedtls_mpi *)NULL), R, A, B);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      return_value_mbedtls_mpi_cmp_int$0=mbedtls_mpi_cmp_int(R, 0ll);
      if(return_value_mbedtls_mpi_cmp_int$0 >= 0)
        break;

      do
      {
        ret=mbedtls_mpi_add_mpi(R, R, B);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
    }
    while((_Bool)1);
    do
    {
      return_value_mbedtls_mpi_cmp_mpi=mbedtls_mpi_cmp_mpi(R, B);
      if(!(return_value_mbedtls_mpi_cmp_mpi >= 0))
        break;

      do
      {
        ret=mbedtls_mpi_sub_mpi(R, R, B);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
    }
    while((_Bool)1);

  cleanup:
    ;
    return ret;
  }
}

// mbedtls_mpi_mul_int
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1225
signed int mbedtls_mpi_mul_int(mbedtls_mpi *X, const mbedtls_mpi *A, mbedtls_mpi_uint b)
{
  mbedtls_mpi _B;
  mbedtls_mpi_uint p[1ll];
  _B.s = 1;
  _B.n = 1ull;
  _B.p = p;
  p[0ll] = b;
  signed int return_value_mbedtls_mpi_mul_mpi=mbedtls_mpi_mul_mpi(X, A, &_B);
  return return_value_mbedtls_mpi_mul_mpi;
}

// mbedtls_mpi_mul_mpi
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1188
signed int mbedtls_mpi_mul_mpi(mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B)
{
  signed int ret;
  size_t i;
  size_t j;
  mbedtls_mpi TA;
  mbedtls_mpi TB;
  mbedtls_mpi_init(&TA);
  mbedtls_mpi_init(&TB);
  if(X == A)
  {
    do
    {
      ret=mbedtls_mpi_copy(&TA, A);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    A = &TA;
  }

  if(X == B)
  {
    do
    {
      ret=mbedtls_mpi_copy(&TB, B);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    B = &TB;
  }

  i = A->n;
  for( ; i >= 1ull; i = i - 1ull)
    if(!(A->p[-1ll + (signed long long int)i] == 0ull))
      break;

  j = B->n;
  for( ; j >= 1ull; j = j - 1ull)
    if(!(B->p[-1ll + (signed long long int)j] == 0ull))
      break;

  do
  {
    ret=mbedtls_mpi_grow(X, i + j);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_lset(X, 0ll);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  for( ; j >= 1ull; j = j - 1ull)
    mpi_mul_hlp(i, A->p, (X->p + (signed long long int)j) - 1ll, B->p[(signed long long int)(j - 1ull)]);
  X->s = A->s * B->s;

cleanup:
  ;
  mbedtls_mpi_free(&TB);
  mbedtls_mpi_free(&TA);
  return ret;
}

// mbedtls_mpi_read_binary
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 683
signed int mbedtls_mpi_read_binary(mbedtls_mpi *X, const unsigned char *buf, size_t buflen)
{
  signed int ret;
  size_t i;
  size_t j;
  const size_t limbs=buflen / sizeof(mbedtls_mpi_uint) /*8ull*/  + (unsigned long long int)(buflen % sizeof(mbedtls_mpi_uint) /*8ull*/  != 0ull);
  if(!(X->n == limbs))
  {
    mbedtls_mpi_free(X);
    mbedtls_mpi_init(X);
    do
    {
      ret=mbedtls_mpi_grow(X, limbs);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
  }

  do
  {
    ret=mbedtls_mpi_lset(X, 0ll);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  i = buflen;
  j = 0ull;
  for( ; i >= 1ull; j = j + 1ull)
  {
    X->p[(signed long long int)(j / sizeof(mbedtls_mpi_uint) /*8ull*/ )] = X->p[(signed long long int)(j / sizeof(mbedtls_mpi_uint) /*8ull*/ )] | (mbedtls_mpi_uint)buf[(signed long long int)(i - 1ull)] << (j % sizeof(mbedtls_mpi_uint) /*8ull*/  << 3);
    i = i - 1ull;
  }

cleanup:
  ;
  return ret;
}

// mbedtls_mpi_read_string
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 435
signed int mbedtls_mpi_read_string(mbedtls_mpi *X, signed int radix, const char *s)
{
  signed int ret;
  size_t i;
  size_t j;
  size_t slen;
  size_t n;
  mbedtls_mpi_uint d;
  mbedtls_mpi T;
  if(radix >= 17 || !(radix >= 2))
    return -0x4;

  else
  {
    mbedtls_mpi_init(&T);
    slen=strlen(s);
    if(radix == 16)
    {
      if(slen >= 4611686018427387904ull)
        return -0x4;

      n = (slen << 2) / (sizeof(mbedtls_mpi_uint) /*8ull*/  << 3) + (unsigned long long int)((slen << 2) % (sizeof(mbedtls_mpi_uint) /*8ull*/  << 3) != 0ull);
      do
      {
        ret=mbedtls_mpi_grow(X, n);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_lset(X, 0ll);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      i = slen;
      j = 0ull;
      for( ; i >= 1ull; j = j + 1ull)
      {
        if(i == 1ull)
        {
          if((signed int)s[-1ll + (signed long long int)i] == 45)
          {
            X->s = -1;
            break;
          }

        }

        do
        {
          ret=mpi_get_digit(&d, radix, s[(signed long long int)(i - 1ull)]);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        X->p[(signed long long int)(j / (2ull * sizeof(mbedtls_mpi_uint) /*8ull*/ ))] = X->p[(signed long long int)(j / (2ull * sizeof(mbedtls_mpi_uint) /*8ull*/ ))] | d << (j % (2ull * sizeof(mbedtls_mpi_uint) /*8ull*/ ) << 2);
        i = i - 1ull;
      }
    }

    else
    {
      do
      {
        ret=mbedtls_mpi_lset(X, 0ll);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      i = 0ull;
      for( ; !(i >= slen); i = i + 1ull)
      {
        if(i == 0ull)
        {
          if((signed int)s[(signed long long int)i] == 45)
          {
            X->s = -1;
            goto __CPROVER_DUMP_L19;
          }

        }

        do
        {
          ret=mpi_get_digit(&d, radix, s[(signed long long int)i]);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        do
        {
          ret=mbedtls_mpi_mul_int(&T, X, (mbedtls_mpi_uint)radix);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        if(X->s == 1)
          do
          {
            ret=mbedtls_mpi_add_int(X, &T, (mbedtls_mpi_sint)d);
            if(!(ret == 0))
              goto cleanup;

          }
          while((_Bool)0);

        else
          do
          {
            ret=mbedtls_mpi_sub_int(X, &T, (mbedtls_mpi_sint)d);
            if(!(ret == 0))
              goto cleanup;

          }
          while((_Bool)0);

      __CPROVER_DUMP_L19:
        ;
      }
    }

  cleanup:
    ;
    mbedtls_mpi_free(&T);
    return ret;
  }
}

// mbedtls_mpi_safe_cond_assign
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 239
signed int mbedtls_mpi_safe_cond_assign(mbedtls_mpi *X, const mbedtls_mpi *Y, unsigned char assign)
{
  signed int ret=0;
  size_t i;
  assign = (unsigned char)(((signed int)assign | (signed int)(unsigned char)-((signed int)assign)) >> 7);
  do
  {
    ret=mbedtls_mpi_grow(X, Y->n);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  X->s = X->s * (1 - (signed int)assign) + Y->s * (signed int)assign;
  i = 0ull;
  for( ; !(i >= Y->n); i = i + 1ull)
    X->p[(signed long long int)i] = X->p[(signed long long int)i] * (unsigned long long int)(1 - (signed int)assign) + Y->p[(signed long long int)i] * (unsigned long long int)assign;
  for( ; !(i >= X->n); i = i + 1ull)
    X->p[(signed long long int)i] = X->p[(signed long long int)i] * (mbedtls_mpi_uint)(1 - (signed int)assign);

cleanup:
  ;
  return ret;
}

// mbedtls_mpi_safe_cond_swap
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 267
signed int mbedtls_mpi_safe_cond_swap(mbedtls_mpi *X, mbedtls_mpi *Y, unsigned char swap)
{
  signed int ret;
  signed int s;
  size_t i;
  mbedtls_mpi_uint tmp;
  if(X == Y)
    return 0;

  else
  {
    swap = (unsigned char)(((signed int)swap | (signed int)(unsigned char)-((signed int)swap)) >> 7);
    do
    {
      ret=mbedtls_mpi_grow(X, Y->n);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_grow(Y, X->n);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    s = X->s;
    X->s = X->s * (1 - (signed int)swap) + Y->s * (signed int)swap;
    Y->s = Y->s * (1 - (signed int)swap) + s * (signed int)swap;
    i = 0ull;
    for( ; !(i >= X->n); i = i + 1ull)
    {
      tmp = X->p[(signed long long int)i];
      X->p[(signed long long int)i] = X->p[(signed long long int)i] * (unsigned long long int)(1 - (signed int)swap) + Y->p[(signed long long int)i] * (unsigned long long int)swap;
      Y->p[(signed long long int)i] = Y->p[(signed long long int)i] * (unsigned long long int)(1 - (signed int)swap) + tmp * (unsigned long long int)swap;
    }

  cleanup:
    ;
    return ret;
  }
}

// mbedtls_mpi_self_test
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 2303
signed int mbedtls_mpi_self_test(signed int verbose)
{
  signed int ret;
  signed int i;
  mbedtls_mpi A;
  mbedtls_mpi E;
  mbedtls_mpi N;
  mbedtls_mpi X;
  mbedtls_mpi Y;
  mbedtls_mpi U;
  mbedtls_mpi V;
  mbedtls_mpi_init(&A);
  mbedtls_mpi_init(&E);
  mbedtls_mpi_init(&N);
  mbedtls_mpi_init(&X);
  mbedtls_mpi_init(&Y);
  mbedtls_mpi_init(&U);
  mbedtls_mpi_init(&V);
  do
  {
    ret=mbedtls_mpi_read_string(&A, 16, "EFE021C2645FD1DC586E69184AF4A31ED5F53E93B5F123FA41680867BA110131944FE7952E2517337780CB0DB80E61AAE7C8DDC6C5C6AADEB34EB38A2F40D5E6");
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_read_string(&E, 16, "B2E7EFD37075B9F03FF989C7C5051C2034D2A323810251127E7BF8625A4F49A5F3E27F4DA8BD59C47D6DAABA4C8127BD5B5C25763222FEFCCFC38B832366C29E");
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_read_string(&N, 16, "0066A198186C18C10B2F5ED9B522752A9830B69916E535C8F047518A889A43A594B6BED27A168D31D4A52F88925AA8F5");
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_mul_mpi(&X, &A, &N);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_read_string(&U, 16, "602AB7ECA597A3D6B56FF9829A5E8B859E857EA95A03512E2BAE7391688D264AA5663B0341DB9CCFD2C4C5F421FEC8148001B72E848A38CAE1C65F78E56ABDEFE12D3C039B8A02D6BE593F0BBBDA56F1ECF677152EF804370C1A305CAF3B5BF130879B56C61DE584A0F53A2447A51E");
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  if(!(verbose == 0))
    printf("  MPI test #1 (mul_mpi): ");

  signed int return_value_mbedtls_mpi_cmp_mpi=mbedtls_mpi_cmp_mpi(&X, &U);
  signed int return_value_mbedtls_mpi_cmp_mpi$0;
  _Bool tmp_if_expr;
  signed int return_value_mbedtls_mpi_cmp_mpi$1;
  signed int return_value_mbedtls_mpi_cmp_mpi$2;
  signed int return_value_mbedtls_mpi_cmp_mpi$3;
  if(!(return_value_mbedtls_mpi_cmp_mpi == 0))
  {
    if(!(verbose == 0))
      printf("failed\n");

    ret = 1;
  }

  else
  {
    if(!(verbose == 0))
      printf("passed\n");

    do
    {
      ret=mbedtls_mpi_div_mpi(&X, &Y, &A, &N);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_read_string(&U, 16, "256567336059E52CAE22925474705F39A94");
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_read_string(&V, 16, "6613F26162223DF488E9CD48CC132C7A0AC93C701B001B092E4E5B9F73BCD27B9EE50D0657C77F374E903CDFA4C642");
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    if(!(verbose == 0))
      printf("  MPI test #2 (div_mpi): ");

    return_value_mbedtls_mpi_cmp_mpi$0=mbedtls_mpi_cmp_mpi(&X, &U);
    if(!(return_value_mbedtls_mpi_cmp_mpi$0 == 0))
      tmp_if_expr = (_Bool)1;

    else
    {
      return_value_mbedtls_mpi_cmp_mpi$1=mbedtls_mpi_cmp_mpi(&Y, &V);
      tmp_if_expr = return_value_mbedtls_mpi_cmp_mpi$1 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr)
    {
      if(!(verbose == 0))
        printf("failed\n");

      ret = 1;
    }

    else
    {
      if(!(verbose == 0))
        printf("passed\n");

      do
      {
        ret=mbedtls_mpi_exp_mod(&X, &A, &E, &N, ((mbedtls_mpi *)NULL));
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_read_string(&U, 16, "36E139AEA55215609D2816998ED020BBBD96C37890F65171D948E9BC7CBAA4D9325D24D6A3C12710F10A09FA08AB87");
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      if(!(verbose == 0))
        printf("  MPI test #3 (exp_mod): ");

      return_value_mbedtls_mpi_cmp_mpi$2=mbedtls_mpi_cmp_mpi(&X, &U);
      if(!(return_value_mbedtls_mpi_cmp_mpi$2 == 0))
      {
        if(!(verbose == 0))
          printf("failed\n");

        ret = 1;
      }

      else
      {
        if(!(verbose == 0))
          printf("passed\n");

        do
        {
          ret=mbedtls_mpi_inv_mod(&X, &A, &N);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        do
        {
          ret=mbedtls_mpi_read_string(&U, 16, "003A0AAEDD7E784FC07D8F9EC6E3BFD5C3DBA76456363A10869622EAC2DD84ECC5B8A74DAC4D09E03B5E0BE779F2DF61");
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        if(!(verbose == 0))
          printf("  MPI test #4 (inv_mod): ");

        return_value_mbedtls_mpi_cmp_mpi$3=mbedtls_mpi_cmp_mpi(&X, &U);
        if(!(return_value_mbedtls_mpi_cmp_mpi$3 == 0))
        {
          if(!(verbose == 0))
            printf("failed\n");

          ret = 1;
        }

        else
        {
          if(!(verbose == 0))
            printf("passed\n");

          if(!(verbose == 0))
            printf("  MPI test #5 (simple gcd): ");

          i = 0;
          for( ; !(i >= 3); i = i + 1)
          {
            do
            {
              ret=mbedtls_mpi_lset(&X, (mbedtls_mpi_sint)gcd_pairs[(signed long long int)i][0ll]);
              if(!(ret == 0))
                goto cleanup;

            }
            while((_Bool)0);
            do
            {
              ret=mbedtls_mpi_lset(&Y, (mbedtls_mpi_sint)gcd_pairs[(signed long long int)i][1ll]);
              if(!(ret == 0))
                goto cleanup;

            }
            while((_Bool)0);
            do
            {
              ret=mbedtls_mpi_gcd(&A, &X, &Y);
              if(!(ret == 0))
                goto cleanup;

            }
            while((_Bool)0);
            signed int return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(&A, (mbedtls_mpi_sint)gcd_pairs[(signed long long int)i][2ll]);
            if(!(return_value_mbedtls_mpi_cmp_int == 0))
            {
              if(!(verbose == 0))
                printf("failed at %d\n", i);

              ret = 1;
              goto cleanup;
            }

          }
          if(!(verbose == 0))
            printf("passed\n");

        }
      }
    }
  }

cleanup:
  ;
  if(!(ret == 0) && !(verbose == 0))
    printf("Unexpected error, return code = %08X\n", ret);

  mbedtls_mpi_free(&A);
  mbedtls_mpi_free(&E);
  mbedtls_mpi_free(&N);
  mbedtls_mpi_free(&X);
  mbedtls_mpi_free(&Y);
  mbedtls_mpi_free(&U);
  mbedtls_mpi_free(&V);
  if(!(verbose == 0))
    printf("\n");

  return ret;
}

// mbedtls_mpi_set_bit
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 330
signed int mbedtls_mpi_set_bit(mbedtls_mpi *X, size_t pos, unsigned char val)
{
  signed int ret=0;
  size_t off=pos / (sizeof(mbedtls_mpi_uint) /*8ull*/  << 3);
  size_t idx=pos % (sizeof(mbedtls_mpi_uint) /*8ull*/  << 3);
  if(!((signed int)val == 0) && !((signed int)val == 1))
    return -0x4;

  else
  {
    if(pos >= 64ull * X->n)
    {
      if((signed int)val == 0)
        return 0;

      do
      {
        ret=mbedtls_mpi_grow(X, off + 1ull);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
    }

    X->p[(signed long long int)off] = X->p[(signed long long int)off] & ~(1ull << idx);
    X->p[(signed long long int)off] = X->p[(signed long long int)off] | (mbedtls_mpi_uint)val << idx;

  cleanup:
    ;
    return ret;
  }
}

// mbedtls_mpi_shift_l
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 730
signed int mbedtls_mpi_shift_l(mbedtls_mpi *X, size_t count)
{
  signed int ret;
  size_t i;
  size_t v0;
  size_t t1;
  mbedtls_mpi_uint r0=0ull;
  mbedtls_mpi_uint r1;
  v0 = count / (sizeof(mbedtls_mpi_uint) /*8ull*/  << 3);
  t1 = count & (sizeof(mbedtls_mpi_uint) /*8ull*/  << 3) - 1ull;
  size_t return_value_mbedtls_mpi_bitlen=mbedtls_mpi_bitlen(X);
  i = return_value_mbedtls_mpi_bitlen + count;
  if(!(64ull * X->n >= i))
    do
    {
      ret=mbedtls_mpi_grow(X, i / (sizeof(mbedtls_mpi_uint) /*8ull*/  << 3) + (unsigned long long int)(i % (sizeof(mbedtls_mpi_uint) /*8ull*/  << 3) != 0ull));
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);

  ret = 0;
  if(v0 >= 1ull)
  {
    i = X->n;
    for( ; !(v0 >= i); i = i - 1ull)
      X->p[(signed long long int)(i - 1ull)] = X->p[(signed long long int)((i - v0) - 1ull)];
    for( ; i >= 1ull; i = i - 1ull)
      X->p[(signed long long int)(i - 1ull)] = 0ull;
  }

  if(t1 >= 1ull)
  {
    i = v0;
    for( ; !(i >= X->n); i = i + 1ull)
    {
      r1 = X->p[(signed long long int)i] >> (sizeof(mbedtls_mpi_uint) /*8ull*/  << 3) - t1;
      X->p[(signed long long int)i] = X->p[(signed long long int)i] << t1;
      X->p[(signed long long int)i] = X->p[(signed long long int)i] | r0;
      r0 = r1;
    }
  }


cleanup:
  ;
  return ret;
}

// mbedtls_mpi_shift_r
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 780
signed int mbedtls_mpi_shift_r(mbedtls_mpi *X, size_t count)
{
  size_t i;
  size_t v0;
  size_t v1;
  mbedtls_mpi_uint r0=0ull;
  mbedtls_mpi_uint r1;
  v0 = count / (sizeof(mbedtls_mpi_uint) /*8ull*/  << 3);
  v1 = count & (sizeof(mbedtls_mpi_uint) /*8ull*/  << 3) - 1ull;
  _Bool tmp_if_expr;
  if(!(X->n >= v0))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = (v0 == X->n ? (v1 > 0ull ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
  signed int return_value_mbedtls_mpi_lset;
  if(tmp_if_expr)
  {
    return_value_mbedtls_mpi_lset=mbedtls_mpi_lset(X, 0ll);
    return return_value_mbedtls_mpi_lset;
  }

  else
  {
    if(v0 >= 1ull)
    {
      i = 0ull;
      for( ; !(i >= X->n + -v0); i = i + 1ull)
        X->p[(signed long long int)i] = X->p[(signed long long int)(i + v0)];
      for( ; !(i >= X->n); i = i + 1ull)
        X->p[(signed long long int)i] = 0ull;
    }

    if(v1 >= 1ull)
    {
      i = X->n;
      for( ; i >= 1ull; i = i - 1ull)
      {
        r1 = X->p[(signed long long int)(i - 1ull)] << (sizeof(mbedtls_mpi_uint) /*8ull*/  << 3) - v1;
        X->p[(signed long long int)(i - 1ull)] = X->p[(signed long long int)(i - 1ull)] >> v1;
        X->p[(signed long long int)(i - 1ull)] = X->p[(signed long long int)(i - 1ull)] | r0;
        r0 = r1;
      }
    }

    return 0;
  }
}

// mbedtls_mpi_shrink
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 149
signed int mbedtls_mpi_shrink(mbedtls_mpi *X, size_t nblimbs)
{
  mbedtls_mpi_uint *p;
  size_t i;
  signed int return_value_mbedtls_mpi_grow;
  if(nblimbs >= X->n)
  {
    return_value_mbedtls_mpi_grow=mbedtls_mpi_grow(X, nblimbs);
    return return_value_mbedtls_mpi_grow;
  }

  else
  {
    i = X->n - 1ull;
    for( ; i >= 1ull; i = i - 1ull)
      if(!(X->p[(signed long long int)i] == 0ull))
        break;

    i = i + 1ull;
    if(!(i >= nblimbs))
      i = nblimbs;

    void *return_value=mbedtls_calloc(i, sizeof(mbedtls_mpi_uint) /*8ull*/ );
    p = (mbedtls_mpi_uint *)return_value;
    if(p == ((mbedtls_mpi_uint *)NULL))
      return -0x10;

    else
    {
      if(!(X->p == ((mbedtls_mpi_uint *)NULL)))
      {
        memcpy((void *)p, (const void *)X->p, i * sizeof(mbedtls_mpi_uint) /*8ull*/ );
        mbedtls_mpi_zeroize(X->p, X->n);
        mbedtls_free((void *)X->p);
      }

      X->n = i;
      X->p = p;
      return 0;
    }
  }
}

// mbedtls_mpi_size
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 410
size_t mbedtls_mpi_size(const mbedtls_mpi *X)
{
  size_t return_value_mbedtls_mpi_bitlen=mbedtls_mpi_bitlen(X);
  return return_value_mbedtls_mpi_bitlen + 7ull >> 3;
}

// mbedtls_mpi_sub_abs
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 979
signed int mbedtls_mpi_sub_abs(mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B)
{
  mbedtls_mpi TB;
  signed int ret;
  size_t n;
  signed int return_value_mbedtls_mpi_cmp_abs=mbedtls_mpi_cmp_abs(A, B);
  if(!(return_value_mbedtls_mpi_cmp_abs >= 0))
    return -0xA;

  else
  {
    mbedtls_mpi_init(&TB);
    if(X == B)
    {
      do
      {
        ret=mbedtls_mpi_copy(&TB, B);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      B = &TB;
    }

    if(!(X == A))
      do
      {
        ret=mbedtls_mpi_copy(X, A);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);

    X->s = 1;
    ret = 0;
    n = B->n;
    for( ; n >= 1ull; n = n - 1ull)
      if(!(B->p[-1ll + (signed long long int)n] == 0ull))
        break;

    mpi_sub_hlp(n, B->p, X->p);

  cleanup:
    ;
    mbedtls_mpi_free(&TB);
    return ret;
  }
}

// mbedtls_mpi_sub_int
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1100
signed int mbedtls_mpi_sub_int(mbedtls_mpi *X, const mbedtls_mpi *A, mbedtls_mpi_sint b)
{
  mbedtls_mpi _B;
  mbedtls_mpi_uint p[1ll];
  p[0ll] = (mbedtls_mpi_uint)(b < 0ll ? -b : b);
  _B.s = b < 0ll ? -1 : 1;
  _B.n = 1ull;
  _B.p = p;
  signed int return_value_mbedtls_mpi_sub_mpi=mbedtls_mpi_sub_mpi(X, A, &_B);
  return return_value_mbedtls_mpi_sub_mpi;
}

// mbedtls_mpi_sub_mpi
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1053
signed int mbedtls_mpi_sub_mpi(mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B)
{
  signed int ret;
  signed int s=A->s;
  if(A->s * B->s >= 1)
  {
    signed int return_value_mbedtls_mpi_cmp_abs=mbedtls_mpi_cmp_abs(A, B);
    if(return_value_mbedtls_mpi_cmp_abs >= 0)
    {
      do
      {
        ret=mbedtls_mpi_sub_abs(X, A, B);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      X->s = s;
    }

    else
    {
      do
      {
        ret=mbedtls_mpi_sub_abs(X, B, A);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      X->s = -s;
    }
  }

  else
  {
    do
    {
      ret=mbedtls_mpi_add_abs(X, A, B);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    X->s = s;
  }

cleanup:
  ;
  return ret;
}

// mbedtls_mpi_swap
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 225
void mbedtls_mpi_swap(mbedtls_mpi *X, mbedtls_mpi *Y)
{
  mbedtls_mpi T;
  memcpy((void *)&T, (const void *)X, sizeof(mbedtls_mpi) /*24ull*/ );
  memcpy((void *)X, (const void *)Y, sizeof(mbedtls_mpi) /*24ull*/ );
  memcpy((void *)Y, (const void *)&T, sizeof(mbedtls_mpi) /*24ull*/ );
}

// mbedtls_mpi_write_binary
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 710
signed int mbedtls_mpi_write_binary(const mbedtls_mpi *X, unsigned char *buf, size_t buflen)
{
  size_t i;
  size_t j;
  size_t n=mbedtls_mpi_size(X);
  if(!(buflen >= n))
    return -0x8;

  else
  {
    memset((void *)buf, 0, buflen);
    i = buflen - 1ull;
    j = 0ull;
    for( ; n >= 1ull; n = n - 1ull)
    {
      buf[(signed long long int)i] = (unsigned char)(X->p[(signed long long int)(j / sizeof(mbedtls_mpi_uint) /*8ull*/ )] >> (j % sizeof(mbedtls_mpi_uint) /*8ull*/  << 3));
      i = i - 1ull;
      j = j + 1ull;
    }
    return 0;
  }
}

// mbedtls_mpi_write_string
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 534
signed int mbedtls_mpi_write_string(const mbedtls_mpi *X, signed int radix, char *buf, size_t buflen, size_t *olen)
{
  signed int ret=0;
  size_t n;
  char *p;
  mbedtls_mpi T;
  char *tmp_post;
  if(radix >= 17 || !(radix >= 2))
    return -0x4;

  else
  {
    n=mbedtls_mpi_bitlen(X);
    if(radix >= 4)
      n = n >> 1;

    if(radix >= 16)
      n = n >> 1;

    n = n + 3ull + (n + 1ull & 1ull);
    if(!(buflen >= n))
    {
      *olen = n;
      return -0x8;
    }

    else
    {
      p = buf;
      mbedtls_mpi_init(&T);
      if(X->s == -1)
      {
        tmp_post = p;
        p = p + 1ll;
        *tmp_post = '-';
      }

      if(radix == 16)
      {
        signed int c;
        size_t i;
        size_t j;
        size_t k;
        i = X->n;
        k = 0ull;
        for( ; i >= 1ull; i = i - 1ull)
        {
          j = sizeof(mbedtls_mpi_uint) /*8ull*/ ;
          for( ; j >= 1ull; j = j - 1ull)
          {
            c = (signed int)(X->p[(signed long long int)(i - 1ull)] >> (j - 1ull << 3) & 255ull);
            if(!(c == 0) || !(k == 0ull) || i + j == 2ull)
            {
              char *tmp_post$0=p;
              p = p + 1ll;
              *tmp_post$0 = "0123456789ABCDEF"[(signed long long int)(c / 16)];
              char *tmp_post$1=p;
              p = p + 1ll;
              *tmp_post$1 = "0123456789ABCDEF"[(signed long long int)(c % 16)];
              k = 1ull;
            }

          }
        }
      }

      else
      {
        do
        {
          ret=mbedtls_mpi_copy(&T, X);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        if(T.s == -1)
          T.s = 1;

        do
        {
          ret=mpi_write_hlp(&T, radix, &p);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
      }
      char *tmp_post$2=p;
      p = p + 1ll;
      *tmp_post$2 = 0;
      *olen = (size_t)(p - buf);

    cleanup:
      ;
      mbedtls_mpi_free(&T);
      return ret;
    }
  }
}

// mbedtls_mpi_zeroize
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 62
static void mbedtls_mpi_zeroize(mbedtls_mpi_uint *v, size_t n)
{
  volatile mbedtls_mpi_uint *p=v;
  size_t tmp_post;
  volatile mbedtls_mpi_uint *tmp_post$0;
  do
  {
    tmp_post = n;
    n = n - 1ull;
    if(tmp_post == 0ull)
      break;

    tmp_post$0 = p;
    p = p + 1ll;
    *tmp_post$0 = 0ull;
  }
  while((_Bool)1);
}

// mbedtls_oid_get_attr_short_name
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 249
signed int mbedtls_oid_get_attr_short_name(const mbedtls_asn1_buf *oid, const char **short_name)
{
  const oid_x520_attr_t *data=oid_x520_attr_from_asn1(oid);
  if(data == ((const oid_x520_attr_t *)NULL))
    return -0x2E;

  else
  {
    *short_name = data->short_name;
    return 0;
  }
}

// mbedtls_oid_get_cipher_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 561
signed int mbedtls_oid_get_cipher_alg(const mbedtls_asn1_buf *oid, mbedtls_cipher_type_t *cipher_alg)
{
  const oid_cipher_alg_t *data=oid_cipher_alg_from_asn1(oid);
  if(data == ((const oid_cipher_alg_t *)NULL))
    return -0x2E;

  else
  {
    *cipher_alg = data->cipher_alg;
    return 0;
  }
}

// mbedtls_oid_get_ec_grp
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 531
signed int mbedtls_oid_get_ec_grp(const mbedtls_asn1_buf *oid, mbedtls_ecp_group_id *grp_id)
{
  const oid_ecp_grp_t *data=oid_grp_id_from_asn1(oid);
  if(data == ((const oid_ecp_grp_t *)NULL))
    return -0x2E;

  else
  {
    *grp_id = data->grp_id;
    return 0;
  }
}

// mbedtls_oid_get_extended_key_usage
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 302
signed int mbedtls_oid_get_extended_key_usage(const mbedtls_asn1_buf *oid, const char **description)
{
  const mbedtls_oid_descriptor_t *data=oid_ext_key_usage_from_asn1(oid);
  if(data == ((const mbedtls_oid_descriptor_t *)NULL))
    return -0x2E;

  else
  {
    *description = data->description;
    return 0;
  }
}

// mbedtls_oid_get_md_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 626
signed int mbedtls_oid_get_md_alg(const mbedtls_asn1_buf *oid, mbedtls_md_type_t *md_alg)
{
  const oid_md_alg_t *data=oid_md_alg_from_asn1(oid);
  if(data == ((const oid_md_alg_t *)NULL))
    return -0x2E;

  else
  {
    *md_alg = data->md_alg;
    return 0;
  }
}

// mbedtls_oid_get_md_hmac
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 672
signed int mbedtls_oid_get_md_hmac(const mbedtls_asn1_buf *oid, mbedtls_md_type_t *md_hmac)
{
  const oid_md_hmac_t *data=oid_md_hmac_from_asn1(oid);
  if(data == ((const oid_md_hmac_t *)NULL))
    return -0x2E;

  else
  {
    *md_hmac = data->md_hmac;
    return 0;
  }
}

// mbedtls_oid_get_numeric_string
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 715
signed int mbedtls_oid_get_numeric_string(char *buf, size_t size, const mbedtls_asn1_buf *oid)
{
  signed int ret;
  size_t i;
  size_t n;
  unsigned int value;
  char *p=buf;
  n = size;
  if(oid->len >= 1ull)
  {
    ret=mbedtls_snprintf(p, n, "%d.%d", (signed int)oid->p[0ll] / 40, (signed int)oid->p[0ll] % 40);
    if((size_t)ret >= n || !(ret >= 0))
      return -0xB;

    n = n - (size_t)ret;
    p = p + (signed long long int)(size_t)ret;
  }

  value = 0u;
  i = 1ull;
  for( ; !(i >= oid->len); i = i + 1ull)
  {
    if(!((value << 7) >> 7 == value))
      return -0xB;

    value = value << 7;
    value = value + (unsigned int)((signed int)oid->p[(signed long long int)i] & 0x7F);
    if((0x80 & (signed int)oid->p[(signed long long int)i]) == 0)
    {
      ret=mbedtls_snprintf(p, n, ".%d", value);
      if((size_t)ret >= n || !(ret >= 0))
        return -0xB;

      n = n - (size_t)ret;
      p = p + (signed long long int)(size_t)ret;
      value = 0u;
    }

  }
  return (signed int)(size - n);
}

// mbedtls_oid_get_oid_by_ec_grp
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 532
signed int mbedtls_oid_get_oid_by_ec_grp(mbedtls_ecp_group_id grp_id, const char **oid, size_t *olen)
{
  const oid_ecp_grp_t *cur=oid_ecp_grp;
  for( ; !(cur->descriptor.asn1 == ((const char *)NULL)); cur = cur + 1ll)
    if(cur->grp_id == grp_id)
    {
      *oid = cur->descriptor.asn1;
      *olen = cur->descriptor.asn1_len;
      return 0;
    }

  return -0x2E;
}

// mbedtls_oid_get_oid_by_md
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 627
signed int mbedtls_oid_get_oid_by_md(mbedtls_md_type_t md_alg, const char **oid, size_t *olen)
{
  const oid_md_alg_t *cur=oid_md_alg;
  for( ; !(cur->descriptor.asn1 == ((const char *)NULL)); cur = cur + 1ll)
    if(cur->md_alg == md_alg)
    {
      *oid = cur->descriptor.asn1;
      *olen = cur->descriptor.asn1_len;
      return 0;
    }

  return -0x2E;
}

// mbedtls_oid_get_oid_by_pk_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 445
signed int mbedtls_oid_get_oid_by_pk_alg(mbedtls_pk_type_t pk_alg, const char **oid, size_t *olen)
{
  const oid_pk_alg_t *cur=oid_pk_alg;
  for( ; !(cur->descriptor.asn1 == ((const char *)NULL)); cur = cur + 1ll)
    if(cur->pk_alg == pk_alg)
    {
      *oid = cur->descriptor.asn1;
      *olen = cur->descriptor.asn1_len;
      return 0;
    }

  return -0x2E;
}

// mbedtls_oid_get_oid_by_sig_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 412
signed int mbedtls_oid_get_oid_by_sig_alg(mbedtls_pk_type_t pk_alg, mbedtls_md_type_t md_alg, const char **oid, size_t *olen)
{
  const oid_sig_alg_t *cur=oid_sig_alg;
  for( ; !(cur->descriptor.asn1 == ((const char *)NULL)); cur = cur + 1ll)
    if(cur->pk_alg == pk_alg)
    {
      if(cur->md_alg == md_alg)
      {
        *oid = cur->descriptor.asn1;
        *olen = cur->descriptor.asn1_len;
        return 0;
      }

    }

  return -0x2E;
}

// mbedtls_oid_get_pk_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 444
signed int mbedtls_oid_get_pk_alg(const mbedtls_asn1_buf *oid, mbedtls_pk_type_t *pk_alg)
{
  const oid_pk_alg_t *data=oid_pk_alg_from_asn1(oid);
  if(data == ((const oid_pk_alg_t *)NULL))
    return -0x2E;

  else
  {
    *pk_alg = data->pk_alg;
    return 0;
  }
}

// mbedtls_oid_get_sig_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 411
signed int mbedtls_oid_get_sig_alg(const mbedtls_asn1_buf *oid, mbedtls_md_type_t *md_alg, mbedtls_pk_type_t *pk_alg)
{
  const oid_sig_alg_t *data=oid_sig_alg_from_asn1(oid);
  if(data == ((const oid_sig_alg_t *)NULL))
    return -0x2E;

  else
  {
    *md_alg = data->md_alg;
    *pk_alg = data->pk_alg;
    return 0;
  }
}

// mbedtls_oid_get_sig_alg_desc
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 410
signed int mbedtls_oid_get_sig_alg_desc(const mbedtls_asn1_buf *oid, const char **description)
{
  const oid_sig_alg_t *data=oid_sig_alg_from_asn1(oid);
  if(data == ((const oid_sig_alg_t *)NULL))
    return -0x2E;

  else
  {
    *description = data->descriptor.description;
    return 0;
  }
}

// mbedtls_oid_get_x509_ext_type
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 288
signed int mbedtls_oid_get_x509_ext_type(const mbedtls_asn1_buf *oid, signed int *ext_type)
{
  const oid_x509_ext_t *data=oid_x509_ext_from_asn1(oid);
  if(data == ((const oid_x509_ext_t *)NULL))
    return -0x2E;

  else
  {
    *ext_type = data->ext_type;
    return 0;
  }
}

// mbedtls_pem_free
// file ..\..\..\..\lib\third_party\mbedtls\library\pem.c line 428
void mbedtls_pem_free(mbedtls_pem_context *ctx)
{
  if(!(ctx->buf == ((unsigned char *)NULL)))
    mbedtls_zeroize$link10((void *)ctx->buf, ctx->buflen);

  mbedtls_free((void *)ctx->buf);
  mbedtls_free((void *)ctx->info);
  mbedtls_zeroize$link10((void *)ctx, sizeof(mbedtls_pem_context) /*24ull*/ );
}

// mbedtls_pem_init
// file ..\..\..\..\lib\third_party\mbedtls\library\pem.c line 53
void mbedtls_pem_init(mbedtls_pem_context *ctx)
{
  memset((void *)ctx, 0, sizeof(mbedtls_pem_context) /*24ull*/ );
}

// mbedtls_pem_read_buffer
// file ..\..\..\..\lib\third_party\mbedtls\library\pem.c line 234
signed int mbedtls_pem_read_buffer(mbedtls_pem_context *ctx, const char *header, const char *footer, const unsigned char *data, const unsigned char *pwd, size_t pwdlen, size_t *use_len)
{
  signed int ret;
  signed int enc;
  size_t len;
  unsigned char *buf;
  const unsigned char *s1;
  const unsigned char *s2;
  const unsigned char *end;
  (void)pwd;
  (void)pwdlen;
  signed int return_value_memcmp;
  if(ctx == ((mbedtls_pem_context *)NULL))
    return -0x1480;

  else
  {
    char *return_value_strstr=strstr((const char *)data, header);
    s1 = (unsigned char *)return_value_strstr;
    if(s1 == ((const unsigned char *)NULL))
      return -0x1080;

    else
    {
      char *return_value_strstr$0=strstr((const char *)data, footer);
      s2 = (unsigned char *)return_value_strstr$0;
      if(s2 == ((const unsigned char *)NULL) || s1 >= s2)
        return -0x1080;

      else
      {
        size_t return_value_strlen=strlen(header);
        s1 = s1 + (signed long long int)return_value_strlen;
        if((signed int)*s1 == 32)
          s1 = s1 + 1ll;

        if((signed int)*s1 == 13)
          s1 = s1 + 1ll;

        if((signed int)*s1 == 10)
          s1 = s1 + 1ll;

        else
          return -0x1080;
        end = s2;
        size_t return_value_strlen$0=strlen(footer);
        end = end + (signed long long int)return_value_strlen$0;
        if((signed int)*end == 32)
          end = end + 1ll;

        if((signed int)*end == 13)
          end = end + 1ll;

        if((signed int)*end == 10)
          end = end + 1ll;

        *use_len = (size_t)(end - data);
        enc = 0;
        if(s2 - s1 >= 22ll)
        {
          return_value_memcmp=memcmp((const void *)s1, (const void *)"Proc-Type: 4,ENCRYPTED", 22ull);
          if(return_value_memcmp == 0)
            return -0x1400;

        }

        if(s1 >= s2)
          return -0x1100;

        else
        {
          ret=mbedtls_base64_decode(((unsigned char *)NULL), 0ull, &len, s1, (size_t)(s2 - s1));
          if(ret == -44)
            return -0x1100 + ret;

          else
          {
            void *return_value=mbedtls_calloc(1ull, len);
            buf = (unsigned char *)return_value;
            if(buf == ((unsigned char *)NULL))
              return -0x1180;

            else
            {
              ret=mbedtls_base64_decode(buf, len, &len, s1, (size_t)(s2 - s1));
              if(!(ret == 0))
              {
                mbedtls_zeroize$link10((void *)buf, len);
                mbedtls_free((void *)buf);
                return -0x1100 + ret;
              }

              else
                if(!(enc == 0))
                {
                  mbedtls_zeroize$link10((void *)buf, len);
                  mbedtls_free((void *)buf);
                  return -0x1400;
                }

                else
                {
                  ctx->buf = buf;
                  ctx->buflen = len;
                  return 0;
                }
            }
          }
        }
      }
    }
  }
}

// mbedtls_pk_can_do
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 151
signed int mbedtls_pk_can_do(const mbedtls_pk_context *ctx, mbedtls_pk_type_t type)
{
  _Bool tmp_if_expr;
  if(ctx == ((const mbedtls_pk_context *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ctx->pk_info == ((const mbedtls_pk_info_t *)NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return 0;

  else
  {
    signed int return_value=ctx->pk_info->can_do(type);
    return return_value;
  }
}

// mbedtls_pk_check_pair
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 311
signed int mbedtls_pk_check_pair(const mbedtls_pk_context *pub, const mbedtls_pk_context *prv)
{
  _Bool tmp_if_expr;
  if(pub == ((const mbedtls_pk_context *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = pub->pk_info == ((const mbedtls_pk_info_t *)NULL) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$0;
  if(prv == ((const mbedtls_pk_context *)NULL) || tmp_if_expr)
    tmp_if_expr$0 = (_Bool)1;

  else
    tmp_if_expr$0 = prv->pk_info == ((const mbedtls_pk_info_t *)NULL) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$1;
  if(tmp_if_expr$0)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = prv->pk_info->check_pair_func == ((signed int (*)(const void *, const void *))NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return -0x3E80;

  else
  {
    if((signed int)prv->pk_info->type == 5)
    {
      if(!((signed int)pub->pk_info->type == 1))
        return -0x3F00;

    }

    else
      if(!(pub->pk_info == prv->pk_info))
        return -0x3F00;

    signed int return_value=prv->pk_info->check_pair_func(pub->pk_ctx, prv->pk_ctx);
    return return_value;
  }
}

// mbedtls_pk_debug
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 348
signed int mbedtls_pk_debug(const mbedtls_pk_context *ctx, mbedtls_pk_debug_item *items)
{
  _Bool tmp_if_expr;
  if(ctx == ((const mbedtls_pk_context *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ctx->pk_info == ((const mbedtls_pk_info_t *)NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return -0x3E80;

  else
    if(ctx->pk_info->debug_func == ((void (*)(const void *, mbedtls_pk_debug_item *))NULL))
      return -0x3F00;

    else
    {
      ctx->pk_info->debug_func(ctx->pk_ctx, items);
      return 0;
    }
}

// mbedtls_pk_decrypt
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 275
signed int mbedtls_pk_decrypt(mbedtls_pk_context *ctx, const unsigned char *input, size_t ilen, unsigned char *output, size_t *olen, size_t osize, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
  _Bool tmp_if_expr;
  if(ctx == ((mbedtls_pk_context *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ctx->pk_info == ((const mbedtls_pk_info_t *)NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return -0x3E80;

  else
    if(ctx->pk_info->decrypt_func == ((signed int (*)(void *, const unsigned char *, size_t, unsigned char *, size_t *, size_t, signed int (*)(void *, unsigned char *, size_t), void *))NULL))
      return -0x3F00;

    else
    {
      signed int return_value=ctx->pk_info->decrypt_func(ctx->pk_ctx, input, ilen, output, olen, osize, f_rng, p_rng);
      return return_value;
    }
}

// mbedtls_pk_ec
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/pk.h line 154
static inline mbedtls_ecp_keypair * mbedtls_pk_ec(const mbedtls_pk_context pk)
{
  return (mbedtls_ecp_keypair *)pk.pk_ctx;
}

// mbedtls_pk_ec$link1
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\pk.h line 154
static inline mbedtls_ecp_keypair * mbedtls_pk_ec$link1(const mbedtls_pk_context pk$link1)
{
  return (mbedtls_ecp_keypair *)pk$link1.pk_ctx;
}

// mbedtls_pk_ec$link2
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\pk.h line 154
static inline mbedtls_ecp_keypair * mbedtls_pk_ec$link2(const mbedtls_pk_context pk$link2)
{
  return (mbedtls_ecp_keypair *)pk$link2.pk_ctx;
}

// mbedtls_pk_encrypt
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 293
signed int mbedtls_pk_encrypt(mbedtls_pk_context *ctx, const unsigned char *input, size_t ilen, unsigned char *output, size_t *olen, size_t osize, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
  _Bool tmp_if_expr;
  if(ctx == ((mbedtls_pk_context *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ctx->pk_info == ((const mbedtls_pk_info_t *)NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return -0x3E80;

  else
    if(ctx->pk_info->encrypt_func == ((signed int (*)(void *, const unsigned char *, size_t, unsigned char *, size_t *, size_t, signed int (*)(void *, unsigned char *, size_t), void *))NULL))
      return -0x3F00;

    else
    {
      signed int return_value=ctx->pk_info->encrypt_func(ctx->pk_ctx, input, ilen, output, olen, osize, f_rng, p_rng);
      return return_value;
    }
}

// mbedtls_pk_free
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 65
void mbedtls_pk_free(mbedtls_pk_context *ctx)
{
  _Bool tmp_if_expr;
  if(ctx == ((mbedtls_pk_context *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ctx->pk_info == ((const mbedtls_pk_info_t *)NULL) ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr)
  {
    ctx->pk_info->ctx_free_func(ctx->pk_ctx);
    mbedtls_zeroize$link11((void *)ctx, sizeof(mbedtls_pk_context) /*16ull*/ );
  }

}

// mbedtls_pk_get_bitlen
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 337
size_t mbedtls_pk_get_bitlen(const mbedtls_pk_context *ctx)
{
  _Bool tmp_if_expr;
  if(ctx == ((const mbedtls_pk_context *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ctx->pk_info == ((const mbedtls_pk_info_t *)NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return 0ull;

  else
  {
    size_t return_value=ctx->pk_info->get_bitlen(ctx->pk_ctx);
    return return_value;
  }
}

// mbedtls_pk_get_name
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 363
const char * mbedtls_pk_get_name(const mbedtls_pk_context *ctx)
{
  _Bool tmp_if_expr;
  if(ctx == ((const mbedtls_pk_context *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ctx->pk_info == ((const mbedtls_pk_info_t *)NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return "invalid PK";

  else
    return ctx->pk_info->name;
}

// mbedtls_pk_get_type
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 374
mbedtls_pk_type_t mbedtls_pk_get_type(const mbedtls_pk_context *ctx)
{
  _Bool tmp_if_expr;
  if(ctx == ((const mbedtls_pk_context *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ctx->pk_info == ((const mbedtls_pk_info_t *)NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return /*enum*/MBEDTLS_PK_NONE;

  else
    return ctx->pk_info->type;
}

// mbedtls_pk_info_from_type
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 78
const mbedtls_pk_info_t * mbedtls_pk_info_from_type(mbedtls_pk_type_t pk_type)
{
  switch((signed int)pk_type)
  {
    case 1:
      return &mbedtls_rsa_info;
    case 2:
      return &mbedtls_eckey_info;
    case 3:
      return &mbedtls_eckeydh_info;
    case 4:
      return &mbedtls_ecdsa_info;
    default:
      return ((const mbedtls_pk_info_t *)NULL);
  }
}

// mbedtls_pk_init
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 53
void mbedtls_pk_init(mbedtls_pk_context *ctx)
{
  if(!(ctx == ((mbedtls_pk_context *)NULL)))
  {
    ctx->pk_info = ((const mbedtls_pk_info_t *)NULL);
    ctx->pk_ctx = NULL;
  }

}

// mbedtls_pk_parse_key
// file ..\..\..\..\lib\third_party\mbedtls\library\pkparse.c line 1149
signed int mbedtls_pk_parse_key(mbedtls_pk_context *pk, const unsigned char *mbedtls_pk_parse_key$$key, size_t keylen, const unsigned char *pwd, size_t pwdlen)
{
  signed int ret;
  const mbedtls_pk_info_t *pk_info;
  size_t len;
  mbedtls_pem_context pem;
  mbedtls_pem_init(&pem);
  _Bool tmp_if_expr;
  if(keylen == 0ull)
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = (signed int)mbedtls_pk_parse_key$$key[(signed long long int)(keylen - 1ull)] != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    ret = -0x1080;

  else
    ret=mbedtls_pem_read_buffer(&pem, "-----BEGIN RSA PRIVATE KEY-----", "-----END RSA PRIVATE KEY-----", mbedtls_pk_parse_key$$key, pwd, pwdlen, &len);
  mbedtls_rsa_context *return_value_mbedtls_pk_rsa;
  if(ret == 0)
  {
    pk_info=mbedtls_pk_info_from_type(/*enum*/MBEDTLS_PK_RSA);
    ret=mbedtls_pk_setup(pk, pk_info);
    _Bool tmp_if_expr$0;
    if(!(ret == 0))
      tmp_if_expr$0 = (_Bool)1;

    else
    {
      return_value_mbedtls_pk_rsa=mbedtls_pk_rsa(*pk);
      ret=pk_parse_key_pkcs1_der(return_value_mbedtls_pk_rsa, pem.buf, pem.buflen);
      tmp_if_expr$0 = ret != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$0)
      mbedtls_pk_free(pk);

    mbedtls_pem_free(&pem);
    return ret;
  }

  else
    if(ret == -4992)
      return -0x3B80;

    else
      if(ret == -4864)
        return -0x3C00;

      else
        if(!(ret == -4224))
          return ret;

  _Bool tmp_if_expr$1;
  if(keylen == 0ull)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)mbedtls_pk_parse_key$$key[(signed long long int)(keylen - 1ull)] != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    ret = -0x1080;

  else
    ret=mbedtls_pem_read_buffer(&pem, "-----BEGIN EC PRIVATE KEY-----", "-----END EC PRIVATE KEY-----", mbedtls_pk_parse_key$$key, pwd, pwdlen, &len);
  mbedtls_ecp_keypair *return_value_mbedtls_pk_ec;
  if(ret == 0)
  {
    pk_info=mbedtls_pk_info_from_type(/*enum*/MBEDTLS_PK_ECKEY);
    ret=mbedtls_pk_setup(pk, pk_info);
    _Bool tmp_if_expr$2;
    if(!(ret == 0))
      tmp_if_expr$2 = (_Bool)1;

    else
    {
      return_value_mbedtls_pk_ec=mbedtls_pk_ec(*pk);
      ret=pk_parse_key_sec1_der(return_value_mbedtls_pk_ec, pem.buf, pem.buflen);
      tmp_if_expr$2 = ret != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$2)
      mbedtls_pk_free(pk);

    mbedtls_pem_free(&pem);
    return ret;
  }

  else
    if(ret == -4992)
      return -0x3B80;

    else
      if(ret == -4864)
        return -0x3C00;

      else
        if(!(ret == -4224))
          return ret;

  _Bool tmp_if_expr$3;
  if(keylen == 0ull)
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = (signed int)mbedtls_pk_parse_key$$key[(signed long long int)(keylen - 1ull)] != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$3)
    ret = -0x1080;

  else
    ret=mbedtls_pem_read_buffer(&pem, "-----BEGIN PRIVATE KEY-----", "-----END PRIVATE KEY-----", mbedtls_pk_parse_key$$key, ((const unsigned char *)NULL), 0ull, &len);
  if(ret == 0)
  {
    ret=pk_parse_key_pkcs8_unencrypted_der(pk, pem.buf, pem.buflen);
    if(!(ret == 0))
      mbedtls_pk_free(pk);

    mbedtls_pem_free(&pem);
    return ret;
  }

  else
    if(!(ret == -4224))
      return ret;

  ret=pk_parse_key_pkcs8_unencrypted_der(pk, mbedtls_pk_parse_key$$key, keylen);
  mbedtls_rsa_context *return_value_mbedtls_pk_rsa$0;
  mbedtls_ecp_keypair *return_value_mbedtls_pk_ec$0;
  if(ret == 0)
    return 0;

  else
  {
    mbedtls_pk_free(pk);
    pk_info=mbedtls_pk_info_from_type(/*enum*/MBEDTLS_PK_RSA);
    ret=mbedtls_pk_setup(pk, pk_info);
    _Bool tmp_if_expr$4;
    if(!(ret == 0))
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value_mbedtls_pk_rsa$0=mbedtls_pk_rsa(*pk);
      ret=pk_parse_key_pkcs1_der(return_value_mbedtls_pk_rsa$0, mbedtls_pk_parse_key$$key, keylen);
      tmp_if_expr$4 = ret != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$4)
      mbedtls_pk_free(pk);

    else
      return 0;
    pk_info=mbedtls_pk_info_from_type(/*enum*/MBEDTLS_PK_ECKEY);
    ret=mbedtls_pk_setup(pk, pk_info);
    _Bool tmp_if_expr$5;
    if(!(ret == 0))
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      return_value_mbedtls_pk_ec$0=mbedtls_pk_ec(*pk);
      ret=pk_parse_key_sec1_der(return_value_mbedtls_pk_ec$0, mbedtls_pk_parse_key$$key, keylen);
      tmp_if_expr$5 = ret != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$5)
      mbedtls_pk_free(pk);

    else
      return 0;
    return -0x3D00;
  }
}

// mbedtls_pk_parse_public_key
// file ..\..\..\..\lib\third_party\mbedtls\library\pkparse.c line 1356
signed int mbedtls_pk_parse_public_key(mbedtls_pk_context *ctx, const unsigned char *mbedtls_pk_parse_public_key$$key, size_t keylen)
{
  signed int ret;
  unsigned char *p;
  const mbedtls_pk_info_t *pk_info;
  size_t len;
  mbedtls_pem_context pem;
  mbedtls_pem_init(&pem);
  _Bool tmp_if_expr;
  if(keylen == 0ull)
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = (signed int)mbedtls_pk_parse_public_key$$key[(signed long long int)(keylen - 1ull)] != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    ret = -0x1080;

  else
    ret=mbedtls_pem_read_buffer(&pem, "-----BEGIN RSA PUBLIC KEY-----", "-----END RSA PUBLIC KEY-----", mbedtls_pk_parse_public_key$$key, ((const unsigned char *)NULL), 0ull, &len);
  if(ret == 0)
  {
    p = pem.buf;
    pk_info=mbedtls_pk_info_from_type(/*enum*/MBEDTLS_PK_RSA);
    if(pk_info == ((const mbedtls_pk_info_t *)NULL))
      return -0x3C80;

    ret=mbedtls_pk_setup(ctx, pk_info);
    if(!(ret == 0))
      return ret;

    mbedtls_rsa_context *return_value_mbedtls_pk_rsa=mbedtls_pk_rsa(*ctx);
    ret=pk_get_rsapubkey(&p, p + (signed long long int)pem.buflen, return_value_mbedtls_pk_rsa);
    if(!(ret == 0))
      mbedtls_pk_free(ctx);

    mbedtls_pem_free(&pem);
    return ret;
  }

  else
    if(!(ret == -4224))
    {
      mbedtls_pem_free(&pem);
      return ret;
    }

  _Bool tmp_if_expr$0;
  if(keylen == 0ull)
    tmp_if_expr$0 = (_Bool)1;

  else
    tmp_if_expr$0 = (signed int)mbedtls_pk_parse_public_key$$key[(signed long long int)(keylen - 1ull)] != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$0)
    ret = -0x1080;

  else
    ret=mbedtls_pem_read_buffer(&pem, "-----BEGIN PUBLIC KEY-----", "-----END PUBLIC KEY-----", mbedtls_pk_parse_public_key$$key, ((const unsigned char *)NULL), 0ull, &len);
  if(ret == 0)
  {
    p = pem.buf;
    ret=mbedtls_pk_parse_subpubkey(&p, p + (signed long long int)pem.buflen, ctx);
    mbedtls_pem_free(&pem);
    return ret;
  }

  else
    if(!(ret == -4224))
    {
      mbedtls_pem_free(&pem);
      return ret;
    }

  mbedtls_pem_free(&pem);
  pk_info=mbedtls_pk_info_from_type(/*enum*/MBEDTLS_PK_RSA);
  if(pk_info == ((const mbedtls_pk_info_t *)NULL))
    return -0x3C80;

  else
  {
    ret=mbedtls_pk_setup(ctx, pk_info);
    if(!(ret == 0))
      return ret;

    else
    {
      p = (unsigned char *)mbedtls_pk_parse_public_key$$key;
      mbedtls_rsa_context *return_value_mbedtls_pk_rsa$0=mbedtls_pk_rsa(*ctx);
      ret=pk_get_rsapubkey(&p, p + (signed long long int)keylen, return_value_mbedtls_pk_rsa$0);
      if(ret == 0)
        return ret;

      else
      {
        mbedtls_pk_free(ctx);
        if(!(ret == -15202))
          return ret;

        else
        {
          p = (unsigned char *)mbedtls_pk_parse_public_key$$key;
          ret=mbedtls_pk_parse_subpubkey(&p, p + (signed long long int)keylen, ctx);
          return ret;
        }
      }
    }
  }
}

// mbedtls_pk_parse_subpubkey
// file ..\..\..\..\lib\third_party\mbedtls\library\pkparse.c line 606
signed int mbedtls_pk_parse_subpubkey(unsigned char **p, const unsigned char *end, mbedtls_pk_context *pk)
{
  signed int ret;
  size_t len;
  mbedtls_asn1_buf alg_params;
  mbedtls_pk_type_t pk_alg=/*enum*/MBEDTLS_PK_NONE;
  const mbedtls_pk_info_t *pk_info;
  ret=mbedtls_asn1_get_tag(p, end, &len, 0x20 | 0x10);
  mbedtls_ecp_keypair *return_value_mbedtls_pk_ec$0;
  if(!(ret == 0))
    return -0x3D00 + ret;

  else
  {
    end = *p + (signed long long int)len;
    ret=pk_get_pk_alg(p, end, &pk_alg, &alg_params);
    if(!(ret == 0))
      return ret;

    else
    {
      ret=mbedtls_asn1_get_bitstring_null(p, end, &len);
      if(!(ret == 0))
        return -0x3B00 + ret;

      else
        if(!(*p + (signed long long int)len == end))
          return -0x3B00 + -0x66;

        else
        {
          pk_info=mbedtls_pk_info_from_type(pk_alg);
          if(pk_info == ((const mbedtls_pk_info_t *)NULL))
            return -0x3C80;

          else
          {
            ret=mbedtls_pk_setup(pk, pk_info);
            if(!(ret == 0))
              return ret;

            else
            {
              if((signed int)pk_alg == 1)
              {
                mbedtls_rsa_context *return_value_mbedtls_pk_rsa=mbedtls_pk_rsa(*pk);
                ret=pk_get_rsapubkey(p, end, return_value_mbedtls_pk_rsa);
              }

              else
                if((signed int)pk_alg == 2 || (signed int)pk_alg == 3)
                {
                  mbedtls_ecp_keypair *return_value_mbedtls_pk_ec=mbedtls_pk_ec(*pk);
                  ret=pk_use_ecparams(&alg_params, &return_value_mbedtls_pk_ec->grp);
                  if(ret == 0)
                  {
                    return_value_mbedtls_pk_ec$0=mbedtls_pk_ec(*pk);
                    ret=pk_get_ecpubkey(p, end, return_value_mbedtls_pk_ec$0);
                  }

                }

                else
                  ret = -0x3C80;
              if(ret == 0)
              {
                if(!(*p == end))
                  ret = -0x3B00 - 0x66;

              }

              if(!(ret == 0))
                mbedtls_pk_free(pk);

              return ret;
            }
          }
        }
    }
  }
}

// mbedtls_pk_rsa
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/pk.h line 141
static inline mbedtls_rsa_context * mbedtls_pk_rsa(const mbedtls_pk_context pk)
{
  return (mbedtls_rsa_context *)pk.pk_ctx;
}

// mbedtls_pk_setup
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 104
signed int mbedtls_pk_setup(mbedtls_pk_context *ctx, const mbedtls_pk_info_t *info)
{
  _Bool tmp_if_expr;
  if(ctx == ((mbedtls_pk_context *)NULL) || info == ((const mbedtls_pk_info_t *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ctx->pk_info != ((const mbedtls_pk_info_t *)NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return -0x3E80;

  else
  {
    ctx->pk_ctx=info->ctx_alloc_func();
    if(ctx->pk_ctx == NULL)
      return -0x3F80;

    else
    {
      ctx->pk_info = info;
      return 0;
    }
  }
}

// mbedtls_pk_setup_rsa_alt
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 121
signed int mbedtls_pk_setup_rsa_alt(mbedtls_pk_context *ctx, void *mbedtls_pk_setup_rsa_alt$$key, mbedtls_pk_rsa_alt_decrypt_func decrypt_func, mbedtls_pk_rsa_alt_sign_func sign_func, mbedtls_pk_rsa_alt_key_len_func key_len_func)
{
  mbedtls_rsa_alt_context *rsa_alt;
  const mbedtls_pk_info_t *info=&mbedtls_rsa_alt_info;
  _Bool tmp_if_expr;
  if(ctx == ((mbedtls_pk_context *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ctx->pk_info != ((const mbedtls_pk_info_t *)NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return -0x3E80;

  else
  {
    ctx->pk_ctx=info->ctx_alloc_func();
    if(ctx->pk_ctx == NULL)
      return -0x3F80;

    else
    {
      ctx->pk_info = info;
      rsa_alt = (mbedtls_rsa_alt_context *)ctx->pk_ctx;
      rsa_alt->key = mbedtls_pk_setup_rsa_alt$$key;
      rsa_alt->decrypt_func = decrypt_func;
      rsa_alt->sign_func = sign_func;
      rsa_alt->key_len_func = key_len_func;
      return 0;
    }
  }
}

// mbedtls_pk_sign
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 256
signed int mbedtls_pk_sign(mbedtls_pk_context *ctx, mbedtls_md_type_t md_alg, const unsigned char *hash, size_t hash_len, unsigned char *sig, size_t *sig_len, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
  _Bool tmp_if_expr;
  if(ctx == ((mbedtls_pk_context *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ctx->pk_info == ((const mbedtls_pk_info_t *)NULL) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$0;
  signed int return_value_pk_hashlen_helper;
  if(tmp_if_expr)
    tmp_if_expr$0 = (_Bool)1;

  else
  {
    return_value_pk_hashlen_helper=pk_hashlen_helper(md_alg, &hash_len);
    tmp_if_expr$0 = return_value_pk_hashlen_helper != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$0)
    return -0x3E80;

  else
    if(ctx->pk_info->sign_func == ((signed int (*)(void *, mbedtls_md_type_t, const unsigned char *, size_t, unsigned char *, size_t *, signed int (*)(void *, unsigned char *, size_t), void *))NULL))
      return -0x3F00;

    else
    {
      signed int return_value=ctx->pk_info->sign_func(ctx->pk_ctx, md_alg, hash, hash_len, sig, sig_len, f_rng, p_rng);
      return return_value;
    }
}

// mbedtls_pk_verify
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 180
signed int mbedtls_pk_verify(mbedtls_pk_context *ctx, mbedtls_md_type_t md_alg, const unsigned char *hash, size_t hash_len, const unsigned char *sig, size_t sig_len)
{
  _Bool tmp_if_expr;
  if(ctx == ((mbedtls_pk_context *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ctx->pk_info == ((const mbedtls_pk_info_t *)NULL) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$0;
  signed int return_value_pk_hashlen_helper;
  if(tmp_if_expr)
    tmp_if_expr$0 = (_Bool)1;

  else
  {
    return_value_pk_hashlen_helper=pk_hashlen_helper(md_alg, &hash_len);
    tmp_if_expr$0 = return_value_pk_hashlen_helper != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$0)
    return -0x3E80;

  else
    if(ctx->pk_info->verify_func == ((signed int (*)(void *, mbedtls_md_type_t, const unsigned char *, size_t, const unsigned char *, size_t))NULL))
      return -0x3F00;

    else
    {
      signed int return_value=ctx->pk_info->verify_func(ctx->pk_ctx, md_alg, hash, hash_len, sig, sig_len);
      return return_value;
    }
}

// mbedtls_pk_verify_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 198
signed int mbedtls_pk_verify_ext(mbedtls_pk_type_t type, const void *options, mbedtls_pk_context *ctx, mbedtls_md_type_t md_alg, const unsigned char *hash, size_t hash_len, const unsigned char *sig, size_t sig_len)
{
  _Bool tmp_if_expr;
  if(ctx == ((mbedtls_pk_context *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ctx->pk_info == ((const mbedtls_pk_info_t *)NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return -0x3E80;

  else
  {
    signed int return_value_mbedtls_pk_can_do=mbedtls_pk_can_do(ctx, type);
    if(return_value_mbedtls_pk_can_do == 0)
      return -0x3F00;

    else
      if((signed int)type == 6)
        return -0x3980;

      else
        if(!(options == NULL))
          return -0x3E80;

        else
        {
          signed int return_value_mbedtls_pk_verify=mbedtls_pk_verify(ctx, md_alg, hash, hash_len, sig, sig_len);
          return return_value_mbedtls_pk_verify;
        }
  }
}

// mbedtls_platform_set_calloc_free
// file ..\..\..\..\lib\third_party\mbedtls\library\platform.c line 64
signed int mbedtls_platform_set_calloc_free(void * (*calloc_func)(size_t, size_t), void (*free_func)(void *))
{
  mbedtls_calloc = calloc_func;
  mbedtls_free = free_func;
  return 0;
}

// mbedtls_platform_set_snprintf
// file ..\..\..\..\lib\third_party\mbedtls\library\platform.c line 122
signed int mbedtls_platform_set_snprintf(signed int (*snprintf_func)(char *, size_t, const char *, ...))
{
  mbedtls_snprintf = snprintf_func;
  return 0;
}

// mbedtls_platform_setup
// file ..\..\..\..\lib\third_party\mbedtls\library\platform.c line 320
signed int mbedtls_platform_setup(mbedtls_platform_context *ctx)
{
  (void)ctx;
  return 0;
}

// mbedtls_platform_teardown
// file ..\..\..\..\lib\third_party\mbedtls\library\platform.c line 330
void mbedtls_platform_teardown(mbedtls_platform_context *ctx)
{
  (void)ctx;
}


// mbedtls_rsa_check_privkey
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 613
signed int mbedtls_rsa_check_privkey(const mbedtls_rsa_context *ctx)
{
  signed int return_value_mbedtls_rsa_check_pubkey=mbedtls_rsa_check_pubkey(ctx);
  _Bool tmp_if_expr;
  signed int return_value_rsa_check_context;
  if(!(return_value_mbedtls_rsa_check_pubkey == 0))
    tmp_if_expr = (_Bool)1;

  else
  {
    return_value_rsa_check_context=rsa_check_context(ctx, 1, 1);
    tmp_if_expr = return_value_rsa_check_context != 0 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_mbedtls_rsa_validate_crt;
  if(tmp_if_expr)
    return -0x4200;

  else
  {
    signed int return_value_mbedtls_rsa_validate_params=mbedtls_rsa_validate_params(&ctx->N, &ctx->P, &ctx->Q, &ctx->D, &ctx->E, ((signed int (*)(void *, unsigned char *, size_t))NULL), NULL);
    if(!(return_value_mbedtls_rsa_validate_params == 0))
      return -0x4200;

    else
    {
      return_value_mbedtls_rsa_validate_crt=mbedtls_rsa_validate_crt(&ctx->P, &ctx->Q, &ctx->D, &ctx->DP, &ctx->DQ, &ctx->QP);
      if(!(return_value_mbedtls_rsa_validate_crt == 0))
        return -0x4200;

    }
    return 0;
  }
}

// mbedtls_rsa_check_pub_priv
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 641
signed int mbedtls_rsa_check_pub_priv(const mbedtls_rsa_context *pub, const mbedtls_rsa_context *prv)
{
  signed int return_value_mbedtls_rsa_check_pubkey=mbedtls_rsa_check_pubkey(pub);
  _Bool tmp_if_expr;
  signed int return_value_mbedtls_rsa_check_privkey;
  if(!(return_value_mbedtls_rsa_check_pubkey == 0))
    tmp_if_expr = (_Bool)1;

  else
  {
    return_value_mbedtls_rsa_check_privkey=mbedtls_rsa_check_privkey(prv);
    tmp_if_expr = return_value_mbedtls_rsa_check_privkey != 0 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_mbedtls_mpi_cmp_mpi$0;
  if(tmp_if_expr)
    return -0x4200;

  else
  {
    signed int return_value_mbedtls_mpi_cmp_mpi=mbedtls_mpi_cmp_mpi(&pub->N, &prv->N);
    _Bool tmp_if_expr$0;
    if(!(return_value_mbedtls_mpi_cmp_mpi == 0))
      tmp_if_expr$0 = (_Bool)1;

    else
    {
      return_value_mbedtls_mpi_cmp_mpi$0=mbedtls_mpi_cmp_mpi(&pub->E, &prv->E);
      tmp_if_expr$0 = return_value_mbedtls_mpi_cmp_mpi$0 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$0)
      return -0x4200;

    else
      return 0;
  }
}

// mbedtls_rsa_check_pubkey
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 590
signed int mbedtls_rsa_check_pubkey(const mbedtls_rsa_context *ctx)
{
  signed int return_value_rsa_check_context=rsa_check_context(ctx, 0, 0);
  size_t return_value_mbedtls_mpi_bitlen$0;
  signed int return_value_mbedtls_mpi_cmp_mpi;
  if(!(return_value_rsa_check_context == 0))
    return -0x4200;

  else
  {
    size_t return_value_mbedtls_mpi_bitlen=mbedtls_mpi_bitlen(&ctx->N);
    if(!(return_value_mbedtls_mpi_bitlen >= 128ull))
      return -0x4200;

    else
    {
      signed int return_value_mbedtls_mpi_get_bit=mbedtls_mpi_get_bit(&ctx->E, 0ull);
      _Bool tmp_if_expr;
      if(return_value_mbedtls_mpi_get_bit == 0)
        tmp_if_expr = (_Bool)1;

      else
      {
        return_value_mbedtls_mpi_bitlen$0=mbedtls_mpi_bitlen(&ctx->E);
        tmp_if_expr = return_value_mbedtls_mpi_bitlen$0 < 2ull ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr$0;
      if(tmp_if_expr)
        tmp_if_expr$0 = (_Bool)1;

      else
      {
        return_value_mbedtls_mpi_cmp_mpi=mbedtls_mpi_cmp_mpi(&ctx->E, &ctx->N);
        tmp_if_expr$0 = return_value_mbedtls_mpi_cmp_mpi >= 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$0)
        return -0x4200;

      else
        return 0;
    }
  }
}

// mbedtls_rsa_complete
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 244
signed int mbedtls_rsa_complete(mbedtls_rsa_context *ctx)
{
  signed int ret=0;
  signed int have_N;
  signed int return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(&ctx->N, 0ll);
  have_N = (const signed int)(return_value_mbedtls_mpi_cmp_int != 0);
  signed int have_P;
  signed int return_value_mbedtls_mpi_cmp_int$0=mbedtls_mpi_cmp_int(&ctx->P, 0ll);
  have_P = (const signed int)(return_value_mbedtls_mpi_cmp_int$0 != 0);
  signed int have_Q;
  signed int return_value_mbedtls_mpi_cmp_int$1=mbedtls_mpi_cmp_int(&ctx->Q, 0ll);
  have_Q = (const signed int)(return_value_mbedtls_mpi_cmp_int$1 != 0);
  signed int have_D;
  signed int return_value_mbedtls_mpi_cmp_int$2=mbedtls_mpi_cmp_int(&ctx->D, 0ll);
  have_D = (const signed int)(return_value_mbedtls_mpi_cmp_int$2 != 0);
  signed int have_E;
  signed int return_value_mbedtls_mpi_cmp_int$3=mbedtls_mpi_cmp_int(&ctx->E, 0ll);
  have_E = (const signed int)(return_value_mbedtls_mpi_cmp_int$3 != 0);
  const signed int n_missing=(const signed int)(have_P != 0 && have_Q != 0 && have_D != 0 && have_E != 0);
  const signed int pq_missing=(const signed int)(have_N != 0 && !(have_P != 0) && !(have_Q != 0) && have_D != 0 && have_E != 0);
  const signed int d_missing=(const signed int)(have_P != 0 && have_Q != 0 && !(have_D != 0) && have_E != 0);
  const signed int is_pub=(const signed int)(have_N != 0 && !(have_P != 0) && !(have_Q != 0) && !(have_D != 0) && have_E != 0);
  const signed int is_priv=(const signed int)(n_missing != 0 || pq_missing != 0 || d_missing != 0);
  if(is_priv == 0 && is_pub == 0)
    return -0x4080;

  else
  {
    if(have_N == 0 && !(have_P == 0) && !(have_Q == 0))
    {
      ret=mbedtls_mpi_mul_mpi(&ctx->N, &ctx->P, &ctx->Q);
      if(!(ret == 0))
        return -0x4080 + ret;

      ctx->len=mbedtls_mpi_size(&ctx->N);
    }

    if(!(pq_missing == 0))
    {
      ret=mbedtls_rsa_deduce_primes(&ctx->N, &ctx->E, &ctx->D, &ctx->P, &ctx->Q);
      if(!(ret == 0))
        return -0x4080 + ret;

    }

    else
      if(!(d_missing == 0))
      {
        ret=mbedtls_rsa_deduce_private_exponent(&ctx->P, &ctx->Q, &ctx->E, &ctx->D);
        if(!(ret == 0))
          return -0x4080 + ret;

      }

    if(!(is_priv == 0))
    {
      ret=mbedtls_rsa_deduce_crt(&ctx->P, &ctx->Q, &ctx->D, &ctx->DP, &ctx->DQ, &ctx->QP);
      if(!(ret == 0))
        return -0x4080 + ret;

    }

    signed int return_value_rsa_check_context=rsa_check_context(ctx, is_priv, 1);
    return return_value_rsa_check_context;
  }
}

// mbedtls_rsa_copy
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 2115
signed int mbedtls_rsa_copy(mbedtls_rsa_context *dst, const mbedtls_rsa_context *src)
{
  signed int ret;
  dst->ver = src->ver;
  dst->len = src->len;
  do
  {
    ret=mbedtls_mpi_copy(&dst->N, &src->N);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_copy(&dst->E, &src->E);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_copy(&dst->D, &src->D);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_copy(&dst->P, &src->P);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_copy(&dst->Q, &src->Q);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_copy(&dst->DP, &src->DP);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_copy(&dst->DQ, &src->DQ);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_copy(&dst->QP, &src->QP);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_copy(&dst->RP, &src->RP);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_copy(&dst->RQ, &src->RQ);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_copy(&dst->RN, &src->RN);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_copy(&dst->Vi, &src->Vi);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_copy(&dst->Vf, &src->Vf);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  dst->padding = src->padding;
  dst->hash_id = src->hash_id;

cleanup:
  ;
  if(!(ret == 0))
    mbedtls_rsa_free(dst);

  return ret;
}

// mbedtls_rsa_deduce_crt
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa_internal.c line 453
signed int mbedtls_rsa_deduce_crt(const mbedtls_mpi *P, const mbedtls_mpi *Q, const mbedtls_mpi *D, mbedtls_mpi *DP, mbedtls_mpi *DQ, mbedtls_mpi *QP)
{
  signed int ret=0;
  mbedtls_mpi mbedtls_rsa_deduce_crt$$1$$K;
  mbedtls_mpi_init(&mbedtls_rsa_deduce_crt$$1$$K);
  if(!(DP == ((mbedtls_mpi *)NULL)))
  {
    do
    {
      ret=mbedtls_mpi_sub_int(&mbedtls_rsa_deduce_crt$$1$$K, P, 1ll);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_mod_mpi(DP, D, &mbedtls_rsa_deduce_crt$$1$$K);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
  }

  if(!(DQ == ((mbedtls_mpi *)NULL)))
  {
    do
    {
      ret=mbedtls_mpi_sub_int(&mbedtls_rsa_deduce_crt$$1$$K, Q, 1ll);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_mod_mpi(DQ, D, &mbedtls_rsa_deduce_crt$$1$$K);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
  }

  if(!(QP == ((mbedtls_mpi *)NULL)))
    do
    {
      ret=mbedtls_mpi_inv_mod(QP, Q, P);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);


cleanup:
  ;
  mbedtls_mpi_free(&mbedtls_rsa_deduce_crt$$1$$K);
  return ret;
}

// mbedtls_rsa_deduce_primes
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa_internal.c line 68
signed int mbedtls_rsa_deduce_primes(const mbedtls_mpi *N, const mbedtls_mpi *E, const mbedtls_mpi *D, mbedtls_mpi *P, mbedtls_mpi *Q)
{
  signed int ret=0;
  uint16_t attempt;
  uint16_t iter;
  uint16_t order;
  mbedtls_mpi T;
  mbedtls_mpi mbedtls_rsa_deduce_primes$$1$$K;
  const unsigned char primes[54ll]={ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251 };
  const size_t num_primes=sizeof(const unsigned char [54ll]) /*54ull*/  / sizeof(const unsigned char) /*1ull*/ ;
  _Bool tmp_if_expr;
  if(P == ((mbedtls_mpi *)NULL) || Q == ((mbedtls_mpi *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = P->p != ((mbedtls_mpi_uint *)NULL) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$0;
  if(tmp_if_expr)
    tmp_if_expr$0 = (_Bool)1;

  else
    tmp_if_expr$0 = Q->p != ((mbedtls_mpi_uint *)NULL) ? (_Bool)1 : (_Bool)0;
  signed int return_value_mbedtls_mpi_cmp_int$0;
  signed int return_value_mbedtls_mpi_cmp_mpi;
  signed int return_value_mbedtls_mpi_cmp_int$1;
  signed int return_value_mbedtls_mpi_cmp_mpi$0;
  signed int return_value_mbedtls_mpi_cmp_mpi$1;
  if(tmp_if_expr$0)
    return -0x4;

  else
  {
    signed int return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(N, 0ll);
    _Bool tmp_if_expr$1;
    if(!(return_value_mbedtls_mpi_cmp_int >= 1))
      tmp_if_expr$1 = (_Bool)1;

    else
    {
      return_value_mbedtls_mpi_cmp_int$0=mbedtls_mpi_cmp_int(D, 1ll);
      tmp_if_expr$1 = return_value_mbedtls_mpi_cmp_int$0 <= 0 ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr$2;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (_Bool)1;

    else
    {
      return_value_mbedtls_mpi_cmp_mpi=mbedtls_mpi_cmp_mpi(D, N);
      tmp_if_expr$2 = return_value_mbedtls_mpi_cmp_mpi >= 0 ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr$3;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      return_value_mbedtls_mpi_cmp_int$1=mbedtls_mpi_cmp_int(E, 1ll);
      tmp_if_expr$3 = return_value_mbedtls_mpi_cmp_int$1 <= 0 ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr$4;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value_mbedtls_mpi_cmp_mpi$0=mbedtls_mpi_cmp_mpi(E, N);
      tmp_if_expr$4 = return_value_mbedtls_mpi_cmp_mpi$0 >= 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$4)
      return -0x4;

    else
    {
      mbedtls_mpi_init(&mbedtls_rsa_deduce_primes$$1$$K);
      mbedtls_mpi_init(&T);
      do
      {
        ret=mbedtls_mpi_mul_mpi(&T, D, E);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_sub_int(&T, &T, 1ll);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      size_t return_value_mbedtls_mpi_lsb=mbedtls_mpi_lsb(&T);
      order = (uint16_t)return_value_mbedtls_mpi_lsb;
      if((signed int)order == 0)
        ret = -0x4;

      else
      {
        do
        {
          ret=mbedtls_mpi_shift_r(&T, (size_t)order);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        attempt = 0;
        if(*N->p % 8ull == 1ull)
          attempt = 1;

        for( ; !((unsigned long long int)attempt >= num_primes); attempt = attempt + 1)
        {
          mbedtls_mpi_lset(&mbedtls_rsa_deduce_primes$$1$$K, (mbedtls_mpi_sint)primes[(signed long long int)attempt]);
          do
          {
            ret=mbedtls_mpi_gcd(P, &mbedtls_rsa_deduce_primes$$1$$K, N);
            if(!(ret == 0))
              goto cleanup;

          }
          while((_Bool)0);
          signed int return_value_mbedtls_mpi_cmp_int$2=mbedtls_mpi_cmp_int(P, 1ll);
          if(return_value_mbedtls_mpi_cmp_int$2 == 0)
          {
            do
            {
              ret=mbedtls_mpi_exp_mod(&mbedtls_rsa_deduce_primes$$1$$K, &mbedtls_rsa_deduce_primes$$1$$K, &T, N, Q);
              if(!(ret == 0))
                goto cleanup;

            }
            while((_Bool)0);
            iter = 1;
            for( ; (signed int)order >= (signed int)iter; iter = iter + 1)
            {
              signed int return_value_mbedtls_mpi_cmp_int$3=mbedtls_mpi_cmp_int(&mbedtls_rsa_deduce_primes$$1$$K, 1ll);
              if(return_value_mbedtls_mpi_cmp_int$3 == 0)
                break;

              do
              {
                ret=mbedtls_mpi_add_int(&mbedtls_rsa_deduce_primes$$1$$K, &mbedtls_rsa_deduce_primes$$1$$K, 1ll);
                if(!(ret == 0))
                  goto cleanup;

              }
              while((_Bool)0);
              do
              {
                ret=mbedtls_mpi_gcd(P, &mbedtls_rsa_deduce_primes$$1$$K, N);
                if(!(ret == 0))
                  goto cleanup;

              }
              while((_Bool)0);
              signed int return_value_mbedtls_mpi_cmp_int$4=mbedtls_mpi_cmp_int(P, 1ll);
              if(return_value_mbedtls_mpi_cmp_int$4 == 1)
              {
                return_value_mbedtls_mpi_cmp_mpi$1=mbedtls_mpi_cmp_mpi(P, N);
                if(return_value_mbedtls_mpi_cmp_mpi$1 == -1)
                {
                  do
                  {
                    ret=mbedtls_mpi_div_mpi(Q, ((mbedtls_mpi *)NULL), N, P);
                    if(!(ret == 0))
                      goto cleanup;

                  }
                  while((_Bool)0);
                  goto cleanup;
                }

              }

              do
              {
                ret=mbedtls_mpi_sub_int(&mbedtls_rsa_deduce_primes$$1$$K, &mbedtls_rsa_deduce_primes$$1$$K, 1ll);
                if(!(ret == 0))
                  goto cleanup;

              }
              while((_Bool)0);
              do
              {
                ret=mbedtls_mpi_mul_mpi(&mbedtls_rsa_deduce_primes$$1$$K, &mbedtls_rsa_deduce_primes$$1$$K, &mbedtls_rsa_deduce_primes$$1$$K);
                if(!(ret == 0))
                  goto cleanup;

              }
              while((_Bool)0);
              do
              {
                ret=mbedtls_mpi_mod_mpi(&mbedtls_rsa_deduce_primes$$1$$K, &mbedtls_rsa_deduce_primes$$1$$K, N);
                if(!(ret == 0))
                  goto cleanup;

              }
              while((_Bool)0);
            }
            signed int return_value_mbedtls_mpi_cmp_int$5=mbedtls_mpi_cmp_int(&mbedtls_rsa_deduce_primes$$1$$K, 1ll);
            if(!(return_value_mbedtls_mpi_cmp_int$5 == 0))
              break;

          }

        }
        ret = -0x4;
      }

    cleanup:
      ;
      mbedtls_mpi_free(&mbedtls_rsa_deduce_primes$$1$$K);
      mbedtls_mpi_free(&T);
      return ret;
    }
  }
}

// mbedtls_rsa_deduce_private_exponent
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa_internal.c line 203
signed int mbedtls_rsa_deduce_private_exponent(const mbedtls_mpi *P, const mbedtls_mpi *Q, const mbedtls_mpi *E, mbedtls_mpi *D)
{
  signed int ret=0;
  mbedtls_mpi mbedtls_rsa_deduce_private_exponent$$1$$K;
  mbedtls_mpi L;
  _Bool tmp_if_expr;
  signed int return_value_mbedtls_mpi_cmp_int;
  if(D == ((mbedtls_mpi *)NULL))
    tmp_if_expr = (_Bool)1;

  else
  {
    return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(D, 0ll);
    tmp_if_expr = return_value_mbedtls_mpi_cmp_int != 0 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_mbedtls_mpi_cmp_int$1;
  signed int return_value_mbedtls_mpi_cmp_int$2;
  if(tmp_if_expr)
    return -0x4;

  else
  {
    signed int return_value_mbedtls_mpi_cmp_int$0=mbedtls_mpi_cmp_int(P, 1ll);
    _Bool tmp_if_expr$0;
    if(!(return_value_mbedtls_mpi_cmp_int$0 >= 1))
      tmp_if_expr$0 = (_Bool)1;

    else
    {
      return_value_mbedtls_mpi_cmp_int$1=mbedtls_mpi_cmp_int(Q, 1ll);
      tmp_if_expr$0 = return_value_mbedtls_mpi_cmp_int$1 <= 0 ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr$1;
    if(tmp_if_expr$0)
      tmp_if_expr$1 = (_Bool)1;

    else
    {
      return_value_mbedtls_mpi_cmp_int$2=mbedtls_mpi_cmp_int(E, 0ll);
      tmp_if_expr$1 = return_value_mbedtls_mpi_cmp_int$2 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$1)
      return -0x4;

    else
    {
      mbedtls_mpi_init(&mbedtls_rsa_deduce_private_exponent$$1$$K);
      mbedtls_mpi_init(&L);
      do
      {
        ret=mbedtls_mpi_sub_int(&mbedtls_rsa_deduce_private_exponent$$1$$K, P, 1ll);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_sub_int(&L, Q, 1ll);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_gcd(D, &mbedtls_rsa_deduce_private_exponent$$1$$K, &L);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_mul_mpi(&mbedtls_rsa_deduce_private_exponent$$1$$K, &mbedtls_rsa_deduce_private_exponent$$1$$K, &L);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_div_mpi(&mbedtls_rsa_deduce_private_exponent$$1$$K, ((mbedtls_mpi *)NULL), &mbedtls_rsa_deduce_private_exponent$$1$$K, D);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_inv_mod(D, E, &mbedtls_rsa_deduce_private_exponent$$1$$K);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);

    cleanup:
      ;
      mbedtls_mpi_free(&mbedtls_rsa_deduce_private_exponent$$1$$K);
      mbedtls_mpi_free(&L);
      return ret;
    }
  }
}

// mbedtls_rsa_export
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 381
signed int mbedtls_rsa_export(const mbedtls_rsa_context *ctx, mbedtls_mpi *N, mbedtls_mpi *P, mbedtls_mpi *Q, mbedtls_mpi *D, mbedtls_mpi *E)
{
  signed int ret;
  signed int is_priv;
  signed int return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(&ctx->N, 0ll);
  _Bool tmp_if_expr;
  signed int return_value_mbedtls_mpi_cmp_int$0;
  if(!(return_value_mbedtls_mpi_cmp_int == 0))
  {
    return_value_mbedtls_mpi_cmp_int$0=mbedtls_mpi_cmp_int(&ctx->P, 0ll);
    tmp_if_expr = return_value_mbedtls_mpi_cmp_int$0 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr = (_Bool)0;
  _Bool tmp_if_expr$0;
  signed int return_value_mbedtls_mpi_cmp_int$1;
  if(tmp_if_expr)
  {
    return_value_mbedtls_mpi_cmp_int$1=mbedtls_mpi_cmp_int(&ctx->Q, 0ll);
    tmp_if_expr$0 = return_value_mbedtls_mpi_cmp_int$1 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$0 = (_Bool)0;
  _Bool tmp_if_expr$1;
  signed int return_value_mbedtls_mpi_cmp_int$2;
  if(tmp_if_expr$0)
  {
    return_value_mbedtls_mpi_cmp_int$2=mbedtls_mpi_cmp_int(&ctx->D, 0ll);
    tmp_if_expr$1 = return_value_mbedtls_mpi_cmp_int$2 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  signed int return_value_mbedtls_mpi_cmp_int$3;
  if(tmp_if_expr$1)
  {
    return_value_mbedtls_mpi_cmp_int$3=mbedtls_mpi_cmp_int(&ctx->E, 0ll);
    tmp_if_expr$2 = return_value_mbedtls_mpi_cmp_int$3 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$2 = (_Bool)0;
  is_priv = (signed int)tmp_if_expr$2;
  if(is_priv == 0)
  {
    if(!(D == ((mbedtls_mpi *)NULL)) || !(P == ((mbedtls_mpi *)NULL)) || !(Q == ((mbedtls_mpi *)NULL)))
      return -0x4080;

  }

  _Bool tmp_if_expr$3;
  if(!(N == ((mbedtls_mpi *)NULL)))
  {
    ret=mbedtls_mpi_copy(N, &ctx->N);
    tmp_if_expr$3 = ret != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  if(tmp_if_expr$3)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    if(!(P == ((mbedtls_mpi *)NULL)))
    {
      ret=mbedtls_mpi_copy(P, &ctx->P);
      tmp_if_expr$4 = ret != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$4 = (_Bool)0;
    tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$6;
  if(tmp_if_expr$5)
    tmp_if_expr$7 = (_Bool)1;

  else
  {
    if(!(Q == ((mbedtls_mpi *)NULL)))
    {
      ret=mbedtls_mpi_copy(Q, &ctx->Q);
      tmp_if_expr$6 = ret != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$6 = (_Bool)0;
    tmp_if_expr$7 = tmp_if_expr$6 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$8;
  if(tmp_if_expr$7)
    tmp_if_expr$9 = (_Bool)1;

  else
  {
    if(!(D == ((mbedtls_mpi *)NULL)))
    {
      ret=mbedtls_mpi_copy(D, &ctx->D);
      tmp_if_expr$8 = ret != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$8 = (_Bool)0;
    tmp_if_expr$9 = tmp_if_expr$8 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$10;
  if(tmp_if_expr$9)
    tmp_if_expr$11 = (_Bool)1;

  else
  {
    if(!(E == ((mbedtls_mpi *)NULL)))
    {
      ret=mbedtls_mpi_copy(E, &ctx->E);
      tmp_if_expr$10 = ret != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$10 = (_Bool)0;
    tmp_if_expr$11 = tmp_if_expr$10 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$11)
    return ret;

  else
    return 0;
}

// mbedtls_rsa_export_crt
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 424
signed int mbedtls_rsa_export_crt(const mbedtls_rsa_context *ctx, mbedtls_mpi *DP, mbedtls_mpi *DQ, mbedtls_mpi *QP)
{
  signed int ret;
  signed int is_priv;
  signed int return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(&ctx->N, 0ll);
  _Bool tmp_if_expr;
  signed int return_value_mbedtls_mpi_cmp_int$0;
  if(!(return_value_mbedtls_mpi_cmp_int == 0))
  {
    return_value_mbedtls_mpi_cmp_int$0=mbedtls_mpi_cmp_int(&ctx->P, 0ll);
    tmp_if_expr = return_value_mbedtls_mpi_cmp_int$0 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr = (_Bool)0;
  _Bool tmp_if_expr$0;
  signed int return_value_mbedtls_mpi_cmp_int$1;
  if(tmp_if_expr)
  {
    return_value_mbedtls_mpi_cmp_int$1=mbedtls_mpi_cmp_int(&ctx->Q, 0ll);
    tmp_if_expr$0 = return_value_mbedtls_mpi_cmp_int$1 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$0 = (_Bool)0;
  _Bool tmp_if_expr$1;
  signed int return_value_mbedtls_mpi_cmp_int$2;
  if(tmp_if_expr$0)
  {
    return_value_mbedtls_mpi_cmp_int$2=mbedtls_mpi_cmp_int(&ctx->D, 0ll);
    tmp_if_expr$1 = return_value_mbedtls_mpi_cmp_int$2 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  signed int return_value_mbedtls_mpi_cmp_int$3;
  if(tmp_if_expr$1)
  {
    return_value_mbedtls_mpi_cmp_int$3=mbedtls_mpi_cmp_int(&ctx->E, 0ll);
    tmp_if_expr$2 = return_value_mbedtls_mpi_cmp_int$3 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$2 = (_Bool)0;
  is_priv = (signed int)tmp_if_expr$2;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$6;
  if(is_priv == 0)
    return -0x4080;

  else
  {
    _Bool tmp_if_expr$3;
    if(!(DP == ((mbedtls_mpi *)NULL)))
    {
      ret=mbedtls_mpi_copy(DP, &ctx->DP);
      tmp_if_expr$3 = ret != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    _Bool tmp_if_expr$5;
    if(tmp_if_expr$3)
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      if(!(DQ == ((mbedtls_mpi *)NULL)))
      {
        ret=mbedtls_mpi_copy(DQ, &ctx->DQ);
        tmp_if_expr$4 = ret != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$4 = (_Bool)0;
      tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr$7;
    if(tmp_if_expr$5)
      tmp_if_expr$7 = (_Bool)1;

    else
    {
      if(!(QP == ((mbedtls_mpi *)NULL)))
      {
        ret=mbedtls_mpi_copy(QP, &ctx->QP);
        tmp_if_expr$6 = ret != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$6 = (_Bool)0;
      tmp_if_expr$7 = tmp_if_expr$6 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$7)
      return -0x4080 + ret;

    else
      return 0;
  }
}

// mbedtls_rsa_export_raw
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 335
signed int mbedtls_rsa_export_raw(const mbedtls_rsa_context *ctx, unsigned char *N, size_t N_len, unsigned char *P, size_t P_len, unsigned char *Q, size_t Q_len, unsigned char *D, size_t D_len, unsigned char *E, size_t E_len)
{
  signed int ret=0;
  signed int is_priv;
  signed int return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(&ctx->N, 0ll);
  _Bool tmp_if_expr;
  signed int return_value_mbedtls_mpi_cmp_int$0;
  if(!(return_value_mbedtls_mpi_cmp_int == 0))
  {
    return_value_mbedtls_mpi_cmp_int$0=mbedtls_mpi_cmp_int(&ctx->P, 0ll);
    tmp_if_expr = return_value_mbedtls_mpi_cmp_int$0 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr = (_Bool)0;
  _Bool tmp_if_expr$0;
  signed int return_value_mbedtls_mpi_cmp_int$1;
  if(tmp_if_expr)
  {
    return_value_mbedtls_mpi_cmp_int$1=mbedtls_mpi_cmp_int(&ctx->Q, 0ll);
    tmp_if_expr$0 = return_value_mbedtls_mpi_cmp_int$1 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$0 = (_Bool)0;
  _Bool tmp_if_expr$1;
  signed int return_value_mbedtls_mpi_cmp_int$2;
  if(tmp_if_expr$0)
  {
    return_value_mbedtls_mpi_cmp_int$2=mbedtls_mpi_cmp_int(&ctx->D, 0ll);
    tmp_if_expr$1 = return_value_mbedtls_mpi_cmp_int$2 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  signed int return_value_mbedtls_mpi_cmp_int$3;
  if(tmp_if_expr$1)
  {
    return_value_mbedtls_mpi_cmp_int$3=mbedtls_mpi_cmp_int(&ctx->E, 0ll);
    tmp_if_expr$2 = return_value_mbedtls_mpi_cmp_int$3 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$2 = (_Bool)0;
  is_priv = (const signed int)tmp_if_expr$2;
  if(is_priv == 0)
  {
    if(!(D == ((unsigned char *)NULL)) || !(P == ((unsigned char *)NULL)) || !(Q == ((unsigned char *)NULL)))
      return -0x4080;

  }

  if(!(N == ((unsigned char *)NULL)))
    do
    {
      ret=mbedtls_mpi_write_binary(&ctx->N, N, N_len);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);

  if(!(P == ((unsigned char *)NULL)))
    do
    {
      ret=mbedtls_mpi_write_binary(&ctx->P, P, P_len);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);

  if(!(Q == ((unsigned char *)NULL)))
    do
    {
      ret=mbedtls_mpi_write_binary(&ctx->Q, Q, Q_len);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);

  if(!(D == ((unsigned char *)NULL)))
    do
    {
      ret=mbedtls_mpi_write_binary(&ctx->D, D, D_len);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);

  if(!(E == ((unsigned char *)NULL)))
    do
    {
      ret=mbedtls_mpi_write_binary(&ctx->E, E, E_len);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);


cleanup:
  ;
  return ret;
}

// mbedtls_rsa_free
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 2155
void mbedtls_rsa_free(mbedtls_rsa_context *ctx)
{
  mbedtls_mpi_free(&ctx->Vi);
  mbedtls_mpi_free(&ctx->Vf);
  mbedtls_mpi_free(&ctx->RN);
  mbedtls_mpi_free(&ctx->D);
  mbedtls_mpi_free(&ctx->Q);
  mbedtls_mpi_free(&ctx->P);
  mbedtls_mpi_free(&ctx->E);
  mbedtls_mpi_free(&ctx->N);
  mbedtls_mpi_free(&ctx->RQ);
  mbedtls_mpi_free(&ctx->RP);
  mbedtls_mpi_free(&ctx->QP);
  mbedtls_mpi_free(&ctx->DQ);
  mbedtls_mpi_free(&ctx->DP);
}

// mbedtls_rsa_gen_key
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 499
signed int mbedtls_rsa_gen_key(mbedtls_rsa_context *ctx, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, unsigned int nbits, signed int exponent)
{
  signed int ret;
  mbedtls_mpi H;
  mbedtls_mpi G;
  signed int return_value_mbedtls_mpi_cmp_int;
  if(f_rng == ((signed int (*)(void *, unsigned char *, size_t))NULL) || !(exponent >= 3) || !(nbits >= 128u))
    return -0x4080;

  else
    if(!(nbits % 2u == 0u))
      return -0x4080;

    else
    {
      mbedtls_mpi_init(&H);
      mbedtls_mpi_init(&G);
      do
      {
        ret=mbedtls_mpi_lset(&ctx->E, (mbedtls_mpi_sint)exponent);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {

      __CPROVER_DUMP_L4:
        ;
        ret=mbedtls_mpi_gen_prime(&ctx->P, (size_t)(nbits >> 1), 0, f_rng, p_rng);
        if(!(ret == 0))
          goto cleanup;

        do
        {
          ret=mbedtls_mpi_gen_prime(&ctx->Q, (size_t)(nbits >> 1), 0, f_rng, p_rng);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        signed int return_value_mbedtls_mpi_cmp_mpi=mbedtls_mpi_cmp_mpi(&ctx->P, &ctx->Q);
        if(!(return_value_mbedtls_mpi_cmp_mpi == 0))
        {
          do
          {
            ret=mbedtls_mpi_mul_mpi(&ctx->N, &ctx->P, &ctx->Q);
            if(!(ret == 0))
              goto cleanup;

          }
          while((_Bool)0);
          size_t return_value_mbedtls_mpi_bitlen=mbedtls_mpi_bitlen(&ctx->N);
          if(return_value_mbedtls_mpi_bitlen == (unsigned long long int)nbits)
          {
            signed int return_value_mbedtls_mpi_cmp_mpi$0=mbedtls_mpi_cmp_mpi(&ctx->P, &ctx->Q);
            if(!(return_value_mbedtls_mpi_cmp_mpi$0 >= 0))
              mbedtls_mpi_swap(&ctx->P, &ctx->Q);

            do
            {
              ret=mbedtls_mpi_sub_int(&ctx->P, &ctx->P, 1ll);
              if(!(ret == 0))
                goto cleanup;

            }
            while((_Bool)0);
            do
            {
              ret=mbedtls_mpi_sub_int(&ctx->Q, &ctx->Q, 1ll);
              if(!(ret == 0))
                goto cleanup;

            }
            while((_Bool)0);
            do
            {
              ret=mbedtls_mpi_mul_mpi(&H, &ctx->P, &ctx->Q);
              if(!(ret == 0))
                goto cleanup;

            }
            while((_Bool)0);
            do
            {
              ret=mbedtls_mpi_gcd(&G, &ctx->E, &H);
              if(!(ret == 0))
                goto cleanup;

            }
            while((_Bool)0);
          }

        }

        return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(&G, 1ll);
      }
      while(!(return_value_mbedtls_mpi_cmp_int == 0));
      do
      {
        ret=mbedtls_mpi_add_int(&ctx->P, &ctx->P, 1ll);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_add_int(&ctx->Q, &ctx->Q, 1ll);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      ctx->len=mbedtls_mpi_size(&ctx->N);
      do
      {
        ret=mbedtls_mpi_inv_mod(&ctx->D, &ctx->E, &H);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_rsa_deduce_crt(&ctx->P, &ctx->Q, &ctx->D, &ctx->DP, &ctx->DQ, &ctx->QP);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_rsa_check_privkey(ctx);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);

    cleanup:
      ;
      mbedtls_mpi_free(&H);
      mbedtls_mpi_free(&G);
      if(!(ret == 0))
      {
        mbedtls_rsa_free(ctx);
        return -0x4180 + ret;
      }

      else
        return 0;
    }
}

// mbedtls_rsa_get_len
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 488
size_t mbedtls_rsa_get_len(const mbedtls_rsa_context *ctx)
{
  return ctx->len;
}

// mbedtls_rsa_import
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 94
signed int mbedtls_rsa_import(mbedtls_rsa_context *ctx, const mbedtls_mpi *N, const mbedtls_mpi *P, const mbedtls_mpi *Q, const mbedtls_mpi *D, const mbedtls_mpi *E)
{
  signed int ret;
  _Bool tmp_if_expr;
  if(!(N == ((const mbedtls_mpi *)NULL)))
  {
    ret=mbedtls_mpi_copy(&ctx->N, N);
    tmp_if_expr = ret != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr = (_Bool)0;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$0;
  if(tmp_if_expr)
    tmp_if_expr$1 = (_Bool)1;

  else
  {
    if(!(P == ((const mbedtls_mpi *)NULL)))
    {
      ret=mbedtls_mpi_copy(&ctx->P, P);
      tmp_if_expr$0 = ret != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$0 = (_Bool)0;
    tmp_if_expr$1 = tmp_if_expr$0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    if(!(Q == ((const mbedtls_mpi *)NULL)))
    {
      ret=mbedtls_mpi_copy(&ctx->Q, Q);
      tmp_if_expr$2 = ret != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
    tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  if(tmp_if_expr$3)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    if(!(D == ((const mbedtls_mpi *)NULL)))
    {
      ret=mbedtls_mpi_copy(&ctx->D, D);
      tmp_if_expr$4 = ret != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$4 = (_Bool)0;
    tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$6;
  if(tmp_if_expr$5)
    tmp_if_expr$7 = (_Bool)1;

  else
  {
    if(!(E == ((const mbedtls_mpi *)NULL)))
    {
      ret=mbedtls_mpi_copy(&ctx->E, E);
      tmp_if_expr$6 = ret != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$6 = (_Bool)0;
    tmp_if_expr$7 = tmp_if_expr$6 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$7)
    return -0x4080 + ret;

  else
  {
    if(!(N == ((const mbedtls_mpi *)NULL)))
      ctx->len=mbedtls_mpi_size(&ctx->N);

    return 0;
  }
}

// mbedtls_rsa_import_raw
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 116
signed int mbedtls_rsa_import_raw(mbedtls_rsa_context *ctx, const unsigned char *N, size_t N_len, const unsigned char *P, size_t P_len, const unsigned char *Q, size_t Q_len, const unsigned char *D, size_t D_len, const unsigned char *E, size_t E_len)
{
  signed int ret=0;
  if(!(N == ((const unsigned char *)NULL)))
  {
    do
    {
      ret=mbedtls_mpi_read_binary(&ctx->N, N, N_len);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    ctx->len=mbedtls_mpi_size(&ctx->N);
  }

  if(!(P == ((const unsigned char *)NULL)))
    do
    {
      ret=mbedtls_mpi_read_binary(&ctx->P, P, P_len);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);

  if(!(Q == ((const unsigned char *)NULL)))
    do
    {
      ret=mbedtls_mpi_read_binary(&ctx->Q, Q, Q_len);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);

  if(!(D == ((const unsigned char *)NULL)))
    do
    {
      ret=mbedtls_mpi_read_binary(&ctx->D, D, D_len);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);

  if(!(E == ((const unsigned char *)NULL)))
    do
    {
      ret=mbedtls_mpi_read_binary(&ctx->E, E, E_len);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);


cleanup:
  ;
  if(!(ret == 0))
    return -0x4080 + ret;

  else
    return 0;
}

// mbedtls_rsa_init
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 462
void mbedtls_rsa_init(mbedtls_rsa_context *ctx, signed int padding, signed int hash_id)
{
  memset((void *)ctx, 0, sizeof(mbedtls_rsa_context) /*336ull*/ );
  mbedtls_rsa_set_padding(ctx, padding, hash_id);
}

// mbedtls_rsa_pkcs1_decrypt
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 1466
signed int mbedtls_rsa_pkcs1_decrypt(mbedtls_rsa_context *ctx, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, signed int mode, size_t *olen, const unsigned char *input, unsigned char *output, size_t output_max_len)
{
  signed int return_value_mbedtls_rsa_rsaes_pkcs1_v15_decrypt;
  if(ctx->padding == 0)
  {
    return_value_mbedtls_rsa_rsaes_pkcs1_v15_decrypt=mbedtls_rsa_rsaes_pkcs1_v15_decrypt(ctx, f_rng, p_rng, mode, olen, input, output, output_max_len);
    return return_value_mbedtls_rsa_rsaes_pkcs1_v15_decrypt;
  }

  else
    return -0x4100;
}

// mbedtls_rsa_pkcs1_encrypt
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 1202
signed int mbedtls_rsa_pkcs1_encrypt(mbedtls_rsa_context *ctx, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, signed int mode, size_t ilen, const unsigned char *input, unsigned char *output)
{
  signed int return_value_mbedtls_rsa_rsaes_pkcs1_v15_encrypt;
  if(ctx->padding == 0)
  {
    return_value_mbedtls_rsa_rsaes_pkcs1_v15_encrypt=mbedtls_rsa_rsaes_pkcs1_v15_encrypt(ctx, f_rng, p_rng, mode, ilen, input, output);
    return return_value_mbedtls_rsa_rsaes_pkcs1_v15_encrypt;
  }

  else
    return -0x4100;
}

// mbedtls_rsa_pkcs1_sign
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 1812
signed int mbedtls_rsa_pkcs1_sign(mbedtls_rsa_context *ctx, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, signed int mode, mbedtls_md_type_t md_alg, unsigned int hashlen, const unsigned char *hash, unsigned char *sig)
{
  signed int return_value_mbedtls_rsa_rsassa_pkcs1_v15_sign;
  if(ctx->padding == 0)
  {
    return_value_mbedtls_rsa_rsassa_pkcs1_v15_sign=mbedtls_rsa_rsassa_pkcs1_v15_sign(ctx, f_rng, p_rng, mode, md_alg, hashlen, hash, sig);
    return return_value_mbedtls_rsa_rsassa_pkcs1_v15_sign;
  }

  else
    return -0x4100;
}

// mbedtls_rsa_pkcs1_verify
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 2084
signed int mbedtls_rsa_pkcs1_verify(mbedtls_rsa_context *ctx, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, signed int mode, mbedtls_md_type_t md_alg, unsigned int hashlen, const unsigned char *hash, const unsigned char *sig)
{
  signed int return_value_mbedtls_rsa_rsassa_pkcs1_v15_verify;
  if(ctx->padding == 0)
  {
    return_value_mbedtls_rsa_rsassa_pkcs1_v15_verify=mbedtls_rsa_rsassa_pkcs1_v15_verify(ctx, f_rng, p_rng, mode, md_alg, hashlen, hash, sig);
    return return_value_mbedtls_rsa_rsassa_pkcs1_v15_verify;
  }

  else
    return -0x4100;
}

// mbedtls_rsa_private
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 770
signed int mbedtls_rsa_private(mbedtls_rsa_context *ctx, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, const unsigned char *input, unsigned char *output)
{
  signed int ret;
  size_t olen;
  mbedtls_mpi T;
  mbedtls_mpi P1;
  mbedtls_mpi Q1;
  mbedtls_mpi R;
  mbedtls_mpi TP;
  mbedtls_mpi TQ;
  mbedtls_mpi DP_blind;
  mbedtls_mpi DQ_blind;
  mbedtls_mpi *DP=&ctx->DP;
  mbedtls_mpi *DQ=&ctx->DQ;
  mbedtls_mpi I;
  mbedtls_mpi C;
  signed int return_value_rsa_check_context=rsa_check_context(ctx, 1, (signed int)(f_rng != ((signed int (*)(void *, unsigned char *, size_t))NULL)));
  signed int return_value_mbedtls_mpi_cmp_mpi$0;
  if(!(return_value_rsa_check_context == 0))
    return -0x4080;

  else
  {
    mbedtls_mpi_init(&T);
    mbedtls_mpi_init(&P1);
    mbedtls_mpi_init(&Q1);
    mbedtls_mpi_init(&R);
    if(!(f_rng == ((signed int (*)(void *, unsigned char *, size_t))NULL)))
    {
      mbedtls_mpi_init(&DP_blind);
      mbedtls_mpi_init(&DQ_blind);
    }

    mbedtls_mpi_init(&TP);
    mbedtls_mpi_init(&TQ);
    mbedtls_mpi_init(&I);
    mbedtls_mpi_init(&C);
    do
    {
      ret=mbedtls_mpi_read_binary(&T, input, ctx->len);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    signed int return_value_mbedtls_mpi_cmp_mpi=mbedtls_mpi_cmp_mpi(&T, &ctx->N);
    if(return_value_mbedtls_mpi_cmp_mpi >= 0)
      ret = -0x4;

    else
    {
      do
      {
        ret=mbedtls_mpi_copy(&I, &T);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      if(!(f_rng == ((signed int (*)(void *, unsigned char *, size_t))NULL)))
      {
        do
        {
          ret=rsa_prepare_blinding(ctx, f_rng, p_rng);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        do
        {
          ret=mbedtls_mpi_mul_mpi(&T, &T, &ctx->Vi);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        do
        {
          ret=mbedtls_mpi_mod_mpi(&T, &T, &ctx->N);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        do
        {
          ret=mbedtls_mpi_sub_int(&P1, &ctx->P, 1ll);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        do
        {
          ret=mbedtls_mpi_sub_int(&Q1, &ctx->Q, 1ll);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        do
        {
          ret=mbedtls_mpi_fill_random(&R, 28ull, f_rng, p_rng);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        do
        {
          ret=mbedtls_mpi_mul_mpi(&DP_blind, &P1, &R);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        do
        {
          ret=mbedtls_mpi_add_mpi(&DP_blind, &DP_blind, &ctx->DP);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        DP = &DP_blind;
        do
        {
          ret=mbedtls_mpi_fill_random(&R, 28ull, f_rng, p_rng);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        do
        {
          ret=mbedtls_mpi_mul_mpi(&DQ_blind, &Q1, &R);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        do
        {
          ret=mbedtls_mpi_add_mpi(&DQ_blind, &DQ_blind, &ctx->DQ);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        DQ = &DQ_blind;
      }

      do
      {
        ret=mbedtls_mpi_exp_mod(&TP, &T, DP, &ctx->P, &ctx->RP);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_exp_mod(&TQ, &T, DQ, &ctx->Q, &ctx->RQ);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_sub_mpi(&T, &TP, &TQ);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_mul_mpi(&TP, &T, &ctx->QP);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_mod_mpi(&T, &TP, &ctx->P);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_mul_mpi(&TP, &T, &ctx->Q);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_add_mpi(&T, &TQ, &TP);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      if(!(f_rng == ((signed int (*)(void *, unsigned char *, size_t))NULL)))
      {
        do
        {
          ret=mbedtls_mpi_mul_mpi(&T, &T, &ctx->Vf);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        do
        {
          ret=mbedtls_mpi_mod_mpi(&T, &T, &ctx->N);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
      }

      do
      {
        ret=mbedtls_mpi_exp_mod(&C, &T, &ctx->E, &ctx->N, &ctx->RN);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      return_value_mbedtls_mpi_cmp_mpi$0=mbedtls_mpi_cmp_mpi(&C, &I);
      if(!(return_value_mbedtls_mpi_cmp_mpi$0 == 0))
        ret = -0x4380;

      else
      {
        olen = ctx->len;
        do
        {
          ret=mbedtls_mpi_write_binary(&T, output, olen);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
      }
    }

  cleanup:
    ;
    mbedtls_mpi_free(&P1);
    mbedtls_mpi_free(&Q1);
    mbedtls_mpi_free(&R);
    if(!(f_rng == ((signed int (*)(void *, unsigned char *, size_t))NULL)))
    {
      mbedtls_mpi_free(&DP_blind);
      mbedtls_mpi_free(&DQ_blind);
    }

    mbedtls_mpi_free(&T);
    mbedtls_mpi_free(&TP);
    mbedtls_mpi_free(&TQ);
    mbedtls_mpi_free(&C);
    mbedtls_mpi_free(&I);
    if(!(ret == 0))
      return -0x4300 + ret;

    else
      return 0;
  }
}

// mbedtls_rsa_public
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 662
signed int mbedtls_rsa_public(mbedtls_rsa_context *ctx, const unsigned char *input, unsigned char *output)
{
  signed int ret;
  size_t olen;
  mbedtls_mpi T;
  signed int return_value_rsa_check_context=rsa_check_context(ctx, 0, 0);
  if(!(return_value_rsa_check_context == 0))
    return -0x4080;

  else
  {
    mbedtls_mpi_init(&T);
    do
    {
      ret=mbedtls_mpi_read_binary(&T, input, ctx->len);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    signed int return_value_mbedtls_mpi_cmp_mpi=mbedtls_mpi_cmp_mpi(&T, &ctx->N);
    if(return_value_mbedtls_mpi_cmp_mpi >= 0)
      ret = -0x4;

    else
    {
      olen = ctx->len;
      do
      {
        ret=mbedtls_mpi_exp_mod(&T, &T, &ctx->E, &ctx->N, &ctx->RN);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_write_binary(&T, output, olen);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
    }

  cleanup:
    ;
    mbedtls_mpi_free(&T);
    if(!(ret == 0))
      return -0x4280 + ret;

    else
      return 0;
  }
}

// mbedtls_rsa_rsaes_pkcs1_v15_decrypt
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 1370
signed int mbedtls_rsa_rsaes_pkcs1_v15_decrypt(mbedtls_rsa_context *ctx, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, signed int mode, size_t *olen, const unsigned char *input, unsigned char *output, size_t output_max_len)
{
  signed int ret;
  size_t ilen;
  size_t pad_count=0ull;
  size_t i;
  unsigned char *p;
  unsigned char bad;
  unsigned char pad_done=0;
  unsigned char buf[1024ll];
  if(mode == 1)
  {
    if(!(ctx->padding == 0))
      return -0x4080;

  }

  ilen = ctx->len;
  signed int return_value_mbedtls_rsa_public;
  signed int return_value_mbedtls_rsa_private;
  unsigned char *tmp_post;
  if(ilen >= 1025ull || !(ilen >= 16ull))
    return -0x4080;

  else
  {
    signed int tmp_if_expr;
    if(mode == 0)
    {
      return_value_mbedtls_rsa_public=mbedtls_rsa_public(ctx, input, buf);
      tmp_if_expr = return_value_mbedtls_rsa_public;
    }

    else
    {
      return_value_mbedtls_rsa_private=mbedtls_rsa_private(ctx, f_rng, p_rng, input, buf);
      tmp_if_expr = return_value_mbedtls_rsa_private;
    }
    ret = tmp_if_expr;
    if(ret == 0)
    {
      p = buf;
      bad = 0;
      tmp_post = p;
      p = p + 1ll;
      bad = bad | *tmp_post;
      if(mode == 1)
      {
        unsigned char *tmp_post$0=p;
        p = p + 1ll;
        bad = bad | (unsigned char)((signed int)*tmp_post$0 ^ 2);
        i = 0ull;
        for( ; !(i >= 18446744073709551613ull + ilen); i = i + 1ull)
        {
          pad_done = pad_done | (unsigned char)(((signed int)p[(signed long long int)i] | (signed int)(unsigned char)-((signed int)p[(signed long long int)i])) >> 7 ^ 1);
          pad_count = pad_count + (size_t)(((signed int)pad_done | (signed int)(unsigned char)-((signed int)pad_done)) >> 7 ^ 1);
        }
        p = p + (signed long long int)pad_count;
        unsigned char *tmp_post$1=p;
        p = p + 1ll;
        bad = bad | *tmp_post$1;
      }

      else
      {
        unsigned char *tmp_post$2=p;
        p = p + 1ll;
        bad = bad | (unsigned char)((signed int)*tmp_post$2 ^ 1);
        i = 0ull;
        for( ; !(i >= 18446744073709551613ull + ilen); i = i + 1ull)
        {
          pad_done = pad_done | (unsigned char)((signed int)p[(signed long long int)i] != 0xFF);
          pad_count = pad_count + (size_t)((signed int)pad_done == 0);
        }
        p = p + (signed long long int)pad_count;
        unsigned char *tmp_post$3=p;
        p = p + 1ll;
        bad = bad | *tmp_post$3;
      }
      bad = bad | (unsigned char)(pad_count < 8ull);
      if(!(bad == 0))
        ret = -0x4100;

      else
        if(!(output_max_len >= ilen + -((unsigned long long int)(p - buf))))
          ret = -0x4400;

        else
        {
          *olen = ilen - (unsigned long long int)(p - buf);
          memcpy((void *)output, (const void *)p, *olen);
          ret = 0;
        }
    }


  cleanup:
    ;
    mbedtls_zeroize$link13((void *)buf, sizeof(unsigned char [1024ll]) /*1024ull*/ );
    return ret;
  }
}

// mbedtls_rsa_rsaes_pkcs1_v15_encrypt
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 1136
signed int mbedtls_rsa_rsaes_pkcs1_v15_encrypt(mbedtls_rsa_context *ctx, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, signed int mode, size_t ilen, const unsigned char *input, unsigned char *output)
{
  size_t nb_pad;
  size_t olen;
  signed int ret;
  unsigned char *p=output;
  if(mode == 1)
  {
    if(!(ctx->padding == 0))
      return -0x4080;

  }

  size_t tmp_post$3;
  unsigned char *tmp_post$4;
  signed int return_value_mbedtls_rsa_public;
  signed int return_value_mbedtls_rsa_private;
  if(f_rng == ((signed int (*)(void *, unsigned char *, size_t))NULL) || input == ((const unsigned char *)NULL) || output == ((unsigned char *)NULL))
    return -0x4080;

  else
  {
    olen = ctx->len;
    if(!(11ull + ilen >= ilen) || !(olen >= 11ull + ilen))
      return -0x4080;

    else
    {
      nb_pad = (olen - 3ull) - ilen;
      unsigned char *tmp_post=p;
      p = p + 1ll;
      *tmp_post = 0;
      if(mode == 0)
      {
        unsigned char *tmp_post$0=p;
        p = p + 1ll;
        *tmp_post$0 = 2;
        size_t tmp_post$1=nb_pad;
        nb_pad = nb_pad - 1ull;
        if(tmp_post$1 >= 1ull)
        {
          signed int rng_dl=100;
          ret=f_rng(p_rng, p, 1ull);
          _Bool tmp_if_expr;
          if((signed int)*p == 0)
          {
            rng_dl = rng_dl - 1;
            tmp_if_expr = rng_dl != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr = (_Bool)0;
          if(rng_dl == 0 || !(ret == 0))
            return -0x4480 + ret;

          p = p + 1ll;
        }

      }

      else
      {
        unsigned char *tmp_post$2=p;
        p = p + 1ll;
        *tmp_post$2 = 1;
        do
        {
          tmp_post$3 = nb_pad;
          nb_pad = nb_pad - 1ull;
          if(!(tmp_post$3 >= 1ull))
            break;

          tmp_post$4 = p;
          p = p + 1ll;
          *tmp_post$4 = 255;
        }
        while((_Bool)1);
      }
      unsigned char *tmp_post$5=p;
      p = p + 1ll;
      *tmp_post$5 = 0;
      memcpy((void *)p, (const void *)input, ilen);
      signed int tmp_if_expr$0;
      if(mode == 0)
      {
        return_value_mbedtls_rsa_public=mbedtls_rsa_public(ctx, output, output);
        tmp_if_expr$0 = return_value_mbedtls_rsa_public;
      }

      else
      {
        return_value_mbedtls_rsa_private=mbedtls_rsa_private(ctx, f_rng, p_rng, output, output);
        tmp_if_expr$0 = return_value_mbedtls_rsa_private;
      }
      return tmp_if_expr$0;
    }
  }
}

// mbedtls_rsa_rsassa_pkcs1_v15_sign
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 1740
signed int mbedtls_rsa_rsassa_pkcs1_v15_sign(mbedtls_rsa_context *ctx, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, signed int mode, mbedtls_md_type_t md_alg, unsigned int hashlen, const unsigned char *hash, unsigned char *sig)
{
  signed int ret;
  unsigned char *sig_try=((unsigned char *)NULL);
  unsigned char *verif=((unsigned char *)NULL);
  if(mode == 1)
  {
    if(!(ctx->padding == 0))
      return -0x4080;

  }

  ret=rsa_rsassa_pkcs1_v15_encode(md_alg, hashlen, hash, ctx->len, sig);
  signed int return_value_mbedtls_safer_memcmp;
  if(!(ret == 0))
    return ret;

  else
    if(mode == 0)
    {
      signed int return_value_mbedtls_rsa_public=mbedtls_rsa_public(ctx, sig, sig);
      return return_value_mbedtls_rsa_public;
    }

    else
    {
      void *return_value=mbedtls_calloc(1ull, ctx->len);
      sig_try = (unsigned char *)return_value;
      if(sig_try == ((unsigned char *)NULL))
        return -0x10;

      else
      {
        void *return_value$0=mbedtls_calloc(1ull, ctx->len);
        verif = (unsigned char *)return_value$0;
        if(verif == ((unsigned char *)NULL))
        {
          mbedtls_free((void *)sig_try);
          return -0x10;
        }

        else
        {
          ret=mbedtls_rsa_private(ctx, f_rng, p_rng, sig, sig_try);
          if(ret == 0)
          {
            ret=mbedtls_rsa_public(ctx, sig_try, verif);
            if(ret == 0)
            {
              return_value_mbedtls_safer_memcmp=mbedtls_safer_memcmp((const void *)verif, (const void *)sig, ctx->len);
              if(!(return_value_mbedtls_safer_memcmp == 0))
                ret = -0x4300;

              else
                memcpy((void *)sig, (const void *)sig_try, ctx->len);
            }

          }


        cleanup:
          ;
          mbedtls_free((void *)sig_try);
          mbedtls_free((void *)verif);
          return ret;
        }
      }
    }
}

// mbedtls_rsa_rsassa_pkcs1_v15_verify
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 2011
signed int mbedtls_rsa_rsassa_pkcs1_v15_verify(mbedtls_rsa_context *ctx, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, signed int mode, mbedtls_md_type_t md_alg, unsigned int hashlen, const unsigned char *hash, const unsigned char *sig)
{
  signed int ret=0;
  const size_t sig_len=ctx->len;
  unsigned char *encoded=((unsigned char *)NULL);
  unsigned char *encoded_expected=((unsigned char *)NULL);
  if(mode == 1)
  {
    if(!(ctx->padding == 0))
      return -0x4080;

  }

  void *return_value=mbedtls_calloc(1ull, sig_len);
  encoded = (unsigned char *)return_value;
  _Bool tmp_if_expr;
  void *return_value$0;
  if(encoded == ((unsigned char *)NULL))
    tmp_if_expr = (_Bool)1;

  else
  {
    return_value$0=mbedtls_calloc(1ull, sig_len);
    encoded_expected = (unsigned char *)return_value$0;
    tmp_if_expr = encoded_expected == ((unsigned char *)NULL) ? (_Bool)1 : (_Bool)0;
  }
  signed int tmp_if_expr$0;
  signed int return_value_mbedtls_rsa_public;
  signed int return_value_mbedtls_rsa_private;
  if(tmp_if_expr)
    ret = -0x10;

  else
  {
    ret=rsa_rsassa_pkcs1_v15_encode(md_alg, hashlen, hash, sig_len, encoded_expected);
    if(ret == 0)
    {
      if(mode == 0)
      {
        return_value_mbedtls_rsa_public=mbedtls_rsa_public(ctx, sig, encoded);
        tmp_if_expr$0 = return_value_mbedtls_rsa_public;
      }

      else
      {
        return_value_mbedtls_rsa_private=mbedtls_rsa_private(ctx, f_rng, p_rng, sig, encoded);
        tmp_if_expr$0 = return_value_mbedtls_rsa_private;
      }
      ret = tmp_if_expr$0;
      if(ret == 0)
      {
        ret=mbedtls_safer_memcmp((const void *)encoded, (const void *)encoded_expected, sig_len);
        if(!(ret == 0))
          ret = -0x4380;

      }

    }

  }

cleanup:
  ;
  if(!(encoded == ((unsigned char *)NULL)))
  {
    mbedtls_zeroize$link13((void *)encoded, sig_len);
    mbedtls_free((void *)encoded);
  }

  if(!(encoded_expected == ((unsigned char *)NULL)))
  {
    mbedtls_zeroize$link13((void *)encoded_expected, sig_len);
    mbedtls_free((void *)encoded_expected);
  }

  return ret;
}

// mbedtls_rsa_self_test
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 2243
signed int mbedtls_rsa_self_test(signed int verbose)
{
  signed int ret=0;
  size_t len;
  mbedtls_rsa_context rsa;
  unsigned char rsa_plaintext[24ll];
  unsigned char rsa_decrypted[24ll];
  unsigned char rsa_ciphertext[128ll];
  unsigned char sha1sum[20ll];
  mbedtls_mpi mbedtls_rsa_self_test$$1$$K;
  mbedtls_mpi_init(&mbedtls_rsa_self_test$$1$$K);
  mbedtls_rsa_init(&rsa, 0, 0);
  do
  {
    ret=mbedtls_mpi_read_string(&mbedtls_rsa_self_test$$1$$K, 16, "9292758453063D803DD603D5E777D7888ED1D5BF35786190FA2F23EBC0848AEADDA92CA6C3D80B32C4D109BE0F36D6AE7130B9CED7ACDF54CFC7555AC14EEBAB93A89813FBF3C4F8066D2D800F7C38A81AE31942917403FF4946B0A83D3D3E05EE57C6F5F5606FB5D4BC6CD34EE0801A5E94BB77B07507233A0BC7BAC8F90F79");
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_rsa_import(&rsa, &mbedtls_rsa_self_test$$1$$K, ((const mbedtls_mpi *)NULL), ((const mbedtls_mpi *)NULL), ((const mbedtls_mpi *)NULL), ((const mbedtls_mpi *)NULL));
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_read_string(&mbedtls_rsa_self_test$$1$$K, 16, "C36D0EB7FCD285223CFB5AABA5BDA3D82C01CAD19EA484A87EA4377637E75500FCB2005C5C7DD6EC4AC023CDA285D796C3D9E75E1EFC42488BB4F1D13AC30A57");
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_rsa_import(&rsa, ((const mbedtls_mpi *)NULL), &mbedtls_rsa_self_test$$1$$K, ((const mbedtls_mpi *)NULL), ((const mbedtls_mpi *)NULL), ((const mbedtls_mpi *)NULL));
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_read_string(&mbedtls_rsa_self_test$$1$$K, 16, "C000DF51A7C77AE8D7C7370C1FF55B69E211C2B9E5DB1ED0BF61D0D9899620F4910E4168387E3C30AA1E00C339A795088452DD96A9A5EA5D9DCA68DA636032AF");
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_rsa_import(&rsa, ((const mbedtls_mpi *)NULL), ((const mbedtls_mpi *)NULL), &mbedtls_rsa_self_test$$1$$K, ((const mbedtls_mpi *)NULL), ((const mbedtls_mpi *)NULL));
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_read_string(&mbedtls_rsa_self_test$$1$$K, 16, "24BF6185468786FDD303083D25E64EFC66CA472BC44D253102F8B4A9D3BFA75091386C0077937FE33FA3252D28855837AE1B484A8A9A45F7EE8C0C634F99E8CDDF79C5CE07EE72C7F123142198164234CABB724CF78B8173B9F880FC86322407AF1FEDFDDE2BEB674CA15F3E81A1521E071513A1E85B5DFA031F21ECAE91A34D");
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_rsa_import(&rsa, ((const mbedtls_mpi *)NULL), ((const mbedtls_mpi *)NULL), ((const mbedtls_mpi *)NULL), &mbedtls_rsa_self_test$$1$$K, ((const mbedtls_mpi *)NULL));
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_read_string(&mbedtls_rsa_self_test$$1$$K, 16, "10001");
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_rsa_import(&rsa, ((const mbedtls_mpi *)NULL), ((const mbedtls_mpi *)NULL), ((const mbedtls_mpi *)NULL), ((const mbedtls_mpi *)NULL), &mbedtls_rsa_self_test$$1$$K);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_rsa_complete(&rsa);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  if(!(verbose == 0))
    printf("  RSA key validation: ");

  signed int return_value_mbedtls_rsa_check_pubkey=mbedtls_rsa_check_pubkey(&rsa);
  _Bool tmp_if_expr;
  signed int return_value_mbedtls_rsa_check_privkey;
  if(!(return_value_mbedtls_rsa_check_pubkey == 0))
    tmp_if_expr = (_Bool)1;

  else
  {
    return_value_mbedtls_rsa_check_privkey=mbedtls_rsa_check_privkey(&rsa);
    tmp_if_expr = return_value_mbedtls_rsa_check_privkey != 0 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_mbedtls_rsa_pkcs1_encrypt;
  signed int return_value_mbedtls_rsa_pkcs1_decrypt;
  signed int return_value_memcmp;
  signed int return_value_mbedtls_sha1_ret;
  signed int return_value_mbedtls_rsa_pkcs1_sign;
  signed int return_value_mbedtls_rsa_pkcs1_verify;
  if(tmp_if_expr)
  {
    if(!(verbose == 0))
      printf("failed\n");

    ret = 1;
  }

  else
  {
    if(!(verbose == 0))
      printf("passed\n  PKCS#1 encryption : ");

    memcpy((void *)rsa_plaintext, (const void *)"\\\\0\\"3\n\v\f", 24ull);
    return_value_mbedtls_rsa_pkcs1_encrypt=mbedtls_rsa_pkcs1_encrypt(&rsa, myrand, NULL, 0, 24ull, rsa_plaintext, rsa_ciphertext);
    if(!(return_value_mbedtls_rsa_pkcs1_encrypt == 0))
    {
      if(!(verbose == 0))
        printf("failed\n");

      ret = 1;
    }

    else
    {
      if(!(verbose == 0))
        printf("passed\n  PKCS#1 decryption : ");

      return_value_mbedtls_rsa_pkcs1_decrypt=mbedtls_rsa_pkcs1_decrypt(&rsa, myrand, NULL, 1, &len, rsa_ciphertext, rsa_decrypted, sizeof(unsigned char [24ll]) /*24ull*/ );
      if(!(return_value_mbedtls_rsa_pkcs1_decrypt == 0))
      {
        if(!(verbose == 0))
          printf("failed\n");

        ret = 1;
      }

      else
      {
        return_value_memcmp=memcmp((const void *)rsa_decrypted, (const void *)rsa_plaintext, len);
        if(!(return_value_memcmp == 0))
        {
          if(!(verbose == 0))
            printf("failed\n");

          ret = 1;
        }

        else
        {
          if(!(verbose == 0))
            printf("passed\n");

          if(!(verbose == 0))
            printf("  PKCS#1 data sign  : ");

          return_value_mbedtls_sha1_ret=mbedtls_sha1_ret(rsa_plaintext, 24ull, sha1sum);
          if(!(return_value_mbedtls_sha1_ret == 0))
          {
            if(!(verbose == 0))
              printf("failed\n");

            return 1;
          }

          return_value_mbedtls_rsa_pkcs1_sign=mbedtls_rsa_pkcs1_sign(&rsa, myrand, NULL, 1, /*enum*/MBEDTLS_MD_SHA1, 0u, sha1sum, rsa_ciphertext);
          if(!(return_value_mbedtls_rsa_pkcs1_sign == 0))
          {
            if(!(verbose == 0))
              printf("failed\n");

            ret = 1;
          }

          else
          {
            if(!(verbose == 0))
              printf("passed\n  PKCS#1 sig. verify: ");

            return_value_mbedtls_rsa_pkcs1_verify=mbedtls_rsa_pkcs1_verify(&rsa, ((signed int (*)(void *, unsigned char *, size_t))NULL), NULL, 0, /*enum*/MBEDTLS_MD_SHA1, 0u, sha1sum, rsa_ciphertext);
            if(!(return_value_mbedtls_rsa_pkcs1_verify == 0))
            {
              if(!(verbose == 0))
                printf("failed\n");

              ret = 1;
            }

            else
            {
              if(!(verbose == 0))
                printf("passed\n");

              if(!(verbose == 0))
                printf("\n");

            }
          }
        }
      }
    }
  }

cleanup:
  ;
  mbedtls_mpi_free(&mbedtls_rsa_self_test$$1$$K);
  mbedtls_rsa_free(&rsa);
  return ret;
}

// mbedtls_rsa_set_padding
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 478
void mbedtls_rsa_set_padding(mbedtls_rsa_context *ctx, signed int padding, signed int hash_id)
{
  ctx->padding = padding;
  ctx->hash_id = hash_id;
}

// mbedtls_rsa_validate_crt
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa_internal.c line 249
signed int mbedtls_rsa_validate_crt(const mbedtls_mpi *P, const mbedtls_mpi *Q, const mbedtls_mpi *D, const mbedtls_mpi *DP, const mbedtls_mpi *DQ, const mbedtls_mpi *QP)
{
  signed int ret=0;
  mbedtls_mpi mbedtls_rsa_validate_crt$$1$$K;
  mbedtls_mpi L;
  mbedtls_mpi_init(&mbedtls_rsa_validate_crt$$1$$K);
  mbedtls_mpi_init(&L);
  if(!(DP == ((const mbedtls_mpi *)NULL)))
  {
    if(P == ((const mbedtls_mpi *)NULL))
    {
      ret = -0x4080;
      goto cleanup;
    }

    do
    {
      ret=mbedtls_mpi_sub_int(&mbedtls_rsa_validate_crt$$1$$K, P, 1ll);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_sub_mpi(&L, DP, D);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_mod_mpi(&L, &L, &mbedtls_rsa_validate_crt$$1$$K);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    signed int return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(&L, 0ll);
    if(!(return_value_mbedtls_mpi_cmp_int == 0))
    {
      ret = -0x4200;
      goto cleanup;
    }

  }

  if(!(DQ == ((const mbedtls_mpi *)NULL)))
  {
    if(Q == ((const mbedtls_mpi *)NULL))
    {
      ret = -0x4080;
      goto cleanup;
    }

    do
    {
      ret=mbedtls_mpi_sub_int(&mbedtls_rsa_validate_crt$$1$$K, Q, 1ll);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_sub_mpi(&L, DQ, D);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_mod_mpi(&L, &L, &mbedtls_rsa_validate_crt$$1$$K);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    signed int return_value_mbedtls_mpi_cmp_int$0=mbedtls_mpi_cmp_int(&L, 0ll);
    if(!(return_value_mbedtls_mpi_cmp_int$0 == 0))
    {
      ret = -0x4200;
      goto cleanup;
    }

  }

  if(!(QP == ((const mbedtls_mpi *)NULL)))
  {
    if(P == ((const mbedtls_mpi *)NULL) || Q == ((const mbedtls_mpi *)NULL))
    {
      ret = -0x4080;
      goto cleanup;
    }

    do
    {
      ret=mbedtls_mpi_mul_mpi(&mbedtls_rsa_validate_crt$$1$$K, QP, Q);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_sub_int(&mbedtls_rsa_validate_crt$$1$$K, &mbedtls_rsa_validate_crt$$1$$K, 1ll);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_mod_mpi(&mbedtls_rsa_validate_crt$$1$$K, &mbedtls_rsa_validate_crt$$1$$K, P);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    signed int return_value_mbedtls_mpi_cmp_int$1=mbedtls_mpi_cmp_int(&mbedtls_rsa_validate_crt$$1$$K, 0ll);
    if(!(return_value_mbedtls_mpi_cmp_int$1 == 0))
    {
      ret = -0x4200;
      goto cleanup;
    }

  }


cleanup:
  ;
  if(!(ret == 0) && !(ret == -16896) && !(ret == -16512))
    ret = ret + -0x4200;

  mbedtls_mpi_free(&mbedtls_rsa_validate_crt$$1$$K);
  mbedtls_mpi_free(&L);
  return ret;
}

// mbedtls_rsa_validate_params
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa_internal.c line 337
signed int mbedtls_rsa_validate_params(const mbedtls_mpi *N, const mbedtls_mpi *P, const mbedtls_mpi *Q, const mbedtls_mpi *D, const mbedtls_mpi *E, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
  signed int ret=0;
  mbedtls_mpi mbedtls_rsa_validate_params$$1$$K;
  mbedtls_mpi L;
  mbedtls_mpi_init(&mbedtls_rsa_validate_params$$1$$K);
  mbedtls_mpi_init(&L);
  if(!(f_rng == ((signed int (*)(void *, unsigned char *, size_t))NULL)) && !(P == ((const mbedtls_mpi *)NULL)))
  {
    ret=mbedtls_mpi_is_prime(P, f_rng, p_rng);
    if(!(ret == 0))
    {
      ret = -0x4200;
      goto cleanup;
    }

  }

  if(!(f_rng == ((signed int (*)(void *, unsigned char *, size_t))NULL)) && !(Q == ((const mbedtls_mpi *)NULL)))
  {
    ret=mbedtls_mpi_is_prime(Q, f_rng, p_rng);
    if(!(ret == 0))
    {
      ret = -0x4200;
      goto cleanup;
    }

  }

  signed int return_value_mbedtls_mpi_cmp_mpi;
  if(!(N == ((const mbedtls_mpi *)NULL)) && !(P == ((const mbedtls_mpi *)NULL)) && !(Q == ((const mbedtls_mpi *)NULL)))
  {
    do
    {
      ret=mbedtls_mpi_mul_mpi(&mbedtls_rsa_validate_params$$1$$K, P, Q);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    signed int return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(N, 1ll);
    _Bool tmp_if_expr;
    if(!(return_value_mbedtls_mpi_cmp_int >= 1))
      tmp_if_expr = (_Bool)1;

    else
    {
      return_value_mbedtls_mpi_cmp_mpi=mbedtls_mpi_cmp_mpi(&mbedtls_rsa_validate_params$$1$$K, N);
      tmp_if_expr = return_value_mbedtls_mpi_cmp_mpi != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr)
    {
      ret = -0x4200;
      goto cleanup;
    }

  }

  signed int return_value_mbedtls_mpi_cmp_int$1;
  signed int return_value_mbedtls_mpi_cmp_mpi$0;
  signed int return_value_mbedtls_mpi_cmp_mpi$1;
  if(!(D == ((const mbedtls_mpi *)NULL)) && !(E == ((const mbedtls_mpi *)NULL)) && !(N == ((const mbedtls_mpi *)NULL)))
  {
    signed int return_value_mbedtls_mpi_cmp_int$0=mbedtls_mpi_cmp_int(D, 1ll);
    _Bool tmp_if_expr$0;
    if(!(return_value_mbedtls_mpi_cmp_int$0 >= 1))
      tmp_if_expr$0 = (_Bool)1;

    else
    {
      return_value_mbedtls_mpi_cmp_int$1=mbedtls_mpi_cmp_int(E, 1ll);
      tmp_if_expr$0 = return_value_mbedtls_mpi_cmp_int$1 <= 0 ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr$1;
    if(tmp_if_expr$0)
      tmp_if_expr$1 = (_Bool)1;

    else
    {
      return_value_mbedtls_mpi_cmp_mpi$0=mbedtls_mpi_cmp_mpi(D, N);
      tmp_if_expr$1 = return_value_mbedtls_mpi_cmp_mpi$0 >= 0 ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr$2;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (_Bool)1;

    else
    {
      return_value_mbedtls_mpi_cmp_mpi$1=mbedtls_mpi_cmp_mpi(E, N);
      tmp_if_expr$2 = return_value_mbedtls_mpi_cmp_mpi$1 >= 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$2)
    {
      ret = -0x4200;
      goto cleanup;
    }

  }

  signed int return_value_mbedtls_mpi_cmp_int$3;
  if(!(D == ((const mbedtls_mpi *)NULL)) && !(E == ((const mbedtls_mpi *)NULL)) && !(P == ((const mbedtls_mpi *)NULL)) && !(Q == ((const mbedtls_mpi *)NULL)))
  {
    signed int return_value_mbedtls_mpi_cmp_int$2=mbedtls_mpi_cmp_int(P, 1ll);
    _Bool tmp_if_expr$3;
    if(!(return_value_mbedtls_mpi_cmp_int$2 >= 1))
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      return_value_mbedtls_mpi_cmp_int$3=mbedtls_mpi_cmp_int(Q, 1ll);
      tmp_if_expr$3 = return_value_mbedtls_mpi_cmp_int$3 <= 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$3)
    {
      ret = -0x4200;
      goto cleanup;
    }

    do
    {
      ret=mbedtls_mpi_mul_mpi(&mbedtls_rsa_validate_params$$1$$K, D, E);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_sub_int(&mbedtls_rsa_validate_params$$1$$K, &mbedtls_rsa_validate_params$$1$$K, 1ll);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_sub_int(&L, P, 1ll);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_mod_mpi(&mbedtls_rsa_validate_params$$1$$K, &mbedtls_rsa_validate_params$$1$$K, &L);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    signed int return_value_mbedtls_mpi_cmp_int$4=mbedtls_mpi_cmp_int(&mbedtls_rsa_validate_params$$1$$K, 0ll);
    if(!(return_value_mbedtls_mpi_cmp_int$4 == 0))
    {
      ret = -0x4200;
      goto cleanup;
    }

    do
    {
      ret=mbedtls_mpi_mul_mpi(&mbedtls_rsa_validate_params$$1$$K, D, E);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_sub_int(&mbedtls_rsa_validate_params$$1$$K, &mbedtls_rsa_validate_params$$1$$K, 1ll);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_sub_int(&L, Q, 1ll);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_mod_mpi(&mbedtls_rsa_validate_params$$1$$K, &mbedtls_rsa_validate_params$$1$$K, &L);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    signed int return_value_mbedtls_mpi_cmp_int$5=mbedtls_mpi_cmp_int(&mbedtls_rsa_validate_params$$1$$K, 0ll);
    if(!(return_value_mbedtls_mpi_cmp_int$5 == 0))
    {
      ret = -0x4200;
      goto cleanup;
    }

  }


cleanup:
  ;
  mbedtls_mpi_free(&mbedtls_rsa_validate_params$$1$$K);
  mbedtls_mpi_free(&L);
  if(!(ret == 0) && !(ret == -16896))
    ret = ret + -0x4200;

  return ret;
}

// mbedtls_safer_memcmp
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 80
static inline signed int mbedtls_safer_memcmp(const void *a, const void *b, size_t n)
{
  size_t i;
  const unsigned char *A=(const unsigned char *)a;
  const unsigned char *B=(const unsigned char *)b;
  unsigned char diff=0;
  i = 0ull;
  for( ; !(i >= n); i = i + 1ull)
    diff = diff | (unsigned char)((signed int)A[(signed long long int)i] ^ (signed int)B[(signed long long int)i]);
  return (signed int)diff;
}

// mbedtls_sha1_clone
// file ..\..\..\..\lib\third_party\mbedtls\library\sha1.c line 91
void mbedtls_sha1_clone(mbedtls_sha1_context *dst, const mbedtls_sha1_context *src)
{
  *dst = *src;
}

// mbedtls_sha1_finish_ret
// file ..\..\..\..\lib\third_party\mbedtls\library\sha1.c line 360
signed int mbedtls_sha1_finish_ret(mbedtls_sha1_context *ctx, unsigned char *output)
{
  signed int ret;
  uint32_t last;
  uint32_t padn;
  uint32_t high;
  uint32_t low;
  unsigned char msglen[8ll];
  high = ctx->total[0ll] >> 29 | ctx->total[1ll] << 3;
  low = ctx->total[0ll] << 3;
  msglen[0ll] = (unsigned char)(high >> 24);
  msglen[(signed long long int)(0 + 1)] = (unsigned char)(high >> 16);
  msglen[(signed long long int)(0 + 2)] = (unsigned char)(high >> 8);
  msglen[(signed long long int)(0 + 3)] = (unsigned char)high;
  msglen[4ll] = (unsigned char)(low >> 24);
  msglen[(signed long long int)(4 + 1)] = (unsigned char)(low >> 16);
  msglen[(signed long long int)(4 + 2)] = (unsigned char)(low >> 8);
  msglen[(signed long long int)(4 + 3)] = (unsigned char)low;
  last = ctx->total[0ll] & 63u;
  padn = last < 56u ? 56u - last : 120u - last;
  ret=mbedtls_sha1_update_ret(ctx, sha1_padding, (size_t)padn);
  if(!(ret == 0))
    return ret;

  else
  {
    ret=mbedtls_sha1_update_ret(ctx, msglen, 8ull);
    if(!(ret == 0))
      return ret;

    else
    {
      output[0ll] = (unsigned char)(ctx->state[0ll] >> 24);
      output[(signed long long int)(0 + 1)] = (unsigned char)(ctx->state[0ll] >> 16);
      output[(signed long long int)(0 + 2)] = (unsigned char)(ctx->state[0ll] >> 8);
      output[(signed long long int)(0 + 3)] = (unsigned char)ctx->state[0ll];
      output[4ll] = (unsigned char)(ctx->state[1ll] >> 24);
      output[(signed long long int)(4 + 1)] = (unsigned char)(ctx->state[1ll] >> 16);
      output[(signed long long int)(4 + 2)] = (unsigned char)(ctx->state[1ll] >> 8);
      output[(signed long long int)(4 + 3)] = (unsigned char)ctx->state[1ll];
      output[8ll] = (unsigned char)(ctx->state[2ll] >> 24);
      output[(signed long long int)(8 + 1)] = (unsigned char)(ctx->state[2ll] >> 16);
      output[(signed long long int)(8 + 2)] = (unsigned char)(ctx->state[2ll] >> 8);
      output[(signed long long int)(8 + 3)] = (unsigned char)ctx->state[2ll];
      output[12ll] = (unsigned char)(ctx->state[3ll] >> 24);
      output[(signed long long int)(12 + 1)] = (unsigned char)(ctx->state[3ll] >> 16);
      output[(signed long long int)(12 + 2)] = (unsigned char)(ctx->state[3ll] >> 8);
      output[(signed long long int)(12 + 3)] = (unsigned char)ctx->state[3ll];
      output[16ll] = (unsigned char)(ctx->state[4ll] >> 24);
      output[(signed long long int)(16 + 1)] = (unsigned char)(ctx->state[4ll] >> 16);
      output[(signed long long int)(16 + 2)] = (unsigned char)(ctx->state[4ll] >> 8);
      output[(signed long long int)(16 + 3)] = (unsigned char)ctx->state[4ll];
      return 0;
    }
  }
}

// mbedtls_sha1_free
// file ..\..\..\..\lib\third_party\mbedtls\library\sha1.c line 83
void mbedtls_sha1_free(mbedtls_sha1_context *ctx)
{
  if(!(ctx == ((mbedtls_sha1_context *)NULL)))
    mbedtls_zeroize$link14((void *)ctx, sizeof(mbedtls_sha1_context) /*92ull*/ );

}

// mbedtls_sha1_init
// file ..\..\..\..\lib\third_party\mbedtls\library\sha1.c line 78
void mbedtls_sha1_init(mbedtls_sha1_context *ctx)
{
  memset((void *)ctx, 0, sizeof(mbedtls_sha1_context) /*92ull*/ );
}

// mbedtls_sha1_ret
// file ..\..\..\..\lib\third_party\mbedtls\library\sha1.c line 405
signed int mbedtls_sha1_ret(const unsigned char *input, size_t ilen, unsigned char *output)
{
  signed int ret;
  mbedtls_sha1_context ctx;
  mbedtls_sha1_init(&ctx);
  ret=mbedtls_sha1_starts_ret(&ctx);
  if(ret == 0)
  {
    ret=mbedtls_sha1_update_ret(&ctx, input, ilen);
    if(ret == 0)
      ret=mbedtls_sha1_finish_ret(&ctx, output);

  }


exit:
  ;
  mbedtls_sha1_free(&ctx);
  return ret;
}

// mbedtls_sha1_self_test
// file ..\..\..\..\lib\third_party\mbedtls\library\sha1.c line 467
signed int mbedtls_sha1_self_test(signed int verbose)
{
  signed int i;
  signed int j;
  signed int buflen;
  signed int ret=0;
  unsigned char buf[1024ll];
  unsigned char sha1sum[20ll];
  mbedtls_sha1_context ctx;
  mbedtls_sha1_init(&ctx);
  i = 0;
  for( ; !(i >= 3); i = i + 1)
  {
    if(!(verbose == 0))
      printf("  SHA-1 test #%d: ", i + 1);

    ret=mbedtls_sha1_starts_ret(&ctx);
    if(!(ret == 0))
      goto fail;

    if(i == 2)
    {
      buflen = 1000;
      memset((void *)buf, 97, (size_t)buflen);
      j = 0;
      for( ; !(j >= 1000); j = j + 1)
      {
        ret=mbedtls_sha1_update_ret(&ctx, buf, (size_t)buflen);
        if(!(ret == 0))
          goto fail;

      }
    }

    else
    {
      ret=mbedtls_sha1_update_ret(&ctx, sha1_test_buf[(signed long long int)i], sha1_test_buflen[(signed long long int)i]);
      if(!(ret == 0))
        goto fail;

    }
    ret=mbedtls_sha1_finish_ret(&ctx, sha1sum);
    if(!(ret == 0))
      goto fail;

    signed int return_value_memcmp=memcmp((const void *)sha1sum, (const void *)sha1_test_sum[(signed long long int)i], 20ull);
    if(!(return_value_memcmp == 0))
    {
      ret = 1;
      goto fail;
    }

    if(!(verbose == 0))
      printf("passed\n");

  }
  if(!(verbose == 0))
    printf("\n");

  goto exit;

fail:
  ;
  if(!(verbose == 0))
    printf("failed\n");


exit:
  ;
  mbedtls_sha1_free(&ctx);
  return ret;
}

// mbedtls_sha1_starts_ret
// file ..\..\..\..\lib\third_party\mbedtls\library\sha1.c line 100
signed int mbedtls_sha1_starts_ret(mbedtls_sha1_context *ctx)
{
  ctx->total[0ll] = 0u;
  ctx->total[1ll] = 0u;
  ctx->state[0ll] = 1732584193u;
  ctx->state[1ll] = 0xEFCDAB89u;
  ctx->state[2ll] = 0x98BADCFEu;
  ctx->state[3ll] = 271733878u;
  ctx->state[4ll] = 0xC3D2E1F0u;
  return 0;
}

// mbedtls_sha1_update_ret
// file ..\..\..\..\lib\third_party\mbedtls\library\sha1.c line 293
signed int mbedtls_sha1_update_ret(mbedtls_sha1_context *ctx, const unsigned char *input, size_t ilen)
{
  signed int ret;
  size_t fill;
  uint32_t left;
  if(ilen == 0ull)
    return 0;

  else
  {
    left = ctx->total[0ll] & 63u;
    fill = (size_t)(64u - left);
    ctx->total[0ll] = ctx->total[0ll] + (uint32_t)ilen;
    ctx->total[0ll] = ctx->total[0ll] & 0xFFFFFFFFu;
    if(!(ctx->total[0ll] >= (uint32_t)ilen))
      ctx->total[1ll] = ctx->total[1ll] + 1u;

    if(ilen >= fill && !(left == 0u))
    {
      memcpy((void *)(ctx->buffer + (signed long long int)left), (const void *)input, fill);
      ret=mbedtls_internal_sha1_process(ctx, ctx->buffer);
      if(!(ret == 0))
        return ret;

      input = input + (signed long long int)fill;
      ilen = ilen - fill;
      left = 0u;
    }

    for( ; ilen >= 64ull; ilen = ilen - 64ull)
    {
      ret=mbedtls_internal_sha1_process(ctx, input);
      if(!(ret == 0))
        return ret;

      input = input + 64ll;
    }
    if(ilen >= 1ull)
      memcpy((void *)(ctx->buffer + (signed long long int)left), (const void *)input, ilen);

    return 0;
  }
}

// mbedtls_sha256_clone
// file ..\..\..\..\lib\third_party\mbedtls\library\sha256.c line 94
void mbedtls_sha256_clone(mbedtls_sha256_context *dst, const mbedtls_sha256_context *src)
{
  *dst = *src;
}

// mbedtls_sha256_finish_ret
// file ..\..\..\..\lib\third_party\mbedtls\library\sha256.c line 329
signed int mbedtls_sha256_finish_ret(mbedtls_sha256_context *ctx, unsigned char *output)
{
  signed int ret;
  uint32_t last;
  uint32_t padn;
  uint32_t high;
  uint32_t low;
  unsigned char msglen[8ll];
  high = ctx->total[0ll] >> 29 | ctx->total[1ll] << 3;
  low = ctx->total[0ll] << 3;
  do
  {
    msglen[0ll] = (unsigned char)(high >> 24);
    msglen[(signed long long int)(0 + 1)] = (unsigned char)(high >> 16);
    msglen[(signed long long int)(0 + 2)] = (unsigned char)(high >> 8);
    msglen[(signed long long int)(0 + 3)] = (unsigned char)high;
  }
  while((_Bool)0);
  do
  {
    msglen[4ll] = (unsigned char)(low >> 24);
    msglen[(signed long long int)(4 + 1)] = (unsigned char)(low >> 16);
    msglen[(signed long long int)(4 + 2)] = (unsigned char)(low >> 8);
    msglen[(signed long long int)(4 + 3)] = (unsigned char)low;
  }
  while((_Bool)0);
  last = ctx->total[0ll] & 63u;
  padn = last < 56u ? 56u - last : 120u - last;
  ret=mbedtls_sha256_update_ret(ctx, sha256_padding, (size_t)padn);
  if(!(ret == 0))
    return ret;

  else
  {
    ret=mbedtls_sha256_update_ret(ctx, msglen, 8ull);
    if(!(ret == 0))
      return ret;

    else
    {
      do
      {
        output[0ll] = (unsigned char)(ctx->state[0ll] >> 24);
        output[(signed long long int)(0 + 1)] = (unsigned char)(ctx->state[0ll] >> 16);
        output[(signed long long int)(0 + 2)] = (unsigned char)(ctx->state[0ll] >> 8);
        output[(signed long long int)(0 + 3)] = (unsigned char)ctx->state[0ll];
      }
      while((_Bool)0);
      do
      {
        output[4ll] = (unsigned char)(ctx->state[1ll] >> 24);
        output[(signed long long int)(4 + 1)] = (unsigned char)(ctx->state[1ll] >> 16);
        output[(signed long long int)(4 + 2)] = (unsigned char)(ctx->state[1ll] >> 8);
        output[(signed long long int)(4 + 3)] = (unsigned char)ctx->state[1ll];
      }
      while((_Bool)0);
      do
      {
        output[8ll] = (unsigned char)(ctx->state[2ll] >> 24);
        output[(signed long long int)(8 + 1)] = (unsigned char)(ctx->state[2ll] >> 16);
        output[(signed long long int)(8 + 2)] = (unsigned char)(ctx->state[2ll] >> 8);
        output[(signed long long int)(8 + 3)] = (unsigned char)ctx->state[2ll];
      }
      while((_Bool)0);
      do
      {
        output[12ll] = (unsigned char)(ctx->state[3ll] >> 24);
        output[(signed long long int)(12 + 1)] = (unsigned char)(ctx->state[3ll] >> 16);
        output[(signed long long int)(12 + 2)] = (unsigned char)(ctx->state[3ll] >> 8);
        output[(signed long long int)(12 + 3)] = (unsigned char)ctx->state[3ll];
      }
      while((_Bool)0);
      do
      {
        output[16ll] = (unsigned char)(ctx->state[4ll] >> 24);
        output[(signed long long int)(16 + 1)] = (unsigned char)(ctx->state[4ll] >> 16);
        output[(signed long long int)(16 + 2)] = (unsigned char)(ctx->state[4ll] >> 8);
        output[(signed long long int)(16 + 3)] = (unsigned char)ctx->state[4ll];
      }
      while((_Bool)0);
      do
      {
        output[20ll] = (unsigned char)(ctx->state[5ll] >> 24);
        output[(signed long long int)(20 + 1)] = (unsigned char)(ctx->state[5ll] >> 16);
        output[(signed long long int)(20 + 2)] = (unsigned char)(ctx->state[5ll] >> 8);
        output[(signed long long int)(20 + 3)] = (unsigned char)ctx->state[5ll];
      }
      while((_Bool)0);
      do
      {
        output[24ll] = (unsigned char)(ctx->state[6ll] >> 24);
        output[(signed long long int)(24 + 1)] = (unsigned char)(ctx->state[6ll] >> 16);
        output[(signed long long int)(24 + 2)] = (unsigned char)(ctx->state[6ll] >> 8);
        output[(signed long long int)(24 + 3)] = (unsigned char)ctx->state[6ll];
      }
      while((_Bool)0);
      if(ctx->is224 == 0)
        do
        {
          output[28ll] = (unsigned char)(ctx->state[7ll] >> 24);
          output[(signed long long int)(28 + 1)] = (unsigned char)(ctx->state[7ll] >> 16);
          output[(signed long long int)(28 + 2)] = (unsigned char)(ctx->state[7ll] >> 8);
          output[(signed long long int)(28 + 3)] = (unsigned char)ctx->state[7ll];
        }
        while((_Bool)0);

      return 0;
    }
  }
}

// mbedtls_sha256_free
// file ..\..\..\..\lib\third_party\mbedtls\library\sha256.c line 86
void mbedtls_sha256_free(mbedtls_sha256_context *ctx)
{
  if(!(ctx == ((mbedtls_sha256_context *)NULL)))
    mbedtls_zeroize$link15((void *)ctx, sizeof(mbedtls_sha256_context) /*108ull*/ );

}

// mbedtls_sha256_init
// file ..\..\..\..\lib\third_party\mbedtls\library\sha256.c line 81
void mbedtls_sha256_init(mbedtls_sha256_context *ctx)
{
  memset((void *)ctx, 0, sizeof(mbedtls_sha256_context) /*108ull*/ );
}

// mbedtls_sha256_ret
// file ..\..\..\..\lib\third_party\mbedtls\library\sha256.c line 380
signed int mbedtls_sha256_ret(const unsigned char *input, size_t ilen, unsigned char *output, signed int is224)
{
  signed int ret;
  mbedtls_sha256_context ctx;
  mbedtls_sha256_init(&ctx);
  ret=mbedtls_sha256_starts_ret(&ctx, is224);
  if(ret == 0)
  {
    ret=mbedtls_sha256_update_ret(&ctx, input, ilen);
    if(ret == 0)
      ret=mbedtls_sha256_finish_ret(&ctx, output);

  }


exit:
  ;
  mbedtls_sha256_free(&ctx);
  return ret;
}

// mbedtls_sha256_self_test
// file ..\..\..\..\lib\third_party\mbedtls\library\sha256.c line 469
signed int mbedtls_sha256_self_test(signed int verbose)
{
  signed int i;
  signed int j;
  signed int k;
  signed int buflen;
  signed int ret=0;
  unsigned char *buf;
  unsigned char sha256sum[32ll];
  mbedtls_sha256_context ctx;
  void *return_value=mbedtls_calloc(1024ull, sizeof(unsigned char) /*1ull*/ );
  buf = (unsigned char *)return_value;
  if(buf == ((unsigned char *)NULL))
  {
    if(!(verbose == 0))
      printf("Buffer allocation failed\n");

    return 1;
  }

  else
  {
    mbedtls_sha256_init(&ctx);
    i = 0;
    if(!(i >= 6))
    {
      j = i % 3;
      k = (signed int)(i < 3);
      if(!(verbose == 0))
        printf("  SHA-%d test #%d: ", 256 - k * 32, j + 1);

      ret=mbedtls_sha256_starts_ret(&ctx, k);
      if(j == 2)
      {
        buflen = 1000;
        memset((void *)buf, 97, (size_t)buflen);
        j = 0;
        if(!(j >= 1000))
        {
          ret=mbedtls_sha256_update_ret(&ctx, buf, (size_t)buflen);
          j = j + 1;
        }

      }

      else
        ret=mbedtls_sha256_update_ret(&ctx, sha256_test_buf[(signed long long int)j], sha256_test_buflen[(signed long long int)j]);
      ret=mbedtls_sha256_finish_ret(&ctx, sha256sum);
      signed int return_value_memcmp=memcmp((const void *)sha256sum, (const void *)sha256_test_sum[(signed long long int)i], (size_t)(32 - k * 4));
      if(!(return_value_memcmp == 0))
        ret = 1;

      if(!(verbose == 0))
        printf("passed\n");

      i = i + 1;
    }

    if(!(verbose == 0))
      printf("\n");


  fail:
    ;
    if(!(verbose == 0))
      printf("failed\n");


  exit:
    ;
    mbedtls_sha256_free(&ctx);
    mbedtls_free((void *)buf);
    return ret;
  }
}

// mbedtls_sha256_starts_ret
// file ..\..\..\..\lib\third_party\mbedtls\library\sha256.c line 103
signed int mbedtls_sha256_starts_ret(mbedtls_sha256_context *ctx, signed int is224)
{
  ctx->total[0ll] = 0u;
  ctx->total[1ll] = 0u;
  if(is224 == 0)
  {
    ctx->state[0ll] = 1779033703u;
    ctx->state[1ll] = 0xBB67AE85u;
    ctx->state[2ll] = 1013904242u;
    ctx->state[3ll] = 0xA54FF53Au;
    ctx->state[4ll] = 1359893119u;
    ctx->state[5ll] = 0x9B05688Cu;
    ctx->state[6ll] = 528734635u;
    ctx->state[7ll] = 1541459225u;
  }

  else
  {
    ctx->state[0ll] = 0xC1059ED8u;
    ctx->state[1ll] = 914150663u;
    ctx->state[2ll] = 812702999u;
    ctx->state[3ll] = 0xF70E5939u;
    ctx->state[4ll] = 0xFFC00B31u;
    ctx->state[5ll] = 1750603025u;
    ctx->state[6ll] = 1694076839u;
    ctx->state[7ll] = 0xBEFA4FA4u;
  }
  ctx->is224 = is224;
  return 0;
}

// mbedtls_sha256_update_ret
// file ..\..\..\..\lib\third_party\mbedtls\library\sha256.c line 262
signed int mbedtls_sha256_update_ret(mbedtls_sha256_context *ctx, const unsigned char *input, size_t ilen)
{
  signed int ret;
  size_t fill;
  uint32_t left;
  if(ilen == 0ull)
    return 0;

  else
  {
    left = ctx->total[0ll] & 63u;
    fill = (size_t)(64u - left);
    ctx->total[0ll] = ctx->total[0ll] + (uint32_t)ilen;
    ctx->total[0ll] = ctx->total[0ll] & 0xFFFFFFFFu;
    if(!(ctx->total[0ll] >= (uint32_t)ilen))
      ctx->total[1ll] = ctx->total[1ll] + 1u;

    if(ilen >= fill && !(left == 0u))
    {
      memcpy((void *)(ctx->buffer + (signed long long int)left), (const void *)input, fill);
      ret=mbedtls_internal_sha256_process(ctx, ctx->buffer);
      if(!(ret == 0))
        return ret;

      input = input + (signed long long int)fill;
      ilen = ilen - fill;
      left = 0u;
    }

    for( ; ilen >= 64ull; ilen = ilen - 64ull)
    {
      ret=mbedtls_internal_sha256_process(ctx, input);
      if(!(ret == 0))
        return ret;

      input = input + 64ll;
    }
    if(ilen >= 1ull)
      memcpy((void *)(ctx->buffer + (signed long long int)left), (const void *)input, ilen);

    return 0;
  }
}

// mbedtls_ssl_check_cert_usage
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 8039
signed int mbedtls_ssl_check_cert_usage(const mbedtls_x509_crt *cert, const mbedtls_ssl_ciphersuite_t *ciphersuite, signed int cert_endpoint, uint32_t *flags)
{
  signed int ret=0;
  signed int usage=0;
  const char *ext_oid;
  size_t ext_len;
  if(cert_endpoint == 1)
    switch((signed int)ciphersuite->key_exchange)
    {
      case 1:

      case 7:
      {
        usage = 0x20;
        goto __CPROVER_DUMP_L5;
      }
      case 2:

      case 3:

      case 4:
      {
        usage = 0x80;
        goto __CPROVER_DUMP_L5;
      }
      case 9:

      case 10:
      {
        usage = 0x8;
        goto __CPROVER_DUMP_L5;
      }
      case 0:

      case 5:

      case 6:

      case 8:

      case 11:
        usage = 0;
      default:

        __CPROVER_DUMP_L5:
          ;
    }

  else
    usage = 0x80;
  signed int return_value_mbedtls_x509_crt_check_key_usage=mbedtls_x509_crt_check_key_usage(cert, (unsigned int)usage);
  if(!(return_value_mbedtls_x509_crt_check_key_usage == 0))
  {
    *flags = *flags | 2048u;
    ret = -1;
  }

  if(cert_endpoint == 1)
  {
    ext_oid = "+\\\\\a\\";
    ext_len = sizeof(char [9ll]) /*9ull*/  - 1ull;
  }

  else
  {
    ext_oid = "+\\\\\a\\";
    ext_len = sizeof(char [9ll]) /*9ull*/  - 1ull;
  }
  signed int return_value_mbedtls_x509_crt_check_extended_key_usage=mbedtls_x509_crt_check_extended_key_usage(cert, ext_oid, ext_len);
  if(!(return_value_mbedtls_x509_crt_check_extended_key_usage == 0))
  {
    *flags = *flags | 4096u;
    ret = -1;
  }

  return ret;
}

// mbedtls_ssl_check_curve
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 8002
signed int mbedtls_ssl_check_curve(const mbedtls_ssl_context *ssl, mbedtls_ecp_group_id grp_id)
{
  const mbedtls_ecp_group_id *gid;
  if(ssl->conf->curve_list == ((const mbedtls_ecp_group_id *)NULL))
    return -1;

  else
  {
    gid = ssl->conf->curve_list;
    for( ; !((signed int)*gid == 0); gid = gid + 1ll)
      if(*gid == grp_id)
        return 0;

    return -1;
  }
}

// mbedtls_ssl_check_pending
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6489
signed int mbedtls_ssl_check_pending(const mbedtls_ssl_context *ssl)
{
  if(ssl->keep_current_message == 1)
  {
    while((_Bool)0)
      ;
    return 1;
  }

  else
  {
    if(ssl->in_hslen >= 1ull)
    {
      if(!(ssl->in_hslen >= ssl->in_msglen))
      {
        while((_Bool)0)
          ;
        return 1;
      }

    }

    if(!(ssl->in_offt == ((unsigned char *)NULL)))
    {
      while((_Bool)0)
        ;
      return 1;
    }

    else
    {
      while((_Bool)0)
        ;
      return 0;
    }
  }
}

// mbedtls_ssl_check_sig_hash
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 8022
signed int mbedtls_ssl_check_sig_hash(const mbedtls_ssl_context *ssl, mbedtls_md_type_t md)
{
  const signed int *cur;
  if(ssl->conf->sig_hashes == ((const signed int *)NULL))
    return -1;

  else
  {
    cur = ssl->conf->sig_hashes;
    for( ; !(*cur == 0); cur = cur + 1ll)
      if(*cur == (signed int)md)
        return 0;

    return -1;
  }
}

// mbedtls_ssl_ciphersuite_cert_req_allowed
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\ssl_ciphersuites.h line 418
static inline signed int mbedtls_ssl_ciphersuite_cert_req_allowed(const mbedtls_ssl_ciphersuite_t *info)
{
  if((signed int)info->key_exchange == 1 || (signed int)info->key_exchange == 2 || (signed int)info->key_exchange == 3 || (signed int)info->key_exchange == 4 || (signed int)info->key_exchange == 9 || (signed int)info->key_exchange == 10)
    return 1;

  else
    return 0;
}

// mbedtls_ssl_ciphersuite_from_id
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_ciphersuites.c line 1759
const mbedtls_ssl_ciphersuite_t * mbedtls_ssl_ciphersuite_from_id(signed int ciphersuite)
{
  const mbedtls_ssl_ciphersuite_t *cur=ciphersuite_definitions;
  for( ; !(cur->id == 0); cur = cur + 1ll)
    if(cur->id == ciphersuite)
      return cur;

  return ((const mbedtls_ssl_ciphersuite_t *)NULL);
}

// mbedtls_ssl_ciphersuite_from_string
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_ciphersuites.c line 1740
const mbedtls_ssl_ciphersuite_t * mbedtls_ssl_ciphersuite_from_string(const char *ciphersuite_name)
{
  const mbedtls_ssl_ciphersuite_t *cur=ciphersuite_definitions;
  if(ciphersuite_name == ((const char *)NULL))
    return ((const mbedtls_ssl_ciphersuite_t *)NULL);

  else
  {
    while(!(cur->id == 0))
    {
      signed int return_value_strcmp=strcmp(cur->name, ciphersuite_name);
      if(return_value_strcmp == 0)
        return cur;

      cur = cur + 1ll;
    }
    return ((const mbedtls_ssl_ciphersuite_t *)NULL);
  }
}

// mbedtls_ssl_ciphersuite_uses_ec
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_ciphersuites.c line 1841
signed int mbedtls_ssl_ciphersuite_uses_ec(const mbedtls_ssl_ciphersuite_t *info)
{
  if((signed int)info->key_exchange == 3 || (signed int)info->key_exchange == 4 || (signed int)info->key_exchange == 8 || (signed int)info->key_exchange == 9 || (signed int)info->key_exchange == 10)
    return 1;

  else
    return 0;
}

// mbedtls_ssl_ciphersuite_uses_server_signature
// file d:\tuttle\freertos\lib\third_party\mbedtls\include\mbedtls\ssl_ciphersuites.h line 467
static inline signed int mbedtls_ssl_ciphersuite_uses_server_signature(const mbedtls_ssl_ciphersuite_t *info)
{
  if((signed int)info->key_exchange == 2 || (signed int)info->key_exchange == 3 || (signed int)info->key_exchange == 4)
    return 1;

  else
    return 0;
}

// mbedtls_ssl_close_notify
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7351
signed int mbedtls_ssl_close_notify(mbedtls_ssl_context *ssl)
{
  signed int ret;
  _Bool tmp_if_expr;
  if(ssl == ((mbedtls_ssl_context *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ssl->conf == ((const mbedtls_ssl_config *)NULL) ? (_Bool)1 : (_Bool)0;
  signed int return_value_mbedtls_ssl_flush_output;
  if(tmp_if_expr)
    return -0x7100;

  else
  {
    while((_Bool)0)
      ;
    if(!(ssl->out_left == 0ull))
    {
      return_value_mbedtls_ssl_flush_output=mbedtls_ssl_flush_output(ssl);
      return return_value_mbedtls_ssl_flush_output;
    }

    else
    {
      if(ssl->state == 16)
      {
        ret=mbedtls_ssl_send_alert_message(ssl, 1, 0);
        if(!(ret == 0))
        {
          while((_Bool)0)
            ;
          return ret;
        }

      }

      while((_Bool)0)
        ;
      return 0;
    }
  }
}

// mbedtls_ssl_conf_alpn_protocols
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6319
signed int mbedtls_ssl_conf_alpn_protocols(mbedtls_ssl_config *conf, const char **protos)
{
  size_t cur_len;
  size_t tot_len;
  const char **p;
  tot_len = 0ull;
  p = protos;
  for( ; !(*p == ((const char *)NULL)); p = p + 1ll)
  {
    cur_len=strlen(*p);
    tot_len = tot_len + cur_len;
    if(cur_len == 0ull || cur_len >= 256ull || tot_len >= 65536ull)
      return -0x7100;

  }
  conf->alpn_list = protos;
  return 0;
}

// mbedtls_ssl_conf_authmode
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5868
void mbedtls_ssl_conf_authmode(mbedtls_ssl_config *conf, signed int authmode)
{
  conf->authmode = (unsigned int)authmode;
}

// mbedtls_ssl_conf_ca_chain
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6030
void mbedtls_ssl_conf_ca_chain(mbedtls_ssl_config *conf, mbedtls_x509_crt *ca_chain, mbedtls_x509_crl *ca_crl)
{
  conf->ca_chain = ca_chain;
  conf->ca_crl = ca_crl;
}

// mbedtls_ssl_conf_cert_profile
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5986
void mbedtls_ssl_conf_cert_profile(mbedtls_ssl_config *conf, const mbedtls_x509_crt_profile *profile)
{
  conf->cert_profile = profile;
}

// mbedtls_ssl_conf_ciphersuites
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5963
void mbedtls_ssl_conf_ciphersuites(mbedtls_ssl_config *conf, const signed int *ciphersuites)
{
  conf->ciphersuite_list[0ll] = ciphersuites;
  conf->ciphersuite_list[1ll] = ciphersuites;
  conf->ciphersuite_list[2ll] = ciphersuites;
  conf->ciphersuite_list[3ll] = ciphersuites;
}

// mbedtls_ssl_conf_ciphersuites_for_version
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5972
void mbedtls_ssl_conf_ciphersuites_for_version(mbedtls_ssl_config *conf, const signed int *ciphersuites, signed int major, signed int minor)
{
  if(major == 3)
  {
    if(!(minor >= 4) && minor >= 0)
      conf->ciphersuite_list[(signed long long int)minor] = ciphersuites;

  }

}

// mbedtls_ssl_conf_curves
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6254
void mbedtls_ssl_conf_curves(mbedtls_ssl_config *conf, const mbedtls_ecp_group_id *curve_list)
{
  conf->curve_list = curve_list;
}

// mbedtls_ssl_conf_dbg
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5891
void mbedtls_ssl_conf_dbg(mbedtls_ssl_config *conf, void (*f_dbg)(void *, signed int, const char *, signed int, const char *), void *p_dbg)
{
  conf->f_dbg = f_dbg;
  conf->p_dbg = p_dbg;
}

// mbedtls_ssl_conf_encrypt_then_mac
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6378
void mbedtls_ssl_conf_encrypt_then_mac(mbedtls_ssl_config *conf, char etm)
{
  conf->encrypt_then_mac = (unsigned int)etm;
}

// mbedtls_ssl_conf_endpoint
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5836
void mbedtls_ssl_conf_endpoint(mbedtls_ssl_config *conf, signed int endpoint)
{
  conf->endpoint = (unsigned int)endpoint;
}

// mbedtls_ssl_conf_extended_master_secret
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6385
void mbedtls_ssl_conf_extended_master_secret(mbedtls_ssl_config *conf, char ems)
{
  conf->extended_ms = (unsigned int)ems;
}

// mbedtls_ssl_conf_legacy_renegotiation
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6427
void mbedtls_ssl_conf_legacy_renegotiation(mbedtls_ssl_config *conf, signed int allow_legacy)
{
  conf->allow_legacy_renegotiation = (unsigned int)allow_legacy;
}

// mbedtls_ssl_conf_max_frag_len
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6399
signed int mbedtls_ssl_conf_max_frag_len(mbedtls_ssl_config *conf, unsigned char mfl_code)
{
  _Bool tmp_if_expr;
  if((signed int)mfl_code >= 5)
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = mfl_code_to_length[(signed long long int)mfl_code] > 8192u ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return -0x7100;

  else
  {
    conf->mfl_code = (unsigned int)mfl_code;
    return 0;
  }
}

// mbedtls_ssl_conf_max_version
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6350
void mbedtls_ssl_conf_max_version(mbedtls_ssl_config *conf, signed int major, signed int minor)
{
  conf->max_major_ver = (unsigned char)major;
  conf->max_minor_ver = (unsigned char)minor;
}

// mbedtls_ssl_conf_min_version
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6356
void mbedtls_ssl_conf_min_version(mbedtls_ssl_config *conf, signed int major, signed int minor)
{
  conf->min_major_ver = (unsigned char)major;
  conf->min_minor_ver = (unsigned char)minor;
}

// mbedtls_ssl_conf_own_cert
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6023
signed int mbedtls_ssl_conf_own_cert(mbedtls_ssl_config *conf, mbedtls_x509_crt *own_cert, mbedtls_pk_context *pk_key)
{
  signed int return_value_ssl_append_key_cert=ssl_append_key_cert(&conf->key_cert, own_cert, pk_key);
  return return_value_ssl_append_key_cert;
}

// mbedtls_ssl_conf_read_timeout
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5911
void mbedtls_ssl_conf_read_timeout(mbedtls_ssl_config *conf, uint32_t timeout)
{
  conf->read_timeout = timeout;
}

// mbedtls_ssl_conf_rng
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5883
void mbedtls_ssl_conf_rng(mbedtls_ssl_config *conf, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
  conf->f_rng = f_rng;
  conf->p_rng = p_rng;
}

// mbedtls_ssl_conf_sig_hashes
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6243
void mbedtls_ssl_conf_sig_hashes(mbedtls_ssl_config *conf, const signed int *hashes)
{
  conf->sig_hashes = hashes;
}

// mbedtls_ssl_conf_sni
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6308
void mbedtls_ssl_conf_sni(mbedtls_ssl_config *conf, signed int (*f_sni)(void *, mbedtls_ssl_context *, const unsigned char *, size_t), void *p_sni)
{
  conf->f_sni = f_sni;
  conf->p_sni = p_sni;
}

// mbedtls_ssl_conf_transport
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5841
void mbedtls_ssl_conf_transport(mbedtls_ssl_config *conf, signed int transport)
{
  conf->transport = (unsigned int)transport;
}

// mbedtls_ssl_conf_verify
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5874
void mbedtls_ssl_conf_verify(mbedtls_ssl_config *conf, signed int (*f_vrfy)(void *, mbedtls_x509_crt *, signed int, uint32_t *), void *p_vrfy)
{
  conf->f_vrfy = f_vrfy;
  conf->p_vrfy = p_vrfy;
}

// mbedtls_ssl_config_defaults
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7637
signed int mbedtls_ssl_config_defaults(mbedtls_ssl_config *conf, signed int endpoint, signed int transport, signed int preset)
{
  mbedtls_ssl_conf_endpoint(conf, endpoint);
  mbedtls_ssl_conf_transport(conf, transport);
  if(endpoint == 0)
    conf->authmode = 2u;

  conf->encrypt_then_mac = 1u;
  conf->extended_ms = 1u;
  if(preset == 2)
  {
    conf->min_major_ver = 3;
    conf->min_minor_ver = 3;
    conf->max_major_ver = 3;
    conf->max_minor_ver = 3;
    conf->ciphersuite_list[3ll] = ssl_preset_suiteb_ciphersuites;
    conf->ciphersuite_list[2ll] = conf->ciphersuite_list[3ll];
    conf->ciphersuite_list[1ll] = conf->ciphersuite_list[2ll];
    conf->ciphersuite_list[0ll] = conf->ciphersuite_list[1ll];
    conf->cert_profile = &mbedtls_x509_crt_profile_suiteb;
    conf->sig_hashes = ssl_preset_suiteb_hashes;
    conf->curve_list = ssl_preset_suiteb_curves;
  }

  else
  {
    conf->min_major_ver = (unsigned char)(3 > 3 ? 3 : 3);
    conf->min_minor_ver = (unsigned char)(3 > 1 ? 3 : 1);
    conf->max_major_ver = 3;
    conf->max_minor_ver = 3;
    conf->ciphersuite_list[3ll]=mbedtls_ssl_list_ciphersuites();
    conf->ciphersuite_list[2ll] = conf->ciphersuite_list[3ll];
    conf->ciphersuite_list[1ll] = conf->ciphersuite_list[2ll];
    conf->ciphersuite_list[0ll] = conf->ciphersuite_list[1ll];
    conf->cert_profile = &mbedtls_x509_crt_profile_default;
    conf->sig_hashes = ssl_preset_default_hashes;
    conf->curve_list=mbedtls_ecp_grp_id_list();
  }
  return 0;
}

// mbedtls_ssl_config_free
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7801
void mbedtls_ssl_config_free(mbedtls_ssl_config *conf)
{
  ssl_key_cert_free(conf->key_cert);
  mbedtls_zeroize$link16((void *)conf, sizeof(mbedtls_ssl_config) /*192ull*/ );
}

// mbedtls_ssl_config_init
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7590
void mbedtls_ssl_config_init(mbedtls_ssl_config *conf)
{
  memset((void *)conf, 0, sizeof(mbedtls_ssl_config) /*192ull*/ );
}

// mbedtls_ssl_derive_keys
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 495
signed int mbedtls_ssl_derive_keys(mbedtls_ssl_context *ssl)
{
  signed int ret=0;
  unsigned char tmp[64ll];
  unsigned char keyblk[256ll];
  unsigned char *key1;
  unsigned char *key2;
  unsigned char *mac_enc;
  unsigned char *mac_dec;
  size_t mac_key_len;
  size_t iv_copy_len;
  const mbedtls_cipher_info_t *cipher_info;
  const mbedtls_md_info_t *md_info;
  mbedtls_ssl_session *session=ssl->session_negotiate;
  mbedtls_ssl_transform *transform=ssl->transform_negotiate;
  mbedtls_ssl_handshake_params *handshake=ssl->handshake;
  while((_Bool)0)
    ;
  cipher_info=mbedtls_cipher_info_from_type(transform->ciphersuite_info->cipher);
  if(cipher_info == ((const mbedtls_cipher_info_t *)NULL))
  {
    while((_Bool)0)
      ;
    return -0x7100;
  }

  else
  {
    md_info=mbedtls_md_info_from_type(transform->ciphersuite_info->mac);
    if(md_info == ((const mbedtls_md_info_t *)NULL))
    {
      while((_Bool)0)
        ;
      return -0x7100;
    }

    else
    {
      if(ssl->minor_ver == 3)
      {
        handshake->tls_prf = tls_prf_sha256;
        handshake->calc_verify = ssl_calc_verify_tls_sha256;
        handshake->calc_finished = ssl_calc_finished_tls_sha256;
      }

      else
      {
        while((_Bool)0)
          ;
        return -0x6C00;
      }
      if(handshake->resume == 0)
      {
        while((_Bool)0)
          ;
        if(ssl->handshake->extended_ms == 1)
        {
          unsigned char session_hash[48ll];
          size_t hash_len;
          while((_Bool)0)
            ;
          ssl->handshake->calc_verify(ssl, session_hash);
          if(ssl->minor_ver == 3)
            hash_len = 32ull;

          else
            hash_len = 36ull;
          ret=handshake->tls_prf(handshake->premaster, handshake->pmslen, "extended master secret", session_hash, hash_len, session->master, 48ull);
          if(!(ret == 0))
            return ret;

        }

        else
          ret=handshake->tls_prf(handshake->premaster, handshake->pmslen, "master secret", handshake->randbytes, 64ull, session->master, 48ull);
        if(!(ret == 0))
          return ret;

        mbedtls_zeroize$link16((void *)handshake->premaster, sizeof(unsigned char [66ll]) /*66ull*/ );
      }

      else
        while((_Bool)0)
          ;
      memcpy((void *)tmp, (const void *)handshake->randbytes, 64ull);
      memcpy((void *)handshake->randbytes, (const void *)(tmp + 32ll), 32ull);
      memcpy((void *)(handshake->randbytes + 32ll), (const void *)tmp, 32ull);
      mbedtls_zeroize$link16((void *)tmp, sizeof(unsigned char [64ll]) /*64ull*/ );
      ret=handshake->tls_prf(session->master, 48ull, "key expansion", handshake->randbytes, 64ull, keyblk, 256ull);
      if(!(ret == 0))
        return ret;

      else
      {
        mbedtls_zeroize$link16((void *)handshake->randbytes, sizeof(unsigned char [64ll]) /*64ull*/ );
        transform->keylen = cipher_info->key_bitlen / 8u;
        _Bool tmp_if_expr$1;
        if((signed int)cipher_info->mode == 6)
          tmp_if_expr$1 = (_Bool)1;

        else
          tmp_if_expr$1 = (signed int)cipher_info->mode == 8 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$1)
        {
          transform->maclen = 0ull;
          mac_key_len = 0ull;
          transform->ivlen = 12ull;
          transform->fixed_ivlen = 4ull;
          transform->minlen = (transform->ivlen - transform->fixed_ivlen) + (unsigned long long int)(((signed int)transform->ciphersuite_info->flags & 0x2) != 0 ? 8 : 16);
        }

        else
        {
          ret=mbedtls_md_setup(&transform->md_ctx_enc, md_info, 1);
          _Bool tmp_if_expr;
          if(!(ret == 0))
            tmp_if_expr = (_Bool)1;

          else
          {
            ret=mbedtls_md_setup(&transform->md_ctx_dec, md_info, 1);
            tmp_if_expr = ret != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr)
            return ret;

          unsigned char return_value_mbedtls_md_get_size=mbedtls_md_get_size(md_info);
          mac_key_len = (size_t)return_value_mbedtls_md_get_size;
          transform->maclen = mac_key_len;
          transform->ivlen = (size_t)cipher_info->iv_size;
          if((signed int)cipher_info->mode == 7)
            transform->minlen = transform->maclen;

          else
          {
            if(session->encrypt_then_mac == 1)
              transform->minlen = transform->maclen + (unsigned long long int)cipher_info->block_size;

            else
              transform->minlen = (transform->maclen + (unsigned long long int)cipher_info->block_size) - transform->maclen % (unsigned long long int)cipher_info->block_size;
            _Bool tmp_if_expr$0;
            if(ssl->minor_ver == 2)
              tmp_if_expr$0 = (_Bool)1;

            else
              tmp_if_expr$0 = ssl->minor_ver == 3 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$0)
              transform->minlen = transform->minlen + transform->ivlen;

            else
              return -0x6C00;
          }
        }
        if((signed int)ssl->conf->endpoint == 0)
        {
          key1 = keyblk + (signed long long int)(mac_key_len * 2ull);
          key2 = keyblk + (signed long long int)(mac_key_len * 2ull) + (signed long long int)transform->keylen;
          mac_enc = keyblk;
          mac_dec = keyblk + (signed long long int)mac_key_len;
          size_t tmp_if_expr$2;
          if(!(transform->fixed_ivlen == 0ull))
            tmp_if_expr$2 = transform->fixed_ivlen;

          else
            tmp_if_expr$2 = transform->ivlen;
          iv_copy_len = tmp_if_expr$2;
          memcpy((void *)transform->iv_enc, (const void *)(key2 + (signed long long int)transform->keylen), iv_copy_len);
          memcpy((void *)transform->iv_dec, (const void *)(key2 + (signed long long int)transform->keylen + (signed long long int)iv_copy_len), iv_copy_len);
        }

        else
          return -0x6C00;
        if(ssl->minor_ver >= 1)
        {
          if(!(mac_key_len == 0ull))
          {
            mbedtls_md_hmac_starts(&transform->md_ctx_enc, mac_enc, mac_key_len);
            mbedtls_md_hmac_starts(&transform->md_ctx_dec, mac_dec, mac_key_len);
          }

        }

        else
          return -0x6C00;
        ret=mbedtls_cipher_setup(&transform->cipher_ctx_enc, cipher_info);
        if(!(ret == 0))
          return ret;

        else
        {
          ret=mbedtls_cipher_setup(&transform->cipher_ctx_dec, cipher_info);
          if(!(ret == 0))
            return ret;

          else
          {
            ret=mbedtls_cipher_setkey(&transform->cipher_ctx_enc, key1, (signed int)cipher_info->key_bitlen, /*enum*/MBEDTLS_ENCRYPT);
            if(!(ret == 0))
              return ret;

            else
            {
              ret=mbedtls_cipher_setkey(&transform->cipher_ctx_dec, key2, (signed int)cipher_info->key_bitlen, /*enum*/MBEDTLS_DECRYPT);
              if(!(ret == 0))
                return ret;

              else
              {
                if((signed int)cipher_info->mode == 2)
                {
                  ret=mbedtls_cipher_set_padding_mode(&transform->cipher_ctx_enc, /*enum*/MBEDTLS_PADDING_NONE);
                  if(!(ret == 0))
                    return ret;

                  ret=mbedtls_cipher_set_padding_mode(&transform->cipher_ctx_dec, /*enum*/MBEDTLS_PADDING_NONE);
                  if(!(ret == 0))
                    return ret;

                }

                mbedtls_zeroize$link16((void *)keyblk, sizeof(unsigned char [256ll]) /*256ull*/ );
                return 0;
              }
            }
          }
        }
      }
    }
  }
}

// mbedtls_ssl_fetch_input
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 2246
signed int mbedtls_ssl_fetch_input(mbedtls_ssl_context *ssl, size_t nb_want)
{
  signed int ret;
  size_t len;
  while((_Bool)0)
    ;
  if(ssl->f_recv == ((mbedtls_ssl_recv_t (*))NULL))
  {
    if(ssl->f_recv_timeout == ((mbedtls_ssl_recv_timeout_t (*))NULL))
    {
      while((_Bool)0)
        ;
      return -0x7100;
    }

  }

  if(!(8509ull + -((size_t)(ssl->in_hdr - ssl->in_buf)) >= nb_want))
  {
    while((_Bool)0)
      ;
    return -0x7100;
  }

  else
  {
    while((_Bool)0)
      ;
    while(!(ssl->in_left >= nb_want))
    {
      len = nb_want - ssl->in_left;
      signed int return_value_ssl_check_timer=ssl_check_timer(ssl);
      if(!(return_value_ssl_check_timer == 0))
        ret = -0x6800;

      else
        if(!(ssl->f_recv_timeout == ((mbedtls_ssl_recv_timeout_t (*))NULL)))
          ret=ssl->f_recv_timeout(ssl->p_bio, ssl->in_hdr + (signed long long int)ssl->in_left, len, ssl->conf->read_timeout);

        else
          ret=ssl->f_recv(ssl->p_bio, ssl->in_hdr + (signed long long int)ssl->in_left, len);
      while((_Bool)0)
        ;
      while((_Bool)0)
        ;
      if(ret == 0)
        return -0x7280;

      if(!(ret >= 0))
        return ret;

      if(!(len >= (size_t)ret))
      {
        while((_Bool)0)
          ;
        return -0x6C00;
      }

      ssl->in_left = ssl->in_left + (size_t)ret;
    }
    while((_Bool)0)
      ;
    return 0;
  }
}

// mbedtls_ssl_flush_output
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 2465
signed int mbedtls_ssl_flush_output(mbedtls_ssl_context *ssl)
{
  signed int ret;
  unsigned char *buf;
  unsigned char i;
  while((_Bool)0)
    ;
  size_t return_value_ssl_ep_len;
  if(ssl->f_send == ((mbedtls_ssl_send_t (*))NULL))
  {
    while((_Bool)0)
      ;
    return -0x7100;
  }

  else
    if(ssl->out_left == 0ull)
    {
      while((_Bool)0)
        ;
      return 0;
    }

    else
    {
      if(ssl->out_left >= 1ull)
      {
        while((_Bool)0)
          ;
        size_t return_value_mbedtls_ssl_hdr_len=mbedtls_ssl_hdr_len(ssl);
        buf = (ssl->out_hdr + (signed long long int)return_value_mbedtls_ssl_hdr_len + (signed long long int)ssl->out_msglen) - (signed long long int)ssl->out_left;
        ret=ssl->f_send(ssl->p_bio, buf, ssl->out_left);
        if(!(ret >= 1))
          return ret;

        if(!(ssl->out_left >= (size_t)ret))
          return -0x6C00;

        ssl->out_left = ssl->out_left - (size_t)ret;
      }

      i = 8;
      do
      {
        return_value_ssl_ep_len=ssl_ep_len(ssl);
        if(return_value_ssl_ep_len >= (unsigned long long int)i)
          break;

        ssl->out_ctr[(signed long long int)((signed int)i - 1)] = ssl->out_ctr[(signed long long int)((signed int)i - 1)] + 1;
        if(!((signed int)ssl->out_ctr[(signed long long int)(-1 + (signed int)i)] == 0))
          break;

        i = i - 1;
      }
      while((_Bool)1);
      size_t return_value_ssl_ep_len$0=ssl_ep_len(ssl);
      if((unsigned long long int)i == return_value_ssl_ep_len$0)
      {
        while((_Bool)0)
          ;
        return -0x6B80;
      }

      else
      {
        while((_Bool)0)
          ;
        return 0;
      }
    }
}

// mbedtls_ssl_free
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7511
void mbedtls_ssl_free(mbedtls_ssl_context *ssl)
{
  if(!(ssl == ((mbedtls_ssl_context *)NULL)))
  {
    while((_Bool)0)
      ;
    if(!(ssl->out_buf == ((unsigned char *)NULL)))
    {
      mbedtls_zeroize$link16((void *)ssl->out_buf, (size_t)(13 + 8192 + 0 + 16 + 32 + 256));
      mbedtls_free((void *)ssl->out_buf);
    }

    if(!(ssl->in_buf == ((unsigned char *)NULL)))
    {
      mbedtls_zeroize$link16((void *)ssl->in_buf, (size_t)(13 + 8192 + 0 + 16 + 32 + 256));
      mbedtls_free((void *)ssl->in_buf);
    }

    if(!(ssl->transform == ((mbedtls_ssl_transform *)NULL)))
    {
      mbedtls_ssl_transform_free(ssl->transform);
      mbedtls_free((void *)ssl->transform);
    }

    if(!(ssl->handshake == ((mbedtls_ssl_handshake_params *)NULL)))
    {
      mbedtls_ssl_handshake_free(ssl->handshake);
      mbedtls_ssl_transform_free(ssl->transform_negotiate);
      mbedtls_ssl_session_free(ssl->session_negotiate);
      mbedtls_free((void *)ssl->handshake);
      mbedtls_free((void *)ssl->transform_negotiate);
      mbedtls_free((void *)ssl->session_negotiate);
    }

    if(!(ssl->session == ((mbedtls_ssl_session *)NULL)))
    {
      mbedtls_ssl_session_free(ssl->session);
      mbedtls_free((void *)ssl->session);
    }

    if(!(ssl->hostname == ((char *)NULL)))
    {
      size_t return_value_strlen=strlen(ssl->hostname);
      mbedtls_zeroize$link16((void *)ssl->hostname, return_value_strlen);
      mbedtls_free((void *)ssl->hostname);
    }

    while((_Bool)0)
      ;
    mbedtls_zeroize$link16((void *)ssl, sizeof(mbedtls_ssl_context) /*352ull*/ );
  }

}

// mbedtls_ssl_get_alpn_protocol
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6344
const char * mbedtls_ssl_get_alpn_protocol(const mbedtls_ssl_context *ssl)
{
  return ssl->alpn_chosen;
}

// mbedtls_ssl_get_bytes_avail
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6484
size_t mbedtls_ssl_get_bytes_avail(const mbedtls_ssl_context *ssl)
{
  unsigned long long int tmp_if_expr;
  if(ssl->in_offt == ((unsigned char *)NULL))
    tmp_if_expr = 0ull;

  else
    tmp_if_expr = ssl->in_msglen;
  return tmp_if_expr;
}

// mbedtls_ssl_get_ciphersuite
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6555
const char * mbedtls_ssl_get_ciphersuite(const mbedtls_ssl_context *ssl)
{
  _Bool tmp_if_expr;
  if(ssl == ((const mbedtls_ssl_context *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ssl->session == ((mbedtls_ssl_session *)NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return ((const char *)NULL);

  else
  {
    const char *return_value_mbedtls_ssl_get_ciphersuite_name=mbedtls_ssl_get_ciphersuite_name(ssl->session->ciphersuite);
    return return_value_mbedtls_ssl_get_ciphersuite_name;
  }
}

// mbedtls_ssl_get_ciphersuite_id
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_ciphersuites.c line 1786
signed int mbedtls_ssl_get_ciphersuite_id(const char *ciphersuite_name)
{
  const mbedtls_ssl_ciphersuite_t *cur=mbedtls_ssl_ciphersuite_from_string(ciphersuite_name);
  if(cur == ((const mbedtls_ssl_ciphersuite_t *)NULL))
    return 0;

  else
    return cur->id;
}

// mbedtls_ssl_get_ciphersuite_name
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_ciphersuites.c line 1774
const char * mbedtls_ssl_get_ciphersuite_name(const signed int ciphersuite_id)
{
  const mbedtls_ssl_ciphersuite_t *cur=mbedtls_ssl_ciphersuite_from_id(ciphersuite_id);
  if(cur == ((const mbedtls_ssl_ciphersuite_t *)NULL))
    return "unknown";

  else
    return cur->name;
}

// mbedtls_ssl_get_ciphersuite_sig_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_ciphersuites.c line 1821
mbedtls_pk_type_t mbedtls_ssl_get_ciphersuite_sig_alg(const mbedtls_ssl_ciphersuite_t *info)
{
  switch((signed int)info->key_exchange)
  {
    case 1:

    case 2:

    case 3:
      return /*enum*/MBEDTLS_PK_RSA;
    case 4:
      return /*enum*/MBEDTLS_PK_ECDSA;
    default:
      return /*enum*/MBEDTLS_PK_NONE;
  }
}

// mbedtls_ssl_get_ciphersuite_sig_pk_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_ciphersuites.c line 1799
mbedtls_pk_type_t mbedtls_ssl_get_ciphersuite_sig_pk_alg(const mbedtls_ssl_ciphersuite_t *info)
{
  switch((signed int)info->key_exchange)
  {
    case 1:

    case 2:

    case 3:

    case 7:
      return /*enum*/MBEDTLS_PK_RSA;
    case 4:
      return /*enum*/MBEDTLS_PK_ECDSA;
    case 9:

    case 10:
      return /*enum*/MBEDTLS_PK_ECKEY;
    default:
      return /*enum*/MBEDTLS_PK_NONE;
  }
}

// mbedtls_ssl_get_key_exchange_md_tls1_2
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 8311
signed int mbedtls_ssl_get_key_exchange_md_tls1_2(mbedtls_ssl_context *ssl, unsigned char *output, unsigned char *data, size_t data_len, mbedtls_md_type_t md_alg)
{
  signed int ret=0;
  mbedtls_md_context_t ctx;
  const mbedtls_md_info_t *md_info=mbedtls_md_info_from_type(md_alg);
  mbedtls_md_init(&ctx);
  ret=mbedtls_md_setup(&ctx, md_info, 0);
  if(!(ret == 0))
    while((_Bool)0)
      ;

  else
  {
    ret=mbedtls_md_starts(&ctx);
    if(!(ret == 0))
      while((_Bool)0)
        ;

    else
    {
      ret=mbedtls_md_update(&ctx, ssl->handshake->randbytes, 64ull);
      if(!(ret == 0))
        while((_Bool)0)
          ;

      else
      {
        ret=mbedtls_md_update(&ctx, data, data_len);
        if(!(ret == 0))
          while((_Bool)0)
            ;

        else
        {
          ret=mbedtls_md_finish(&ctx, output);
          if(!(ret == 0))
            while((_Bool)0)
              ;

        }
      }
    }
  }

exit:
  ;
  mbedtls_md_free(&ctx);
  if(!(ret == 0))
    mbedtls_ssl_send_alert_message(ssl, 2, 80);

  return ret;
}

// mbedtls_ssl_get_max_frag_len
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6636
size_t mbedtls_ssl_get_max_frag_len(const mbedtls_ssl_context *ssl)
{
  size_t max_len=(size_t)mfl_code_to_length[(signed long long int)ssl->conf->mfl_code];
  if(!(ssl->session_out == ((mbedtls_ssl_session *)NULL)))
  {
    if(!((unsigned long long int)mfl_code_to_length[(signed long long int)ssl->session_out->mfl_code] >= max_len))
      max_len = (size_t)mfl_code_to_length[(signed long long int)ssl->session_out->mfl_code];

  }

  return max_len;
}

// mbedtls_ssl_get_peer_cert
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6659
const mbedtls_x509_crt * mbedtls_ssl_get_peer_cert(const mbedtls_ssl_context *ssl)
{
  _Bool tmp_if_expr;
  if(ssl == ((const mbedtls_ssl_context *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ssl->session == ((mbedtls_ssl_session *)NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return ((const mbedtls_x509_crt *)NULL);

  else
    return ssl->session->peer_cert;
}

// mbedtls_ssl_get_record_expansion
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6601
signed int mbedtls_ssl_get_record_expansion(const mbedtls_ssl_context *ssl)
{
  size_t transform_expansion;
  const mbedtls_ssl_transform *transform=ssl->transform_out;
  size_t return_value_mbedtls_ssl_hdr_len;
  unsigned int return_value_mbedtls_cipher_get_block_size;
  if(transform == ((const mbedtls_ssl_transform *)NULL))
  {
    return_value_mbedtls_ssl_hdr_len=mbedtls_ssl_hdr_len(ssl);
    return (signed int)return_value_mbedtls_ssl_hdr_len;
  }

  else
  {
    mbedtls_cipher_mode_t return_value_mbedtls_cipher_get_cipher_mode=mbedtls_cipher_get_cipher_mode(&transform->cipher_ctx_enc);
    switch((signed int)return_value_mbedtls_cipher_get_cipher_mode)
    {
      case 6:

      case 8:

      case 7:
      {
        transform_expansion = transform->minlen;
        break;
      }
      case 2:
      {
        return_value_mbedtls_cipher_get_block_size=mbedtls_cipher_get_block_size$link1(&transform->cipher_ctx_enc);
        transform_expansion = transform->maclen + (unsigned long long int)return_value_mbedtls_cipher_get_block_size;
        break;
      }
      default:
      {
        while((_Bool)0)
          ;
        return -0x6C00;
      }
    }
    size_t return_value_mbedtls_ssl_hdr_len$0=mbedtls_ssl_hdr_len(ssl);
    return (signed int)(return_value_mbedtls_ssl_hdr_len$0 + transform_expansion);
  }
}

// mbedtls_ssl_get_session
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6669
signed int mbedtls_ssl_get_session(const mbedtls_ssl_context *ssl, mbedtls_ssl_session *dst)
{
  _Bool tmp_if_expr;
  if(ssl == ((const mbedtls_ssl_context *)NULL) || dst == ((mbedtls_ssl_session *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ssl->session == ((mbedtls_ssl_session *)NULL) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$0;
  if(tmp_if_expr)
    tmp_if_expr$0 = (_Bool)1;

  else
    tmp_if_expr$0 = (signed int)ssl->conf->endpoint != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$0)
    return -0x7100;

  else
  {
    signed int return_value_ssl_session_copy=ssl_session_copy(dst, ssl->session);
    return return_value_ssl_session_copy;
  }
}

// mbedtls_ssl_get_verify_result
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6544
uint32_t mbedtls_ssl_get_verify_result(const mbedtls_ssl_context *ssl)
{
  if(!(ssl->session == ((mbedtls_ssl_session *)NULL)))
    return ssl->session->verify_result;

  else
    if(!(ssl->session_negotiate == ((mbedtls_ssl_session *)NULL)))
      return ssl->session_negotiate->verify_result;

    else
      return 0xFFFFFFFFu;
}

// mbedtls_ssl_get_version
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6563
const char * mbedtls_ssl_get_version(const mbedtls_ssl_context *ssl)
{
  switch(ssl->minor_ver)
  {
    case 0:
      return "SSLv3.0";
    case 1:
      return "TLSv1.0";
    case 2:
      return "TLSv1.1";
    case 3:
      return "TLSv1.2";
    default:
      return "unknown";
  }
}

// mbedtls_ssl_handle_message_type
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 4081
signed int mbedtls_ssl_handle_message_type(mbedtls_ssl_context *ssl)
{
  signed int ret;
  if(ssl->in_msgtype == 22)
  {
    ret=mbedtls_ssl_prepare_handshake_record(ssl);
    if(!(ret == 0))
      return ret;

  }

  if(ssl->in_msgtype == 21)
  {
    while((_Bool)0)
      ;
    if((signed int)*ssl->in_msg == 2)
    {
      while((_Bool)0)
        ;
      return -0x7780;
    }

    if((signed int)*ssl->in_msg == 1)
    {
      if((signed int)ssl->in_msg[1ll] == 0)
      {
        while((_Bool)0)
          ;
        return -0x7880;
      }

    }

    if((signed int)*ssl->in_msg == 1)
    {
      if((signed int)ssl->in_msg[1ll] == 100)
      {
        while((_Bool)0)
          ;
        return 0;
      }

    }

    return -0x6680;
  }

  else
    return 0;
}

// mbedtls_ssl_handshake
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6708
signed int mbedtls_ssl_handshake(mbedtls_ssl_context *ssl)
{
  signed int ret=0;
  _Bool tmp_if_expr;
  if(ssl == ((mbedtls_ssl_context *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ssl->conf == ((const mbedtls_ssl_config *)NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return -0x7100;

  else
  {
    while((_Bool)0)
      ;
    while(!(ssl->state == 16))
    {
      ret=mbedtls_ssl_handshake_step(ssl);
      if(!(ret == 0))
        break;

    }
    while((_Bool)0)
      ;
    return ret;
  }
}

// mbedtls_ssl_handshake_client_step
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 3329
signed int mbedtls_ssl_handshake_client_step(mbedtls_ssl_context *ssl)
{
  signed int ret=0;
  _Bool tmp_if_expr;
  if(ssl->state == 16)
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ssl->handshake == ((mbedtls_ssl_handshake_params *)NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return -0x7100;

  else
  {
    while((_Bool)0)
      ;
    ret=mbedtls_ssl_flush_output(ssl);
    if(!(ret == 0))
      return ret;

    else
    {
      switch(ssl->state)
      {
        case 0:
        {
          ssl->state = 1;
          break;
        }
        case 1:
        {
          ret=ssl_write_client_hello(ssl);
          break;
        }
        case 2:
        {
          ret=ssl_parse_server_hello(ssl);
          break;
        }
        case 3:
        {
          ret=mbedtls_ssl_parse_certificate(ssl);
          break;
        }
        case 4:
        {
          ret=ssl_parse_server_key_exchange(ssl);
          break;
        }
        case 5:
        {
          ret=ssl_parse_certificate_request(ssl);
          break;
        }
        case 6:
        {
          ret=ssl_parse_server_hello_done(ssl);
          break;
        }
        case 7:
        {
          ret=mbedtls_ssl_write_certificate(ssl);
          break;
        }
        case 8:
        {
          ret=ssl_write_client_key_exchange(ssl);
          break;
        }
        case 9:
        {
          ret=ssl_write_certificate_verify(ssl);
          break;
        }
        case 10:
        {
          ret=mbedtls_ssl_write_change_cipher_spec(ssl);
          break;
        }
        case 11:
        {
          ret=mbedtls_ssl_write_finished(ssl);
          break;
        }
        case 12:
        {
          ret=mbedtls_ssl_parse_change_cipher_spec(ssl);
          break;
        }
        case 13:
        {
          ret=mbedtls_ssl_parse_finished(ssl);
          break;
        }
        case 14:
        {
          while((_Bool)0)
            ;
          ssl->state = 15;
          break;
        }
        case 15:
        {
          mbedtls_ssl_handshake_wrapup(ssl);
          break;
        }
        default:
        {
          while((_Bool)0)
            ;
          return -0x7100;
        }
      }
      return ret;
    }
  }
}

// mbedtls_ssl_handshake_free
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7412
void mbedtls_ssl_handshake_free(mbedtls_ssl_handshake_params *handshake)
{
  if(!(handshake == ((mbedtls_ssl_handshake_params *)NULL)))
  {
    mbedtls_sha256_free(&handshake->fin_sha256);
    mbedtls_ecdh_free(&handshake->ecdh_ctx);
    mbedtls_free((void *)handshake->curves);
    if(!(handshake->sni_key_cert == ((mbedtls_ssl_key_cert *)NULL)))
    {
      mbedtls_ssl_key_cert *cur=handshake->sni_key_cert;
      mbedtls_ssl_key_cert *next;
      if(!(cur == ((mbedtls_ssl_key_cert *)NULL)))
      {
        next = cur->next;
        mbedtls_free((void *)cur);
        cur = next;
      }

    }

    mbedtls_zeroize$link16((void *)handshake, sizeof(mbedtls_ssl_handshake_params) /*976ull*/ );
  }

}

// mbedtls_ssl_handshake_step
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6686
signed int mbedtls_ssl_handshake_step(mbedtls_ssl_context *ssl)
{
  signed int ret=-0x7080;
  _Bool tmp_if_expr;
  if(ssl == ((mbedtls_ssl_context *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ssl->conf == ((const mbedtls_ssl_config *)NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return -0x7100;

  else
  {
    if((signed int)ssl->conf->endpoint == 0)
      ret=mbedtls_ssl_handshake_client_step(ssl);

    return ret;
  }
}

// mbedtls_ssl_handshake_wrapup
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5222
void mbedtls_ssl_handshake_wrapup(mbedtls_ssl_context *ssl)
{
  signed int resume=ssl->handshake->resume;
  while((_Bool)0)
    ;
  if(!(ssl->session == ((mbedtls_ssl_session *)NULL)))
  {
    ssl->session_negotiate->encrypt_then_mac = ssl->session->encrypt_then_mac;
    mbedtls_ssl_session_free(ssl->session);
    mbedtls_free((void *)ssl->session);
  }

  ssl->session = ssl->session_negotiate;
  ssl->session_negotiate = ((mbedtls_ssl_session *)NULL);
  if(!(ssl->conf->f_set_cache == ((signed int (*)(void *, const mbedtls_ssl_session *))NULL)))
  {
    if(!(ssl->session->id_len == 0ull))
    {
      if(resume == 0)
      {
        signed int return_value=ssl->conf->f_set_cache(ssl->conf->p_cache, ssl->session);
      }

    }

  }

  ssl_handshake_wrapup_free_hs_transform(ssl);
  ssl->state = ssl->state + 1;
  while((_Bool)0)
    ;
}

// mbedtls_ssl_hash_from_md_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7968
unsigned char mbedtls_ssl_hash_from_md_alg(signed int md)
{
  switch(md)
  {
    case 4:
      return 2;
    case 5:
      return 3;
    case 6:
      return 4;
    default:
      return 0;
  }
}

// mbedtls_ssl_hdr_len
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/ssl_internal.h line 590
static inline size_t mbedtls_ssl_hdr_len(const mbedtls_ssl_context *ssl)
{
  (void)ssl;
  return 5ull;
}

// mbedtls_ssl_hs_hdr_len
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/ssl_internal.h line 601
static inline size_t mbedtls_ssl_hs_hdr_len(const mbedtls_ssl_context *ssl)
{
  (void)ssl;
  return 4ull;
}

// mbedtls_ssl_hs_hdr_len$link1
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/ssl_internal.h line 601
static inline size_t mbedtls_ssl_hs_hdr_len$link1(const mbedtls_ssl_context *ssl$link1)
{
  (void)ssl$link1;
  return 4ull;
}

// mbedtls_ssl_init
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5652
void mbedtls_ssl_init(mbedtls_ssl_context *ssl)
{
  memset((void *)ssl, 0, sizeof(mbedtls_ssl_context) /*352ull*/ );
}

// mbedtls_ssl_list_ciphersuites
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_ciphersuites.c line 1707
const signed int * mbedtls_ssl_list_ciphersuites(void)
{
  _Bool tmp_if_expr;
  signed int *tmp_post;
  if(supported_init$link1 == 0)
  {
    const signed int *p;
    signed int *q;
    p = ciphersuite_preference;
    q = supported_ciphersuites;
    do
    {
      if(!(*p == 0))
        tmp_if_expr = q < (supported_ciphersuites + (signed long long int)(sizeof(const mbedtls_ssl_ciphersuite_t [9ll]) /*432ull*/  / sizeof(const mbedtls_ssl_ciphersuite_t) /*48ull*/ )) - 1ll ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr = (_Bool)0;
      if(!tmp_if_expr)
        break;

      const mbedtls_ssl_ciphersuite_t *return_value_mbedtls_ssl_ciphersuite_from_id=mbedtls_ssl_ciphersuite_from_id(*p);
      if(!(return_value_mbedtls_ssl_ciphersuite_from_id == ((const mbedtls_ssl_ciphersuite_t *)NULL)))
      {
        tmp_post = q;
        q = q + 1ll;
        *tmp_post = *p;
      }

      p = p + 1ll;
    }
    while((_Bool)1);
    *q = 0;
    supported_init$link1 = 1;
  }

  return supported_ciphersuites;
}

// mbedtls_ssl_md_alg_from_hash
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7936
mbedtls_md_type_t mbedtls_ssl_md_alg_from_hash(unsigned char hash)
{
  switch((signed int)hash)
  {
    case 2:
      return /*enum*/MBEDTLS_MD_SHA1;
    case 3:
      return /*enum*/MBEDTLS_MD_SHA224;
    case 4:
      return /*enum*/MBEDTLS_MD_SHA256;
    default:
      return /*enum*/MBEDTLS_MD_NONE;
  }
}

// mbedtls_ssl_optimize_checksum
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 4861
void mbedtls_ssl_optimize_checksum(mbedtls_ssl_context *ssl, const mbedtls_ssl_ciphersuite_t *ciphersuite_info)
{
  (void)ciphersuite_info;
  if(!((signed int)ciphersuite_info->mac == 7))
    ssl->handshake->update_checksum = ssl_update_checksum_sha256;

  else
  {
    while((_Bool)0)
      ;
    goto __CPROVER_DUMP_L3;
  }

__CPROVER_DUMP_L3:
  ;
}

// mbedtls_ssl_own_cert
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/ssl_internal.h line 558
static inline mbedtls_x509_crt * mbedtls_ssl_own_cert(mbedtls_ssl_context *ssl)
{
  mbedtls_ssl_key_cert *key_cert;
  _Bool tmp_if_expr;
  if(!(ssl->handshake == ((mbedtls_ssl_handshake_params *)NULL)))
    tmp_if_expr = ssl->handshake->key_cert != ((mbedtls_ssl_key_cert *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr = (_Bool)0;
  if(tmp_if_expr)
    key_cert = ssl->handshake->key_cert;

  else
    key_cert = ssl->conf->key_cert;
  mbedtls_x509_crt *tmp_if_expr$0;
  if(key_cert == ((mbedtls_ssl_key_cert *)NULL))
    tmp_if_expr$0 = ((mbedtls_x509_crt *)NULL);

  else
    tmp_if_expr$0 = key_cert->cert;
  return tmp_if_expr$0;
}

// mbedtls_ssl_own_cert$link1
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/ssl_internal.h line 558
static inline mbedtls_x509_crt * mbedtls_ssl_own_cert$link1(mbedtls_ssl_context *ssl$link1)
{
  mbedtls_ssl_key_cert *key_cert$link1;
  _Bool tmp_if_expr$link1;
  if(!(ssl$link1->handshake == ((mbedtls_ssl_handshake_params *)NULL)))
    tmp_if_expr$link1 = ssl$link1->handshake->key_cert != ((mbedtls_ssl_key_cert *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$link1 = (_Bool)0;
  if(tmp_if_expr$link1)
    key_cert$link1 = ssl$link1->handshake->key_cert;

  else
    key_cert$link1 = ssl$link1->conf->key_cert;
  mbedtls_x509_crt *tmp_if_expr$0$link1;
  if(key_cert$link1 == ((mbedtls_ssl_key_cert *)NULL))
    tmp_if_expr$0$link1 = ((mbedtls_x509_crt *)NULL);

  else
    tmp_if_expr$0$link1 = key_cert$link1->cert;
  return tmp_if_expr$0$link1;
}

// mbedtls_ssl_own_key
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/ssl_internal.h line 546
static inline mbedtls_pk_context * mbedtls_ssl_own_key(mbedtls_ssl_context *ssl)
{
  mbedtls_ssl_key_cert *key_cert;
  _Bool tmp_if_expr;
  if(!(ssl->handshake == ((mbedtls_ssl_handshake_params *)NULL)))
    tmp_if_expr = ssl->handshake->key_cert != ((mbedtls_ssl_key_cert *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr = (_Bool)0;
  if(tmp_if_expr)
    key_cert = ssl->handshake->key_cert;

  else
    key_cert = ssl->conf->key_cert;
  mbedtls_pk_context *tmp_if_expr$0;
  if(key_cert == ((mbedtls_ssl_key_cert *)NULL))
    tmp_if_expr$0 = ((mbedtls_pk_context *)NULL);

  else
    tmp_if_expr$0 = key_cert->key;
  return tmp_if_expr$0;
}

// mbedtls_ssl_parse_certificate
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 4367
signed int mbedtls_ssl_parse_certificate(mbedtls_ssl_context *ssl)
{
  signed int ret=-0x7080;
  size_t i;
  size_t n;
  const mbedtls_ssl_ciphersuite_t *ciphersuite_info=ssl->transform_negotiate->ciphersuite_info;
  signed int authmode=(signed int)ssl->conf->authmode;
  uint8_t alert;
  while((_Bool)0)
    ;
  _Bool tmp_if_expr;
  if((signed int)ciphersuite_info->key_exchange == 5)
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = (signed int)ciphersuite_info->key_exchange == 6 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$0;
  if(tmp_if_expr)
    tmp_if_expr$0 = (_Bool)1;

  else
    tmp_if_expr$0 = (signed int)ciphersuite_info->key_exchange == 8 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$1;
  if(tmp_if_expr$0)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)ciphersuite_info->key_exchange == 11 ? (_Bool)1 : (_Bool)0;
  size_t return_value_mbedtls_ssl_hs_hdr_len;
  size_t return_value_mbedtls_ssl_hs_hdr_len$0;
  mbedtls_ecp_keypair *return_value_mbedtls_pk_ec;
  signed int return_value_mbedtls_ssl_check_curve;
  if(tmp_if_expr$1)
  {
    while((_Bool)0)
      ;
    ssl->state = ssl->state + 1;
    return 0;
  }

  else
  {
    ret=mbedtls_ssl_read_record(ssl);
    if(!(ret == 0))
    {
      while((_Bool)0)
        ;
      return ret;
    }

    else
    {
      ssl->state = ssl->state + 1;
      if(!(ssl->in_msgtype == 22))
      {
        while((_Bool)0)
          ;
        mbedtls_ssl_send_alert_message(ssl, 2, 10);
        return -0x7700;
      }

      else
      {
        _Bool tmp_if_expr$2;
        if(!((signed int)*ssl->in_msg == 11))
          tmp_if_expr$2 = (_Bool)1;

        else
        {
          return_value_mbedtls_ssl_hs_hdr_len=mbedtls_ssl_hs_hdr_len$link1(ssl);
          tmp_if_expr$2 = ssl->in_hslen < return_value_mbedtls_ssl_hs_hdr_len + 3ull + 3ull ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$2)
        {
          while((_Bool)0)
            ;
          mbedtls_ssl_send_alert_message(ssl, 2, 50);
          return -0x7A00;
        }

        else
        {
          i=mbedtls_ssl_hs_hdr_len$link1(ssl);
          n = (size_t)((signed int)ssl->in_msg[(signed long long int)(i + 1ull)] << 8 | (signed int)ssl->in_msg[(signed long long int)(i + 2ull)]);
          _Bool tmp_if_expr$3;
          if(!((signed int)ssl->in_msg[(signed long long int)i] == 0))
            tmp_if_expr$3 = (_Bool)1;

          else
          {
            return_value_mbedtls_ssl_hs_hdr_len$0=mbedtls_ssl_hs_hdr_len$link1(ssl);
            tmp_if_expr$3 = ssl->in_hslen != n + 3ull + return_value_mbedtls_ssl_hs_hdr_len$0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$3)
          {
            while((_Bool)0)
              ;
            mbedtls_ssl_send_alert_message(ssl, 2, 50);
            return -0x7A00;
          }

          else
          {
            if(!(ssl->session_negotiate->peer_cert == ((mbedtls_x509_crt *)NULL)))
            {
              mbedtls_x509_crt_free(ssl->session_negotiate->peer_cert);
              mbedtls_free((void *)ssl->session_negotiate->peer_cert);
            }

            void *return_value=mbedtls_calloc(1ull, sizeof(mbedtls_x509_crt) /*552ull*/ );
            ssl->session_negotiate->peer_cert = (mbedtls_x509_crt *)return_value;
            if(ssl->session_negotiate->peer_cert == ((mbedtls_x509_crt *)NULL))
            {
              mbedtls_ssl_send_alert_message(ssl, 2, 80);
              return -0x7F00;
            }

            else
            {
              mbedtls_x509_crt_init(ssl->session_negotiate->peer_cert);
              i = i + 3ull;
              if(!(i >= ssl->in_hslen))
              {
                if(!((signed int)ssl->in_msg[(signed long long int)i] == 0))
                {
                  mbedtls_ssl_send_alert_message(ssl, 2, 50);
                  return -0x7A00;
                }

                n = (size_t)((unsigned int)ssl->in_msg[(signed long long int)(i + 1ull)] << 8 | (unsigned int)ssl->in_msg[(signed long long int)(i + 2ull)]);
                i = i + 3ull;
                _Bool tmp_if_expr$4;
                if(!(n >= 128ull))
                  tmp_if_expr$4 = (_Bool)1;

                else
                  tmp_if_expr$4 = i + n > ssl->in_hslen ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr$4)
                {
                  mbedtls_ssl_send_alert_message(ssl, 2, 50);
                  return -0x7A00;
                }

                ret=mbedtls_x509_crt_parse_der(ssl->session_negotiate->peer_cert, ssl->in_msg + (signed long long int)i, n);
                if(ret == 0 || ret == -9774)
                {
                  alert = 80;
                  alert = 43;
                }

                alert = 42;

              crt_parse_der_failed:
                ;
                mbedtls_ssl_send_alert_message(ssl, 2, alert);
                return ret;
                i = i + n;
              }

              if(!(authmode == 0))
              {
                mbedtls_x509_crt *ca_chain;
                mbedtls_x509_crl *ca_crl;
                if(!(ssl->handshake->sni_ca_chain == ((mbedtls_x509_crt *)NULL)))
                {
                  ca_chain = ssl->handshake->sni_ca_chain;
                  ca_crl = ssl->handshake->sni_ca_crl;
                }

                else
                {
                  ca_chain = ssl->conf->ca_chain;
                  ca_crl = ssl->conf->ca_crl;
                }
                ret=mbedtls_x509_crt_verify_with_profile(ssl->session_negotiate->peer_cert, ca_chain, ca_crl, ssl->conf->cert_profile, ssl->hostname, &ssl->session_negotiate->verify_result, ssl->conf->f_vrfy, ssl->conf->p_vrfy);
                const mbedtls_pk_context *pk=&ssl->session_negotiate->peer_cert->pk;
                signed int return_value_mbedtls_pk_can_do=mbedtls_pk_can_do(pk, /*enum*/MBEDTLS_PK_ECKEY);
                if(!(return_value_mbedtls_pk_can_do == 0))
                {
                  return_value_mbedtls_pk_ec=mbedtls_pk_ec$link1(*pk);
                  return_value_mbedtls_ssl_check_curve=mbedtls_ssl_check_curve(ssl, return_value_mbedtls_pk_ec->grp.id);
                  if(!(return_value_mbedtls_ssl_check_curve == 0))
                  {
                    ssl->session_negotiate->verify_result = ssl->session_negotiate->verify_result | 65536u;
                    if(ret == 0)
                      ret = -0x7A00;

                  }

                }

                signed int return_value_mbedtls_ssl_check_cert_usage=mbedtls_ssl_check_cert_usage(ssl->session_negotiate->peer_cert, ciphersuite_info, (signed int)!(ssl->conf->endpoint != 0u), &ssl->session_negotiate->verify_result);
                if(!(return_value_mbedtls_ssl_check_cert_usage == 0))
                {
                  if(ret == 0)
                    ret = -0x7A00;

                }

                if(authmode == 1 && (ret == -31232 || ret == -9984))
                  ret = 0;

                if(ca_chain == ((mbedtls_x509_crt *)NULL) && authmode == 2)
                  ret = -0x7680;

                if(!(ret == 0))
                {
                  if(!((256u & ssl->session_negotiate->verify_result) == 0u))
                    alert = 49;

                  else
                    if(!((4u & ssl->session_negotiate->verify_result) == 0u))
                      alert = 42;

                    else
                      if(!((2048u & ssl->session_negotiate->verify_result) == 0u))
                        alert = 43;

                      else
                        if(!((4096u & ssl->session_negotiate->verify_result) == 0u))
                          alert = 43;

                        else
                          if(!((8192u & ssl->session_negotiate->verify_result) == 0u))
                            alert = 43;

                          else
                            if(!((32768u & ssl->session_negotiate->verify_result) == 0u))
                              alert = 43;

                            else
                              if(!((65536u & ssl->session_negotiate->verify_result) == 0u))
                                alert = 43;

                              else
                                if(!((1u & ssl->session_negotiate->verify_result) == 0u))
                                  alert = 45;

                                else
                                  if(!((2u & ssl->session_negotiate->verify_result) == 0u))
                                    alert = 44;

                                  else
                                    if(!((8u & ssl->session_negotiate->verify_result) == 0u))
                                      alert = 48;

                                    else
                                      alert = 46;
                  mbedtls_ssl_send_alert_message(ssl, 2, alert);
                }

              }

              return ret;
            }
          }
        }
      }
    }
  }
}

// mbedtls_ssl_parse_change_cipher_spec
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 4774
signed int mbedtls_ssl_parse_change_cipher_spec(mbedtls_ssl_context *ssl)
{
  signed int ret;
  while((_Bool)0)
    ;
  ret=mbedtls_ssl_read_record(ssl);
  if(!(ret == 0))
  {
    while((_Bool)0)
      ;
    return ret;
  }

  else
    if(!(ssl->in_msgtype == 20))
    {
      while((_Bool)0)
        ;
      mbedtls_ssl_send_alert_message(ssl, 2, 10);
      return -0x7700;
    }

    else
    {
      _Bool tmp_if_expr;
      if(!(ssl->in_msglen == 1ull))
        tmp_if_expr = (_Bool)1;

      else
        tmp_if_expr = (signed int)ssl->in_msg[0ll] != 1 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr)
      {
        while((_Bool)0)
          ;
        mbedtls_ssl_send_alert_message(ssl, 2, 50);
        return -0x7E00;
      }

      else
      {
        while((_Bool)0)
          ;
        ssl->transform_in = ssl->transform_negotiate;
        ssl->session_in = ssl->session_negotiate;
        memset((void *)ssl->in_ctr, 0, 8ull);
        if(ssl->minor_ver >= 2)
          ssl->in_msg = (ssl->in_iv + (signed long long int)ssl->transform_negotiate->ivlen) - (signed long long int)ssl->transform_negotiate->fixed_ivlen;

        else
          ssl->in_msg = ssl->in_iv;
        ssl->state = ssl->state + 1;
        while((_Bool)0)
          ;
        return 0;
      }
    }
}

// mbedtls_ssl_parse_finished
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5408
signed int mbedtls_ssl_parse_finished(mbedtls_ssl_context *ssl)
{
  signed int ret;
  unsigned int hash_len;
  unsigned char buf[12ll];
  while((_Bool)0)
    ;
  ssl->handshake->calc_finished(ssl, buf, (signed int)ssl->conf->endpoint ^ 1);
  ret=mbedtls_ssl_read_record(ssl);
  size_t return_value_mbedtls_ssl_hs_hdr_len;
  if(!(ret == 0))
    return ret;

  else
    if(!(ssl->in_msgtype == 22))
    {
      mbedtls_ssl_send_alert_message(ssl, 2, 10);
      return -0x7700;
    }

    else
    {
      hash_len = 12u;
      _Bool tmp_if_expr;
      if(!((signed int)*ssl->in_msg == 20))
        tmp_if_expr = (_Bool)1;

      else
      {
        return_value_mbedtls_ssl_hs_hdr_len=mbedtls_ssl_hs_hdr_len$link1(ssl);
        tmp_if_expr = ssl->in_hslen != return_value_mbedtls_ssl_hs_hdr_len + (unsigned long long int)hash_len ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr)
      {
        mbedtls_ssl_send_alert_message(ssl, 2, 50);
        return -0x7E80;
      }

      else
      {
        size_t return_value_mbedtls_ssl_hs_hdr_len$0=mbedtls_ssl_hs_hdr_len$link1(ssl);
        signed int return_value_mbedtls_ssl_safer_memcmp=mbedtls_ssl_safer_memcmp((const void *)(ssl->in_msg + (signed long long int)return_value_mbedtls_ssl_hs_hdr_len$0), (const void *)buf, (size_t)hash_len);
        if(!(return_value_mbedtls_ssl_safer_memcmp == 0))
        {
          mbedtls_ssl_send_alert_message(ssl, 2, 50);
          return -0x7E80;
        }

        else
        {
          if(!(ssl->handshake->resume == 0))
          {
            if((signed int)ssl->conf->endpoint == 0)
              ssl->state = 10;

          }

          else
            ssl->state = ssl->state + 1;
          return 0;
        }
      }
    }
}

// mbedtls_ssl_pk_alg_from_sig
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7864
mbedtls_pk_type_t mbedtls_ssl_pk_alg_from_sig(unsigned char sig)
{
  switch((signed int)sig)
  {
    case 1:
      return /*enum*/MBEDTLS_PK_RSA;
    case 3:
      return /*enum*/MBEDTLS_PK_ECDSA;
    default:
      return /*enum*/MBEDTLS_PK_NONE;
  }
}

// mbedtls_ssl_prepare_handshake_record
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 3144
signed int mbedtls_ssl_prepare_handshake_record(mbedtls_ssl_context *ssl)
{
  size_t return_value_mbedtls_ssl_hs_hdr_len=mbedtls_ssl_hs_hdr_len$link1(ssl);
  if(!(ssl->in_msglen >= return_value_mbedtls_ssl_hs_hdr_len))
  {
    while((_Bool)0)
      ;
    return -0x7200;
  }

  else
  {
    size_t return_value_mbedtls_ssl_hs_hdr_len$0=mbedtls_ssl_hs_hdr_len$link1(ssl);
    ssl->in_hslen = return_value_mbedtls_ssl_hs_hdr_len$0 + (unsigned long long int)((signed int)ssl->in_msg[1ll] << 16 | (signed int)ssl->in_msg[2ll] << 8 | (signed int)ssl->in_msg[3ll]);
    while((_Bool)0)
      ;
    if(!(ssl->in_msglen >= ssl->in_hslen))
    {
      while((_Bool)0)
        ;
      return -0x7080;
    }

    else
      return 0;
  }
}

// mbedtls_ssl_read
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6893
signed int mbedtls_ssl_read(mbedtls_ssl_context *ssl, unsigned char *buf, size_t len)
{
  signed int ret;
  size_t n;
  _Bool tmp_if_expr;
  if(ssl == ((mbedtls_ssl_context *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ssl->conf == ((const mbedtls_ssl_config *)NULL) ? (_Bool)1 : (_Bool)0;
  signed int return_value;
  _Bool tmp_if_expr$0;
  size_t return_value_mbedtls_ssl_hs_hdr_len;
  if(tmp_if_expr)
    return -0x7100;

  else
  {
    while((_Bool)0)
      ;
    if(!(ssl->state == 16))
    {
      ret=mbedtls_ssl_handshake(ssl);
      if(!(ret == 0) && !(ret == -27392))
      {
        while((_Bool)0)
          ;
        return ret;
      }

    }

    while(ssl->in_offt == ((unsigned char *)NULL))
    {
      if(!(ssl->f_get_timer == ((mbedtls_ssl_get_timer_t (*))NULL)))
      {
        return_value=ssl->f_get_timer(ssl->p_timer);
        if(return_value == -1)
          ssl_set_timer(ssl, ssl->conf->read_timeout);

      }

      ret=mbedtls_ssl_read_record(ssl);
      if(!(ret == 0))
      {
        if(ret == -29312)
          return 0;

        while((_Bool)0)
          ;
        return ret;
      }

      if(ssl->in_msglen == 0ull)
      {
        if(ssl->in_msgtype == 23)
        {
          ret=mbedtls_ssl_read_record(ssl);
          if(!(ret == 0))
          {
            if(ret == -29312)
              return 0;

            while((_Bool)0)
              ;
            return ret;
          }

        }

      }

      if(ssl->in_msgtype == 22)
      {
        while((_Bool)0)
          ;
        if((signed int)ssl->conf->endpoint == 0)
        {
          if(!((signed int)*ssl->in_msg == 0))
            tmp_if_expr$0 = (_Bool)1;

          else
          {
            return_value_mbedtls_ssl_hs_hdr_len=mbedtls_ssl_hs_hdr_len$link1(ssl);
            tmp_if_expr$0 = ssl->in_hslen != return_value_mbedtls_ssl_hs_hdr_len ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$0)
          {
            while((_Bool)0)
              ;
            return -0x7700;
          }

        }

        while((_Bool)0)
          ;
        if(ssl->minor_ver >= 1)
        {
          ret=mbedtls_ssl_send_alert_message(ssl, 1, 100);
          if(!(ret == 0))
            return ret;

        }

        else
        {
          while((_Bool)0)
            ;
          return -0x6C00;
        }
      }

      else
      {
        if(ssl->in_msgtype == 21)
        {
          while((_Bool)0)
            ;
          return -0x6900;
        }

        if(!(ssl->in_msgtype == 23))
        {
          while((_Bool)0)
            ;
          return -0x7700;
        }

        ssl->in_offt = ssl->in_msg;
        if(ssl->state == 16)
          ssl_set_timer(ssl, 0u);

      }
    }
    size_t tmp_if_expr$1;
    if(!(len >= ssl->in_msglen))
      tmp_if_expr$1 = len;

    else
      tmp_if_expr$1 = ssl->in_msglen;
    n = tmp_if_expr$1;
    memcpy((void *)buf, (const void *)ssl->in_offt, n);
    ssl->in_msglen = ssl->in_msglen - n;
    if(ssl->in_msglen == 0ull)
    {
      ssl->in_offt = ((unsigned char *)NULL);
      ssl->keep_current_message = 0;
    }

    else
      ssl->in_offt = ssl->in_offt + (signed long long int)n;
    while((_Bool)0)
      ;
    return (signed int)n;
  }
}

// mbedtls_ssl_read_record
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 3804
signed int mbedtls_ssl_read_record(mbedtls_ssl_context *ssl)
{
  signed int ret;
  while((_Bool)0)
    ;
  if(ssl->keep_current_message == 0)
  {
    do
    {

    __CPROVER_DUMP_L2:
      ;
      ret=mbedtls_ssl_read_record_layer(ssl);
      if(ret == -25984)
        goto __CPROVER_DUMP_L2;

      if(!(ret == 0))
      {
        while((_Bool)0)
          ;
        return ret;
      }

      ret=mbedtls_ssl_handle_message_type(ssl);
    }
    while(ret == -26240 || ret == -25984);
    if(!(ret == 0))
    {
      while((_Bool)0)
        ;
      return ret;
    }

    if(ssl->in_msgtype == 22)
      mbedtls_ssl_update_handshake_status(ssl);

  }

  else
  {
    while((_Bool)0)
      ;
    ssl->keep_current_message = 0;
  }
  while((_Bool)0)
    ;
  return 0;
}

// mbedtls_ssl_read_record_layer
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 3850
signed int mbedtls_ssl_read_record_layer(mbedtls_ssl_context *ssl)
{
  signed int ret;
  if(!(ssl->in_hslen == 0ull))
  {
    if(!(ssl->in_offt == ((unsigned char *)NULL)))
    {
      while((_Bool)0)
        ;
      return -0x6C00;
    }

    if(!(ssl->in_hslen >= ssl->in_msglen))
    {
      ssl->in_msglen = ssl->in_msglen - ssl->in_hslen;
      memmove((void *)ssl->in_msg, (const void *)(ssl->in_msg + (signed long long int)ssl->in_hslen), ssl->in_msglen);
      while((_Bool)0)
        ;
    }

    else
      ssl->in_msglen = 0ull;
    ssl->in_hslen = 0ull;
  }

  else
    if(!(ssl->in_offt == ((unsigned char *)NULL)))
      return 0;

    else
      ssl->in_msglen = 0ull;
  if(ssl->in_msglen >= 1ull)
    return 0;

  else
  {
    size_t return_value_mbedtls_ssl_hdr_len=mbedtls_ssl_hdr_len(ssl);
    ret=mbedtls_ssl_fetch_input(ssl, return_value_mbedtls_ssl_hdr_len);
    if(!(ret == 0))
    {
      while((_Bool)0)
        ;
      return ret;
    }

    else
    {
      ret=ssl_parse_record_header(ssl);
      if(!(ret == 0))
        return ret;

      else
      {
        size_t return_value_mbedtls_ssl_hdr_len$0=mbedtls_ssl_hdr_len(ssl);
        ret=mbedtls_ssl_fetch_input(ssl, return_value_mbedtls_ssl_hdr_len$0 + ssl->in_msglen);
        if(!(ret == 0))
        {
          while((_Bool)0)
            ;
          return ret;
        }

        else
        {
          ssl->in_left = 0ull;
          ret=ssl_prepare_record_content(ssl);
          if(!(ret == 0))
          {
            if(ret == -29056)
              mbedtls_ssl_send_alert_message(ssl, 2, 20);

            return ret;
          }

          else
            return 0;
        }
      }
    }
  }
}

// mbedtls_ssl_read_version
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 8160
void mbedtls_ssl_read_version(signed int *major, signed int *minor, signed int transport, const unsigned char *ver)
{
  (void)transport;
  *major = (signed int)ver[0ll];
  *minor = (signed int)ver[1ll];
}

// mbedtls_ssl_reset_checksum
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 4890
void mbedtls_ssl_reset_checksum(mbedtls_ssl_context *ssl)
{
  mbedtls_sha256_starts_ret(&ssl->handshake->fin_sha256, 0);
}

// mbedtls_ssl_safer_memcmp
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/ssl_internal.h line 625
static inline signed int mbedtls_ssl_safer_memcmp(const void *a, const void *b, size_t n)
{
  size_t i;
  const volatile unsigned char *A=(const volatile unsigned char *)a;
  const volatile unsigned char *B=(const volatile unsigned char *)b;
  volatile unsigned char diff=0;
  i = 0ull;
  for( ; !(i >= n); i = i + 1ull)
    diff = diff | (volatile unsigned char)((signed int)A[(signed long long int)i] ^ (signed int)B[(signed long long int)i]);
  return (signed int)diff;
}

// mbedtls_ssl_send_alert_message
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 4170
signed int mbedtls_ssl_send_alert_message(mbedtls_ssl_context *ssl, unsigned char level, unsigned char message)
{
  signed int ret;
  _Bool tmp_if_expr;
  if(ssl == ((mbedtls_ssl_context *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ssl->conf == ((const mbedtls_ssl_config *)NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return -0x7100;

  else
  {
    while((_Bool)0)
      ;
    while((_Bool)0)
      ;
    ssl->out_msgtype = 21;
    ssl->out_msglen = 2ull;
    ssl->out_msg[0ll] = level;
    ssl->out_msg[1ll] = message;
    ret=mbedtls_ssl_write_record(ssl);
    if(!(ret == 0))
    {
      while((_Bool)0)
        ;
      return ret;
    }

    else
    {
      while((_Bool)0)
        ;
      return 0;
    }
  }
}

// mbedtls_ssl_send_fatal_handshake_failure
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 4156
signed int mbedtls_ssl_send_fatal_handshake_failure(mbedtls_ssl_context *ssl)
{
  signed int ret=mbedtls_ssl_send_alert_message(ssl, 2, 40);
  if(!(ret == 0))
    return ret;

  else
    return 0;
}

// mbedtls_ssl_session_free
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7488
void mbedtls_ssl_session_free(mbedtls_ssl_session *session)
{
  if(!(session == ((mbedtls_ssl_session *)NULL)))
  {
    if(!(session->peer_cert == ((mbedtls_x509_crt *)NULL)))
    {
      mbedtls_x509_crt_free(session->peer_cert);
      mbedtls_free((void *)session->peer_cert);
    }

    mbedtls_zeroize$link16((void *)session, sizeof(mbedtls_ssl_session) /*120ull*/ );
  }

}

// mbedtls_ssl_session_init
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5546
void mbedtls_ssl_session_init(mbedtls_ssl_session *session)
{
  memset((void *)session, 0, sizeof(mbedtls_ssl_session) /*120ull*/ );
}

// mbedtls_ssl_session_reset
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5828
signed int mbedtls_ssl_session_reset(mbedtls_ssl_context *ssl)
{
  signed int return_value_ssl_session_reset_int=ssl_session_reset_int(ssl, 0);
  return return_value_ssl_session_reset_int;
}

// mbedtls_ssl_set_bio
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5899
void mbedtls_ssl_set_bio(mbedtls_ssl_context *ssl, void *p_bio, mbedtls_ssl_send_t (*f_send), mbedtls_ssl_recv_t (*f_recv), mbedtls_ssl_recv_timeout_t (*f_recv_timeout))
{
  ssl->p_bio = p_bio;
  ssl->f_send = f_send;
  ssl->f_recv = f_recv;
  ssl->f_recv_timeout = f_recv_timeout;
}

// mbedtls_ssl_set_calc_verify_md
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 8182
signed int mbedtls_ssl_set_calc_verify_md(mbedtls_ssl_context *ssl, signed int md)
{
  if(!(ssl->minor_ver == 3))
    return -0x6600;

  else
  {
    if(md == 4)
      ssl->handshake->calc_verify = ssl_calc_verify_tls_sha256;

    else
      return -0x6600;
    return 0;
  }
}

// mbedtls_ssl_set_hostname
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6262
signed int mbedtls_ssl_set_hostname(mbedtls_ssl_context *ssl, const char *hostname)
{
  size_t hostname_len=0ull;
  if(!(hostname == ((const char *)NULL)))
  {
    hostname_len=strlen(hostname);
    if(hostname_len >= 256ull)
      return -0x7100;

  }

  if(!(ssl->hostname == ((char *)NULL)))
  {
    size_t return_value_strlen=strlen(ssl->hostname);
    mbedtls_zeroize$link16((void *)ssl->hostname, return_value_strlen);
    mbedtls_free((void *)ssl->hostname);
  }

  if(hostname == ((const char *)NULL))
    ssl->hostname = ((char *)NULL);

  else
  {
    void *return_value=mbedtls_calloc(1ull, hostname_len + 1ull);
    ssl->hostname = (char *)return_value;
    if(ssl->hostname == ((char *)NULL))
      return -0x7F00;

    memcpy((void *)ssl->hostname, (const void *)hostname, hostname_len);
    ssl->hostname[(signed long long int)hostname_len] = 0;
  }
  return 0;
}

// mbedtls_ssl_set_hs_authmode
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6056
void mbedtls_ssl_set_hs_authmode(mbedtls_ssl_context *ssl, signed int authmode)
{
  ssl->handshake->sni_authmode = authmode;
}

// mbedtls_ssl_set_hs_ca_chain
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6048
void mbedtls_ssl_set_hs_ca_chain(mbedtls_ssl_context *ssl, mbedtls_x509_crt *ca_chain, mbedtls_x509_crl *ca_crl)
{
  ssl->handshake->sni_ca_chain = ca_chain;
  ssl->handshake->sni_ca_crl = ca_crl;
}

// mbedtls_ssl_set_hs_own_cert
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 6040
signed int mbedtls_ssl_set_hs_own_cert(mbedtls_ssl_context *ssl, mbedtls_x509_crt *own_cert, mbedtls_pk_context *pk_key)
{
  signed int return_value_ssl_append_key_cert=ssl_append_key_cert(&ssl->handshake->sni_key_cert, own_cert, pk_key);
  return return_value_ssl_append_key_cert;
}

// mbedtls_ssl_set_session
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5942
signed int mbedtls_ssl_set_session(mbedtls_ssl_context *ssl, const mbedtls_ssl_session *session)
{
  signed int ret;
  _Bool tmp_if_expr;
  if(ssl == ((mbedtls_ssl_context *)NULL) || session == ((const mbedtls_ssl_session *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ssl->session_negotiate == ((mbedtls_ssl_session *)NULL) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$0;
  if(tmp_if_expr)
    tmp_if_expr$0 = (_Bool)1;

  else
    tmp_if_expr$0 = (signed int)ssl->conf->endpoint != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$0)
    return -0x7100;

  else
  {
    ret=ssl_session_copy(ssl->session_negotiate, session);
    if(!(ret == 0))
      return ret;

    else
    {
      ssl->handshake->resume = 1;
      return 0;
    }
  }
}

// mbedtls_ssl_set_timer_cb
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5916
void mbedtls_ssl_set_timer_cb(mbedtls_ssl_context *ssl, void *p_timer, mbedtls_ssl_set_timer_t (*f_set_timer), mbedtls_ssl_get_timer_t (*f_get_timer))
{
  ssl->p_timer = p_timer;
  ssl->f_set_timer = f_set_timer;
  ssl->f_get_timer = f_get_timer;
  ssl_set_timer(ssl, 0u);
}

// mbedtls_ssl_setup
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5660
signed int mbedtls_ssl_setup(mbedtls_ssl_context *ssl, const mbedtls_ssl_config *conf)
{
  signed int ret;
  const size_t len=(const size_t)(13 + 8192 + 0 + 16 + 32 + 256);
  ssl->conf = conf;
  void *return_value=mbedtls_calloc(1ull, len);
  ssl->in_buf = (unsigned char *)return_value;
  _Bool tmp_if_expr;
  void *return_value$0;
  if(ssl->in_buf == ((unsigned char *)NULL))
    tmp_if_expr = (_Bool)1;

  else
  {
    return_value$0=mbedtls_calloc(1ull, len);
    ssl->out_buf = (unsigned char *)return_value$0;
    tmp_if_expr = ssl->out_buf == ((unsigned char *)NULL) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr)
  {
    mbedtls_free((void *)ssl->in_buf);
    ssl->in_buf = ((unsigned char *)NULL);
    return -0x7F00;
  }

  else
  {
    ssl->out_ctr = ssl->out_buf;
    ssl->out_hdr = ssl->out_buf + 8ll;
    ssl->out_len = ssl->out_buf + 11ll;
    ssl->out_iv = ssl->out_buf + 13ll;
    ssl->out_msg = ssl->out_buf + 13ll;
    ssl->in_ctr = ssl->in_buf;
    ssl->in_hdr = ssl->in_buf + 8ll;
    ssl->in_len = ssl->in_buf + 11ll;
    ssl->in_iv = ssl->in_buf + 13ll;
    ssl->in_msg = ssl->in_buf + 13ll;
    ret=ssl_handshake_init(ssl);
    if(!(ret == 0))
      return ret;

    else
      return 0;
  }
}

// mbedtls_ssl_sig_from_pk
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7837
unsigned char mbedtls_ssl_sig_from_pk(mbedtls_pk_context *pk)
{
  signed int return_value_mbedtls_pk_can_do=mbedtls_pk_can_do(pk, /*enum*/MBEDTLS_PK_RSA);
  if(!(return_value_mbedtls_pk_can_do == 0))
    return 1;

  else
  {
    signed int return_value_mbedtls_pk_can_do$0=mbedtls_pk_can_do(pk, /*enum*/MBEDTLS_PK_ECDSA);
    if(!(return_value_mbedtls_pk_can_do$0 == 0))
      return 3;

    else
      return 0;
  }
}

// mbedtls_ssl_sig_from_pk_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7851
unsigned char mbedtls_ssl_sig_from_pk_alg(mbedtls_pk_type_t type)
{
  switch((signed int)type)
  {
    case 1:
      return 1;
    case 4:

    case 2:
      return 3;
    default:
      return 0;
  }
}

// mbedtls_ssl_sig_hash_set_add
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7900
void mbedtls_ssl_sig_hash_set_add(mbedtls_ssl_sig_hash_set_t *set, mbedtls_pk_type_t sig_alg, mbedtls_md_type_t md_alg)
{
  switch((signed int)sig_alg)
  {
    case 1:
    {
      if((signed int)set->rsa == 0)
        set->rsa = md_alg;

      break;
    }
    case 4:
    {
      if((signed int)set->ecdsa == 0)
        set->ecdsa = md_alg;

      break;
    }
    default:
      ;
  }
}

// mbedtls_ssl_sig_hash_set_const_hash
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7922
void mbedtls_ssl_sig_hash_set_const_hash(mbedtls_ssl_sig_hash_set_t *set, mbedtls_md_type_t md_alg)
{
  set->rsa = md_alg;
  set->ecdsa = md_alg;
}

// mbedtls_ssl_sig_hash_set_find
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7885
mbedtls_md_type_t mbedtls_ssl_sig_hash_set_find(mbedtls_ssl_sig_hash_set_t *set, mbedtls_pk_type_t sig_alg)
{
  switch((signed int)sig_alg)
  {
    case 1:
      return set->rsa;
    case 4:
      return set->ecdsa;
    default:
      return /*enum*/MBEDTLS_MD_NONE;
  }
}

// mbedtls_ssl_sig_hash_set_init
// file ..\..\..\..\lib\third_party\mbedtls\include\mbedtls/ssl_internal.h line 392
static inline void mbedtls_ssl_sig_hash_set_init(mbedtls_ssl_sig_hash_set_t *set)
{
  mbedtls_ssl_sig_hash_set_const_hash(set, /*enum*/MBEDTLS_MD_NONE);
}

// mbedtls_ssl_transform_free
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7379
void mbedtls_ssl_transform_free(mbedtls_ssl_transform *transform)
{
  if(!(transform == ((mbedtls_ssl_transform *)NULL)))
  {
    mbedtls_cipher_free(&transform->cipher_ctx_enc);
    mbedtls_cipher_free(&transform->cipher_ctx_dec);
    mbedtls_md_free(&transform->md_ctx_enc);
    mbedtls_md_free(&transform->md_ctx_dec);
    mbedtls_zeroize$link16((void *)transform, sizeof(mbedtls_ssl_transform) /*304ull*/ );
  }

}

// mbedtls_ssl_update_handshake_status
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 3231
void mbedtls_ssl_update_handshake_status(mbedtls_ssl_context *ssl)
{
  if(!(ssl->state == 16))
  {
    if(!(ssl->handshake == ((mbedtls_ssl_handshake_params *)NULL)))
      ssl->handshake->update_checksum(ssl, ssl->in_msg, ssl->in_hslen);

  }

}

// mbedtls_ssl_write
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7311
signed int mbedtls_ssl_write(mbedtls_ssl_context *ssl, const unsigned char *buf, size_t len)
{
  signed int ret;
  while((_Bool)0)
    ;
  _Bool tmp_if_expr;
  if(ssl == ((mbedtls_ssl_context *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ssl->conf == ((const mbedtls_ssl_config *)NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return -0x7100;

  else
  {
    if(!(ssl->state == 16))
    {
      ret=mbedtls_ssl_handshake(ssl);
      if(!(ret == 0))
      {
        while((_Bool)0)
          ;
        return ret;
      }

    }

    ret=ssl_write_real(ssl, buf, len);
    while((_Bool)0)
      ;
    return ret;
  }
}

// mbedtls_ssl_write_certificate
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 4251
signed int mbedtls_ssl_write_certificate(mbedtls_ssl_context *ssl)
{
  signed int ret=-0x7080;
  size_t i;
  size_t n;
  const mbedtls_x509_crt *crt;
  const mbedtls_ssl_ciphersuite_t *ciphersuite_info=ssl->transform_negotiate->ciphersuite_info;
  while((_Bool)0)
    ;
  _Bool tmp_if_expr;
  if((signed int)ciphersuite_info->key_exchange == 5)
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = (signed int)ciphersuite_info->key_exchange == 6 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$0;
  if(tmp_if_expr)
    tmp_if_expr$0 = (_Bool)1;

  else
    tmp_if_expr$0 = (signed int)ciphersuite_info->key_exchange == 8 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$1;
  if(tmp_if_expr$0)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)ciphersuite_info->key_exchange == 11 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    while((_Bool)0)
      ;
    ssl->state = ssl->state + 1;
    return 0;
  }

  else
  {
    if((signed int)ssl->conf->endpoint == 0)
    {
      if(ssl->client_auth == 0)
      {
        while((_Bool)0)
          ;
        ssl->state = ssl->state + 1;
        return 0;
      }

    }

    while((_Bool)0)
      ;
    i = 7ull;
    crt=mbedtls_ssl_own_cert$link1(ssl);
    for( ; !(crt == ((const mbedtls_x509_crt *)NULL)); crt = crt->next)
    {
      n = crt->raw.len;
      if(!(8189ull + -i >= n))
      {
        while((_Bool)0)
          ;
        return -0x7500;
      }

      ssl->out_msg[(signed long long int)i] = (unsigned char)(n >> 16);
      ssl->out_msg[(signed long long int)(i + 1ull)] = (unsigned char)(n >> 8);
      ssl->out_msg[(signed long long int)(i + 2ull)] = (unsigned char)n;
      i = i + 3ull;
      memcpy((void *)(ssl->out_msg + (signed long long int)i), (const void *)crt->raw.p, n);
      i = i + n;
    }
    ssl->out_msg[4ll] = (unsigned char)(i - 7ull >> 16);
    ssl->out_msg[5ll] = (unsigned char)(i - 7ull >> 8);
    ssl->out_msg[6ll] = (unsigned char)(i - 7ull);
    ssl->out_msglen = i;
    ssl->out_msgtype = 22;
    ssl->out_msg[0ll] = 11;
    ssl->state = ssl->state + 1;
    ret=mbedtls_ssl_write_record(ssl);
    if(!(ret == 0))
    {
      while((_Bool)0)
        ;
      return ret;
    }

    else
    {
      while((_Bool)0)
        ;
      return ret;
    }
  }
}

// mbedtls_ssl_write_change_cipher_spec
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 4751
signed int mbedtls_ssl_write_change_cipher_spec(mbedtls_ssl_context *ssl)
{
  signed int ret;
  while((_Bool)0)
    ;
  ssl->out_msgtype = 20;
  ssl->out_msglen = 1ull;
  ssl->out_msg[0ll] = 1;
  ssl->state = ssl->state + 1;
  ret=mbedtls_ssl_write_record(ssl);
  if(!(ret == 0))
  {
    while((_Bool)0)
      ;
    return ret;
  }

  else
  {
    while((_Bool)0)
      ;
    return 0;
  }
}

// mbedtls_ssl_write_finished
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5284
signed int mbedtls_ssl_write_finished(mbedtls_ssl_context *ssl)
{
  signed int ret;
  signed int hash_len;
  while((_Bool)0)
    ;
  if(ssl->minor_ver >= 2)
    ssl->out_msg = (ssl->out_iv + (signed long long int)ssl->transform_negotiate->ivlen) - (signed long long int)ssl->transform_negotiate->fixed_ivlen;

  else
    ssl->out_msg = ssl->out_iv;
  ssl->handshake->calc_finished(ssl, ssl->out_msg + 4ll, (signed int)ssl->conf->endpoint);
  hash_len = ssl->minor_ver == 0 ? 36 : 12;
  ssl->out_msglen = (size_t)(4 + hash_len);
  ssl->out_msgtype = 22;
  ssl->out_msg[0ll] = 20;
  if(!(ssl->handshake->resume == 0))
  {
    if((signed int)ssl->conf->endpoint == 0)
      ssl->state = 15;

  }

  else
    ssl->state = ssl->state + 1;
  memset((void *)ssl->out_ctr, 0, 8ull);
  ssl->transform_out = ssl->transform_negotiate;
  ssl->session_out = ssl->session_negotiate;
  ret=mbedtls_ssl_write_record(ssl);
  if(!(ret == 0))
    return ret;

  else
    return 0;
}

// mbedtls_ssl_write_record
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 2758
signed int mbedtls_ssl_write_record(mbedtls_ssl_context *ssl)
{
  signed int ret;
  signed int done=0;
  signed int out_msg_type;
  size_t len=ssl->out_msglen;
  while((_Bool)0)
    ;
  if(ssl->out_msgtype == 22)
  {
    out_msg_type = (signed int)ssl->out_msg[0ll];
    if(!(out_msg_type == 0))
    {
      if(ssl->handshake == ((mbedtls_ssl_handshake_params *)NULL))
      {
        while((_Bool)0)
          ;
        return -0x6C00;
      }

    }

    ssl->out_msg[1ll] = (unsigned char)(len - 4ull >> 16);
    ssl->out_msg[2ll] = (unsigned char)(len - 4ull >> 8);
    ssl->out_msg[3ll] = (unsigned char)(len - 4ull);
    if(!(out_msg_type == 0))
      ssl->handshake->update_checksum(ssl, ssl->out_msg, len);

  }

  if(done == 0)
  {
    ssl->out_hdr[0ll] = (unsigned char)ssl->out_msgtype;
    mbedtls_ssl_write_version(ssl->major_ver, ssl->minor_ver, (signed int)ssl->conf->transport, ssl->out_hdr + 1ll);
    ssl->out_len[0ll] = (unsigned char)(len >> 8);
    ssl->out_len[1ll] = (unsigned char)len;
    if(!(ssl->transform_out == ((mbedtls_ssl_transform *)NULL)))
    {
      ret=ssl_encrypt_buf(ssl);
      if(!(ret == 0))
      {
        while((_Bool)0)
          ;
        return ret;
      }

      len = ssl->out_msglen;
      ssl->out_len[0ll] = (unsigned char)(len >> 8);
      ssl->out_len[1ll] = (unsigned char)len;
    }

    size_t return_value_mbedtls_ssl_hdr_len=mbedtls_ssl_hdr_len(ssl);
    ssl->out_left = return_value_mbedtls_ssl_hdr_len + ssl->out_msglen;
    while((_Bool)0)
      ;
    while((_Bool)0)
      ;
  }

  ret=mbedtls_ssl_flush_output(ssl);
  if(!(ret == 0))
  {
    while((_Bool)0)
      ;
    return ret;
  }

  else
  {
    while((_Bool)0)
      ;
    return 0;
  }
}

// mbedtls_ssl_write_version
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 8138
void mbedtls_ssl_write_version(signed int major, signed int minor, signed int transport, unsigned char *ver)
{
  (void)transport;
  ver[0ll] = (unsigned char)major;
  ver[1ll] = (unsigned char)minor;
}

// mbedtls_version_check_feature
// file ..\..\..\..\lib\third_party\mbedtls\library\version_features.c line 706
signed int mbedtls_version_check_feature(const char *feature)
{
  const char **idx=features;
  if(*idx == ((const char *)NULL))
    return -2;

  else
    if(feature == ((const char *)NULL))
      return -1;

    else
    {
      while(!(*idx == ((const char *)NULL)))
      {
        signed int return_value_strcmp=strcmp(*idx, feature);
        if(return_value_strcmp == 0)
          return 0;

        idx = idx + 1ll;
      }
      return -1;
    }
}

// mbedtls_version_get_number
// file ..\..\..\..\lib\third_party\mbedtls\library\version.c line 33
unsigned int mbedtls_version_get_number(void)
{
  return 34078720u;
}

// mbedtls_version_get_string
// file ..\..\..\..\lib\third_party\mbedtls\library\version.c line 38
void mbedtls_version_get_string(char *string)
{
  memcpy((void *)string, (const void *)"2.8.0", sizeof(char [6ll]) /*6ull*/ );
}

// mbedtls_version_get_string_full
// file ..\..\..\..\lib\third_party\mbedtls\library\version.c line 44
void mbedtls_version_get_string_full(char *string)
{
  memcpy((void *)string, (const void *)"mbed TLS 2.8.0", sizeof(char [15ll]) /*15ull*/ );
}

// mbedtls_x509_crt_check_extended_key_usage
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 1597
signed int mbedtls_x509_crt_check_extended_key_usage(const mbedtls_x509_crt *crt, const char *usage_oid, size_t usage_len)
{
  const mbedtls_x509_sequence *cur;
  signed int return_value_memcmp;
  signed int return_value_memcmp$0;
  if((2048 & crt->ext_types) == 0)
    return 0;

  else
  {
    cur = &crt->ext_key_usage;
    for( ; !(cur == ((const mbedtls_x509_sequence *)NULL)); cur = cur->next)
    {
      const mbedtls_x509_buf *cur_oid=&cur->buf;
      if(cur_oid->len == usage_len)
      {
        return_value_memcmp=memcmp((const void *)cur_oid->p, (const void *)usage_oid, usage_len);
        if(return_value_memcmp == 0)
          return 0;

      }

      _Bool tmp_if_expr;
      if(!(cur_oid->len == 4ull))
        tmp_if_expr = (_Bool)1;

      else
      {
        return_value_memcmp$0=memcmp((const void *)"U\%\0", (const void *)cur_oid->p, cur_oid->len);
        tmp_if_expr = return_value_memcmp$0 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr)
        return 0;

    }
    return -0x2800;
  }
}

// mbedtls_x509_crt_check_key_usage
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 1572
signed int mbedtls_x509_crt_check_key_usage(const mbedtls_x509_crt *crt, unsigned int usage)
{
  unsigned int usage_must;
  unsigned int usage_may;
  unsigned int may_mask=(unsigned int)(0x1 | 0x8000);
  if((4 & crt->ext_types) == 0)
    return 0;

  else
  {
    usage_must = usage & ~may_mask;
    if(!((~may_mask & crt->key_usage & usage_must) == usage_must))
      return -0x2800;

    else
    {
      usage_may = usage & may_mask;
      if(!((crt->key_usage & may_mask | usage_may) == usage_may))
        return -0x2800;

      else
        return 0;
    }
  }
}

// mbedtls_x509_crt_free
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 2404
void mbedtls_x509_crt_free(mbedtls_x509_crt *crt)
{
  mbedtls_x509_crt *cert_cur=crt;
  mbedtls_x509_crt *cert_prv;
  mbedtls_x509_name *name_cur;
  mbedtls_x509_name *name_prv;
  mbedtls_x509_sequence *seq_cur;
  mbedtls_x509_sequence *seq_prv;
  if(!(crt == ((mbedtls_x509_crt *)NULL)))
  {
    do
    {
      mbedtls_pk_free(&cert_cur->pk);
      name_cur = cert_cur->issuer.next;
      if(!(name_cur == ((mbedtls_x509_name *)NULL)))
      {
        name_prv = name_cur;
        name_cur = name_cur->next;
        mbedtls_zeroize$link17((void *)name_prv, sizeof(mbedtls_x509_name) /*64ull*/ );
        mbedtls_free((void *)name_prv);
      }

      name_cur = cert_cur->subject.next;
      if(!(name_cur == ((mbedtls_x509_name *)NULL)))
      {
        name_prv = name_cur;
        name_cur = name_cur->next;
        mbedtls_zeroize$link17((void *)name_prv, sizeof(mbedtls_x509_name) /*64ull*/ );
        mbedtls_free((void *)name_prv);
      }

      seq_cur = cert_cur->ext_key_usage.next;
      if(!(seq_cur == ((mbedtls_x509_sequence *)NULL)))
      {
        seq_prv = seq_cur;
        seq_cur = seq_cur->next;
        mbedtls_zeroize$link17((void *)seq_prv, sizeof(mbedtls_x509_sequence) /*32ull*/ );
        mbedtls_free((void *)seq_prv);
      }

      seq_cur = cert_cur->subject_alt_names.next;
      if(!(seq_cur == ((mbedtls_x509_sequence *)NULL)))
      {
        seq_prv = seq_cur;
        seq_cur = seq_cur->next;
        mbedtls_zeroize$link17((void *)seq_prv, sizeof(mbedtls_x509_sequence) /*32ull*/ );
        mbedtls_free((void *)seq_prv);
      }

      if(!(cert_cur->raw.p == ((unsigned char *)NULL)))
      {
        mbedtls_zeroize$link17((void *)cert_cur->raw.p, cert_cur->raw.len);
        mbedtls_free((void *)cert_cur->raw.p);
      }

      cert_cur = cert_cur->next;
    }
    while(!(cert_cur == ((mbedtls_x509_crt *)NULL)));
    cert_cur = crt;
    do
    {
      cert_prv = cert_cur;
      cert_cur = cert_cur->next;
      mbedtls_zeroize$link17((void *)cert_prv, sizeof(mbedtls_x509_crt) /*552ull*/ );
      if(!(cert_prv == crt))
        mbedtls_free((void *)cert_prv);

    }
    while(!(cert_cur == ((mbedtls_x509_crt *)NULL)));
  }

}

// mbedtls_x509_crt_info
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 1382
signed int mbedtls_x509_crt_info(char *buf, size_t size, const char *prefix, const mbedtls_x509_crt *crt)
{
  signed int ret;
  size_t n;
  char *p;
  char key_size_str[18ll];
  p = buf;
  n = size;
  if(crt == ((const mbedtls_x509_crt *)NULL))
  {
    ret=mbedtls_snprintf(p, n, "\nCertificate is uninitialised!\n");
    if((size_t)ret >= n || !(ret >= 0))
      return -0x2980;

    n = n - (size_t)ret;
    p = p + (signed long long int)(size_t)ret;
    return (signed int)(size - n);
  }

  else
  {
    ret=mbedtls_snprintf(p, n, "%scert. version     : %d\n", prefix, crt->version);
    if((size_t)ret >= n || !(ret >= 0))
      return -0x2980;

    else
    {
      n = n - (size_t)ret;
      p = p + (signed long long int)(size_t)ret;
      ret=mbedtls_snprintf(p, n, "%sserial number     : ", prefix);
      if((size_t)ret >= n || !(ret >= 0))
        return -0x2980;

      else
      {
        n = n - (size_t)ret;
        p = p + (signed long long int)(size_t)ret;
        ret=mbedtls_x509_serial_gets(p, n, &crt->serial);
        if((size_t)ret >= n || !(ret >= 0))
          return -0x2980;

        else
        {
          n = n - (size_t)ret;
          p = p + (signed long long int)(size_t)ret;
          ret=mbedtls_snprintf(p, n, "\n%sissuer name       : ", prefix);
          if((size_t)ret >= n || !(ret >= 0))
            return -0x2980;

          else
          {
            n = n - (size_t)ret;
            p = p + (signed long long int)(size_t)ret;
            ret=mbedtls_x509_dn_gets(p, n, &crt->issuer);
            if((size_t)ret >= n || !(ret >= 0))
              return -0x2980;

            else
            {
              n = n - (size_t)ret;
              p = p + (signed long long int)(size_t)ret;
              ret=mbedtls_snprintf(p, n, "\n%ssubject name      : ", prefix);
              if((size_t)ret >= n || !(ret >= 0))
                return -0x2980;

              else
              {
                n = n - (size_t)ret;
                p = p + (signed long long int)(size_t)ret;
                ret=mbedtls_x509_dn_gets(p, n, &crt->subject);
                if((size_t)ret >= n || !(ret >= 0))
                  return -0x2980;

                else
                {
                  n = n - (size_t)ret;
                  p = p + (signed long long int)(size_t)ret;
                  ret=mbedtls_snprintf(p, n, "\n%sissued  on        : %04d-%02d-%02d %02d:%02d:%02d", prefix, crt->valid_from.year, crt->valid_from.mon, crt->valid_from.day, crt->valid_from.hour, crt->valid_from.min, crt->valid_from.sec);
                  if((size_t)ret >= n || !(ret >= 0))
                    return -0x2980;

                  else
                  {
                    n = n - (size_t)ret;
                    p = p + (signed long long int)(size_t)ret;
                    ret=mbedtls_snprintf(p, n, "\n%sexpires on        : %04d-%02d-%02d %02d:%02d:%02d", prefix, crt->valid_to.year, crt->valid_to.mon, crt->valid_to.day, crt->valid_to.hour, crt->valid_to.min, crt->valid_to.sec);
                    if((size_t)ret >= n || !(ret >= 0))
                      return -0x2980;

                    else
                    {
                      n = n - (size_t)ret;
                      p = p + (signed long long int)(size_t)ret;
                      ret=mbedtls_snprintf(p, n, "\n%ssigned using      : ", prefix);
                      if((size_t)ret >= n || !(ret >= 0))
                        return -0x2980;

                      else
                      {
                        n = n - (size_t)ret;
                        p = p + (signed long long int)(size_t)ret;
                        ret=mbedtls_x509_sig_alg_gets(p, n, &crt->sig_oid, crt->sig_pk, crt->sig_md, crt->sig_opts);
                        if((size_t)ret >= n || !(ret >= 0))
                          return -0x2980;

                        else
                        {
                          n = n - (size_t)ret;
                          p = p + (signed long long int)(size_t)ret;
                          const char *return_value_mbedtls_pk_get_name=mbedtls_pk_get_name(&crt->pk);
                          ret=mbedtls_x509_key_size_helper(key_size_str, 18ull, return_value_mbedtls_pk_get_name);
                          if(!(ret == 0))
                            return ret;

                          else
                          {
                            size_t return_value_mbedtls_pk_get_bitlen=mbedtls_pk_get_bitlen(&crt->pk);
                            ret=mbedtls_snprintf(p, n, "\n%s%-18s: %d bits", prefix, (const void *)key_size_str, (signed int)return_value_mbedtls_pk_get_bitlen);
                            if((size_t)ret >= n || !(ret >= 0))
                              return -0x2980;

                            else
                            {
                              n = n - (size_t)ret;
                              p = p + (signed long long int)(size_t)ret;
                              if(!((256 & crt->ext_types) == 0))
                              {
                                ret=mbedtls_snprintf(p, n, "\n%sbasic constraints : CA=%s", prefix, crt->ca_istrue != 0 ? "true" : "false");
                                if((size_t)ret >= n || !(ret >= 0))
                                  return -0x2980;

                                n = n - (size_t)ret;
                                p = p + (signed long long int)(size_t)ret;
                                if(crt->max_pathlen >= 1)
                                {
                                  ret=mbedtls_snprintf(p, n, ", max_pathlen=%d", crt->max_pathlen - 1);
                                  if((size_t)ret >= n || !(ret >= 0))
                                    return -0x2980;

                                  n = n - (size_t)ret;
                                  p = p + (signed long long int)(size_t)ret;
                                }

                              }

                              if(!((32 & crt->ext_types) == 0))
                              {
                                ret=mbedtls_snprintf(p, n, "\n%ssubject alt name  : ", prefix);
                                if((size_t)ret >= n || !(ret >= 0))
                                  return -0x2980;

                                n = n - (size_t)ret;
                                p = p + (signed long long int)(size_t)ret;
                                ret=x509_info_subject_alt_name(&p, &n, &crt->subject_alt_names);
                                if(!(ret == 0))
                                  return ret;

                              }

                              if(!((65536 & crt->ext_types) == 0))
                              {
                                ret=mbedtls_snprintf(p, n, "\n%scert. type        : ", prefix);
                                if((size_t)ret >= n || !(ret >= 0))
                                  return -0x2980;

                                n = n - (size_t)ret;
                                p = p + (signed long long int)(size_t)ret;
                                ret=x509_info_cert_type(&p, &n, crt->ns_cert_type);
                                if(!(ret == 0))
                                  return ret;

                              }

                              if(!((4 & crt->ext_types) == 0))
                              {
                                ret=mbedtls_snprintf(p, n, "\n%skey usage         : ", prefix);
                                if((size_t)ret >= n || !(ret >= 0))
                                  return -0x2980;

                                n = n - (size_t)ret;
                                p = p + (signed long long int)(size_t)ret;
                                ret=x509_info_key_usage(&p, &n, crt->key_usage);
                                if(!(ret == 0))
                                  return ret;

                              }

                              if(!((2048 & crt->ext_types) == 0))
                              {
                                ret=mbedtls_snprintf(p, n, "\n%sext key usage     : ", prefix);
                                if((size_t)ret >= n || !(ret >= 0))
                                  return -0x2980;

                                n = n - (size_t)ret;
                                p = p + (signed long long int)(size_t)ret;
                                ret=x509_info_ext_key_usage(&p, &n, &crt->ext_key_usage);
                                if(!(ret == 0))
                                  return ret;

                              }

                              ret=mbedtls_snprintf(p, n, "\n");
                              if((size_t)ret >= n || !(ret >= 0))
                                return -0x2980;

                              else
                              {
                                n = n - (size_t)ret;
                                p = p + (signed long long int)(size_t)ret;
                                return (signed int)(size - n);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// mbedtls_x509_crt_init
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 2396
void mbedtls_x509_crt_init(mbedtls_x509_crt *crt)
{
  memset((void *)crt, 0, sizeof(mbedtls_x509_crt) /*552ull*/ );
}

// mbedtls_x509_crt_parse
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 992
signed int mbedtls_x509_crt_parse(mbedtls_x509_crt *chain, const unsigned char *buf, size_t buflen)
{
  signed int success=0;
  signed int first_error=0;
  signed int total_failed=0;
  signed int buf_format=1;
  char *return_value_strstr;
  signed int return_value_mbedtls_x509_crt_parse_der;
  if(chain == ((mbedtls_x509_crt *)NULL) || buf == ((const unsigned char *)NULL))
    return -0x2800;

  else
  {
    if(!(buflen == 0ull))
    {
      if((signed int)buf[-1ll + (signed long long int)buflen] == 0)
      {
        return_value_strstr=strstr((const char *)buf, "-----BEGIN CERTIFICATE-----");
        if(!(return_value_strstr == ((char *)NULL)))
          buf_format = 2;

      }

    }

    if(buf_format == 1)
    {
      return_value_mbedtls_x509_crt_parse_der=mbedtls_x509_crt_parse_der(chain, buf, buflen);
      return return_value_mbedtls_x509_crt_parse_der;
    }

    else
    {
      if(buf_format == 2)
      {
        signed int ret;
        mbedtls_pem_context pem;
        while(buflen >= 2ull)
        {
          size_t use_len;
          mbedtls_pem_init(&pem);
          ret=mbedtls_pem_read_buffer(&pem, "-----BEGIN CERTIFICATE-----", "-----END CERTIFICATE-----", buf, ((const unsigned char *)NULL), 0ull, &use_len);
          if(ret == 0)
          {
            buflen = buflen - use_len;
            buf = buf + (signed long long int)use_len;
          }

          else
            if(ret == -5248)
              return ret;

            else
              if(!(ret == -4224))
              {
                mbedtls_pem_free(&pem);
                buflen = buflen - use_len;
                buf = buf + (signed long long int)use_len;
                if(first_error == 0)
                  first_error = ret;

                total_failed = total_failed + 1;
                continue;
              }

              else
                break;
          ret=mbedtls_x509_crt_parse_der(chain, pem.buf, pem.buflen);
          mbedtls_pem_free(&pem);
          if(!(ret == 0))
          {
            if(ret == -10368)
              return ret;

            if(first_error == 0)
              first_error = ret;

            total_failed = total_failed + 1;
          }

          else
            success = 1;
        }
      }

      if(!(success == 0))
        return total_failed;

      else
        if(!(first_error == 0))
          return first_error;

        else
          return -0x2780;
    }
  }
}

// mbedtls_x509_crt_parse_der
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 941
signed int mbedtls_x509_crt_parse_der(mbedtls_x509_crt *chain, const unsigned char *buf, size_t buflen)
{
  signed int ret;
  mbedtls_x509_crt *crt=chain;
  mbedtls_x509_crt *prev=((mbedtls_x509_crt *)NULL);
  if(crt == ((mbedtls_x509_crt *)NULL) || buf == ((const unsigned char *)NULL))
    return -0x2800;

  else
  {
    for( ; !(crt->version == 0); crt = crt->next)
    {
      if(crt->next == ((struct mbedtls_x509_crt *)NULL))
        break;

      prev = crt;
    }
    if(!(crt->version == 0))
    {
      if(crt->next == ((struct mbedtls_x509_crt *)NULL))
      {
        void *return_value=mbedtls_calloc(1ull, sizeof(mbedtls_x509_crt) /*552ull*/ );
        crt->next = (struct mbedtls_x509_crt *)return_value;
        if(crt->next == ((struct mbedtls_x509_crt *)NULL))
          return -0x2880;

        prev = crt;
        mbedtls_x509_crt_init(crt->next);
        crt = crt->next;
      }

    }

    ret=x509_crt_parse_der_core(crt, buf, buflen);
    if(!(ret == 0))
    {
      if(!(prev == ((mbedtls_x509_crt *)NULL)))
        prev->next = ((struct mbedtls_x509_crt *)NULL);

      if(!(crt == chain))
        mbedtls_free((void *)crt);

      return ret;
    }

    else
      return 0;
  }
}

// mbedtls_x509_crt_verify
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 2306
signed int mbedtls_x509_crt_verify(mbedtls_x509_crt *crt, mbedtls_x509_crt *trust_ca, mbedtls_x509_crl *ca_crl, const char *cn, uint32_t *flags, signed int (*f_vrfy)(void *, mbedtls_x509_crt *, signed int, uint32_t *), void *p_vrfy)
{
  signed int return_value_mbedtls_x509_crt_verify_with_profile=mbedtls_x509_crt_verify_with_profile(crt, trust_ca, ca_crl, &mbedtls_x509_crt_profile_default, cn, flags, f_vrfy, p_vrfy);
  return return_value_mbedtls_x509_crt_verify_with_profile;
}

// mbedtls_x509_crt_verify_info
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 1543
signed int mbedtls_x509_crt_verify_info(char *buf, size_t size, const char *prefix, uint32_t flags)
{
  signed int ret;
  const struct x509_crt_verify_string *cur;
  char *p=buf;
  size_t n=size;
  cur = x509_crt_verify_strings;
  for( ; !(cur->string == ((const char *)NULL)); cur = cur + 1ll)
    if(!((flags & (unsigned int)cur->code) == 0u))
    {
      ret=mbedtls_snprintf(p, n, "%s%s\n", prefix, cur->string);
      if((size_t)ret >= n || !(ret >= 0))
        return -0x2980;

      n = n - (size_t)ret;
      p = p + (signed long long int)(size_t)ret;
      flags = flags ^ (uint32_t)cur->code;
    }

  if(!(flags == 0u))
  {
    ret=mbedtls_snprintf(p, n, "%sUnknown reason (this should not happen)\n", prefix);
    if((size_t)ret >= n || !(ret >= 0))
      return -0x2980;

    n = n - (size_t)ret;
    p = p + (signed long long int)(size_t)ret;
  }

  return (signed int)(size - n);
}

// mbedtls_x509_crt_verify_with_profile
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 2327
signed int mbedtls_x509_crt_verify_with_profile(mbedtls_x509_crt *crt, mbedtls_x509_crt *trust_ca, mbedtls_x509_crl *ca_crl, const mbedtls_x509_crt_profile *profile, const char *cn, uint32_t *flags, signed int (*f_vrfy)(void *, mbedtls_x509_crt *, signed int, uint32_t *), void *p_vrfy)
{
  signed int ret;
  mbedtls_pk_type_t pk_type;
  x509_crt_verify_chain_item ver_chain[10ll];
  size_t chain_len;
  uint32_t *ee_flags=&ver_chain[0ll].flags;
  *flags = 0u;
  memset((void *)ver_chain, 0, sizeof(x509_crt_verify_chain_item [10ll]) /*160ull*/ );
  chain_len = 0ull;
  signed int return_value_x509_profile_check_pk_alg;
  signed int return_value_x509_profile_check_key;
  if(profile == ((const mbedtls_x509_crt_profile *)NULL))
    ret = -0x2800;

  else
  {
    if(!(cn == ((const char *)NULL)))
      x509_crt_verify_name(crt, cn, ee_flags);

    pk_type=mbedtls_pk_get_type(&crt->pk);
    return_value_x509_profile_check_pk_alg=x509_profile_check_pk_alg(profile, pk_type);
    if(!(return_value_x509_profile_check_pk_alg == 0))
      *ee_flags = *ee_flags | 32768u;

    return_value_x509_profile_check_key=x509_profile_check_key(profile, &crt->pk);
    if(!(return_value_x509_profile_check_key == 0))
      *ee_flags = *ee_flags | 65536u;

    ret=x509_crt_verify_chain(crt, trust_ca, ca_crl, profile, ver_chain, &chain_len);
    if(ret == 0)
      ret=x509_crt_merge_flags_with_cb(flags, ver_chain, chain_len, f_vrfy, p_vrfy);

  }

exit:
  ;
  if(ret == -9984)
    ret = -0x3000;

  if(!(ret == 0))
  {
    *flags = (uint32_t)-1;
    return ret;
  }

  else
    if(!(*flags == 0u))
      return -0x2700;

    else
      return 0;
}

// mbedtls_x509_dn_gets
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 748
signed int mbedtls_x509_dn_gets(char *buf, size_t size, const mbedtls_x509_name *dn)
{
  signed int ret;
  size_t i;
  size_t n;
  unsigned char c;
  unsigned char merge=0;
  const mbedtls_x509_name *name;
  const char *short_name=((const char *)NULL);
  char s[256ll];
  char *p;
  memset((void *)s, 0, sizeof(char [256ll]) /*256ull*/ );
  name = dn;
  p = buf;
  n = size;
  while(!(name == ((const mbedtls_x509_name *)NULL)))
    if(name->oid.p == ((unsigned char *)NULL))
      name = name->next;

    else
    {
      if(!(name == dn))
      {
        ret=mbedtls_snprintf(p, n, merge != 0 ? " + " : ", ");
        if((size_t)ret >= n || !(ret >= 0))
          return -0x2980;

        n = n - (size_t)ret;
        p = p + (signed long long int)(size_t)ret;
      }

      ret=mbedtls_oid_get_attr_short_name(&name->oid, &short_name);
      if(ret == 0)
        ret=mbedtls_snprintf(p, n, "%s=", short_name);

      else
        ret=mbedtls_snprintf(p, n, "??=");
      if((size_t)ret >= n || !(ret >= 0))
        return -0x2980;

      n = n - (size_t)ret;
      p = p + (signed long long int)(size_t)ret;
      i = 0ull;
      if(!(i >= name->val.len))
      {
        if(!(i >= 255ull))
        {
          c = name->val.p[(signed long long int)i];
          if((signed int)c == 127 || (signed int)c >= 129 && !((signed int)c >= 160) || !((signed int)c >= 32))
            s[(signed long long int)i] = '?';

          else
            s[(signed long long int)i] = (char)c;
          i = i + 1ull;
        }

      }

      s[(signed long long int)i] = 0;
      ret=mbedtls_snprintf(p, n, "%s", (const void *)s);
      if((size_t)ret >= n || !(ret >= 0))
        return -0x2980;

      n = n - (size_t)ret;
      p = p + (signed long long int)(size_t)ret;
      merge = name->next_merged;
      name = name->next;
    }
  return (signed int)(size - n);
}

// mbedtls_x509_get_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 133
signed int mbedtls_x509_get_alg(unsigned char **p, const unsigned char *end, mbedtls_x509_buf *alg, mbedtls_x509_buf *params)
{
  signed int ret=mbedtls_asn1_get_alg(p, end, alg, params);
  if(!(ret == 0))
    return -0x2300 + ret;

  else
    return 0;
}

// mbedtls_x509_get_alg_null
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 119
signed int mbedtls_x509_get_alg_null(unsigned char **p, const unsigned char *end, mbedtls_x509_buf *alg)
{
  signed int ret=mbedtls_asn1_get_alg_null(p, end, alg);
  if(!(ret == 0))
    return -0x2300 + ret;

  else
    return 0;
}

// mbedtls_x509_get_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 707
signed int mbedtls_x509_get_ext(unsigned char **p, const unsigned char *end, mbedtls_x509_buf *ext, signed int mbedtls_x509_get_ext$$tag)
{
  signed int ret;
  size_t len;
  if(*p == end)
    return 0;

  else
  {
    ext->tag = (signed int)*(*p);
    ret=mbedtls_asn1_get_tag(p, end, &ext->len, 0x80 | 0x20 | mbedtls_x509_get_ext$$tag);
    if(!(ret == 0))
      return ret;

    else
    {
      ext->p = *p;
      end = *p + (signed long long int)ext->len;
      ret=mbedtls_asn1_get_tag(p, end, &len, 0x20 | 0x10);
      if(!(ret == 0))
        return -0x2500 + ret;

      else
        if(!(end == *p + (signed long long int)len))
          return -0x2500 + -0x66;

        else
          return 0;
    }
  }
}

// mbedtls_x509_get_name
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 430
signed int mbedtls_x509_get_name(unsigned char **p, const unsigned char *end, mbedtls_x509_name *cur)
{
  signed int ret;
  size_t set_len;
  const unsigned char *end_set;
  {
    ret=mbedtls_asn1_get_tag(p, end, &set_len, 0x20 | 0x11);
    if(!(ret == 0))
      return -0x2380 + ret;

    end_set = *p + (signed long long int)set_len;
    ret=x509_get_attr_type_value(p, end_set, cur);
    if(!(ret == 0))
      return ret;

    if(!(*p == end_set))
    {
      cur->next_merged = 1;
      void *return_value=mbedtls_calloc(1ull, sizeof(mbedtls_x509_name) /*64ull*/ );
      cur->next = (struct mbedtls_asn1_named_data *)return_value;
      if(cur->next == ((struct mbedtls_asn1_named_data *)NULL))
        return -0x2880;

      cur = cur->next;
    }

    if(*p == end)
      return 0;

    void *return_value$0=mbedtls_calloc(1ull, sizeof(mbedtls_x509_name) /*64ull*/ );
    cur->next = (struct mbedtls_asn1_named_data *)return_value$0;
    if(cur->next == ((struct mbedtls_asn1_named_data *)NULL))
      return -0x2880;

    cur = cur->next;
  }
}

// mbedtls_x509_get_serial
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 88
signed int mbedtls_x509_get_serial(unsigned char **p, const unsigned char *end, mbedtls_x509_buf *serial)
{
  signed int ret;
  if(!(end - *p >= 1ll))
    return -0x2280 + -0x60;

  else
  {
    if(!((signed int)*(*p) == 130))
    {
      if(!((signed int)*(*p) == 0x2))
        return -0x2280 + -0x62;

    }

    unsigned char *tmp_post=*p;
    *p = *p + 1ll;
    serial->tag = (signed int)*tmp_post;
    ret=mbedtls_asn1_get_len(p, end, &serial->len);
    if(!(ret == 0))
      return -0x2280 + ret;

    else
    {
      serial->p = *p;
      *p = *p + (signed long long int)serial->len;
      return 0;
    }
  }
}

// mbedtls_x509_get_sig
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 631
signed int mbedtls_x509_get_sig(unsigned char **p, const unsigned char *end, mbedtls_x509_buf *sig)
{
  signed int ret;
  size_t len;
  signed int tag_type;
  if(!(end - *p >= 1ll))
    return -0x2480 + -0x60;

  else
  {
    tag_type = (signed int)*(*p);
    ret=mbedtls_asn1_get_bitstring_null(p, end, &len);
    if(!(ret == 0))
      return -0x2480 + ret;

    else
    {
      sig->tag = tag_type;
      sig->len = len;
      sig->p = *p;
      *p = *p + (signed long long int)len;
      return 0;
    }
  }
}

// mbedtls_x509_get_sig_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 658
signed int mbedtls_x509_get_sig_alg(const mbedtls_x509_buf *sig_oid, const mbedtls_x509_buf *sig_params, mbedtls_md_type_t *md_alg, mbedtls_pk_type_t *pk_alg, void **sig_opts)
{
  signed int ret;
  if(!(*sig_opts == NULL))
    return -0x2800;

  else
  {
    ret=mbedtls_oid_get_sig_alg(sig_oid, md_alg, pk_alg);
    if(!(ret == 0))
      return -0x2600 + ret;

    else
    {
      _Bool tmp_if_expr;
      if(!(sig_params->tag == 0x5))
        tmp_if_expr = sig_params->tag != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr = (_Bool)0;
      _Bool tmp_if_expr$0;
      if(tmp_if_expr)
        tmp_if_expr$0 = (_Bool)1;

      else
        tmp_if_expr$0 = sig_params->len != 0ull ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$0)
        return -0x2300;

      else
        return 0;
    }
  }
}

// mbedtls_x509_get_time
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 601
signed int mbedtls_x509_get_time(unsigned char **p, const unsigned char *end, mbedtls_x509_time *tm)
{
  signed int ret;
  size_t len;
  size_t year_len;
  unsigned char mbedtls_x509_get_time$$1$$tag;
  if(!(end - *p >= 1ll))
    return -0x2400 + -0x60;

  else
  {
    mbedtls_x509_get_time$$1$$tag = *(*p);
    if((signed int)mbedtls_x509_get_time$$1$$tag == 0x17)
      year_len = 2ull;

    else
      if((signed int)mbedtls_x509_get_time$$1$$tag == 0x18)
        year_len = 4ull;

      else
        return -0x2400 + -0x62;
    *p = *p + 1ll;
    ret=mbedtls_asn1_get_len(p, end, &len);
    if(!(ret == 0))
      return -0x2400 + ret;

    else
    {
      signed int return_value_x509_parse_time=x509_parse_time(p, len, year_len, tm);
      return return_value_x509_parse_time;
    }
  }
}

// mbedtls_x509_key_size_helper
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 889
signed int mbedtls_x509_key_size_helper(char *buf, size_t buf_size, const char *name)
{
  char *p=buf;
  size_t n=buf_size;
  signed int ret=mbedtls_snprintf(p, n, "%s key size", name);
  if((size_t)ret >= n || !(ret >= 0))
    return -0x2980;

  else
  {
    n = n - (size_t)ret;
    p = p + (signed long long int)(size_t)ret;
    return 0;
  }
}

// mbedtls_x509_self_test
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 1042
signed int mbedtls_x509_self_test(signed int verbose)
{
  (void)verbose;
  return 0;
}

// mbedtls_x509_serial_gets
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 810
signed int mbedtls_x509_serial_gets(char *buf, size_t size, const mbedtls_x509_buf *serial)
{
  signed int ret;
  size_t i;
  size_t n;
  size_t nr;
  char *p=buf;
  n = size;
  size_t tmp_if_expr;
  if(!(serial->len >= 33ull))
    tmp_if_expr = serial->len;

  else
    tmp_if_expr = 28ull;
  nr = tmp_if_expr;
  i = 0ull;
  for( ; !(i >= nr); i = i + 1ull)
  {
    if(i == 0ull && nr >= 2ull)
    {
      if((signed int)serial->p[(signed long long int)i] == 0x0)
        goto __CPROVER_DUMP_L7;

    }

    ret=mbedtls_snprintf(p, n, "%02X%s", serial->p[(signed long long int)i], i < nr - 1ull ? ":" : "");
    if((size_t)ret >= n || !(ret >= 0))
      return -0x2980;

    n = n - (size_t)ret;
    p = p + (signed long long int)(size_t)ret;

  __CPROVER_DUMP_L7:
    ;
  }
  if(!(nr == serial->len))
  {
    ret=mbedtls_snprintf(p, n, "....");
    if((size_t)ret >= n || !(ret >= 0))
      return -0x2980;

    n = n - (size_t)ret;
    p = p + (signed long long int)(size_t)ret;
  }

  return (signed int)(size - n);
}

// mbedtls_x509_sig_alg_gets
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 844
signed int mbedtls_x509_sig_alg_gets(char *buf, size_t size, const mbedtls_x509_buf *sig_oid, mbedtls_pk_type_t pk_alg, mbedtls_md_type_t md_alg, const void *sig_opts)
{
  signed int ret;
  char *p=buf;
  size_t n=size;
  const char *desc=((const char *)NULL);
  ret=mbedtls_oid_get_sig_alg_desc(sig_oid, &desc);
  if(!(ret == 0))
    ret=mbedtls_snprintf(p, n, "???");

  else
    ret=mbedtls_snprintf(p, n, "%s", desc);
  if((size_t)ret >= n || !(ret >= 0))
    return -0x2980;

  else
  {
    n = n - (size_t)ret;
    p = p + (signed long long int)(size_t)ret;
    (void)pk_alg;
    (void)md_alg;
    (void)sig_opts;
    return (signed int)(size - n);
  }
}

// mbedtls_x509_time_is_future
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 1027
signed int mbedtls_x509_time_is_future(const mbedtls_x509_time *from)
{
  (void)from;
  return 0;
}

// mbedtls_x509_time_is_past
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 1021
signed int mbedtls_x509_time_is_past(const mbedtls_x509_time *to)
{
  (void)to;
  return 0;
}

// mbedtls_zeroize
// file ..\..\..\..\lib\third_party\mbedtls\library\aes.c line 58
static void mbedtls_zeroize(void *v, size_t n)
{
  volatile unsigned char *p=(unsigned char *)v;
  size_t tmp_post;
  volatile unsigned char *tmp_post$0;
  do
  {
    tmp_post = n;
    n = n - 1ull;
    if(tmp_post == 0ull)
      break;

    tmp_post$0 = p;
    p = p + 1ll;
    *tmp_post$0 = 0;
  }
  while((_Bool)1);
}

// mbedtls_zeroize$link1
// file ..\..\..\..\lib\third_party\mbedtls\library\asn1parse.c line 47
static void mbedtls_zeroize$link1(void *v$link1, size_t n$link1)
{
  volatile unsigned char *p$link1=(unsigned char *)v$link1;
  size_t tmp_post$link1;
  volatile unsigned char *tmp_post$0$link1;
  do
  {
    tmp_post$link1 = n$link1;
    n$link1 = n$link1 - 1ull;
    if(tmp_post$link1 == 0ull)
      break;

    tmp_post$0$link1 = p$link1;
    p$link1 = p$link1 + 1ll;
    *tmp_post$0$link1 = 0;
  }
  while((_Bool)1);
}

// mbedtls_zeroize$link10
// file ..\..\..\..\lib\third_party\mbedtls\library\pem.c line 49
static void mbedtls_zeroize$link10(void *v$link10, size_t n$link10)
{
  volatile unsigned char *p$link10=(volatile unsigned char *)v$link10;
  size_t tmp_post$link10;
  volatile unsigned char *tmp_post$0$link10;
  do
  {
    tmp_post$link10 = n$link10;
    n$link10 = n$link10 - 1ull;
    if(tmp_post$link10 == 0ull)
      break;

    tmp_post$0$link10 = p$link10;
    p$link10 = p$link10 + 1ll;
    *tmp_post$0$link10 = 0;
  }
  while((_Bool)1);
}

// mbedtls_zeroize$link11
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 46
static void mbedtls_zeroize$link11(void *v$link11, size_t n$link11)
{
  volatile unsigned char *p$link11=(volatile unsigned char *)v$link11;
  size_t tmp_post$link11;
  volatile unsigned char *tmp_post$0$link11;
  do
  {
    tmp_post$link11 = n$link11;
    n$link11 = n$link11 - 1ull;
    if(tmp_post$link11 == 0ull)
      break;

    tmp_post$0$link11 = p$link11;
    p$link11 = p$link11 + 1ll;
    *tmp_post$0$link11 = 0;
  }
  while((_Bool)1);
}

// mbedtls_zeroize$link12
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 57
static void mbedtls_zeroize$link12(void *v$link12, size_t n$link12)
{
  volatile unsigned char *p$link12=(volatile unsigned char *)v$link12;
  size_t tmp_post$link12;
  volatile unsigned char *tmp_post$0$link12;
  do
  {
    tmp_post$link12 = n$link12;
    n$link12 = n$link12 - 1ull;
    if(tmp_post$link12 == 0ull)
      break;

    tmp_post$0$link12 = p$link12;
    p$link12 = p$link12 + 1ll;
    *tmp_post$0$link12 = 0;
  }
  while((_Bool)1);
}

// mbedtls_zeroize$link13
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 74
static void mbedtls_zeroize$link13(void *v$link13, size_t n$link13)
{
  volatile unsigned char *p$link13=(unsigned char *)v$link13;
  size_t tmp_post$link13;
  volatile unsigned char *tmp_post$0$link13;
  do
  {
    tmp_post$link13 = n$link13;
    n$link13 = n$link13 - 1ull;
    if(tmp_post$link13 == 0ull)
      break;

    tmp_post$0$link13 = p$link13;
    p$link13 = p$link13 + 1ll;
    *tmp_post$0$link13 = 0;
  }
  while((_Bool)1);
}

// mbedtls_zeroize$link14
// file ..\..\..\..\lib\third_party\mbedtls\library\sha1.c line 51
static void mbedtls_zeroize$link14(void *v$link14, size_t n$link14)
{
  volatile unsigned char *p$link14=(unsigned char *)v$link14;
  size_t tmp_post$link14;
  volatile unsigned char *tmp_post$0$link14;
  do
  {
    tmp_post$link14 = n$link14;
    n$link14 = n$link14 - 1ull;
    if(tmp_post$link14 == 0ull)
      break;

    tmp_post$0$link14 = p$link14;
    p$link14 = p$link14 + 1ll;
    *tmp_post$0$link14 = 0;
  }
  while((_Bool)1);
}

// mbedtls_zeroize$link15
// file ..\..\..\..\lib\third_party\mbedtls\library\sha256.c line 54
static void mbedtls_zeroize$link15(void *v$link15, size_t n$link15)
{
  volatile unsigned char *p$link15=(volatile unsigned char *)v$link15;
  size_t tmp_post$link15;
  volatile unsigned char *tmp_post$0$link15;
  do
  {
    tmp_post$link15 = n$link15;
    n$link15 = n$link15 - 1ull;
    if(tmp_post$link15 == 0ull)
      break;

    tmp_post$0$link15 = p$link15;
    p$link15 = p$link15 + 1ll;
    *tmp_post$0$link15 = 0;
  }
  while((_Bool)1);
}

// mbedtls_zeroize$link16
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 57
static void mbedtls_zeroize$link16(void *v$link16, size_t n$link16)
{
  volatile unsigned char *p$link16=(volatile unsigned char *)v$link16;
  size_t tmp_post$link16;
  volatile unsigned char *tmp_post$0$link16;
  do
  {
    tmp_post$link16 = n$link16;
    n$link16 = n$link16 - 1ull;
    if(tmp_post$link16 == 0ull)
      break;

    tmp_post$0$link16 = p$link16;
    p$link16 = p$link16 + 1ll;
    *tmp_post$0$link16 = 0;
  }
  while((_Bool)1);
}

// mbedtls_zeroize$link17
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 94
static void mbedtls_zeroize$link17(void *v$link17, size_t n$link17)
{
  volatile unsigned char *p$link17=(volatile unsigned char *)v$link17;
  size_t tmp_post$link17;
  volatile unsigned char *tmp_post$0$link17;
  do
  {
    tmp_post$link17 = n$link17;
    n$link17 = n$link17 - 1ull;
    if(tmp_post$link17 == 0ull)
      break;

    tmp_post$0$link17 = p$link17;
    p$link17 = p$link17 + 1ll;
    *tmp_post$0$link17 = 0;
  }
  while((_Bool)1);
}

// mbedtls_zeroize$link2
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 67
static void mbedtls_zeroize$link2(void *v$link2, size_t n$link2)
{
  volatile unsigned char *p$link2=(volatile unsigned char *)v$link2;
  size_t tmp_post$link2;
  volatile unsigned char *tmp_post$0$link2;
  do
  {
    tmp_post$link2 = n$link2;
    n$link2 = n$link2 - 1ull;
    if(tmp_post$link2 == 0ull)
      break;

    tmp_post$0$link2 = p$link2;
    p$link2 = p$link2 + 1ll;
    *tmp_post$0$link2 = 0;
  }
  while((_Bool)1);
}

// mbedtls_zeroize$link3
// file ..\..\..\..\lib\third_party\mbedtls\library\cipher.c line 64
static void mbedtls_zeroize$link3(void *v$link3, size_t n$link3)
{
  volatile unsigned char *p$link3=(unsigned char *)v$link3;
  size_t tmp_post$link3;
  volatile unsigned char *tmp_post$0$link3;
  do
  {
    tmp_post$link3 = n$link3;
    n$link3 = n$link3 - 1ull;
    if(tmp_post$link3 == 0ull)
      break;

    tmp_post$0$link3 = p$link3;
    p$link3 = p$link3 + 1ll;
    *tmp_post$0$link3 = 0;
  }
  while((_Bool)1);
}

// mbedtls_zeroize$link4
// file ..\..\..\..\lib\third_party\mbedtls\library\ctr_drbg.c line 53
static void mbedtls_zeroize$link4(void *v$link4, size_t n$link4)
{
  volatile unsigned char *p$link4=(volatile unsigned char *)v$link4;
  size_t tmp_post$link4;
  volatile unsigned char *tmp_post$0$link4;
  do
  {
    tmp_post$link4 = n$link4;
    n$link4 = n$link4 - 1ull;
    if(tmp_post$link4 == 0ull)
      break;

    tmp_post$0$link4 = p$link4;
    p$link4 = p$link4 + 1ll;
    *tmp_post$0$link4 = 0;
  }
  while((_Bool)1);
}

// mbedtls_zeroize$link5
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp.c line 77
static void mbedtls_zeroize$link5(void *v$link5, size_t n$link5)
{
  volatile unsigned char *p$link5=(volatile unsigned char *)v$link5;
  size_t tmp_post$link5;
  volatile unsigned char *tmp_post$0$link5;
  do
  {
    tmp_post$link5 = n$link5;
    n$link5 = n$link5 - 1ull;
    if(tmp_post$link5 == 0ull)
      break;

    tmp_post$0$link5 = p$link5;
    p$link5 = p$link5 + 1ll;
    *tmp_post$0$link5 = 0;
  }
  while((_Bool)1);
}

// mbedtls_zeroize$link6
// file ..\..\..\..\lib\third_party\mbedtls\library\entropy.c line 63
static void mbedtls_zeroize$link6(void *v$link6, size_t n$link6)
{
  volatile unsigned char *p$link6=(volatile unsigned char *)v$link6;
  size_t tmp_post$link6;
  volatile unsigned char *tmp_post$0$link6;
  do
  {
    tmp_post$link6 = n$link6;
    n$link6 = n$link6 - 1ull;
    if(tmp_post$link6 == 0ull)
      break;

    tmp_post$0$link6 = p$link6;
    p$link6 = p$link6 + 1ll;
    *tmp_post$0$link6 = 0;
  }
  while((_Bool)1);
}

// mbedtls_zeroize$link7
// file ..\..\..\..\lib\third_party\mbedtls\library\gcm.c line 84
static void mbedtls_zeroize$link7(void *v$link7, size_t n$link7)
{
  volatile unsigned char *p$link7=(volatile unsigned char *)v$link7;
  size_t tmp_post$link7;
  volatile unsigned char *tmp_post$0$link7;
  do
  {
    tmp_post$link7 = n$link7;
    n$link7 = n$link7 - 1ull;
    if(tmp_post$link7 == 0ull)
      break;

    tmp_post$0$link7 = p$link7;
    p$link7 = p$link7 + 1ll;
    *tmp_post$0$link7 = 0;
  }
  while((_Bool)1);
}

// mbedtls_zeroize$link8
// file ..\..\..\..\lib\third_party\mbedtls\library\hmac_drbg.c line 54
static void mbedtls_zeroize$link8(void *v$link8, size_t n$link8)
{
  volatile unsigned char *p$link8=(volatile unsigned char *)v$link8;
  size_t tmp_post$link8;
  volatile unsigned char *tmp_post$0$link8;
  do
  {
    tmp_post$link8 = n$link8;
    n$link8 = n$link8 - 1ull;
    if(tmp_post$link8 == 0ull)
      break;

    tmp_post$0$link8 = p$link8;
    p$link8 = p$link8 + 1ll;
    *tmp_post$0$link8 = 0;
  }
  while((_Bool)1);
}

// mbedtls_zeroize$link9
// file ..\..\..\..\lib\third_party\mbedtls\library\md.c line 52
static void mbedtls_zeroize$link9(void *v$link9, size_t n$link9)
{
  volatile unsigned char *p$link9=(volatile unsigned char *)v$link9;
  size_t tmp_post$link9;
  volatile unsigned char *tmp_post$0$link9;
  do
  {
    tmp_post$link9 = n$link9;
    n$link9 = n$link9 - 1ull;
    if(tmp_post$link9 == 0ull)
      break;

    tmp_post$0$link9 = p$link9;
    p$link9 = p$link9 + 1ll;
    *tmp_post$0$link9 = 0;
  }
  while((_Bool)1);
}

// modfl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 890
/*inline double modfl(double _X, double *_Y)*/
/*{*/
  /*double _F;*/
  /*double _I;*/
  /*_F=modf((double)_X, &_I);*/
  /**_Y = _I;*/
  /*return _F;*/
/*}*/

// mpi_check_small_factors
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 2035
static signed int mpi_check_small_factors(const mbedtls_mpi *X)
{
  signed int ret=0;
  size_t i;
  mbedtls_mpi_uint r;
  if((1ull & *X->p) == 0ull)
    return -0xE;

  else
  {
    i = 0ull;
    for( ; small_prime[(signed long long int)i] >= 1; i = i + 1ull)
    {
      signed int return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(X, (mbedtls_mpi_sint)small_prime[(signed long long int)i]);
      if(!(return_value_mbedtls_mpi_cmp_int >= 1))
        return 1;

      do
      {
        ret=mbedtls_mpi_mod_int(&r, X, (mbedtls_mpi_sint)small_prime[(signed long long int)i]);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      if(r == 0ull)
        return -0xE;

    }

  cleanup:
    ;
    return ret;
  }
}

// mpi_get_digit
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 418
static signed int mpi_get_digit(mbedtls_mpi_uint *d, signed int radix, char c)
{
  *d = 255ull;
  if((signed int)c >= 0x30 && !((signed int)c >= 58))
    *d = (mbedtls_mpi_uint)((signed int)c - 0x30);

  if((signed int)c >= 0x41 && !((signed int)c >= 71))
    *d = (mbedtls_mpi_uint)((signed int)c - 0x37);

  if((signed int)c >= 0x61 && !((signed int)c >= 103))
    *d = (mbedtls_mpi_uint)((signed int)c - 0x57);

  if(*d >= (mbedtls_mpi_uint)radix)
    return -0x6;

  else
    return 0;
}

// mpi_miller_rabin
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 2062
static signed int mpi_miller_rabin(const mbedtls_mpi *X, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
  signed int ret;
  signed int count;
  size_t i;
  size_t j;
  size_t k;
  size_t n;
  size_t s;
  mbedtls_mpi W;
  mbedtls_mpi R;
  mbedtls_mpi T;
  mbedtls_mpi A;
  mbedtls_mpi RR;
  mbedtls_mpi_init(&W);
  mbedtls_mpi_init(&R);
  mbedtls_mpi_init(&T);
  mbedtls_mpi_init(&A);
  mbedtls_mpi_init(&RR);
  do
  {
    ret=mbedtls_mpi_sub_int(&W, X, 1ll);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  s=mbedtls_mpi_lsb(&W);
  do
  {
    ret=mbedtls_mpi_copy(&R, &W);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  do
  {
    ret=mbedtls_mpi_shift_r(&R, s);
    if(!(ret == 0))
      goto cleanup;

  }
  while((_Bool)0);
  i=mbedtls_mpi_bitlen(X);
  n = (size_t)(i >= 1300ull ? 2 : (i >= 850ull ? 3 : (i >= 650ull ? 4 : (i >= 350ull ? 8 : (i >= 250ull ? 12 : (i >= 150ull ? 18 : 27))))));
  i = 0ull;
  signed int return_value_mbedtls_mpi_cmp_mpi$0;
  _Bool tmp_if_expr;
  signed int return_value_mbedtls_mpi_cmp_int;
  signed int return_value_mbedtls_mpi_cmp_int$0;
  signed int return_value_mbedtls_mpi_cmp_mpi$2;
  signed int return_value_mbedtls_mpi_cmp_int$2;
  for( ; !(i >= n); i = i + 1ull)
  {
    do
    {
      ret=mbedtls_mpi_fill_random(&A, X->n * sizeof(mbedtls_mpi_uint) /*8ull*/ , f_rng, p_rng);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    signed int return_value_mbedtls_mpi_cmp_mpi=mbedtls_mpi_cmp_mpi(&A, &W);
    if(return_value_mbedtls_mpi_cmp_mpi >= 0)
    {
      size_t return_value_mbedtls_mpi_bitlen=mbedtls_mpi_bitlen(&A);
      size_t return_value_mbedtls_mpi_bitlen$0=mbedtls_mpi_bitlen(&W);
      j = return_value_mbedtls_mpi_bitlen - return_value_mbedtls_mpi_bitlen$0;
      do
      {
        ret=mbedtls_mpi_shift_r(&A, j + 1ull);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
    }

    A.p[0ll] = A.p[0ll] | 3ull;
    count = 0;
    do
    {

    __CPROVER_DUMP_L9:
      ;
      ret=mbedtls_mpi_fill_random(&A, X->n * sizeof(mbedtls_mpi_uint) /*8ull*/ , f_rng, p_rng);
      if(!(ret == 0))
        goto cleanup;

      j=mbedtls_mpi_bitlen(&A);
      k=mbedtls_mpi_bitlen(&W);
      if(!(k >= j))
        do
        {
          ret=mbedtls_mpi_shift_r(&A, j - k);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);

      signed int tmp_post=count;
      count = count + 1;
      if(tmp_post >= 31)
        return -0xE;

      return_value_mbedtls_mpi_cmp_mpi$0=mbedtls_mpi_cmp_mpi(&A, &W);
      if(return_value_mbedtls_mpi_cmp_mpi$0 >= 0)
        tmp_if_expr = (_Bool)1;

      else
      {
        return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(&A, 1ll);
        tmp_if_expr = return_value_mbedtls_mpi_cmp_int <= 0 ? (_Bool)1 : (_Bool)0;
      }
    }
    while(tmp_if_expr);
    do
    {
      ret=mbedtls_mpi_exp_mod(&A, &A, &R, X, &RR);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    signed int return_value_mbedtls_mpi_cmp_mpi$1=mbedtls_mpi_cmp_mpi(&A, &W);
    _Bool tmp_if_expr$0;
    if(return_value_mbedtls_mpi_cmp_mpi$1 == 0)
      tmp_if_expr$0 = (_Bool)1;

    else
    {
      return_value_mbedtls_mpi_cmp_int$0=mbedtls_mpi_cmp_int(&A, 1ll);
      tmp_if_expr$0 = return_value_mbedtls_mpi_cmp_int$0 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr$0)
    {
      j = 1ull;
      while(!(j >= s))
      {
        return_value_mbedtls_mpi_cmp_mpi$2=mbedtls_mpi_cmp_mpi(&A, &W);
        if(return_value_mbedtls_mpi_cmp_mpi$2 == 0)
          break;

        do
        {
          ret=mbedtls_mpi_mul_mpi(&T, &A, &A);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        do
        {
          ret=mbedtls_mpi_mod_mpi(&A, &T, X);
          if(!(ret == 0))
            goto cleanup;

        }
        while((_Bool)0);
        signed int return_value_mbedtls_mpi_cmp_int$1=mbedtls_mpi_cmp_int(&A, 1ll);
        if(return_value_mbedtls_mpi_cmp_int$1 == 0)
          break;

        j = j + 1ull;
      }
      signed int return_value_mbedtls_mpi_cmp_mpi$3=mbedtls_mpi_cmp_mpi(&A, &W);
      _Bool tmp_if_expr$1;
      if(!(return_value_mbedtls_mpi_cmp_mpi$3 == 0))
        tmp_if_expr$1 = (_Bool)1;

      else
      {
        return_value_mbedtls_mpi_cmp_int$2=mbedtls_mpi_cmp_int(&A, 1ll);
        tmp_if_expr$1 = return_value_mbedtls_mpi_cmp_int$2 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$1)
      {
        ret = -0xE;
        break;
      }

    }

  }

cleanup:
  ;
  mbedtls_mpi_free(&W);
  mbedtls_mpi_free(&R);
  mbedtls_mpi_free(&T);
  mbedtls_mpi_free(&A);
  mbedtls_mpi_free(&RR);
  return ret;
}

// mpi_montg_init
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1548
static void mpi_montg_init(mbedtls_mpi_uint *mm, const mbedtls_mpi *N)
{
  mbedtls_mpi_uint x;
  mbedtls_mpi_uint m0=N->p[0ll];
  unsigned int i;
  x = m0;
  x = x + ((m0 + 2ull & 4ull) << 1);
  i = (unsigned int)(sizeof(mbedtls_mpi_uint) /*8ull*/  << 3);
  for( ; i >= 8u; i = i / 2u)
    x = x * (2ull - m0 * x);
  *mm = ~x + 1ull;
}

// mpi_montmul
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1565
static signed int mpi_montmul(mbedtls_mpi *A, const mbedtls_mpi *B, const mbedtls_mpi *N, mbedtls_mpi_uint mm, const mbedtls_mpi *T)
{
  size_t i;
  size_t n;
  size_t m;
  mbedtls_mpi_uint u0;
  mbedtls_mpi_uint u1;
  mbedtls_mpi_uint *d;
  _Bool tmp_if_expr;
  if(!(T->n >= 1ull + N->n))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = T->p == ((mbedtls_mpi_uint *)NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    return -0x4;

  else
  {
    memset((void *)T->p, 0, T->n * sizeof(mbedtls_mpi_uint) /*8ull*/ );
    d = T->p;
    n = N->n;
    size_t tmp_if_expr$0;
    if(!(B->n >= n))
      tmp_if_expr$0 = B->n;

    else
      tmp_if_expr$0 = n;
    m = tmp_if_expr$0;
    i = 0ull;
    for( ; !(i >= n); i = i + 1ull)
    {
      u0 = A->p[(signed long long int)i];
      u1 = (d[0ll] + u0 * B->p[0ll]) * mm;
      mpi_mul_hlp(m, B->p, d, u0);
      mpi_mul_hlp(n, N->p, d, u1);
      mbedtls_mpi_uint *tmp_post=d;
      d = d + 1ll;
      *tmp_post = u0;
      d[(signed long long int)(n + 1ull)] = 0ull;
    }
    memcpy((void *)A->p, (const void *)d, (n + 1ull) * sizeof(mbedtls_mpi_uint) /*8ull*/ );
    signed int return_value_mbedtls_mpi_cmp_abs=mbedtls_mpi_cmp_abs(A, N);
    if(return_value_mbedtls_mpi_cmp_abs >= 0)
      mpi_sub_hlp(n, N->p, A->p);

    else
      mpi_sub_hlp(n, A->p, T->p);
    return 0;
  }
}

// mpi_montred
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1608
static signed int mpi_montred(mbedtls_mpi *A, const mbedtls_mpi *N, mbedtls_mpi_uint mm, const mbedtls_mpi *T)
{
  mbedtls_mpi_uint z=1ull;
  mbedtls_mpi U;
  U.s = (signed int)z;
  U.n = (size_t)U.s;
  U.p = &z;
  signed int return_value_mpi_montmul=mpi_montmul(A, &U, N, mm, T);
  return return_value_mpi_montmul;
}

// mpi_mul_hlp
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 1124
/*static void mpi_mul_hlp(size_t i, mbedtls_mpi_uint *s, mbedtls_mpi_uint *d, mbedtls_mpi_uint b)*/
/*{*/
  /*mbedtls_mpi_uint c=0ull;*/
  /*mbedtls_mpi_uint t=0ull;*/
  /*for( ; i >= 16ull; i = i - 16ull)*/
  /*{*/
    /*__asm (*/
    /*" mov esi, s __asm mov edi, d __asm mov ecx, c __asm mov ebx, b"*/
/*)*/
    /*__asm (*/
    /*" lodsd __asm mul ebx __asm add eax, ecx __asm adc edx, 0 __asm add eax, [edi] __asm adc edx, 0 __asm mov ecx, edx __asm stosd   __asm lodsd __asm mul ebx __asm add eax, ecx __asm adc edx, 0 __asm add eax, [edi] __asm adc edx, 0 __asm mov ecx, edx __asm stosd"*/
/*)*/
    /*__asm (*/
    /*" lodsd __asm mul ebx __asm add eax, ecx __asm adc edx, 0 __asm add eax, [edi] __asm adc edx, 0 __asm mov ecx, edx __asm stosd   __asm lodsd __asm mul ebx __asm add eax, ecx __asm adc edx, 0 __asm add eax, [edi] __asm adc edx, 0 __asm mov ecx, edx __asm stosd"*/
/*)*/
    /*__asm (*/
    /*" lodsd __asm mul ebx __asm add eax, ecx __asm adc edx, 0 __asm add eax, [edi] __asm adc edx, 0 __asm mov ecx, edx __asm stosd   __asm lodsd __asm mul ebx __asm add eax, ecx __asm adc edx, 0 __asm add eax, [edi] __asm adc edx, 0 __asm mov ecx, edx __asm stosd"*/
/*)*/
    /*__asm (*/
    /*" lodsd __asm mul ebx __asm add eax, ecx __asm adc edx, 0 __asm add eax, [edi] __asm adc edx, 0 __asm mov ecx, edx __asm stosd   __asm lodsd __asm mul ebx __asm add eax, ecx __asm adc edx, 0 __asm add eax, [edi] __asm adc edx, 0 __asm mov ecx, edx __asm stosd"*/
/*)*/
    /*__asm (*/
    /*" lodsd __asm mul ebx __asm add eax, ecx __asm adc edx, 0 __asm add eax, [edi] __asm adc edx, 0 __asm mov ecx, edx __asm stosd   __asm lodsd __asm mul ebx __asm add eax, ecx __asm adc edx, 0 __asm add eax, [edi] __asm adc edx, 0 __asm mov ecx, edx __asm stosd"*/
/*)*/
    /*__asm (*/
    /*" lodsd __asm mul ebx __asm add eax, ecx __asm adc edx, 0 __asm add eax, [edi] __asm adc edx, 0 __asm mov ecx, edx __asm stosd   __asm lodsd __asm mul ebx __asm add eax, ecx __asm adc edx, 0 __asm add eax, [edi] __asm adc edx, 0 __asm mov ecx, edx __asm stosd"*/
/*)*/
    /*__asm (*/
    /*" lodsd __asm mul ebx __asm add eax, ecx __asm adc edx, 0 __asm add eax, [edi] __asm adc edx, 0 __asm mov ecx, edx __asm stosd   __asm lodsd __asm mul ebx __asm add eax, ecx __asm adc edx, 0 __asm add eax, [edi] __asm adc edx, 0 __asm mov ecx, edx __asm stosd"*/
/*)*/
    /*__asm (*/
    /*" lodsd __asm mul ebx __asm add eax, ecx __asm adc edx, 0 __asm add eax, [edi] __asm adc edx, 0 __asm mov ecx, edx __asm stosd   __asm lodsd __asm mul ebx __asm add eax, ecx __asm adc edx, 0 __asm add eax, [edi] __asm adc edx, 0 __asm mov ecx, edx __asm stosd"*/
/*)*/
    /*__asm (*/
    /*" mov c, ecx __asm mov d, edi __asm mov s, esi"*/
/*)*/
  /*}*/
  /*for( ; i >= 8ull; i = i - 8ull)*/
  /*{*/
    /*__asm (*/
    /*" mov esi, s __asm mov edi, d __asm mov ecx, c __asm mov ebx, b"*/
/*)*/
    /*__asm (*/
    /*" lodsd __asm mul ebx __asm add eax, ecx __asm adc edx, 0 __asm add eax, [edi] __asm adc edx, 0 __asm mov ecx, edx __asm stosd   __asm lodsd __asm mul ebx __asm add eax, ecx __asm adc edx, 0 __asm add eax, [edi] __asm adc edx, 0 __asm mov ecx, edx __asm stosd"*/
/*)*/
    /*__asm (*/
    /*" lodsd __asm mul ebx __asm add eax, ecx __asm adc edx, 0 __asm add eax, [edi] __asm adc edx, 0 __asm mov ecx, edx __asm stosd   __asm lodsd __asm mul ebx __asm add eax, ecx __asm adc edx, 0 __asm add eax, [edi] __asm adc edx, 0 __asm mov ecx, edx __asm stosd"*/
/*)*/
    /*__asm (*/
    /*" lodsd __asm mul ebx __asm add eax, ecx __asm adc edx, 0 __asm add eax, [edi] __asm adc edx, 0 __asm mov ecx, edx __asm stosd   __asm lodsd __asm mul ebx __asm add eax, ecx __asm adc edx, 0 __asm add eax, [edi] __asm adc edx, 0 __asm mov ecx, edx __asm stosd"*/
/*)*/
    /*__asm (*/
    /*" lodsd __asm mul ebx __asm add eax, ecx __asm adc edx, 0 __asm add eax, [edi] __asm adc edx, 0 __asm mov ecx, edx __asm stosd   __asm lodsd __asm mul ebx __asm add eax, ecx __asm adc edx, 0 __asm add eax, [edi] __asm adc edx, 0 __asm mov ecx, edx __asm stosd"*/
/*)*/
    /*__asm (*/
    /*" mov c, ecx __asm mov d, edi __asm mov s, esi"*/
/*)*/
  /*}*/
  /*for( ; i >= 1ull; i = i - 1ull)*/
  /*{*/
    /*__asm (*/
    /*" mov esi, s __asm mov edi, d __asm mov ecx, c __asm mov ebx, b"*/
/*)*/
    /*__asm (*/
    /*" lodsd __asm mul ebx __asm add eax, ecx __asm adc edx, 0 __asm add eax, [edi] __asm adc edx, 0 __asm mov ecx, edx __asm stosd"*/
/*)*/
    /*__asm (*/
    /*" mov c, ecx __asm mov d, edi __asm mov s, esi"*/
/*)*/
  /*}*/
  /*t = t + 1ull;*/
  /*do*/
  /*{*/
    /**d = *d + c;*/
    /*c = (mbedtls_mpi_uint)(*d < c);*/
    /*d = d + 1ll;*/
  /*}*/
  /*while(!(c == 0ull));*/
/*}*/

// mpi_sub_hlp
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 958
static void mpi_sub_hlp(size_t n, mbedtls_mpi_uint *s, mbedtls_mpi_uint *d)
{
  size_t i;
  mbedtls_mpi_uint c;
  mbedtls_mpi_uint z;
  c = 0ull;
  i = c;
  for( ; !(i >= n); d = d + 1ll)
  {
    z = (mbedtls_mpi_uint)(*d < c);
    *d = *d - c;
    c = (unsigned long long int)(*d < *s) + z;
    *d = *d - *s;
    i = i + 1ull;
    s = s + 1ll;
  }
  for( ; !(c == 0ull); d = d + 1ll)
  {
    z = (mbedtls_mpi_uint)(*d < c);
    *d = *d - c;
    c = z;
  }
}

// mpi_write_hlp
// file ..\..\..\..\lib\third_party\mbedtls\library\bignum.c line 507
static signed int mpi_write_hlp(mbedtls_mpi *X, signed int radix, char **p)
{
  signed int ret;
  mbedtls_mpi_uint r;
  char *tmp_post;
  char *tmp_post$0;
  if(radix >= 17 || !(radix >= 2))
    return -0x4;

  else
  {
    do
    {
      ret=mbedtls_mpi_mod_int(&r, X, (mbedtls_mpi_sint)radix);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_div_int(X, ((mbedtls_mpi *)NULL), X, (mbedtls_mpi_sint)radix);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    signed int return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(X, 0ll);
    if(!(return_value_mbedtls_mpi_cmp_int == 0))
      do
      {
        ret=mpi_write_hlp(X, radix, p);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);

    if(!(r >= 10ull))
    {
      tmp_post = *p;
      *p = *p + 1ll;
      *tmp_post = (char)(r + 48ull);
    }

    else
    {
      tmp_post$0 = *p;
      *p = *p + 1ll;
      *tmp_post$0 = (char)(r + 55ull);
    }

  cleanup:
    ;
    return ret;
  }
}

// myrand
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 2219
static signed int myrand(void *rng_state, unsigned char *output, size_t len)
{
  size_t i;
  if(!(rng_state == NULL))
    rng_state = NULL;

  i = 0ull;
  signed int return_value_rand;
  for( ; !(i >= len); i = i + 1ull)
  {
    return_value_rand=rand();
    output[(signed long long int)i] = (unsigned char)return_value_rand;
  }
  return 0;
}

// oid_cipher_alg_from_asn1
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 560
static const oid_cipher_alg_t * oid_cipher_alg_from_asn1(const mbedtls_asn1_buf *oid)
{
  const oid_cipher_alg_t *p=oid_cipher_alg;
  const mbedtls_oid_descriptor_t *cur=(const mbedtls_oid_descriptor_t *)p;
  signed int return_value_memcmp;
  if(p == ((const oid_cipher_alg_t *)NULL) || oid == ((const mbedtls_asn1_buf *)NULL))
    return ((const oid_cipher_alg_t *)NULL);

  else
  {
    while(!(cur->asn1 == ((const char *)NULL)))
    {
      if(cur->asn1_len == oid->len)
      {
        return_value_memcmp=memcmp((const void *)cur->asn1, (const void *)oid->p, oid->len);
        if(return_value_memcmp == 0)
          return p;

      }

      p = p + 1ll;
      cur = (const mbedtls_oid_descriptor_t *)p;
    }
    return ((const oid_cipher_alg_t *)NULL);
  }
}

// oid_ext_key_usage_from_asn1
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 301
static const mbedtls_oid_descriptor_t * oid_ext_key_usage_from_asn1(const mbedtls_asn1_buf *oid)
{
  const mbedtls_oid_descriptor_t *p=oid_ext_key_usage;
  const mbedtls_oid_descriptor_t *cur=(const mbedtls_oid_descriptor_t *)p;
  signed int return_value_memcmp;
  if(p == ((const mbedtls_oid_descriptor_t *)NULL) || oid == ((const mbedtls_asn1_buf *)NULL))
    return ((const mbedtls_oid_descriptor_t *)NULL);

  else
  {
    while(!(cur->asn1 == ((const char *)NULL)))
    {
      if(cur->asn1_len == oid->len)
      {
        return_value_memcmp=memcmp((const void *)cur->asn1, (const void *)oid->p, oid->len);
        if(return_value_memcmp == 0)
          return p;

      }

      p = p + 1ll;
      cur = (const mbedtls_oid_descriptor_t *)p;
    }
    return ((const mbedtls_oid_descriptor_t *)NULL);
  }
}

// oid_grp_id_from_asn1
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 530
static const oid_ecp_grp_t * oid_grp_id_from_asn1(const mbedtls_asn1_buf *oid)
{
  const oid_ecp_grp_t *p=oid_ecp_grp;
  const mbedtls_oid_descriptor_t *cur=(const mbedtls_oid_descriptor_t *)p;
  signed int return_value_memcmp;
  if(p == ((const oid_ecp_grp_t *)NULL) || oid == ((const mbedtls_asn1_buf *)NULL))
    return ((const oid_ecp_grp_t *)NULL);

  else
  {
    while(!(cur->asn1 == ((const char *)NULL)))
    {
      if(cur->asn1_len == oid->len)
      {
        return_value_memcmp=memcmp((const void *)cur->asn1, (const void *)oid->p, oid->len);
        if(return_value_memcmp == 0)
          return p;

      }

      p = p + 1ll;
      cur = (const mbedtls_oid_descriptor_t *)p;
    }
    return ((const oid_ecp_grp_t *)NULL);
  }
}

// oid_md_alg_from_asn1
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 625
static const oid_md_alg_t * oid_md_alg_from_asn1(const mbedtls_asn1_buf *oid)
{
  const oid_md_alg_t *p=oid_md_alg;
  const mbedtls_oid_descriptor_t *cur=(const mbedtls_oid_descriptor_t *)p;
  signed int return_value_memcmp;
  if(p == ((const oid_md_alg_t *)NULL) || oid == ((const mbedtls_asn1_buf *)NULL))
    return ((const oid_md_alg_t *)NULL);

  else
  {
    while(!(cur->asn1 == ((const char *)NULL)))
    {
      if(cur->asn1_len == oid->len)
      {
        return_value_memcmp=memcmp((const void *)cur->asn1, (const void *)oid->p, oid->len);
        if(return_value_memcmp == 0)
          return p;

      }

      p = p + 1ll;
      cur = (const mbedtls_oid_descriptor_t *)p;
    }
    return ((const oid_md_alg_t *)NULL);
  }
}

// oid_md_hmac_from_asn1
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 671
static const oid_md_hmac_t * oid_md_hmac_from_asn1(const mbedtls_asn1_buf *oid)
{
  const oid_md_hmac_t *p=oid_md_hmac;
  const mbedtls_oid_descriptor_t *cur=(const mbedtls_oid_descriptor_t *)p;
  signed int return_value_memcmp;
  if(p == ((const oid_md_hmac_t *)NULL) || oid == ((const mbedtls_asn1_buf *)NULL))
    return ((const oid_md_hmac_t *)NULL);

  else
  {
    while(!(cur->asn1 == ((const char *)NULL)))
    {
      if(cur->asn1_len == oid->len)
      {
        return_value_memcmp=memcmp((const void *)cur->asn1, (const void *)oid->p, oid->len);
        if(return_value_memcmp == 0)
          return p;

      }

      p = p + 1ll;
      cur = (const mbedtls_oid_descriptor_t *)p;
    }
    return ((const oid_md_hmac_t *)NULL);
  }
}

// oid_pk_alg_from_asn1
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 443
static const oid_pk_alg_t * oid_pk_alg_from_asn1(const mbedtls_asn1_buf *oid)
{
  const oid_pk_alg_t *p=oid_pk_alg;
  const mbedtls_oid_descriptor_t *cur=(const mbedtls_oid_descriptor_t *)p;
  signed int return_value_memcmp;
  if(p == ((const oid_pk_alg_t *)NULL) || oid == ((const mbedtls_asn1_buf *)NULL))
    return ((const oid_pk_alg_t *)NULL);

  else
  {
    while(!(cur->asn1 == ((const char *)NULL)))
    {
      if(cur->asn1_len == oid->len)
      {
        return_value_memcmp=memcmp((const void *)cur->asn1, (const void *)oid->p, oid->len);
        if(return_value_memcmp == 0)
          return p;

      }

      p = p + 1ll;
      cur = (const mbedtls_oid_descriptor_t *)p;
    }
    return ((const oid_pk_alg_t *)NULL);
  }
}

// oid_sig_alg_from_asn1
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 409
static const oid_sig_alg_t * oid_sig_alg_from_asn1(const mbedtls_asn1_buf *oid)
{
  const oid_sig_alg_t *p=oid_sig_alg;
  const mbedtls_oid_descriptor_t *cur=(const mbedtls_oid_descriptor_t *)p;
  signed int return_value_memcmp;
  if(p == ((const oid_sig_alg_t *)NULL) || oid == ((const mbedtls_asn1_buf *)NULL))
    return ((const oid_sig_alg_t *)NULL);

  else
  {
    while(!(cur->asn1 == ((const char *)NULL)))
    {
      if(cur->asn1_len == oid->len)
      {
        return_value_memcmp=memcmp((const void *)cur->asn1, (const void *)oid->p, oid->len);
        if(return_value_memcmp == 0)
          return p;

      }

      p = p + 1ll;
      cur = (const mbedtls_oid_descriptor_t *)p;
    }
    return ((const oid_sig_alg_t *)NULL);
  }
}

// oid_x509_ext_from_asn1
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 287
static const oid_x509_ext_t * oid_x509_ext_from_asn1(const mbedtls_asn1_buf *oid)
{
  const oid_x509_ext_t *p=oid_x509_ext;
  const mbedtls_oid_descriptor_t *cur=(const mbedtls_oid_descriptor_t *)p;
  signed int return_value_memcmp;
  if(p == ((const oid_x509_ext_t *)NULL) || oid == ((const mbedtls_asn1_buf *)NULL))
    return ((const oid_x509_ext_t *)NULL);

  else
  {
    while(!(cur->asn1 == ((const char *)NULL)))
    {
      if(cur->asn1_len == oid->len)
      {
        return_value_memcmp=memcmp((const void *)cur->asn1, (const void *)oid->p, oid->len);
        if(return_value_memcmp == 0)
          return p;

      }

      p = p + 1ll;
      cur = (const mbedtls_oid_descriptor_t *)p;
    }
    return ((const oid_x509_ext_t *)NULL);
  }
}

// oid_x520_attr_from_asn1
// file ..\..\..\..\lib\third_party\mbedtls\library\oid.c line 248
static const oid_x520_attr_t * oid_x520_attr_from_asn1(const mbedtls_asn1_buf *oid)
{
  const oid_x520_attr_t *p=oid_x520_attr_type;
  const mbedtls_oid_descriptor_t *cur=(const mbedtls_oid_descriptor_t *)p;
  signed int return_value_memcmp;
  if(p == ((const oid_x520_attr_t *)NULL) || oid == ((const mbedtls_asn1_buf *)NULL))
    return ((const oid_x520_attr_t *)NULL);

  else
  {
    while(!(cur->asn1 == ((const char *)NULL)))
    {
      if(cur->asn1_len == oid->len)
      {
        return_value_memcmp=memcmp((const void *)cur->asn1, (const void *)oid->p, oid->len);
        if(return_value_memcmp == 0)
          return p;

      }

      p = p + 1ll;
      cur = (const mbedtls_oid_descriptor_t *)p;
    }
    return ((const oid_x520_attr_t *)NULL);
  }
}

// pcApplicationHostnameHook
// file ..\common\application_code\main.c line 290
const char * pcApplicationHostnameHook(void)
{
  return "RTOSDemo";
}

// pcTaskGetName
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 2326
char * pcTaskGetName(TaskHandle_t xTaskToQuery)
{
  TCB_t *pxTCB=xTaskToQuery == NULL ? (TCB_t *)pxCurrentTCB : (TCB_t *)xTaskToQuery;
  if(pxTCB == ((TCB_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 2333u);

  return pxTCB->pcTaskName;
}

// pcTimerGetName
// file ..\..\..\..\lib\FreeRTOS\timers.c line 453
const char * pcTimerGetName(TimerHandle_t xTimer)
{
  Timer_t *pxTimer=(Timer_t *)xTimer;
  if(xTimer == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\timers.c", 457u);

  return pxTimer->pcTimerName;
}

// pcap_callback
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 436
void pcap_callback(u_char *user, const struct pcap_pkthdr *pkt_header, const u_char *pkt_data)
{
  (void)user;
  size_t return_value_uxStreamBufferGetSpace;
  if(!(pkt_header->caplen >= 1215u))
  {
    return_value_uxStreamBufferGetSpace=uxStreamBufferGetSpace$link3(xRecvBuffer);
    if(return_value_uxStreamBufferGetSpace >= sizeof(const struct pcap_pkthdr) /*16ull*/  + (size_t)pkt_header->caplen)
    {
      uxStreamBufferAdd(xRecvBuffer, 0ull, (const uint8_t *)pkt_header, sizeof(const struct pcap_pkthdr) /*16ull*/ );
      uxStreamBufferAdd(xRecvBuffer, 0ull, (const uint8_t *)pkt_data, (size_t)pkt_header->caplen);
    }

  }

}

// pk_get_ecparams
// file ..\..\..\..\lib\third_party\mbedtls\library\pkparse.c line 179
static signed int pk_get_ecparams(unsigned char **p, const unsigned char *end, mbedtls_asn1_buf *params)
{
  signed int ret;
  if(!(end - *p >= 1ll))
    return -0x3D00 + -0x60;

  else
  {
    params->tag = (signed int)*(*p);
    if(!(params->tag == 0x6))
      return -0x3D00 + -0x62;

    else
    {
      ret=mbedtls_asn1_get_tag(p, end, &params->len, params->tag);
      if(!(ret == 0))
        return -0x3D00 + ret;

      else
      {
        params->p = *p;
        *p = *p + (signed long long int)params->len;
        if(!(*p == end))
          return -0x3D00 + -0x66;

        else
          return 0;
      }
    }
  }
}

// pk_get_ecpubkey
// file ..\..\..\..\lib\third_party\mbedtls\library\pkparse.c line 491
static signed int pk_get_ecpubkey(unsigned char **p, const unsigned char *end, mbedtls_ecp_keypair *pk_get_ecpubkey$$key)
{
  signed int ret=mbedtls_ecp_point_read_binary(&pk_get_ecpubkey$$key->grp, &pk_get_ecpubkey$$key->Q, (const unsigned char *)*p, (size_t)(end - *p));
  if(ret == 0)
    ret=mbedtls_ecp_check_pubkey(&pk_get_ecpubkey$$key->grp, &pk_get_ecpubkey$$key->Q);

  *p = (unsigned char *)end;
  return ret;
}

// pk_get_pk_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\pkparse.c line 573
static signed int pk_get_pk_alg(unsigned char **p, const unsigned char *end, mbedtls_pk_type_t *pk_alg, mbedtls_asn1_buf *params)
{
  signed int ret;
  mbedtls_asn1_buf alg_oid;
  memset((void *)params, 0, sizeof(mbedtls_asn1_buf) /*24ull*/ );
  ret=mbedtls_asn1_get_alg(p, end, &alg_oid, params);
  _Bool tmp_if_expr;
  _Bool tmp_if_expr$0;
  if(!(ret == 0))
    return -0x3A80 + ret;

  else
  {
    signed int return_value_mbedtls_oid_get_pk_alg=mbedtls_oid_get_pk_alg(&alg_oid, pk_alg);
    if(!(return_value_mbedtls_oid_get_pk_alg == 0))
      return -0x3C80;

    else
    {
      if((signed int)*pk_alg == 1)
      {
        if(!(params->tag == 0x5))
          tmp_if_expr = params->tag != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr = (_Bool)0;
        if(tmp_if_expr)
          tmp_if_expr$0 = (_Bool)1;

        else
          tmp_if_expr$0 = params->len != 0ull ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$0)
          return -0x3A80;

      }

      return 0;
    }
  }
}

// pk_get_rsapubkey
// file ..\..\..\..\lib\third_party\mbedtls\library\pkparse.c line 518
static signed int pk_get_rsapubkey(unsigned char **p, const unsigned char *end, mbedtls_rsa_context *rsa)
{
  signed int ret;
  size_t len;
  ret=mbedtls_asn1_get_tag(p, end, &len, 0x20 | 0x10);
  signed int return_value_mbedtls_rsa_check_pubkey;
  if(!(ret == 0))
    return -0x3B00 + ret;

  else
    if(!(*p + (signed long long int)len == end))
      return -0x3B00 + -0x66;

    else
    {
      ret=mbedtls_asn1_get_tag(p, end, &len, 0x2);
      if(!(ret == 0))
        return -0x3B00 + ret;

      else
      {
        ret=mbedtls_rsa_import_raw(rsa, *p, len, ((const unsigned char *)NULL), 0ull, ((const unsigned char *)NULL), 0ull, ((const unsigned char *)NULL), 0ull, ((const unsigned char *)NULL), 0ull);
        if(!(ret == 0))
          return -0x3B00;

        else
        {
          *p = *p + (signed long long int)len;
          ret=mbedtls_asn1_get_tag(p, end, &len, 0x2);
          if(!(ret == 0))
            return -0x3B00 + ret;

          else
          {
            ret=mbedtls_rsa_import_raw(rsa, ((const unsigned char *)NULL), 0ull, ((const unsigned char *)NULL), 0ull, ((const unsigned char *)NULL), 0ull, ((const unsigned char *)NULL), 0ull, *p, len);
            if(!(ret == 0))
              return -0x3B00;

            else
            {
              *p = *p + (signed long long int)len;
              signed int return_value_mbedtls_rsa_complete=mbedtls_rsa_complete(rsa);
              _Bool tmp_if_expr;
              if(!(return_value_mbedtls_rsa_complete == 0))
                tmp_if_expr = (_Bool)1;

              else
              {
                return_value_mbedtls_rsa_check_pubkey=mbedtls_rsa_check_pubkey(rsa);
                tmp_if_expr = return_value_mbedtls_rsa_check_pubkey != 0 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr)
                return -0x3B00;

              else
                if(!(*p == end))
                  return -0x3B00 + -0x66;

                else
                  return 0;
            }
          }
        }
      }
    }
}

// pk_hashlen_helper
// file ..\..\..\..\lib\third_party\mbedtls\library\pk.c line 163
static inline signed int pk_hashlen_helper(mbedtls_md_type_t md_alg, size_t *hash_len)
{
  const mbedtls_md_info_t *md_info;
  if(!(*hash_len == 0ull))
    return 0;

  else
  {
    md_info=mbedtls_md_info_from_type(md_alg);
    if(md_info == ((const mbedtls_md_info_t *)NULL))
      return -1;

    else
    {
      unsigned char return_value_mbedtls_md_get_size=mbedtls_md_get_size(md_info);
      *hash_len = (size_t)return_value_mbedtls_md_get_size;
      return 0;
    }
  }
}

// pk_parse_key_pkcs1_der
// file ..\..\..\..\lib\third_party\mbedtls\library\pkparse.c line 669
static signed int pk_parse_key_pkcs1_der(mbedtls_rsa_context *rsa, const unsigned char *pk_parse_key_pkcs1_der$$key, size_t keylen)
{
  signed int ret;
  signed int version;
  size_t len;
  unsigned char *p;
  unsigned char *end;
  mbedtls_mpi T;
  mbedtls_mpi_init(&T);
  p = (unsigned char *)pk_parse_key_pkcs1_der$$key;
  end = p + (signed long long int)keylen;
  ret=mbedtls_asn1_get_tag(&p, end, &len, 0x20 | 0x10);
  _Bool tmp_if_expr$0;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  if(!(ret == 0))
    return -0x3D00 + ret;

  else
  {
    end = p + (signed long long int)len;
    ret=mbedtls_asn1_get_int(&p, end, &version);
    if(!(ret == 0))
      return -0x3D00 + ret;

    else
      if(!(version == 0))
        return -0x3D80;

      else
      {
        ret=mbedtls_asn1_get_tag(&p, end, &len, 0x2);
        _Bool tmp_if_expr;
        if(!(ret == 0))
          tmp_if_expr = (_Bool)1;

        else
        {
          ret=mbedtls_rsa_import_raw(rsa, p, len, ((const unsigned char *)NULL), 0ull, ((const unsigned char *)NULL), 0ull, ((const unsigned char *)NULL), 0ull, ((const unsigned char *)NULL), 0ull);
          tmp_if_expr = ret != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(!tmp_if_expr)
        {
          p = p + (signed long long int)len;
          ret=mbedtls_asn1_get_tag(&p, end, &len, 0x2);
          if(!(ret == 0))
            tmp_if_expr$0 = (_Bool)1;

          else
          {
            ret=mbedtls_rsa_import_raw(rsa, ((const unsigned char *)NULL), 0ull, ((const unsigned char *)NULL), 0ull, ((const unsigned char *)NULL), 0ull, ((const unsigned char *)NULL), 0ull, p, len);
            tmp_if_expr$0 = ret != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(!tmp_if_expr$0)
          {
            p = p + (signed long long int)len;
            ret=mbedtls_asn1_get_tag(&p, end, &len, 0x2);
            if(!(ret == 0))
              tmp_if_expr$1 = (_Bool)1;

            else
            {
              ret=mbedtls_rsa_import_raw(rsa, ((const unsigned char *)NULL), 0ull, ((const unsigned char *)NULL), 0ull, ((const unsigned char *)NULL), 0ull, p, len, ((const unsigned char *)NULL), 0ull);
              tmp_if_expr$1 = ret != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(!tmp_if_expr$1)
            {
              p = p + (signed long long int)len;
              ret=mbedtls_asn1_get_tag(&p, end, &len, 0x2);
              if(!(ret == 0))
                tmp_if_expr$2 = (_Bool)1;

              else
              {
                ret=mbedtls_rsa_import_raw(rsa, ((const unsigned char *)NULL), 0ull, p, len, ((const unsigned char *)NULL), 0ull, ((const unsigned char *)NULL), 0ull, ((const unsigned char *)NULL), 0ull);
                tmp_if_expr$2 = ret != 0 ? (_Bool)1 : (_Bool)0;
              }
              if(!tmp_if_expr$2)
              {
                p = p + (signed long long int)len;
                ret=mbedtls_asn1_get_tag(&p, end, &len, 0x2);
                if(!(ret == 0))
                  tmp_if_expr$3 = (_Bool)1;

                else
                {
                  ret=mbedtls_rsa_import_raw(rsa, ((const unsigned char *)NULL), 0ull, ((const unsigned char *)NULL), 0ull, p, len, ((const unsigned char *)NULL), 0ull, ((const unsigned char *)NULL), 0ull);
                  tmp_if_expr$3 = ret != 0 ? (_Bool)1 : (_Bool)0;
                }
                if(!tmp_if_expr$3)
                {
                  p = p + (signed long long int)len;
                  ret=mbedtls_rsa_complete(rsa);
                  if(ret == 0)
                  {
                    ret=mbedtls_asn1_get_mpi(&p, end, &T);
                    if(!(ret == 0))
                      tmp_if_expr$4 = (_Bool)1;

                    else
                    {
                      ret=mbedtls_asn1_get_mpi(&p, end, &T);
                      tmp_if_expr$4 = ret != 0 ? (_Bool)1 : (_Bool)0;
                    }
                    if(tmp_if_expr$4)
                      tmp_if_expr$5 = (_Bool)1;

                    else
                    {
                      ret=mbedtls_asn1_get_mpi(&p, end, &T);
                      tmp_if_expr$5 = ret != 0 ? (_Bool)1 : (_Bool)0;
                    }
                    if(!tmp_if_expr$5)
                    {
                      if(!(p == end))
                        ret = -0x3D00 + -0x66;

                    }

                  }

                }

              }

            }

          }

        }


      cleanup:
        ;
        mbedtls_mpi_free(&T);
        if(!(ret == 0))
        {
          if((0xFF80 & ret) == 0)
            ret = -0x3D00 + ret;

          else
            ret = -0x3D00;
          mbedtls_rsa_free(rsa);
        }

        return ret;
      }
  }
}

// pk_parse_key_pkcs8_unencrypted_der
// file ..\..\..\..\lib\third_party\mbedtls\library\pkparse.c line 934
static signed int pk_parse_key_pkcs8_unencrypted_der(mbedtls_pk_context *pk, const unsigned char *pk_parse_key_pkcs8_unencrypted_der$$key, size_t keylen)
{
  signed int ret;
  signed int version;
  size_t len;
  mbedtls_asn1_buf params;
  unsigned char *p=(unsigned char *)pk_parse_key_pkcs8_unencrypted_der$$key;
  unsigned char *end=p + (signed long long int)keylen;
  mbedtls_pk_type_t pk_alg=/*enum*/MBEDTLS_PK_NONE;
  const mbedtls_pk_info_t *pk_info;
  ret=mbedtls_asn1_get_tag(&p, end, &len, 0x20 | 0x10);
  mbedtls_ecp_keypair *return_value_mbedtls_pk_ec$0;
  if(!(ret == 0))
    return -0x3D00 + ret;

  else
  {
    end = p + (signed long long int)len;
    ret=mbedtls_asn1_get_int(&p, end, &version);
    if(!(ret == 0))
      return -0x3D00 + ret;

    else
      if(!(version == 0))
        return -0x3D80 + ret;

      else
      {
        ret=pk_get_pk_alg(&p, end, &pk_alg, &params);
        if(!(ret == 0))
          return -0x3D00 + ret;

        else
        {
          ret=mbedtls_asn1_get_tag(&p, end, &len, 0x4);
          if(!(ret == 0))
            return -0x3D00 + ret;

          else
            if(!(len >= 1ull))
              return -0x3D00 + -0x60;

            else
            {
              pk_info=mbedtls_pk_info_from_type(pk_alg);
              if(pk_info == ((const mbedtls_pk_info_t *)NULL))
                return -0x3C80;

              else
              {
                ret=mbedtls_pk_setup(pk, pk_info);
                if(!(ret == 0))
                  return ret;

                else
                {
                  if((signed int)pk_alg == 1)
                  {
                    mbedtls_rsa_context *return_value_mbedtls_pk_rsa=mbedtls_pk_rsa(*pk);
                    ret=pk_parse_key_pkcs1_der(return_value_mbedtls_pk_rsa, p, len);
                    if(!(ret == 0))
                    {
                      mbedtls_pk_free(pk);
                      return ret;
                    }

                  }

                  else
                    if((signed int)pk_alg == 2 || (signed int)pk_alg == 3)
                    {
                      mbedtls_ecp_keypair *return_value_mbedtls_pk_ec=mbedtls_pk_ec(*pk);
                      ret=pk_use_ecparams(&params, &return_value_mbedtls_pk_ec->grp);
                      _Bool tmp_if_expr;
                      if(!(ret == 0))
                        tmp_if_expr = (_Bool)1;

                      else
                      {
                        return_value_mbedtls_pk_ec$0=mbedtls_pk_ec(*pk);
                        ret=pk_parse_key_sec1_der(return_value_mbedtls_pk_ec$0, p, len);
                        tmp_if_expr = ret != 0 ? (_Bool)1 : (_Bool)0;
                      }
                      if(tmp_if_expr)
                      {
                        mbedtls_pk_free(pk);
                        return ret;
                      }

                    }

                    else
                      return -0x3C80;
                  return 0;
                }
              }
            }
        }
      }
  }
}

// pk_parse_key_sec1_der
// file ..\..\..\..\lib\third_party\mbedtls\library\pkparse.c line 796
static signed int pk_parse_key_sec1_der(mbedtls_ecp_keypair *eck, const unsigned char *pk_parse_key_sec1_der$$key, size_t keylen)
{
  signed int ret;
  signed int version;
  signed int pubkey_done;
  size_t len;
  mbedtls_asn1_buf params;
  unsigned char *p=(unsigned char *)pk_parse_key_sec1_der$$key;
  unsigned char *end=p + (signed long long int)keylen;
  unsigned char *end2;
  ret=mbedtls_asn1_get_tag(&p, end, &len, 0x20 | 0x10);
  if(!(ret == 0))
    return -0x3D00 + ret;

  else
  {
    end = p + (signed long long int)len;
    ret=mbedtls_asn1_get_int(&p, end, &version);
    if(!(ret == 0))
      return -0x3D00 + ret;

    else
      if(!(version == 1))
        return -0x3D80;

      else
      {
        ret=mbedtls_asn1_get_tag(&p, end, &len, 0x4);
        if(!(ret == 0))
          return -0x3D00 + ret;

        else
        {
          ret=mbedtls_mpi_read_binary(&eck->d, p, len);
          if(!(ret == 0))
          {
            mbedtls_ecp_keypair_free(eck);
            return -0x3D00 + ret;
          }

          else
          {
            p = p + (signed long long int)len;
            pubkey_done = 0;
            if(!(p == end))
            {
              ret=mbedtls_asn1_get_tag(&p, end, &len, 0x80 | 0x20 | 0);
              if(ret == 0)
              {
                ret=pk_get_ecparams(&p, p + (signed long long int)len, &params);
                _Bool tmp_if_expr;
                if(!(ret == 0))
                  tmp_if_expr = (_Bool)1;

                else
                {
                  ret=pk_use_ecparams(&params, &eck->grp);
                  tmp_if_expr = ret != 0 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr)
                {
                  mbedtls_ecp_keypair_free(eck);
                  return ret;
                }

              }

              else
                if(!(ret == -98))
                {
                  mbedtls_ecp_keypair_free(eck);
                  return -0x3D00 + ret;
                }

            }

            if(!(p == end))
            {
              ret=mbedtls_asn1_get_tag(&p, end, &len, 0x80 | 0x20 | 1);
              if(ret == 0)
              {
                end2 = p + (signed long long int)len;
                ret=mbedtls_asn1_get_bitstring_null(&p, end2, &len);
                if(!(ret == 0))
                  return -0x3D00 + ret;

                if(!(p + (signed long long int)len == end2))
                  return -0x3D00 + -0x66;

                ret=pk_get_ecpubkey(&p, end2, eck);
                if(ret == 0)
                  pubkey_done = 1;

                else
                  if(!(ret == -20096))
                    return -0x3D00;

              }

              else
                if(!(ret == -98))
                {
                  mbedtls_ecp_keypair_free(eck);
                  return -0x3D00 + ret;
                }

            }

            if(pubkey_done == 0)
            {
              ret=mbedtls_ecp_mul(&eck->grp, &eck->Q, &eck->d, &eck->grp.G, ((signed int (*)(void *, unsigned char *, size_t))NULL), NULL);
              if(!(ret == 0))
              {
                mbedtls_ecp_keypair_free(eck);
                return -0x3D00 + ret;
              }

            }

            ret=mbedtls_ecp_check_privkey(&eck->grp, &eck->d);
            if(!(ret == 0))
            {
              mbedtls_ecp_keypair_free(eck);
              return ret;
            }

            else
              return 0;
          }
        }
      }
  }
}

// pk_use_ecparams
// file ..\..\..\..\lib\third_party\mbedtls\library\pkparse.c line 452
static signed int pk_use_ecparams(const mbedtls_asn1_buf *params, mbedtls_ecp_group *grp)
{
  signed int ret;
  mbedtls_ecp_group_id grp_id;
  if(params->tag == 0x6)
  {
    signed int return_value_mbedtls_oid_get_ec_grp=mbedtls_oid_get_ec_grp(params, &grp_id);
    if(!(return_value_mbedtls_oid_get_ec_grp == 0))
      return -0x3A00;

  }

  else
    return -0x3D00;
  if(!((signed int)grp->id == 0))
  {
    if(!(grp->id == grp_id))
      return -0x3D00;

  }

  ret=mbedtls_ecp_group_load(grp, grp_id);
  if(!(ret == 0))
    return ret;

  else
    return 0;
}

// powl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 903
/*inline double powl(double _X, double _Y)*/
/*{*/
  /*double return_value_pow=pow((double)_X, (double)_Y);*/
  /*return return_value_pow;*/
/*}*/

// preparse_next_value
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 256
static CborError preparse_next_value(CborValue *it)
{
  if(!(it->remaining == 4294967295u))
  {
    if(!((signed int)it->type == 192))
    {
      it->remaining = it->remaining - 1u;
      if(it->remaining == 0u)
      {
        it->type = 255;
        return /*enum*/CborNoError;
      }

    }

  }

  else
    if(it->remaining == 4294967295u)
    {
      if(!(it->ptr == it->parser->end))
      {
        if(*it->ptr == 255)
        {
          it->ptr = it->ptr + 1ll;
          it->type = 255;
          it->remaining = 0u;
          return /*enum*/CborNoError;
        }

      }

    }

  CborError return_value_preparse_value=preparse_value(it);
  return return_value_preparse_value;
}

// preparse_value
// file ..\..\..\..\lib\third_party\tinycbor\cborparser.c line 170
static CborError preparse_value(CborValue *it)
{
  const CborParser *parser=it->parser;
  it->type = 255;
  if(it->ptr == parser->end)
    return /*enum*/CborErrorUnexpectedEOF;

  else
  {
    uint8_t descriptor=*it->ptr;
    uint8_t type=(uint8_t)((signed int)descriptor & -32);
    it->type = type;
    it->flags = 0;
    descriptor = descriptor & 31;
    it->extra = (uint16_t)descriptor;
    if((signed int)descriptor >= 28)
    {
      if(!((signed int)descriptor == 31))
        return (CborError)((signed int)type == 224 ? 259 : 261);

      _Bool return_value_is_fixed_type=is_fixed_type(type);
      if(return_value_is_fixed_type == (_Bool)0)
      {
        it->flags = it->flags | 4;
        it->type = type;
        return /*enum*/CborNoError;
      }

      return (CborError)((signed int)type == 224 ? 258 : 261);
    }

    else
    {
      size_t bytesNeeded=(size_t)((signed int)descriptor < 24 ? 0 : 1 << (signed int)descriptor - 24);
      if(!((size_t)(parser->end - it->ptr) >= 1ull + bytesNeeded))
        return /*enum*/CborErrorUnexpectedEOF;

      else
      {
        uint8_t majortype=(uint8_t)((signed int)type >> 5);
        if((signed int)majortype == 1)
        {
          it->flags = it->flags | 2;
          it->type = 0;
        }

        else
          if((signed int)majortype == 7)
            switch((signed int)descriptor)
            {
              case 20:
              {
                it->extra = 0;
                it->type = 245;
                goto __CPROVER_DUMP_L13;
              }
              case 26:

              case 27:
                it->flags = it->flags | 1;
              case 21:

              case 22:

              case 23:

              case 25:
              {
                it->type = *it->ptr;
                goto __CPROVER_DUMP_L13;
              }
              case 24:
              {
                it->extra = (uint16_t)(uint8_t)it->ptr[1ll];
                if(!((signed int)it->extra >= 32))
                {
                  it->type = 255;
                  return /*enum*/CborErrorIllegalSimpleType;
                }

                goto __CPROVER_DUMP_L13;
              }
              case 28:

              case 29:

              case 30:

              case 31:
              {
                /* assertion false */
                assert(0 != 0);
                return /*enum*/CborErrorUnexpectedBreak;
              }
              default:
              {

              __CPROVER_DUMP_L13:
                ;
                return /*enum*/CborNoError;
              }
            }

        if(!((signed int)descriptor >= 24))
          return /*enum*/CborNoError;

        else
        {
          if((signed int)descriptor == 24)
            it->extra = (uint16_t)(uint8_t)it->ptr[1ll];

          else
            if((signed int)descriptor == 25)
              it->extra=get16$link1(it->ptr + 1ll);

            else
              it->flags = it->flags | 1;
          return /*enum*/CborNoError;
        }
      }
    }
  }
}


// prvAbort
// file ..\..\..\..\lib\ota\portable\pc\windows\aws_ota_pal.c line 38
static OTA_Err_t prvAbort(OTA_FileContext_t * const C)
{
  int32_t iStatus=0;
  if(!(C->$anon0.pstFile == ((FILE *)NULL)))
  {
    iStatus=fclose(C->$anon0.pstFile);
    C->$anon0.pstFile = ((FILE *)NULL);
  }

  return (OTA_Err_t)iStatus;
}

// prvActivateNewImage
// file ..\..\..\..\lib\ota\portable\pc\windows\aws_ota_pal.c line 104
static OTA_Err_t prvActivateNewImage(void)
{
  return 0u;
}

// prvAddCurrentTaskToDelayedList
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 4983
static void prvAddCurrentTaskToDelayedList(TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely)
{
  TickType_t xTimeToWake;
  const TickType_t xConstTickCount=xTickCount;
  pxCurrentTCB->ucDelayAborted = 0;
  UBaseType_t return_value_uxListRemove=uxListRemove(&pxCurrentTCB->xStateListItem);
  if(return_value_uxListRemove == 0ul)
    uxTopReadyPriority = uxTopReadyPriority & ~(1ul << pxCurrentTCB->uxPriority);

  if(xTicksToWait == 0xFFFFFFFFul && !(xCanBlockIndefinitely == 0))
    vListInsertEnd(&xSuspendedTaskList, &pxCurrentTCB->xStateListItem);

  else
  {
    xTimeToWake = xConstTickCount + xTicksToWait;
    (&pxCurrentTCB->xStateListItem)->xItemValue = xTimeToWake;
    if(!(xTimeToWake >= xConstTickCount))
      vListInsert(pxOverflowDelayedTaskList, &pxCurrentTCB->xStateListItem);

    else
    {
      vListInsert(pxDelayedTaskList, &pxCurrentTCB->xStateListItem);
      if(!(xTimeToWake >= xNextTaskUnblockTime))
        xNextTaskUnblockTime = xTimeToWake;

    }
  }
}

// prvAddNewTaskToReadyList
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 1038
static void prvAddNewTaskToReadyList(TCB_t *pxNewTCB)
{
  vPortEnterCritical();
  uxCurrentNumberOfTasks = uxCurrentNumberOfTasks + 1ul;
  if(pxCurrentTCB == ((TCB_t *)NULL))
  {
    pxCurrentTCB = pxNewTCB;
    if(uxCurrentNumberOfTasks == 1ul)
      prvInitialiseTaskLists();

  }

  else
    if(xSchedulerRunning == 0)
    {
      if(pxNewTCB->uxPriority >= pxCurrentTCB->uxPriority)
        pxCurrentTCB = pxNewTCB;

    }

  uxTaskNumber = uxTaskNumber + 1ul;
  pxNewTCB->uxTCBNumber = uxTaskNumber;
  if(!(pxNewTCB == ((TCB_t *)NULL)))
  {
    traceHandle return_value_prvTraceGetObjectHandle=prvTraceGetObjectHandle(3);
    pxNewTCB->uxTaskNumber = (UBaseType_t)return_value_prvTraceGetObjectHandle;
    traceHandle return_value_prvTraceGetTaskNumber=prvTraceGetTaskNumber((void *)pxNewTCB);
    prvTraceSetObjectName(3, return_value_prvTraceGetTaskNumber, (char *)pxNewTCB->pcTaskName);
    traceHandle return_value_prvTraceGetTaskNumber$0=prvTraceGetTaskNumber((void *)pxNewTCB);
    prvTraceSetPriorityProperty(3, return_value_prvTraceGetTaskNumber$0, (uint8_t)pxNewTCB->uxPriority);
    traceHandle return_value_prvTraceGetTaskNumber$1=prvTraceGetTaskNumber((void *)pxNewTCB);
    prvTraceStoreKernelCall((uint32_t)(uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 3u), 3, (uint32_t)return_value_prvTraceGetTaskNumber$1);
  }

  traceHandle return_value_prvTraceGetTaskNumber$2=prvTraceGetTaskNumber((void *)pxNewTCB);
  prvTraceStoreTaskReady(return_value_prvTraceGetTaskNumber$2);
  uxTopReadyPriority = uxTopReadyPriority | 1ul << pxNewTCB->uxPriority;
  vListInsertEnd(&pxReadyTasksLists[(signed long long int)pxNewTCB->uxPriority], &pxNewTCB->xStateListItem);
  (void)pxNewTCB;
  vPortExitCritical();
  if(!(xSchedulerRunning == 0))
  {
    if(!(pxCurrentTCB->uxPriority >= pxNewTCB->uxPriority))
      vPortGenerateSimulatedInterrupt(0ul);

  }

}

// prvAgentShutdown
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 515
void prvAgentShutdown(void)
{
  uint32_t i;
  eOTA_AgentState = /*enum*/eOTA_AgentState_ShuttingDown;
  prvUnSubscribeFromJobNotificationTopic();
  i = 0u;
  for( ; !(i >= 1u); i = i + 1u)
    prvOTA_Close(&astOTA_Files[(signed long long int)i]);
  if(!(pacOTA_Singleton_ActiveJobName == ((uint8_t *)NULL)))
  {
    vPortFree((void *)pacOTA_Singleton_ActiveJobName);
    pacOTA_Singleton_ActiveJobName = ((uint8_t *)NULL);
  }

}

// prvAllowIPPacket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 1422
static eFrameProcessingResult_t prvAllowIPPacket(const IPPacket_t * const pxIPPacket, NetworkBufferDescriptor_t * const pxNetworkBuffer, UBaseType_t uxHeaderLength)
{
  eFrameProcessingResult_t eReturn=/*enum*/eProcessBuffer;
  const IPHeader_t *pxIPHeader=&pxIPPacket->xIPHeader;
  uint32_t ulDestinationIPAddress=pxIPHeader->ulDestinationIPAddress;
  _Bool tmp_if_expr;
  if(!((65295u & (unsigned int)(signed int)pxIPHeader->usFragmentOffset) == 0u))
    eReturn = /*enum*/eReleaseBuffer;

  else
  {
    if(!((unsigned int)pxIPHeader->ucVersionHeaderLength >= 0x45u))
      tmp_if_expr = (_Bool)1;

    else
      tmp_if_expr = (unsigned int)pxIPHeader->ucVersionHeaderLength > 0x4Fu ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr)
      eReturn = /*enum*/eReleaseBuffer;

    else
      if(!(ulDestinationIPAddress == xDefaultPartUDPPacketHeader.ulWords[5ll]))
      {
        if(!(ulDestinationIPAddress == 0xFFFFFFFFul))
        {
          if(!(ulDestinationIPAddress == xNetworkAddressing.ulBroadcastAddress))
          {
            if(!(xDefaultPartUDPPacketHeader.ulWords[5ll] == 0ul))
              eReturn = /*enum*/eReleaseBuffer;

          }

        }

      }

  }
  (void)pxNetworkBuffer;
  (void)uxHeaderLength;
  return eReturn;
}

// prvBuildDataRequestTopicName
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1759
static uint32_t prvBuildDataRequestTopicName(char *pcNameBuffer, uint32_t ulBufSize, OTA_FileContext_t *C)
{
  uint32_t ulTopicLen;
  size_t return_value_strlen=strlen((const char *)C->pacStreamName);
  ulTopicLen = (uint32_t)((return_value_strlen + (sizeof(const char [62ll]) /*62ull*/  - 1ull)) - 1ull);
  if(ulBufSize >= ulTopicLen)
    ulTopicLen=rsprintf(pcNameBuffer, acOTA_Request_TopicTemplate, C->pacStreamName);

  else
    ulTopicLen = 0u;
  return ulTopicLen;
}

// prvBuildDataStreamTopicName
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1783
static uint32_t prvBuildDataStreamTopicName(char *pcNameBuffer, uint32_t ulBufSize, OTA_FileContext_t *C)
{
  uint32_t ulTopicLen;
  size_t return_value_strlen=strlen((const char *)C->pacStreamName);
  ulTopicLen = (uint32_t)((return_value_strlen + (sizeof(const char [54ll]) /*54ull*/  - 1ull)) - 1ull);
  if(ulBufSize >= ulTopicLen)
    ulTopicLen=rsprintf(pcNameBuffer, acOTA_RxStream_TopicTemplate, C->pacStreamName);

  else
    ulTopicLen = 0u;
  return ulTopicLen;
}

// prvBuildJobStatusTopicName
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1730
static uint32_t prvBuildJobStatusTopicName(char *pcNameBuffer, uint32_t ulBufSize, const char *pacJobName)
{
  uint32_t ulTopicLen=0u;
  if(!(pacJobName == ((const char *)NULL)))
  {
    size_t return_value_strlen=strlen(pacJobName);
    ulTopicLen = (uint32_t)((return_value_strlen + (sizeof(const char [58ll]) /*58ull*/  - 1ull)) - 1ull);
  }

  if(ulBufSize >= ulTopicLen)
    ulTopicLen=rsprintf(pcNameBuffer, acOTA_JobStatus_TopicTemplate, pacJobName);

  else
    ulTopicLen = 0u;
  return ulTopicLen;
}

// prvBytesInBuffer
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 1121
static size_t prvBytesInBuffer(const StreamBuffer_t1 * const pxStreamBuffer)
{
  size_t xCount=pxStreamBuffer->xLength + pxStreamBuffer->xHead;
  xCount = xCount - pxStreamBuffer->xTail;
  if(xCount >= pxStreamBuffer->xLength)
    xCount = xCount - pxStreamBuffer->xLength;

  return xCount;
}

// prvCacheLookup
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_ARP.c line 461
static eARPLookupResult_t prvCacheLookup(uint32_t ulAddressToLookup, MACAddress_t * const pxMACAddress)
{
  BaseType_t x;
  eARPLookupResult_t eReturn=/*enum*/eARPCacheMiss;
  x = 0;
  for( ; !(x >= 6); x = x + 1l)
    if(xARPCache[(signed long long int)x].ulIPAddress == ulAddressToLookup)
    {
      if(xARPCache[(signed long long int)x].ucValid == 0)
        eReturn = /*enum*/eCantSendPacket;

      else
      {
        memcpy((void *)pxMACAddress->ucBytes, (const void *)xARPCache[(signed long long int)x].xMACAddress.ucBytes, sizeof(MACAddress_t) /*6ull*/ );
        eReturn = /*enum*/eARPCacheHit;
      }
      break;
    }

  return eReturn;
}

// prvCalculateSleepTime
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 571
static TickType_t prvCalculateSleepTime(void)
{
  TickType_t xMaximumSleepTime=(TickType_t)((10000ul * 1000u) / 1000u);
  if(!((unsigned int)xARPTimer.bActive == 0u))
  {
    if(!(xARPTimer.ulRemainingTime >= xMaximumSleepTime))
      xMaximumSleepTime = xARPTimer.ulReloadTime;

  }

  if(!((unsigned int)xDHCPTimer.bActive == 0u))
  {
    if(!(xDHCPTimer.ulRemainingTime >= xMaximumSleepTime))
      xMaximumSleepTime = xDHCPTimer.ulRemainingTime;

  }

  if(!(xTCPTimer.ulRemainingTime >= xMaximumSleepTime))
    xMaximumSleepTime = xTCPTimer.ulRemainingTime;

  return xMaximumSleepTime;
}

// prvCalloc
// file ..\..\..\..\lib\crypto\aws_crypto.c line 61
static void * prvCalloc(size_t xNmemb, size_t xSize)
{
  void *pvNew=pvPortMalloc(xNmemb * xSize);
  if(!(pvNew == NULL))
    memset(pvNew, 0, xNmemb * xSize);

  return pvNew;
}

// prvChangeDesiredTask
// file ..\..\..\common\shadow\aws_shadow_lightbulb_on_off.c line 372
static void prvChangeDesiredTask(void *pvParameters)
{
  uint8_t ucBulbState=0;
  uint32_t ulInitialReportLength;
  TickType_t xLastWakeTime;
  ShadowTaskParam_t *pxShadowTaskParam;
  ShadowQueueData_t xShadowQueueData;
  char pcInitialReportBuffer[(signed long long int)(sizeof(char [11ll]) * 2ul + 3ul) /*25ll*/ ];
  pxShadowTaskParam = (ShadowTaskParam_t *)pvParameters;
  memset((void *)&xShadowQueueData, 0x0, sizeof(ShadowQueueData_t) /*144ull*/ );
  xShadowQueueData.xTaskToNotify = pxShadowTaskParam->xTaskHandle;
  signed int return_value_snprintf=snprintf(pcInitialReportBuffer, sizeof(char [11ll]) /*11ull*/  + sizeof(char [14ll]) /*14ull*/ , "{\"%s\": \"red\"}", (const void *)pxShadowTaskParam->cTaskName);
  ulInitialReportLength = (uint32_t)return_value_snprintf;
  xShadowQueueData.ulDataLength=prvGenerateReportedJSON(&xShadowQueueData, pcInitialReportBuffer, ulInitialReportLength);
  BaseType_t return_value_xQueueGenericSend=xQueueGenericSend(xUpdateQueue, (const void *)&xShadowQueueData, 3000u, 0);
  if(!(return_value_xQueueGenericSend == 1))
    vAssertCalled("..\\..\\..\\common\\shadow\\aws_shadow_lightbulb_on_off.c", 395u);

  uint32_t return_value_ulTaskNotifyTake=ulTaskNotifyTake(1, (TickType_t)((100000ul * 1000u) / 1000u));
  if(!(return_value_ulTaskNotifyTake == 1u))
    vAssertCalled("..\\..\\..\\common\\shadow\\aws_shadow_lightbulb_on_off.c", 396u);

  xLastWakeTime=xTaskGetTickCount();
  while((_Bool)1)
  {
    vLoggingPrintf("%s changing desired state.\r\n", (const void *)pxShadowTaskParam->cTaskName);
    ucBulbState = (uint8_t)!(ucBulbState != 0);
    xShadowQueueData.ulDataLength=prvGenerateDesiredJSON(&xShadowQueueData, pxShadowTaskParam->cTaskName, ucBulbState);
    BaseType_t return_value_xQueueGenericSend$0=xQueueGenericSend(xUpdateQueue, (const void *)&xShadowQueueData, 3000u, 0);
    if(return_value_xQueueGenericSend$0 == 1)
    {
      uint32_t return_value_ulTaskNotifyTake$0=ulTaskNotifyTake(1, (TickType_t)((100000ul * 1000u) / 1000u));
      if(!(return_value_ulTaskNotifyTake$0 == 1u))
        vAssertCalled("..\\..\\..\\common\\shadow\\aws_shadow_lightbulb_on_off.c", 415u);

      vLoggingPrintf("%s done changing desired state.\r\n", (const void *)pxShadowTaskParam->cTaskName);
    }

    else
      vLoggingPrintf("Update queue full, deferring desired state change.\r\n");
    vTaskDelayUntil(&xLastWakeTime, (TickType_t)(((TickType_t)(5ul * 1000ul) * 1000u) / 1000u));
  }
}

// prvCheckCertificate
// file ..\..\..\..\lib\tls\aws_tls.c line 194
static signed int prvCheckCertificate(void *pvCtx, mbedtls_x509_crt *pxCertificate, signed int lPathCount, uint32_t *pulFlags)
{
  signed int lCompilationYear=0;
  char pcCompilationMonth[4ll];
  signed int lCompilationMonth=0;
  signed int lCompilationDay=0;
  const char pcMonths[37ll]={ 'J', 'a', 'n', 'F', 'e', 'b', 'M', 'a', 'r', 'A', 'p', 'r', 'M', 'a', 'y', 'J', 'u', 'n', 'J', 'u', 'l', 'A', 'u', 'g', 'S', 'e', 'p', 'O', 'c', 't', 'N', 'o', 'v', 'D', 'e', 'c', 0 };
  (void)pvCtx;
  (void)lPathCount;
  sscanf("Aug 14 2018", "%3s %d %d", (const void *)pcCompilationMonth, &lCompilationDay, &lCompilationYear);
  pcCompilationMonth[(signed long long int)(4 - 1)] = 0;
  if(!(pxCertificate->valid_to.year >= lCompilationYear))
    *pulFlags = *pulFlags | 1u;

  else
    if(pxCertificate->valid_to.year == lCompilationYear)
    {
      char *return_value_strstr=strstr(pcMonths, pcCompilationMonth);
      lCompilationMonth = (signed int)((return_value_strstr - pcMonths) / (signed long long int)(4 - 1) + 1ll);
      if(!(pxCertificate->valid_to.mon >= lCompilationMonth))
        *pulFlags = *pulFlags | 1u;

      else
        if(pxCertificate->valid_to.mon == lCompilationMonth)
        {
          if(!(pxCertificate->valid_to.day >= lCompilationDay))
            *pulFlags = *pulFlags | 1u;

        }

    }

  return 0;
}

// prvCheckDataToBeOverwrittenForMultiEntryEvents
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2570
static void prvCheckDataToBeOverwrittenForMultiEntryEvents(uint8_t nofEntriesToCheck)
{
  unsigned int i=0u;
  unsigned int e=0u;
  if((signed int)nofEntriesToCheck == 0)
    prvTraceError("TRACE_ASSERT: prvCheckDataToBeOverwrittenForMultiEntryEvents: nofEntriesToCheck == 0");

  else
    while(!(i >= (unsigned int)nofEntriesToCheck))
    {
      e = RecorderDataPtr->nextFreeIndex + i;
      _Bool tmp_if_expr;
      if((unsigned int)RecorderDataPtr->eventData[(signed long long int)(4u * e)] >= 153ul)
        tmp_if_expr = (unsigned int)RecorderDataPtr->eventData[(signed long long int)(e * 4u)] < 0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 0ul + 16u ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr = (_Bool)0;
      if(tmp_if_expr)
      {
        uint8_t nDataEvents=(uint8_t)((unsigned int)RecorderDataPtr->eventData[(signed long long int)(e * 4u)] - (0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 0ul));
        if(!(e + (unsigned int)nDataEvents >= RecorderDataPtr->maxEvents))
          memset((void *)&RecorderDataPtr->eventData[(signed long long int)(e * 4u)], 0, (size_t)(4 + 4 * (signed int)nDataEvents));

      }

      else
        if((unsigned int)RecorderDataPtr->eventData[(signed long long int)(4u * e)] == 1ul)
        {
          if(!(1u + e >= RecorderDataPtr->maxEvents))
            memset((void *)&RecorderDataPtr->eventData[(signed long long int)(e * 4u)], 0, (size_t)(4 + 4));

          else
          {
            memset((void *)RecorderDataPtr->eventData, 0, 4ull);
            memset((void *)&RecorderDataPtr->eventData[(signed long long int)(e * 4u)], 0, 4ull);
          }
        }

      i = i + 1u;
    }
}

// prvCheckFileSignature
// file ..\..\..\..\lib\ota\portable\pc\windows\aws_ota_pal.c line 124
static OTA_Err_t prvCheckFileSignature(OTA_FileContext_t * const C)
{
  OTA_Err_t err=0u;
  uint32_t ulBytesRead;
  uint32_t ulTotalBytes=0u;
  int32_t lSignerCertSize;
  uint8_t *pucBuf;
  uint8_t *pucSignerCert;
  void *pvSigVerifyContext;
  BaseType_t return_value_CRYPTO_SignatureVerificationStart=CRYPTO_SignatureVerificationStart(&pvSigVerifyContext, 1, 2);
  if(return_value_CRYPTO_SignatureVerificationStart == 0)
    err = 16777216u;

  else
  {
    vLoggingPrintf("[OTA] Started %s signature verification\r\n", (const void *)acOTA_JSON_FileSignatureKey);
    pucSignerCert=prvReadAndAssumeCertificate((const uint8_t *)C->pacCertFilepath, &lSignerCertSize);
    if(!(pucSignerCert == ((uint8_t *)NULL)))
    {
      void *return_value_pvPortMalloc=pvPortMalloc(1024ull);
      pucBuf = (uint8_t *)return_value_pvPortMalloc;
      if(!(pucBuf == ((uint8_t *)NULL)) && !(pucSignerCert == ((uint8_t *)NULL)))
      {
        if(!(C->$anon0.pstFile == ((FILE *)NULL)))
        {
          signed int return_value_fseek=fseek(C->$anon0.pstFile, 0l, 0);
          if(return_value_fseek == 0)
          {
            do
            {
              size_t return_value_fread=fread((void *)pucBuf, 1ull, 1024ull, C->$anon0.pstFile);
              ulBytesRead = (uint32_t)return_value_fread;
              ulTotalBytes = ulTotalBytes + ulBytesRead;
              CRYPTO_SignatureVerificationUpdate(pvSigVerifyContext, pucBuf, (size_t)ulBytesRead);
            }
            while(ulBytesRead >= 1u);
            BaseType_t return_value_CRYPTO_SignatureVerificationFinal=CRYPTO_SignatureVerificationFinal(pvSigVerifyContext, (char *)pucSignerCert, (size_t)lSignerCertSize, C->pacSignature, (size_t)C->usSigSize);
            if(return_value_CRYPTO_SignatureVerificationFinal == 0)
              err = 16777216u;

          }

        }

        else
          err = 536870912u;
        vPortFree((void *)pucBuf);
      }

      else
        err = 50331648u;
      vPortFree((void *)pucSignerCert);
    }

    else
      err = 33554432u;
  }
  return err;
}

// prvCheckForContentLengthString
// file ..\..\..\..\lib\greengrass\aws_greengrass_discovery.c line 863
static BaseType_t prvCheckForContentLengthString(uint8_t *pucIndex, const char cNewChar)
{
  BaseType_t xMatch=0;
  if(cNewChar == "content-length:"[(signed long long int)*pucIndex])
  {
    *pucIndex = *pucIndex + 1;
    if(*pucIndex == 15)
      xMatch = 1;

  }

  else
    *pucIndex = 0;
  return xMatch;
}

// prvCheckForValidListAndQueue
// file ..\..\..\..\lib\FreeRTOS\timers.c line 894
static void prvCheckForValidListAndQueue(void)
{
  vPortEnterCritical();
  if(xTimerQueue == NULL)
  {
    vListInitialise(&xActiveTimerList1);
    vListInitialise(&xActiveTimerList2);
    pxCurrentTimerList = &xActiveTimerList1;
    pxOverflowTimerList = &xActiveTimerList2;
    static StaticQueue_t xStaticTimerQueue;
    static uint8_t ucStaticTimerQueueStorage[(signed long long int)(sizeof(DaemonTaskMessage_t) * 5ul) /*160ll*/ ];
    xTimerQueue=xQueueGenericCreateStatic(5ul, (UBaseType_t)sizeof(DaemonTaskMessage_t) /*32ul*/ , ucStaticTimerQueueStorage, &xStaticTimerQueue, 0);
  }

  vPortExitCritical();
}

// prvCheckMatch
// file ..\..\..\..\lib\greengrass\aws_greengrass_discovery.c line 614
static void prvCheckMatch(const char *prvCheckMatch$$pcJSONFile, const jsmntok_t *pxTok, const uint32_t ulTokenIndex, BaseType_t *pxMatch, const char *pcMatchCategory, const char *pcMatchString, const BaseType_t xAutoSelectFlag)
{
  *pxMatch=prvGGDJsoneq(prvCheckMatch$$pcJSONFile, &pxTok[(signed long long int)ulTokenIndex], pcMatchCategory);
  if(*pxMatch == 1)
  {
    if(!(xAutoSelectFlag == 1))
    {
      BaseType_t return_value_prvGGDJsoneq=prvGGDJsoneq(prvCheckMatch$$pcJSONFile, &pxTok[(signed long long int)(ulTokenIndex + 1u)], pcMatchString);
      if(return_value_prvGGDJsoneq == 1)
        *pxMatch = 1;

      else
        *pxMatch = 0;
    }

    else
      *pxMatch = 1;
  }

}

// prvCheckNetworkTimers
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 624
static void prvCheckNetworkTimers(void)
{
  BaseType_t return_value_prvIPTimerCheck=prvIPTimerCheck(&xARPTimer);
  if(!(return_value_prvIPTimerCheck == 0))
    xSendEventToIPTask(/*enum*/eARPTimerEvent);

  BaseType_t return_value_prvIPTimerCheck$0=prvIPTimerCheck(&xDHCPTimer);
  if(!(return_value_prvIPTimerCheck$0 == 0))
    xSendEventToIPTask(/*enum*/eDHCPEvent);

  BaseType_t xWillSleep;
  TickType_t xNextTime;
  BaseType_t xCheckTCPSockets;
  UBaseType_t return_value_uxQueueMessagesWaiting=uxQueueMessagesWaiting(xNetworkEventQueue);
  if(return_value_uxQueueMessagesWaiting == 0u)
    xWillSleep = 1;

  else
    xWillSleep = 0;
  xCheckTCPSockets=prvIPTimerCheck(&xTCPTimer);
  if(!(xWillSleep == 0) && !(xProcessedTCPMessage == 0))
    xCheckTCPSockets = 1;

  if(!(xCheckTCPSockets == 0))
  {
    xNextTime=xTCPTimerCheck(xWillSleep);
    prvIPTimerStart(&xTCPTimer, xNextTime);
    xProcessedTCPMessage = 0;
  }

}

// prvCheckOptions
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 1138
static void prvCheckOptions(FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxNetworkBuffer)
{
  TCPPacket_t *pxTCPPacket;
  TCPHeader_t *pxTCPHeader;
  const unsigned char *pucPtr;
  const unsigned char *pucLast;
  TCPWindow_t *pxTCPWindow;
  UBaseType_t uxNewMSS;
  pxTCPPacket = (TCPPacket_t *)pxNetworkBuffer->pucEthernetBuffer;
  pxTCPHeader = &pxTCPPacket->xTCPHeader;
  pucPtr = pxTCPHeader->ucOptdata;
  pucLast = pucPtr + (signed long long int)(((signed int)pxTCPHeader->ucTCPOffset >> 4) - 5 << 2);
  pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
  if(pxNetworkBuffer->pucEthernetBuffer + (signed long long int)pxNetworkBuffer->xDataLength >= pucLast)
    while(!(pucPtr >= pucLast))
    {
      UBaseType_t xRemainingOptionsBytes=(UBaseType_t)(pucLast - pucPtr);
      if((unsigned int)*pucPtr == 0u)
        break;

      if((unsigned int)*pucPtr == 1u)
        pucPtr = pucPtr + 1ll;

      else
        if(!(xRemainingOptionsBytes >= 2u))
          break;

        else
          if((unsigned int)*pucPtr == 3u)
          {
            _Bool tmp_if_expr;
            if(!(xRemainingOptionsBytes >= 3u))
              tmp_if_expr = (_Bool)1;

            else
              tmp_if_expr = (unsigned int)pucPtr[1ll] != 3u ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr)
              break;

            pxSocket->u.xTCP.ucPeerWinScaleFactor = pucPtr[2ll];
            pxSocket->u.xTCP.bits.bWinScaling = 1u;
            pucPtr = pucPtr + 3ll;
          }

          else
            if((unsigned int)*pucPtr == 2u)
            {
              _Bool tmp_if_expr$0;
              if(!(xRemainingOptionsBytes >= 4u))
                tmp_if_expr$0 = (_Bool)1;

              else
                tmp_if_expr$0 = (unsigned int)pucPtr[1ll] != 4u ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$0)
                break;

              uint16_t return_value_usChar2u16=usChar2u16$link1(pucPtr + 2ll);
              uxNewMSS = (UBaseType_t)return_value_usChar2u16;
              if(!((unsigned int)pxSocket->u.xTCP.usInitMSS == uxNewMSS))
              {
                if(uxNewMSS == 0u)
                  break;

                while((_Bool)0)
                  ;
              }

              if(!(uxNewMSS >= (unsigned int)pxSocket->u.xTCP.usInitMSS))
              {
                pxSocket->u.xTCP.bits.bMssChange = 1u;
                if(!(pxTCPWindow == ((TCPWindow_t *)NULL)))
                {
                  if(!(uxNewMSS >= (unsigned int)pxSocket->u.xTCP.usCurMSS))
                  {
                    while((_Bool)0)
                      ;
                    pxSocket->u.xTCP.usCurMSS = (uint16_t)uxNewMSS;
                  }

                }

                pxTCPWindow->xSize.ulRxWindowLength = (uint32_t)uxNewMSS * (pxTCPWindow->xSize.ulRxWindowLength / (uint32_t)uxNewMSS);
                pxTCPWindow->usMSSInit = (uint16_t)uxNewMSS;
                pxTCPWindow->usMSS = (uint16_t)uxNewMSS;
                pxSocket->u.xTCP.usInitMSS = (uint16_t)uxNewMSS;
                pxSocket->u.xTCP.usCurMSS = (uint16_t)uxNewMSS;
              }

              pucPtr = pucPtr + 4ll;
            }

            else
            {
              unsigned char len=pucPtr[1ll];
              if((signed int)len == 0 || !(xRemainingOptionsBytes >= (unsigned int)len))
                break;

              if((unsigned int)*pucPtr == 5u)
              {
                len = len - 2;
                pucPtr = pucPtr + 2ll;
                while((signed int)len >= 8)
                {
                  uint32_t ulFirst=ulChar2u32(pucPtr);
                  uint32_t ulLast=ulChar2u32(pucPtr + 4ll);
                  uint32_t ulCount=ulTCPWindowTxSack(&pxSocket->u.xTCP.xTCPWindow, ulFirst, ulLast);
                  if(!(pxSocket->u.xTCP.txStream == ((const StreamBuffer_t *)NULL)))
                  {
                    if(ulCount >= 1u)
                    {
                      uxStreamBufferGet(pxSocket->u.xTCP.txStream, 0ull, ((uint8_t *)NULL), (size_t)ulCount, 0);
                      pxSocket->xEventBits = pxSocket->xEventBits | 2u;
                    }

                  }

                  pucPtr = pucPtr + 8ll;
                  len = len - 8;
                }
              }

              pucPtr = pucPtr + (signed long long int)len;
            }
    }

}

// prvCheckRxData
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 2062
static BaseType_t prvCheckRxData(NetworkBufferDescriptor_t *pxNetworkBuffer, uint8_t **ppucRecvData)
{
  TCPPacket_t *pxTCPPacket=(TCPPacket_t *)pxNetworkBuffer->pucEthernetBuffer;
  TCPHeader_t *pxTCPHeader=&pxTCPPacket->xTCPHeader;
  int32_t lLength;
  int32_t lTCPHeaderLength;
  int32_t lReceiveLength;
  int32_t lUrgentLength;
  lTCPHeaderLength = (BaseType_t)(((unsigned int)pxTCPHeader->ucTCPOffset & 0xF0u) >> 2);
  *ppucRecvData = pxNetworkBuffer->pucEthernetBuffer + 14ll + 20ll + (signed long long int)lTCPHeaderLength;
  lReceiveLength = (int32_t)pxNetworkBuffer->xDataLength - 14;
  lLength = (int32_t)(uint16_t)((signed int)pxTCPPacket->xIPHeader.usLength << 8u | (signed int)pxTCPPacket->xIPHeader.usLength >> 8u);
  if(!(lLength >= lReceiveLength))
    lReceiveLength = lLength;

  if(!(20 + lTCPHeaderLength >= lReceiveLength))
    lReceiveLength = lReceiveLength - (lTCPHeaderLength + 20);

  else
    lReceiveLength = 0;
  if(!((0x20u & (unsigned int)pxTCPHeader->ucTCPFlags) == 0u))
  {
    lUrgentLength = (int32_t)(uint16_t)((signed int)pxTCPHeader->usUrgent << 8u | (signed int)pxTCPHeader->usUrgent >> 8u);
    *ppucRecvData = *ppucRecvData + (signed long long int)lUrgentLength;
    int32_t return_value_FreeRTOS_min_int32=FreeRTOS_min_int32$link1(lReceiveLength, lUrgentLength);
    lReceiveLength = lReceiveLength - return_value_FreeRTOS_min_int32;
  }

  return (BaseType_t)lReceiveLength;
}

// prvCheckTasksWaitingTermination
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3539
static void prvCheckTasksWaitingTermination(void)
{
  TCB_t *pxTCB;
  while(uxDeletedTasksWaitingCleanUp >= 1u)
  {
    vPortEnterCritical();
    pxTCB = (TCB_t *)(&(&xTasksWaitingTermination)->xListEnd)->pxNext->pvOwner;
    uxListRemove(&pxTCB->xStateListItem);
    uxCurrentNumberOfTasks = uxCurrentNumberOfTasks - 1ul;
    uxDeletedTasksWaitingCleanUp = uxDeletedTasksWaitingCleanUp - 1ul;
    vPortExitCritical();
    prvDeleteTCB(pxTCB);
  }
}

// prvCloseFile
// file ..\..\..\..\lib\ota\portable\pc\windows\aws_ota_pal.c line 74
static OTA_Err_t prvCloseFile(OTA_FileContext_t * const C)
{
  OTA_Err_t result;
  if(!(C->pacSignature == ((uint8_t *)NULL)))
    result=prvCheckFileSignature(C);

  else
    result = 16777216u;
  if(!(C->$anon0.pstFile == ((FILE *)NULL)))
  {
    fclose(C->$anon0.pstFile);
    C->$anon0.pstFile = ((FILE *)NULL);
  }

  if(result == 0u)
    vLoggingPrintf("[OTA] %s signature verification passed.\r\n", (const void *)acOTA_JSON_FileSignatureKey);

  else
    vLoggingPrintf("[OTA] ERROR: Failed to start %s signature verification.\r\n", (const void *)acOTA_JSON_FileSignatureKey);
  return result;
}

// prvConfigureCaptureBehaviour
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 369
static void prvConfigureCaptureBehaviour(void)
{
  struct bpf_program xFilterCode;
  uint32_t ulNetMask;
  sprintf(cErrorBuffer, "broadcast or multicast or ether host %x:%x:%x:%x:%x:%x", ucMACAddress[0ll], ucMACAddress[1ll], ucMACAddress[2ll], ucMACAddress[3ll], ucMACAddress[4ll], ucMACAddress[5ll]);
  ulNetMask = (uint32_t)(0 << 24ul | 255 << 16ul | 255 << 8l | 255);
  signed int return_value_pcap_compile=pcap_compile(pxOpenedInterfaceHandle, &xFilterCode, cErrorBuffer, 1, ulNetMask);
  if(!(return_value_pcap_compile >= 0))
    printf("\nThe packet filter string is invalid\n");

  else
  {
    signed int return_value_pcap_setfilter=pcap_setfilter(pxOpenedInterfaceHandle, &xFilterCode);
    if(!(return_value_pcap_setfilter >= 0))
      printf("\nAn error occurred setting the packet filter.\n");

  }
  prvCreateThreadSafeBuffers();
  if(pvSendEvent == NULL)
  {
    pvSendEvent=CreateEventA(((LPSECURITY_ATTRIBUTES)NULL), 0, 1, ((LPCSTR)NULL));
    vWinPcapRecvThreadHandle=CreateThread(((LPSECURITY_ATTRIBUTES)NULL), 0ull, prvWinPcapRecvThread, NULL, 0ul, ((LPDWORD)NULL));
    SetThreadAffinityMask(vWinPcapRecvThreadHandle, (DWORD_PTR)~0x1u);
    vWinPcapSendThreadHandle=CreateThread(((LPSECURITY_ATTRIBUTES)NULL), 0ull, prvWinPcapSendThread, NULL, 0ul, ((LPDWORD)NULL));
    SetThreadAffinityMask(vWinPcapSendThreadHandle, (DWORD_PTR)~0x1u);
    xTaskCreate(prvInterruptSimulatorTask, "MAC_ISR", 60, NULL, (UBaseType_t)(7 - 1), ((TaskHandle_t * const )NULL));
  }

}

// prvConnectionListeningTask
// file ..\..\..\common\tcp\aws_simple_tcp_echo_server.c line 113
static void prvConnectionListeningTask(void *pvParameters)
{
  struct freertos_sockaddr xClient;
  struct freertos_sockaddr xBindAddress;
  Socket_t xListeningSocket;
  Socket_t xConnectedSocket;
  uint32_t xSize=(uint32_t)sizeof(struct freertos_sockaddr) /*8u*/ ;
  const BaseType_t xBacklog=20;
  WinProperties_t xWinProps;
  (void)pvParameters;
  xListeningSocket=FreeRTOS_socket(2, 1, 6);
  if(xListeningSocket == (void *)4294967295u)
    vAssertCalled("..\\..\\..\\common\\tcp\\aws_simple_tcp_echo_server.c", 127u);

  static const TickType_t prvConnectionListeningTask$$1$$xReceiveTimeOut=0xFFFFFFFFul;
  FreeRTOS_setsockopt(xListeningSocket, 0, 0, (const void *)&prvConnectionListeningTask$$1$$xReceiveTimeOut, sizeof(const TickType_t) /*4ull*/ );
  xWinProps.lTxBufSize = (int32_t)(6u * ((1200u - 20u) - 20u));
  xWinProps.lTxWinSize = 3;
  xWinProps.lRxBufSize = (int32_t)(6u * ((1200u - 20u) - 20u));
  xWinProps.lRxWinSize = 3;
  FreeRTOS_setsockopt(xListeningSocket, 0, 13, (void *)&xWinProps, sizeof(WinProperties_t) /*16ull*/ );
  xBindAddress.sin_port = 7;
  xBindAddress.sin_port = (uint16_t)((signed int)xBindAddress.sin_port << 8u | (signed int)xBindAddress.sin_port >> 8u);
  FreeRTOS_bind(xListeningSocket, &xBindAddress, (uint32_t)sizeof(struct freertos_sockaddr) /*8u*/ );
  FreeRTOS_listen(xListeningSocket, xBacklog);
  while((_Bool)1)
  {
    xConnectedSocket=FreeRTOS_accept(xListeningSocket, &xClient, &xSize);
    if(xConnectedSocket == (void *)4294967295u)
      vAssertCalled("..\\..\\..\\common\\tcp\\aws_simple_tcp_echo_server.c", 152u);

    xTaskCreate(prvServerConnectionInstance, "EchoServer", usUsedStackSize, (void *)xConnectedSocket, 0u, ((TaskHandle_t * const )NULL));
  }
}

// prvConvertMQTTReturnCode
// file ..\..\..\..\lib\shadow\aws_shadow.c line 415
static ShadowReturnCode_t prvConvertMQTTReturnCode(MQTTAgentReturnCode_t xMQTTReturn, ShadowClientHandle_t xShadowClientHandle, const char * const pcDebugMessageSubject)
{
  ShadowReturnCode_t xReturn=3;
  switch((signed int)xMQTTReturn)
  {
    case 0:
    {
      vLoggingPrintf("[Shadow %d] MQTT: %s succeeded.\r\n", (BaseType_t)xShadowClientHandle, pcDebugMessageSubject);
      xReturn = 0;
      break;
    }
    case 2:
    {
      vLoggingPrintf("[Shadow %d] MQTT: %s timed out.\r\n", (BaseType_t)xShadowClientHandle, pcDebugMessageSubject);
      xReturn = 1;
      break;
    }
    case 1:

    default:
    {
      vLoggingPrintf("[Shadow %d] MQTT: %s failed.\r\n", (BaseType_t)xShadowClientHandle, pcDebugMessageSubject);
      xReturn = 2;
    }
  }
  (void)xShadowClientHandle;
  (void)pcDebugMessageSubject;
  return xReturn;
}

// prvCopyDataFromQueue
// file ..\..\..\..\lib\FreeRTOS\queue.c line 2120
static void prvCopyDataFromQueue(Queue_t * const pxQueue, void * const pvBuffer)
{
  if(!(pxQueue->uxItemSize == 0ul))
  {
    pxQueue->u.pcReadFrom = pxQueue->u.pcReadFrom + (signed long long int)pxQueue->uxItemSize;
    if(pxQueue->u.pcReadFrom >= pxQueue->pcTail)
      pxQueue->u.pcReadFrom = pxQueue->pcHead;

    memcpy((void *)pvBuffer, (void *)pxQueue->u.pcReadFrom, (size_t)pxQueue->uxItemSize);
  }

}

// prvCopyDataToQueue
// file ..\..\..\..\lib\FreeRTOS\queue.c line 2041
static BaseType_t prvCopyDataToQueue(Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition)
{
  BaseType_t xReturn=0;
  UBaseType_t uxMessagesWaiting=pxQueue->uxMessagesWaiting;
  if(pxQueue->uxItemSize == 0ul)
  {
    if(pxQueue->pcHead == ((int8_t *)NULL))
    {
      xReturn=xTaskPriorityDisinherit((void *)pxQueue->pcTail);
      pxQueue->pcTail = ((int8_t *)NULL);
    }

  }

  else
    if(xPosition == 0)
    {
      memcpy((void *)pxQueue->pcWriteTo, pvItemToQueue, (size_t)pxQueue->uxItemSize);
      pxQueue->pcWriteTo = pxQueue->pcWriteTo + (signed long long int)pxQueue->uxItemSize;
      if(pxQueue->pcWriteTo >= pxQueue->pcTail)
        pxQueue->pcWriteTo = pxQueue->pcHead;

    }

    else
    {
      memcpy((void *)pxQueue->u.pcReadFrom, pvItemToQueue, (size_t)pxQueue->uxItemSize);
      pxQueue->u.pcReadFrom = pxQueue->u.pcReadFrom - (signed long long int)pxQueue->uxItemSize;
      if(!(pxQueue->u.pcReadFrom >= pxQueue->pcHead))
        pxQueue->u.pcReadFrom = pxQueue->pcTail - (signed long long int)pxQueue->uxItemSize;

      if(xPosition == 2)
      {
        if(uxMessagesWaiting >= 1ul)
          uxMessagesWaiting = uxMessagesWaiting - 1ul;

      }

    }
  pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1ul;
  return xReturn;
}

// prvCreateClientAndConnectToBroker
// file ..\..\..\common\mqtt\aws_hello_world.c line 183
static BaseType_t prvCreateClientAndConnectToBroker(void)
{
  MQTTAgentReturnCode_t xReturned;
  BaseType_t xReturn=0;
  MQTTAgentConnectParams_t xConnectParameters={ .pcURL=clientcredentialMQTT_BROKER_ENDPOINT$link1, .xFlags=0x2 | 0x4,
    .xURLIsIPAddress=0, .usPort=8883,
    .pucClientId=(const uint8_t *)"MQTTEcho", .usClientIdLength=0,
    .xSecuredConnection=0, .pvUserData=NULL,
    .pxCallback=((MQTTAgentCallback_t)NULL), .pcCertificate=((char *)NULL),
    .ulCertificateSize=0u };
  if(!(xMQTTHandle == NULL))
    vAssertCalled("..\\..\\..\\common\\mqtt\\aws_hello_world.c", 203u);

  xReturned=MQTT_AGENT_Create(&xMQTTHandle);
  if((signed int)xReturned == 0)
  {
    size_t return_value_strlen=strlen((const char *)(const uint8_t *)"MQTTEcho");
    xConnectParameters.usClientIdLength = (uint16_t)return_value_strlen;
    vLoggingPrintf("MQTT echo attempting to connect to %s.\r\n", (const void *)clientcredentialMQTT_BROKER_ENDPOINT$link1);
    xReturned=MQTT_AGENT_Connect(xMQTTHandle, &xConnectParameters, (TickType_t)((12000u * 1000u) / 1000u));
    if(!((signed int)xReturned == 0))
    {
      MQTT_AGENT_Delete(xMQTTHandle);
      vLoggingPrintf("ERROR:  MQTT echo failed to connect.\r\n");
    }

    else
    {
      vLoggingPrintf("MQTT echo connected.\r\n");
      xReturn = 1;
    }
  }

  return xReturn;
}

// prvCreateDHCPSocket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DHCP.c line 555
static void prvCreateDHCPSocket(void)
{
  struct freertos_sockaddr xAddress;
  BaseType_t xReturn;
  TickType_t xTimeoutTime=0u;
  if(xDHCPData.xDHCPSocket == NULL)
  {
    xDHCPData.xDHCPSocket=FreeRTOS_socket(2, 2, 17);
    if(!(xDHCPData.xDHCPSocket == (void *)4294967295u))
    {
      FreeRTOS_setsockopt(xDHCPData.xDHCPSocket, 0, 0, (void *)&xTimeoutTime, sizeof(TickType_t) /*4ull*/ );
      FreeRTOS_setsockopt(xDHCPData.xDHCPSocket, 0, 1, (void *)&xTimeoutTime, sizeof(TickType_t) /*4ull*/ );
      xAddress.sin_port = 17408;
      xReturn=vSocketBind((FreeRTOS_Socket_t *)xDHCPData.xDHCPSocket, &xAddress, sizeof(struct freertos_sockaddr) /*8ull*/ , 0);
      if(!(xReturn == 0))
      {
        vSocketClose((FreeRTOS_Socket_t *)xDHCPData.xDHCPSocket);
        xDHCPData.xDHCPSocket = NULL;
      }

    }

    else
      xDHCPData.xDHCPSocket = NULL;
  }

}

// prvCreateDNSMessage
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DNS.c line 601
static size_t prvCreateDNSMessage(uint8_t *pucUDPPayloadBuffer, const char *pcHostName, TickType_t xIdentifier)
{
  DNSMessage_t *pxDNSMessageHeader;
  uint8_t *pucStart;
  uint8_t *pucByte;
  DNSTail_t *pxTail;
  static const DNSMessage_t xDefaultPartDNSHeader={ .usIdentifier=0, .usFlags=1, .usQuestions=256, .usAnswers=0,
    .usAuthorityRRs=0, .usAdditionalRRs=0 };
  memcpy((void *)pucUDPPayloadBuffer, (void *)&xDefaultPartDNSHeader, sizeof(const DNSMessage_t) /*12ull*/ );
  pxDNSMessageHeader = (DNSMessage_t *)pucUDPPayloadBuffer;
  pxDNSMessageHeader->usIdentifier = (uint16_t)xIdentifier;
  pucStart = pucUDPPayloadBuffer + (signed long long int)sizeof(const DNSMessage_t) /*12ll*/ ;
  pucByte = pucStart + 1ll;
  strcpy((char *)pucByte, pcHostName);
  size_t return_value_strlen=strlen(pcHostName);
  pucByte = pucByte + (signed long long int)return_value_strlen;
  *pucByte = 0;
  pucByte = pucStart;
  do
  {
    pucByte = pucByte + 1ll;
    for( ; !((signed int)*pucByte == 0x0); pucByte = pucByte + 1ll)
      if((signed int)*pucByte == 46)
        break;

    *pucStart = (uint8_t)((uint32_t)pucByte - (uint32_t)pucStart);
    *pucStart = *pucStart - 1;
    pucStart = pucByte;
  }
  while(!((signed int)*pucByte == 0x0));
  pxTail = (DNSTail_t *)(pucByte + 1ll);
  ((uint8_t *)pxTail)[(signed long long int)((size_t)&((DNSTail_t *)NULL)->usType + 0ull)] = (uint8_t)(0x1 >> 8);
  ((uint8_t *)pxTail)[(signed long long int)((size_t)&((DNSTail_t *)NULL)->usType + 1ull)] = (uint8_t)(0x1 & 0xFF);
  ((uint8_t *)pxTail)[(signed long long int)((size_t)&((DNSTail_t *)NULL)->usClass + 0ull)] = (uint8_t)(0x1 >> 8);
  ((uint8_t *)pxTail)[(signed long long int)((size_t)&((DNSTail_t *)NULL)->usClass + 1ull)] = (uint8_t)(0x1 & 0xFF);
  return (unsigned long long int)(((uint32_t)pucByte - (uint32_t)pucUDPPayloadBuffer) + 1u) + sizeof(DNSTail_t) /*4ull*/ ;
}

// prvCreateDNSSocket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DNS.c line 1262
static Socket_t prvCreateDNSSocket(void)
{
  Socket_t xSocket=NULL;
  struct freertos_sockaddr xAddress;
  BaseType_t xReturn;
  TickType_t xTimeoutTime=(TickType_t)((200u * 1000u) / 1000u);
  xSocket=FreeRTOS_socket(2, 2, 17);
  xAddress.sin_port = 0;
  xReturn=FreeRTOS_bind(xSocket, &xAddress, (uint32_t)sizeof(struct freertos_sockaddr) /*8u*/ );
  if(!(xReturn == 0))
  {
    FreeRTOS_closesocket(xSocket);
    xSocket = NULL;
  }

  else
  {
    FreeRTOS_setsockopt(xSocket, 0, 0, (void *)&xTimeoutTime, sizeof(TickType_t) /*4ull*/ );
    FreeRTOS_setsockopt(xSocket, 0, 1, (void *)&xTimeoutTime, sizeof(TickType_t) /*4ull*/ );
  }
  return xSocket;
}

// prvCreateFileForRx
// file ..\..\..\..\lib\ota\portable\pc\windows\aws_ota_pal.c line 54
static uint8_t prvCreateFileForRx(OTA_FileContext_t * const C)
{
  uint8_t xStatus;
  C->$anon0.pstFile=fopen((const char *)C->pacFilepath, "w+b");
  if(!(C->$anon0.pstFile == ((FILE *)NULL)))
  {
    xStatus = 1;
    vLoggingPrintf("[OTA] file handle: %08x\r\n", (uint32_t)C->$anon0.pstFile);
  }

  else
  {
    xStatus = 0;
    vLoggingPrintf("[OTA] Error (%d) trying to open local receive file.\r\n", (int32_t)C->$anon0.pstFile);
  }
  return xStatus;
}

// prvCreatePartDHCPMessage
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DHCP.c line 826
static uint8_t * prvCreatePartDHCPMessage(struct freertos_sockaddr *pxAddress, BaseType_t xOpcode, const uint8_t * const pucOptionsArray, size_t *pxOptionsArraySize)
{
  DHCPMessage_t *pxDHCPMessage;
  size_t xRequiredBufferSize=sizeof(DHCPMessage_t) /*241ull*/  + *pxOptionsArraySize;
  uint8_t *pucUDPPayloadBuffer;
  const char *pucHostName=pcApplicationHostnameHook();
  size_t xNameLength=strlen(pucHostName);
  uint8_t *pucPtr;
  xRequiredBufferSize = xRequiredBufferSize + 2ull + xNameLength;
  void *return_value_FreeRTOS_GetUDPPayloadBuffer;
  do
  {
    return_value_FreeRTOS_GetUDPPayloadBuffer=FreeRTOS_GetUDPPayloadBuffer(xRequiredBufferSize, 0xFFFFFFFFul);
    pucUDPPayloadBuffer = (uint8_t *)return_value_FreeRTOS_GetUDPPayloadBuffer;
  }
  while(pucUDPPayloadBuffer == ((uint8_t *)NULL));
  pxDHCPMessage = (DHCPMessage_t *)pucUDPPayloadBuffer;
  memset((void *)pxDHCPMessage, 0x0, sizeof(DHCPMessage_t) /*241ull*/ );
  pxDHCPMessage->ucOpcode = (uint8_t)xOpcode;
  pxDHCPMessage->ucAddressType = 1;
  pxDHCPMessage->ucAddressLength = 6;
  pxDHCPMessage->ulTransactionID = (uint32_t)((uint32_t)xDHCPData.ulTransactionId << 24 | ((uint32_t)xDHCPData.ulTransactionId & 0xFF00ul) << 8 | ((uint32_t)xDHCPData.ulTransactionId & 0xFF0000ul) >> 8 | (uint32_t)xDHCPData.ulTransactionId >> 24);
  pxDHCPMessage->ulDHCPCookie = 0x63538263ul;
  if(!(xDHCPData.xUseBroadcast == 0))
    pxDHCPMessage->usFlags = 128;

  else
    pxDHCPMessage->usFlags = 0;
  memcpy((void *)pxDHCPMessage->ucClientHardwareAddress, (void *)xDefaultPartUDPPacketHeader.ucBytes, sizeof(MACAddress_t) /*6ull*/ );
  memcpy((void *)&pucUDPPayloadBuffer[240ll], (void *)pucOptionsArray, *pxOptionsArraySize);
  pucPtr = &pucUDPPayloadBuffer[(signed long long int)(240ull + (*pxOptionsArraySize - 1ull))];
  pucPtr[0ll] = 12;
  pucPtr[1ll] = (uint8_t)xNameLength;
  memcpy((void *)(pucPtr + 2ll), (const void *)pucHostName, xNameLength);
  pucPtr[(signed long long int)(2ull + xNameLength)] = 255;
  *pxOptionsArraySize = *pxOptionsArraySize + 2ull + xNameLength;
  memcpy((void *)&pucUDPPayloadBuffer[(signed long long int)(0xF0 + 5)], (void *)xDefaultPartUDPPacketHeader.ucBytes, sizeof(MACAddress_t) /*6ull*/ );
  pxAddress->sin_addr = 0xFFFFFFFFul;
  pxAddress->sin_port = 17152;
  return pucUDPPayloadBuffer;
}

// prvCreatePrintSocket
// file ..\common\application_code\aws_demo_logging.c line 240
static void prvCreatePrintSocket(void *pvParameter1, uint32_t ulParameter2)
{
  Socket_t xSocket;
  (void)pvParameter1;
  (void)ulParameter2;
  xSocket=FreeRTOS_socket(2, 2, 17);
  if(!(xSocket == (void *)4294967295u))
  {
    static const TickType_t prvCreatePrintSocket$$1$$xSendTimeOut=(TickType_t)((0u * 1000u) / 1000u);
    FreeRTOS_setsockopt(xSocket, 0, 1, (const void *)&prvCreatePrintSocket$$1$$xSendTimeOut, sizeof(const TickType_t) /*4ull*/ );
    FreeRTOS_bind(xSocket, ((struct freertos_sockaddr *)NULL), 0u);
    xPrintSocket = xSocket;
  }

}

// prvCreateSectors
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 303
static BaseType_t prvCreateSectors(void)
{
  BaseType_t xIndex;
  BaseType_t xReturn;
  vListInitialise(&xSegmentList);
  void *return_value_pvPortMalloc=pvPortMalloc(240ull * sizeof(TCPSegment_t) /*104ull*/ );
  xTCPSegments = (TCPSegment_t *)return_value_pvPortMalloc;
  if(xTCPSegments == ((TCPSegment_t *)NULL))
  {
    while((_Bool)0)
      ;
    xReturn = 0;
  }

  else
  {
    memset((void *)xTCPSegments, 0, 240ull * sizeof(TCPSegment_t) /*104ull*/ );
    xIndex = 0;
    for( ; !(xIndex >= 240); xIndex = xIndex + 1l)
    {
      (&(xTCPSegments + (signed long long int)xIndex)->xListItem)->pvOwner = (void *)&xTCPSegments[(signed long long int)xIndex];
      (&(xTCPSegments + (signed long long int)xIndex)->xQueueItem)->pvOwner = (void *)&xTCPSegments[(signed long long int)xIndex];
      vListInsertFifo(&xSegmentList, &(xTCPSegments + (signed long long int)xIndex)->xListItem);
    }
    xReturn = 1;
  }
  return xReturn;
}

// prvCreateThreadSafeBuffers
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 167
static void prvCreateThreadSafeBuffers(void)
{
  if(xSendBuffer == ((const StreamBuffer_t *)NULL))
  {
    void *return_value_malloc=malloc((sizeof(const StreamBuffer_t) /*48ull*/  - sizeof(uint8_t [8ll]) /*8ull*/ ) + 32768ull + 1ull);
    xSendBuffer = (const StreamBuffer_t *)return_value_malloc;
    if(xSendBuffer == ((const StreamBuffer_t *)NULL))
      vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS-Plus-TCP\\source\\portable\\NetworkInterface\\WinPCap\\NetworkInterface.c", 174u);

    memset((void *)xSendBuffer, 0, sizeof(const StreamBuffer_t) /*48ull*/  - sizeof(uint8_t [8ll]) /*8ull*/ );
    xSendBuffer->LENGTH = (size_t)(32768 + 1);
  }

  if(xRecvBuffer == ((const StreamBuffer_t *)NULL))
  {
    void *return_value_malloc$0=malloc((sizeof(const StreamBuffer_t) /*48ull*/  - sizeof(uint8_t [8ll]) /*8ull*/ ) + 32768ull + 1ull);
    xRecvBuffer = (const StreamBuffer_t *)return_value_malloc$0;
    if(xRecvBuffer == ((const StreamBuffer_t *)NULL))
      vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS-Plus-TCP\\source\\portable\\NetworkInterface\\WinPCap\\NetworkInterface.c", 184u);

    memset((void *)xRecvBuffer, 0, sizeof(const StreamBuffer_t) /*48ull*/  - sizeof(uint8_t [8ll]) /*8ull*/ );
    xRecvBuffer->LENGTH = (size_t)(32768 + 1);
  }

}

// prvCreateTopic
// file ..\..\..\..\lib\shadow\aws_shadow.c line 455
static uint16_t prvCreateTopic(char *pcTopicString, const uint16_t usBufferLength, const char *pcTopicFormat, const char *pcthingName)
{
  uint16_t usTopicFormatIdx;
  uint16_t usThingIdx;
  uint16_t usTopicFormatSize;
  uint16_t usThingNameSize;
  uint16_t usTopicSize;
  uint16_t usTopicIdx=0;
  char cCurrentChar;
  char cPrevChar='0';
  size_t return_value_strlen=strlen(pcTopicFormat);
  usTopicFormatSize = (uint16_t)return_value_strlen;
  size_t return_value_strlen$0=strlen(pcthingName);
  usThingNameSize = (uint16_t)return_value_strlen$0;
  usTopicSize = (uint16_t)(((signed int)usTopicFormatSize + (signed int)usThingNameSize) - 2);
  if((signed int)usTopicSize >= (signed int)usBufferLength)
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 475u);

  usTopicFormatIdx = 0;
  for( ; !((signed int)usTopicFormatIdx >= (signed int)usTopicFormatSize); usTopicFormatIdx = usTopicFormatIdx + 1)
  {
    cCurrentChar = pcTopicFormat[(signed long long int)usTopicFormatIdx];
    if((signed int)cCurrentChar == 115 && (signed int)cPrevChar == 37)
    {
      usThingIdx = 0;
      for( ; !((signed int)usThingIdx >= (signed int)usThingNameSize); usThingIdx = usThingIdx + 1)
        pcTopicString[(signed long long int)(((signed int)usThingIdx + (signed int)usTopicFormatIdx) - 1)] = (char)pcthingName[(signed long long int)usThingIdx];
      usTopicIdx = usTopicIdx + (uint16_t)((signed int)usThingNameSize - 1);
    }

    else
    {
      pcTopicString[(signed long long int)usTopicIdx] = cCurrentChar;
      usTopicIdx = usTopicIdx + 1;
    }
    cPrevChar = cCurrentChar;
  }
  pcTopicString[(signed long long int)usTopicIdx] = 0;
  return usTopicSize;
}

// prvCreateTxData
// file ..\..\..\common\tcp\aws_tcp_echo_client_single_task.c line 359
static BaseType_t prvCreateTxData(char *cBuffer, uint32_t ulBufferLength)
{
  uint32_t ulCharacter;
  static uint32_t ulCharactersToAdd=0ul;
  ulCharactersToAdd = ulCharactersToAdd + 1u;
  if(!(ulBufferLength >= ulCharactersToAdd))
    ulCharactersToAdd = 1ul;

  ulCharacter = 0u;
  for( ; !(ulCharacter >= ulCharactersToAdd); ulCharacter = ulCharacter + 1u)
  {
    static char cChar='0';
    cBuffer[(signed long long int)ulCharacter] = cChar;
    cChar = cChar + 1;
    if((signed int)cChar >= 127)
      cChar = '0';

  }
  return (BaseType_t)ulCharactersToAdd;
}

// prvDecodeRemainingLength
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1927
static uint8_t prvDecodeRemainingLength(const uint8_t * const pucEncodedRemainingLength, uint32_t * const pulRemainingLength)
{
  uint8_t ucBytesRead;
  uint8_t ucDecodedByte;
  uint32_t x;
  uint32_t ulDecodedRemainingLength=0u;
  uint32_t ulDecodedByte;
  x = 0u;
  for( ; !(x >= 4u); x = x + 1u)
  {
    ucDecodedByte = (uint8_t)((signed int)pucEncodedRemainingLength[(signed long long int)x] & ~((signed int)(uint8_t)(1 << 7)));
    ulDecodedByte = (uint32_t)ucDecodedByte;
    ulDecodedByte = ulDecodedByte << x * 7u;
    ulDecodedRemainingLength = ulDecodedRemainingLength | ulDecodedByte;
    if((128 & (signed int)pucEncodedRemainingLength[(signed long long int)x]) == 0)
      break;

  }
  if(x >= 4u)
    ucBytesRead = 0;

  else
  {
    ucBytesRead = (uint8_t)((signed int)(uint8_t)x + 1);
    if(!(pulRemainingLength == ((uint32_t *)NULL)))
      *pulRemainingLength = ulDecodedRemainingLength;

  }
  return ucBytesRead;
}

// prvDeleteTCB
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3747
static void prvDeleteTCB(TCB_t *pxTCB)
{
  vPortDeleteThread((void *)pxTCB);
  if(pxTCB->ucStaticallyAllocated == 0)
  {
    vPortFree((void *)pxTCB->pxStack);
    vPortFree((void *)pxTCB);
  }

  else
    if(pxTCB->ucStaticallyAllocated == 1)
      vPortFree((void *)pxTCB);

    else
      if(!(pxTCB->ucStaticallyAllocated == 2))
        vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 3791u);

}

// prvDeltaCallback
// file ..\..\..\common\shadow\aws_shadow_lightbulb_on_off.c line 226
static BaseType_t prvDeltaCallback(void *pvUserData, const char * const pcThingName, const char * const pcDeltaDocument, uint32_t ulDocumentLength, MQTTBufferHandle_t xBuffer)
{
  int32_t lNbTokens;
  uint16_t usTokenIndex;
  uint32_t ulStringSize;
  jsmn_parser xJSMNParser;
  ShadowQueueData_t xShadowQueueData;
  jsmntok_t pxJSMNTokens[40ll];
  (void)pvUserData;
  (void)xBuffer;
  (void)pcThingName;
  jsmn_init(&xJSMNParser);
  memset((void *)&xShadowQueueData, 0x0, sizeof(ShadowQueueData_t) /*144ull*/ );
  signed int return_value_jsmn_parse=jsmn_parse(&xJSMNParser, pcDeltaDocument, (size_t)ulDocumentLength, pxJSMNTokens, 40u);
  lNbTokens = (int32_t)return_value_jsmn_parse;
  if(lNbTokens >= 1)
  {
    usTokenIndex = 0;
    for( ; !((signed int)usTokenIndex >= (signed int)(uint16_t)lNbTokens); usTokenIndex = usTokenIndex + 1)
    {
      BaseType_t return_value_prvIsStringEqual=prvIsStringEqual(pcDeltaDocument, &pxJSMNTokens[(signed long long int)usTokenIndex], "state");
      if(return_value_prvIsStringEqual == 1)
      {
        ulStringSize = (uint32_t)(pxJSMNTokens[(signed long long int)((signed int)usTokenIndex + 1)].end - pxJSMNTokens[(signed long long int)((signed int)usTokenIndex + 1)].start);
        if(ulStringSize >= 128u)
          vAssertCalled("..\\..\\..\\common\\shadow\\aws_shadow_lightbulb_on_off.c", 262u);

        xShadowQueueData.ulDataLength=prvGenerateReportedJSON(&xShadowQueueData, &pcDeltaDocument[(signed long long int)pxJSMNTokens[(signed long long int)((signed int)usTokenIndex + 1)].start], ulStringSize);
        BaseType_t return_value_xQueueGenericSend=xQueueGenericSend(xUpdateQueue, (const void *)&xShadowQueueData, 3000u, 0);
        if(return_value_xQueueGenericSend == 1)
          vLoggingPrintf("Successfully added new reported state to update queue.\r\n");

        else
          vLoggingPrintf("Update queue full, deferring reported state update.\r\n");
        break;
      }

    }
  }

  return 0;
}

// prvDetermineSocketSize
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 205
static BaseType_t prvDetermineSocketSize(BaseType_t xDomain, BaseType_t xType, BaseType_t xProtocol, size_t *pxSocketSize)
{
  BaseType_t xReturn=1;
  FreeRTOS_Socket_t *pxSocket;
  BaseType_t return_value_xIPIsNetworkTaskReady=xIPIsNetworkTaskReady();
  if(return_value_xIPIsNetworkTaskReady == 0)
    xReturn = 0;

  else
  {
    if(!(xDomain == 2))
      vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS-Plus-TCP\\source\\FreeRTOS_Sockets.c", 219u);

    if(!(xBoundUDPSocketsList.xListEnd.xItemValue == 0xFFFFFFFFul))
      vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS-Plus-TCP\\source\\FreeRTOS_Sockets.c", 222u);

    if(!(xBoundTCPSocketsList.xListEnd.xItemValue == 0xFFFFFFFFul))
      vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS-Plus-TCP\\source\\FreeRTOS_Sockets.c", 226u);

    if(xProtocol == 17)
    {
      if(!(xType == 2))
      {
        xReturn = 0;
        if(xReturn == 0)
          vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS-Plus-TCP\\source\\FreeRTOS_Sockets.c", 235u);

      }

      *pxSocketSize = (sizeof(FreeRTOS_Socket_t) /*592ull*/  - sizeof(union anonymous$105) /*512ull*/ ) + sizeof(IPUDPSocket_t) /*40ull*/ ;
    }

    else
      if(xProtocol == 6)
      {
        if(!(xType == 1))
        {
          xReturn = 0;
          if(xReturn == 0)
            vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS-Plus-TCP\\source\\FreeRTOS_Sockets.c", 247u);

        }

        *pxSocketSize = (sizeof(FreeRTOS_Socket_t) /*592ull*/  - sizeof(union anonymous$105) /*512ull*/ ) + sizeof(IPTCPSocket_t) /*512ull*/ ;
      }

      else
      {
        xReturn = 0;
        if(xReturn == 0)
          vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS-Plus-TCP\\source\\FreeRTOS_Sockets.c", 256u);

      }
  }
  (void)xDomain;
  return xReturn;
}

// prvDiscoverGreenGrassCore
// file ..\..\..\common\greengrass_connectivity\aws_greengrass_discovery_demo.c line 181
static void prvDiscoverGreenGrassCore(void *pvParameters)
{
  GGD_HostAddressData_t xHostAddressData;
  (void)pvParameters;
  MQTTAgentReturnCode_t return_value_MQTT_AGENT_Create=MQTT_AGENT_Create(&xMQTTClientHandle);
  if((signed int)return_value_MQTT_AGENT_Create == 0)
  {
    memset((void *)&xHostAddressData, 0, sizeof(GGD_HostAddressData_t) /*24ull*/ );
    vLoggingPrintf("Attempting automated selection of Greengrass device\r\n");
    BaseType_t return_value_GGD_GetGGCIPandCertificate=GGD_GetGGCIPandCertificate(pcJSONFile, 2500u, &xHostAddressData);
    if(return_value_GGD_GetGGCIPandCertificate == 1)
    {
      vLoggingPrintf("Greengrass device discovered.\r\n");
      vLoggingPrintf("Establishing MQTT communication to Greengrass...\r\n");
      prvSendMessageToGGC(&xHostAddressData);
      size_t return_value_xPortGetMinimumEverFreeHeapSize=xPortGetMinimumEverFreeHeapSize();
      UBaseType_t return_value_uxTaskGetStackHighWaterMark=uxTaskGetStackHighWaterMark(NULL);
      vLoggingPrintf("Heap low watermark: %u. Stack high watermark: %u.\r\n", return_value_xPortGetMinimumEverFreeHeapSize, return_value_uxTaskGetStackHighWaterMark);
    }

    else
      vLoggingPrintf("Auto-connect: Failed to retrieve Greengrass address and certificate.\r\n");
  }

  vLoggingPrintf("----Demo finished----\r\n");
  vTaskDelete(NULL);
}

// prvDoesTopicMatchTopicFilter
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 2324
static MQTTBool_t prvDoesTopicMatchTopicFilter(const uint8_t * const pucTopic, uint16_t usTopicLength, const uint8_t * const pucTopicFilter, uint16_t usTopicFilterLength)
{
  MQTTBool_t xTopicMatchesTopicFilter=/*enum*/eMQTTFalse;
  uint16_t usTopicIndex=0;
  uint16_t usTopicFilterIndex=0;
  while(!((signed int)usTopicFilterIndex >= (signed int)usTopicFilterLength) && !((signed int)usTopicIndex >= (signed int)usTopicLength))
  {
    if(pucTopic[(signed long long int)usTopicIndex] == pucTopicFilter[(signed long long int)usTopicFilterIndex])
    {
      if((signed int)usTopicFilterIndex == -3 + (signed int)usTopicFilterLength && (signed int)usTopicIndex == -1 + (signed int)usTopicLength)
      {
        if(pucTopicFilter[(signed long long int)(1 + (signed int)usTopicFilterIndex)] == 47)
        {
          if(pucTopicFilter[(signed long long int)(2 + (signed int)usTopicFilterIndex)] == 35)
          {
            xTopicMatchesTopicFilter = /*enum*/eMQTTTrue;
            break;
          }

        }

      }

      if((signed int)usTopicFilterIndex == -2 + (signed int)usTopicFilterLength && (signed int)usTopicIndex == -1 + (signed int)usTopicLength)
      {
        if(pucTopicFilter[(signed long long int)(1 + (signed int)usTopicFilterIndex)] == 43)
        {
          xTopicMatchesTopicFilter = /*enum*/eMQTTTrue;
          break;
        }

      }

    }

    else
      if(pucTopicFilter[(signed long long int)usTopicFilterIndex] == 43)
      {
        for( ; !((signed int)usTopicIndex >= (signed int)usTopicLength); usTopicIndex = usTopicIndex + 1)
          if(pucTopic[(signed long long int)usTopicIndex] == 47)
            break;

        usTopicFilterIndex = usTopicFilterIndex + 1;
        continue;
      }

      else
        if(pucTopicFilter[(signed long long int)usTopicFilterIndex] == 35)
        {
          xTopicMatchesTopicFilter = /*enum*/eMQTTTrue;
          break;
        }

        else
          break;
    usTopicIndex = usTopicIndex + 1;
    usTopicFilterIndex = usTopicFilterIndex + 1;
  }
  if((signed int)xTopicMatchesTopicFilter == 0 && (signed int)usTopicFilterIndex >= 1 && (signed int)usTopicFilterIndex >= (signed int)usTopicFilterLength && (signed int)usTopicIndex >= 1 && (signed int)usTopicIndex >= (signed int)usTopicLength)
    xTopicMatchesTopicFilter = /*enum*/eMQTTTrue;

  return xTopicMatchesTopicFilter;
}

// prvEchoClientRxTask
// file ..\..\..\common\tcp\aws_tcp_echo_client_separate_tasks.c line 323
static void prvEchoClientRxTask(void *pvParameters)
{
  Socket_t xSocket;
  BaseType_t lReceived;
  BaseType_t lReturned=0;
  BaseType_t lExpectedCharacter;
  (void)pvParameters;
  while((_Bool)1)
  {
    lExpectedCharacter = 0;
    xQueueReceive(xSocketPassingQueue, (void *)&xSocket, 0xFFFFFFFFul);
    while((_Bool)1)
    {
      static char cReceivedString[256ll];
      memset((void *)cReceivedString, 0x0, 256ull);
      static char cExpectedString[256ll];
      memset((void *)cExpectedString, 48 + lExpectedCharacter, 256ull);
      lExpectedCharacter = lExpectedCharacter + 1l;
      if(lExpectedCharacter >= 10)
        lExpectedCharacter = 0;

      lReceived = 0;
      while(!(lReceived >= 256))
      {
        lReturned=SOCKETS_Recv(xSocket, (void *)&cReceivedString[(signed long long int)lReceived], (size_t)(256 - lReceived), 0u);
        if(lShuttingDown == 1 && lReturned == 0)
        {
          lReturned = -1;
          break;
        }

        else
          if(lReturned >= 0)
          {
            lReceived = lReceived + lReturned;
            vLoggingPrintf("Multi task echo correctly received %d bytes.\r\n", (signed int)lReceived);
          }

          else
            break;
      }
      if(!(lReturned >= 0))
        break;

      else
      {
        signed int return_value_memcmp=memcmp((void *)cReceivedString, (void *)cExpectedString, 256ull);
        if(!(return_value_memcmp == 0))
          vAssertCalled("..\\..\\..\\common\\tcp\\aws_tcp_echo_client_separate_tasks.c", 392u);

        ulRxTaskCycles = ulRxTaskCycles + 1u;
      }
    }
    xEventGroupSync(xSyncEventGroup, (const EventBits_t)(0x1 << 2), (const EventBits_t)(0x1 << 1 | 0x1 << 2), 0xFFFFFFFFul);
  }
}

// prvEchoClientTask
// file ..\..\..\common\tcp\aws_tcp_echo_client_single_task.c line 158
static void prvEchoClientTask(void *pvParameters)
{
  Socket_t xSocket;
  SocketsSockaddr_t xEchoServerAddress;
  int32_t lLoopCount=0;
  const int32_t lMaxLoopCount=10;
  volatile uint32_t ulTxCount=0ul;
  BaseType_t xReceivedBytes;
  BaseType_t xReturned;
  BaseType_t xInstance;
  BaseType_t lTransmitted;
  BaseType_t lStringLength;
  char *pcTransmittedString;
  char *pcReceivedString;
  TickType_t xTimeOnEntering;
  xInstance = (BaseType_t)pvParameters;
  pcTransmittedString = cTxBuffers[(signed long long int)xInstance];
  pcReceivedString = cRxBuffers[(signed long long int)xInstance];
  xEchoServerAddress.usPort = (uint16_t)(7 << 8u | 7 >> 8u);
  xEchoServerAddress.ulAddress = 6u << 24ul | 2u << 16ul | 168u << 8ul | 192u;
  TickType_t return_value_xTaskGetTickCount;
  while((_Bool)1)
  {
    xSocket=SOCKETS_Socket(2, 1, 6);
    if(xSocket == (Socket_t)4294967295u)
      vAssertCalled("..\\..\\..\\common\\tcp\\aws_tcp_echo_client_single_task.c", 202u);

    SOCKETS_SetSockOpt(xSocket, 0, 0, (const void *)&xReceiveTimeOut$link1, sizeof(const TickType_t) /*4ull*/ );
    SOCKETS_SetSockOpt(xSocket, 0, 1, (const void *)&xSendTimeOut$link1, sizeof(const TickType_t) /*4ull*/ );
    vLoggingPrintf("Connecting to echo server\r\n");
    int32_t return_value_SOCKETS_Connect=SOCKETS_Connect(xSocket, &xEchoServerAddress, (uint32_t)sizeof(SocketsSockaddr_t) /*8u*/ );
    if(return_value_SOCKETS_Connect == 0)
    {
      vLoggingPrintf("Connected to echo server\r\n");
      ulConnections[(signed long long int)xInstance] = ulConnections[(signed long long int)xInstance] + 1u;
      lLoopCount = 0;
      for( ; !(lLoopCount >= lMaxLoopCount); lLoopCount = lLoopCount + 1)
      {
        lStringLength=prvCreateTxData(pcTransmittedString, 2000u);
        sprintf(pcTransmittedString, "TxRx message number %u", (unsigned int)ulTxCount);
        ulTxCount = ulTxCount + 1u;
        lTransmitted=SOCKETS_Send(xSocket, (void *)pcTransmittedString, (size_t)lStringLength, 0u);
        vLoggingPrintf("Sending %s of length %d to echo server\r\n", pcTransmittedString, lStringLength);
        if(!(lTransmitted >= 0))
        {
          vLoggingPrintf("ERROR - Failed to send to echo server\r\n", pcTransmittedString);
          break;
        }

        memset((void *)pcReceivedString, 0x0, 2000ull);
        xReceivedBytes = 0;
        while(!(xReceivedBytes >= lTransmitted))
        {
          xReturned=SOCKETS_Recv(xSocket, (void *)&pcReceivedString[(signed long long int)xReceivedBytes], (size_t)(lStringLength - xReceivedBytes), 0u);
          if(!(xReturned >= 0))
          {
            xReceivedBytes = xReturned;
            break;
          }

          else
            if(xReturned == 0)
            {
              vLoggingPrintf("Timed out receiving from echo server\r\n");
              break;
            }

            else
              xReceivedBytes = xReceivedBytes + xReturned;
        }
        if(xReceivedBytes >= 1)
        {
          signed int return_value_strncmp=strncmp(pcReceivedString, pcTransmittedString, (size_t)lTransmitted);
          if(!(return_value_strncmp == 0))
            vAssertCalled("..\\..\\..\\common\\tcp\\aws_tcp_echo_client_single_task.c", 288u);

          signed int return_value_strncmp$0=strncmp(pcReceivedString, pcTransmittedString, (size_t)lTransmitted);
          if(return_value_strncmp$0 == 0)
          {
            ulTxRxCycles[(signed long long int)xInstance] = ulTxRxCycles[(signed long long int)xInstance] + 1u;
            vLoggingPrintf("Received correct string from echo server.\r\n");
          }

          else
          {
            ulTxRxFailures[(signed long long int)xInstance] = ulTxRxFailures[(signed long long int)xInstance] + 1u;
            vLoggingPrintf("ERROR - Received incorrect string from echo server.\r\n");
            break;
          }
        }

        else
          if(!(xReceivedBytes >= 0))
            break;

          else
            break;
      }
      vLoggingPrintf("Shutting down connection to echo server.\r\n");
      SOCKETS_Shutdown(xSocket, 2u);
      xTimeOnEntering=xTaskGetTickCount();
      do
      {
        xReturned=SOCKETS_Recv(xSocket, (void *)&pcReceivedString[0ll], 2000ull, 0u);
        if(!(xReturned >= 0))
          break;

        return_value_xTaskGetTickCount=xTaskGetTickCount();
      }
      while(!(return_value_xTaskGetTickCount + -xTimeOnEntering >= xReceiveTimeOut$link1));
    }

    else
      vLoggingPrintf("Echo demo failed to connect to echo server %d.%d.%d.%d.\r\n", 192, 168, 2, 6);
    xReturned=SOCKETS_Close(xSocket);
    if(!(xReturned == 0))
      vAssertCalled("..\\..\\..\\common\\tcp\\aws_tcp_echo_client_single_task.c", 350u);

    vTaskDelay(150u / (1000u / 1000u));
  }
}

// prvEchoClientTxTask
// file ..\..\..\common\tcp\aws_tcp_echo_client_separate_tasks.c line 140
static void prvEchoClientTxTask(void *pvParameters)
{
  Socket_t xSocket;
  SocketsSockaddr_t xEchoServerAddress;
  uint32_t ulTxCount=0ul;
  uint32_t ulJunk;
  BaseType_t lTransmitted;
  BaseType_t lReturned=0;
  BaseType_t lCharacter;
  const BaseType_t lStringLength=256 * 10;
  size_t xLenToSend;
  const uint32_t ulNumTxPerSocket=5ul;
  TickType_t xTimeEnteringLoop;
  (void)pvParameters;
  xEchoServerAddress.usPort = (uint16_t)(7 << 8u | 7 >> 8u);
  xEchoServerAddress.ulAddress = 6u << 24ul | 2u << 16ul | 168u << 8ul | 192u;
  ulTxCount = 0u;
  static char cTransmittedString[2560ll];
  for( ; !(ulTxCount >= 10u); ulTxCount = ulTxCount + 1u)
  {
    lCharacter = (BaseType_t)(48u + ulTxCount);
    memset((void *)&cTransmittedString[(signed long long int)(256u * ulTxCount)], lCharacter, 256ull);
  }
  TickType_t return_value_xTaskGetTickCount;
  while((_Bool)1)
  {
    ulTxCount = 0u;
    xSocket=SOCKETS_Socket(2, 1, 6);
    if(xSocket == (Socket_t)4294967295u)
      vAssertCalled("..\\..\\..\\common\\tcp\\aws_tcp_echo_client_separate_tasks.c", 190u);

    SOCKETS_SetSockOpt(xSocket, 0, 0, (const void *)&xReceiveTimeOut, sizeof(const TickType_t) /*4ull*/ );
    SOCKETS_SetSockOpt(xSocket, 0, 1, (const void *)&xSendTimeOut, sizeof(const TickType_t) /*4ull*/ );
    int32_t return_value_SOCKETS_Connect=SOCKETS_Connect(xSocket, &xEchoServerAddress, (uint32_t)sizeof(SocketsSockaddr_t) /*8u*/ );
    if(return_value_SOCKETS_Connect == 0)
    {
      vLoggingPrintf("Multi task demo connected to echo server.\r\n");
      lReturned=xQueueGenericSend(xSocketPassingQueue, (const void *)&xSocket, 0xFFFFFFFFul, 0);
      if(!(lReturned == 1))
        vAssertCalled("..\\..\\..\\common\\tcp\\aws_tcp_echo_client_separate_tasks.c", 210u);

      while(!(ulTxCount >= ulNumTxPerSocket))
      {
        lTransmitted = 0;
        while(!(lTransmitted >= lStringLength))
        {
          xLenToSend = (size_t)(lStringLength - lTransmitted);
          lReturned=SOCKETS_Send(xSocket, (void *)&cTransmittedString[(signed long long int)lTransmitted], xLenToSend, 0u);
          vPortGenerateSimulatedInterrupt(0ul);
          if(lReturned >= 0)
          {
            vLoggingPrintf("Multi task echo sending %d bytes to echo server\r\n", lReturned);
            lTransmitted = lTransmitted + lReturned;
          }

          else
          {
            vLoggingPrintf("Multi task echo failed to send %d bytes to echo server\r\n", xLenToSend);
            break;
          }
        }
        if(!(lReturned >= 0))
          break;

        else
        {
          ulTxTaskCycles = ulTxTaskCycles + 1u;
          ulTxCount = ulTxCount + 1u;
        }
      }
      lShuttingDown = 1;
      xEventGroupSync(xSyncEventGroup, (const EventBits_t)(0x1 << 1), (const EventBits_t)(0x1 << 1 | 0x1 << 2), 0xFFFFFFFFul);
      lShuttingDown = 0;
      xTimeEnteringLoop=xTaskGetTickCount();
      vLoggingPrintf("Multi task echo socket being shut down.\r\n");
      SOCKETS_Shutdown(xSocket, 2u);
      xTimeEnteringLoop=xTaskGetTickCount();
      do
      {
        lReturned=SOCKETS_Recv(xSocket, (void *)&ulJunk, sizeof(uint32_t) /*4ull*/ , 0u);
        if(!(lReturned >= 0))
          break;

        return_value_xTaskGetTickCount=xTaskGetTickCount();
      }
      while(!(return_value_xTaskGetTickCount + -xTimeEnteringLoop >= 2u * xReceiveTimeOut));
    }

    else
      vLoggingPrintf("Separate task echo demo failed to connect to echo server %d.%d.%d.%d.\r\n", 192, 168, 2, 6);
    lReturned=SOCKETS_Close(xSocket);
    if(!(lReturned == 0))
      vAssertCalled("..\\..\\..\\common\\tcp\\aws_tcp_echo_client_separate_tasks.c", 314u);

    vTaskDelay((TickType_t)((500ul * 1000u) / 1000u));
  }
}

// prvEncodeRemainingLength
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1882
static uint8_t prvEncodeRemainingLength(uint32_t ulRemainingLength, uint8_t * const pucEncodedRemainingLength, const uint8_t * const pucLastByteInBuffer)
{
  uint8_t ucBytesWritten=0;
  uint8_t ucEncodedByte;
  do
  {
    ucEncodedByte = (uint8_t)((signed int)(uint8_t)ulRemainingLength & ~((signed int)(uint8_t)(1 << 7)));
    ulRemainingLength = ulRemainingLength >> 7;
    if(ulRemainingLength >= 1u)
      ucEncodedByte = ucEncodedByte | (uint8_t)(1 << 7);

    if(pucLastByteInBuffer >= pucEncodedRemainingLength + (signed long long int)ucBytesWritten)
    {
      pucEncodedRemainingLength[(signed long long int)ucBytesWritten] = ucEncodedByte;
      ucBytesWritten = ucBytesWritten + 1;
    }

    else
    {
      ucBytesWritten = 0;
      break;
    }
  }
  while(ulRemainingLength >= 1u);
  return ucBytesWritten;
}

// prvEndProcess
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 193
static BOOL prvEndProcess(DWORD dwCtrlType)
{
  TIMECAPS xTimeCaps;
  (void)dwCtrlType;
  MMRESULT return_value_timeGetDevCaps=timeGetDevCaps(&xTimeCaps, (UINT)sizeof(TIMECAPS) /*8u*/ );
  if(return_value_timeGetDevCaps == 0u)
    timeEndPeriod(xTimeCaps.wPeriodMin);

  return 0;
}

// prvFileClose
// file ..\common\application_code\aws_demo_logging.c line 565
static void prvFileClose(void)
{
  if(!(pxLoggingFileHandle == ((FILE *)NULL)))
  {
    fclose(pxLoggingFileHandle);
    pxLoggingFileHandle = ((FILE *)NULL);
  }

}

// prvFileLoggingInit
// file ..\common\application_code\aws_demo_logging.c line 548
static void prvFileLoggingInit(void)
{
  FILE *pxHandle=fopen(pcLogFileName, "a");
  if(!(pxHandle == ((FILE *)NULL)))
  {
    fseek(pxHandle, 2, 0);
    signed long int return_value_ftell=ftell(pxHandle);
    ulSizeOfLoggingFile = (size_t)return_value_ftell;
    fclose(pxHandle);
  }

  else
    ulSizeOfLoggingFile = 0ull;
}

// prvFreeContext
// file ..\..\..\..\lib\tls\aws_tls.c line 108
static void prvFreeContext(TLSContext_t *pCtx)
{
  if(!(pCtx == ((TLSContext_t *)NULL)))
  {
    mbedtls_ssl_close_notify(&pCtx->mbedSslCtx);
    mbedtls_ssl_free(&pCtx->mbedSslCtx);
    mbedtls_ssl_config_free(&pCtx->mbedSslConfig);
    if(!(pCtx->pxP11FunctionList == ((CK_FUNCTION_LIST_PTR)NULL)))
    {
      if(!(pCtx->pxP11FunctionList->C_CloseSession == ((CK_C_CloseSession)NULL)))
      {
        pCtx->pxP11FunctionList->C_CloseSession(pCtx->xP11Session);
        pCtx->pxP11FunctionList->C_Finalize(NULL);
      }

    }

    pCtx->xMbedInitialized = 0;
  }

}

// prvFreeKey
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 379
static void prvFreeKey(P11KeyPtr_t pxKey)
{
  if(!(pxKey == ((P11KeyPtr_t)NULL)))
  {
    pxKey->xMbedPkCtx.pk_ctx = pxKey->pvSavedMbedPkCtx;
    mbedtls_pk_free(&pxKey->xMbedPkCtx);
    mbedtls_x509_crt_free(&pxKey->xMbedX509Cli);
    vPortFree((void *)pxKey);
  }

}

// prvGGDGetCertificate
// file ..\..\..\..\lib\greengrass\aws_greengrass_discovery.c line 709
static BaseType_t prvGGDGetCertificate(char *prvGGDGetCertificate$$pcJSONFile, const HostParameters_t *pxHostParameters, const BaseType_t xAutoSelectFlag, const jsmntok_t *pxTok, const uint32_t ulNbTokens, GGD_HostAddressData_t *pxHostAddressData)
{
  BaseType_t xMatchGroup=0;
  uint32_t ulTokenIndex;
  uint32_t ulReadIndex=0u;
  uint32_t ulWriteIndex=0u;
  BaseType_t xStatus=0;
  ulTokenIndex = 0u;
  for( ; !(ulTokenIndex >= ulNbTokens); ulTokenIndex = ulTokenIndex + 1u)
  {
    if(xAutoSelectFlag == 1)
      xMatchGroup = 1;

    if(!(xMatchGroup == 1))
      prvCheckMatch(prvGGDGetCertificate$$pcJSONFile, pxTok, ulTokenIndex, &xMatchGroup, "GGGroupId", pxHostParameters->pcGroupName, xAutoSelectFlag);

    else
    {
      BaseType_t return_value_prvGGDJsoneq=prvGGDJsoneq(prvGGDGetCertificate$$pcJSONFile, &pxTok[(signed long long int)ulTokenIndex], "CAs");
      if(return_value_prvGGDJsoneq == 1)
      {
        pxHostAddressData->pcCertificate = &prvGGDGetCertificate$$pcJSONFile[(signed long long int)(pxTok + (signed long long int)(ulTokenIndex + 1u))->start];
        pxHostAddressData->pcCertificate = &pxHostAddressData->pcCertificate[2ll];
        pxHostAddressData->ulCertificateSize = ((uint32_t)(pxTok + (signed long long int)(ulTokenIndex + 1u))->end - (uint32_t)(pxTok + (signed long long int)(ulTokenIndex + 1u))->start) - 2u;
        ulWriteIndex = 0u;
        ulReadIndex = 1u;
        do
        {
          _Bool tmp_if_expr;
          if((signed int)pxHostAddressData->pcCertificate[(signed long long int)(4294967295u + ulReadIndex)] == 92)
            tmp_if_expr = (signed int)pxHostAddressData->pcCertificate[(signed long long int)ulReadIndex] == 110 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr = (_Bool)0;
          if(tmp_if_expr)
          {
            pxHostAddressData->pcCertificate[(signed long long int)ulWriteIndex] = '\n';
            ulReadIndex = ulReadIndex + 1u;
          }

          else
            pxHostAddressData->pcCertificate[(signed long long int)ulWriteIndex] = pxHostAddressData->pcCertificate[(signed long long int)(ulReadIndex - 1u)];
          ulReadIndex = ulReadIndex + 1u;
          ulWriteIndex = ulWriteIndex + 1u;
        }
        while(!(ulReadIndex >= pxHostAddressData->ulCertificateSize));
        pxHostAddressData->ulCertificateSize = ulWriteIndex;
        pxHostAddressData->pcCertificate[(signed long long int)(ulWriteIndex - 1u)] = 0;
        xStatus = 1;
      }

    }
  }
  return xStatus;
}

// prvGGDGetCore
// file ..\..\..\..\lib\greengrass\aws_greengrass_discovery.c line 650
static BaseType_t prvGGDGetCore(const char *prvGGDGetCore$$pcJSONFile, const HostParameters_t * const pxHostParameters, const BaseType_t xAutoSelectFlag, const jsmntok_t *pxTok, const uint32_t ulNbTokens, uint32_t *pulTokenIndex)
{
  BaseType_t xStatus=0;
  BaseType_t xMatchGroup=0;
  BaseType_t xMatchCore=0;
  *pulTokenIndex = 0u;
  for( ; !(*pulTokenIndex >= ulNbTokens); *pulTokenIndex = *pulTokenIndex + 1u)
  {
    if(xAutoSelectFlag == 1)
    {
      xMatchGroup = 1;
      xMatchCore = 1;
    }

    else
      if(!(xMatchGroup == 1))
        prvCheckMatch(prvGGDGetCore$$pcJSONFile, pxTok, *pulTokenIndex, &xMatchGroup, "GGGroupId", pxHostParameters->pcGroupName, xAutoSelectFlag);

      else
        prvCheckMatch(prvGGDGetCore$$pcJSONFile, pxTok, *pulTokenIndex, &xMatchCore, "thingArn", pxHostParameters->pcCoreAddress, xAutoSelectFlag);
    if(xMatchCore == 1 && xMatchGroup == 1)
    {
      xStatus = 1;
      break;
    }

  }
  return xStatus;
}

// prvGGDGetIPOnInterface
// file ..\..\..\..\lib\greengrass\aws_greengrass_discovery.c line 812
static BaseType_t prvGGDGetIPOnInterface(char *prvGGDGetIPOnInterface$$pcJSONFile, const uint8_t ucTargetInterface, const jsmntok_t *pxTok, const uint32_t ulNbTokens, GGD_HostAddressData_t *pxHostAddressData, uint32_t *pulTokenIndex, uint8_t *pucCurrentInterface)
{
  BaseType_t xStatus=0;
  BaseType_t xFoundIP=0;
  BaseType_t xFoundPort=0;
  for( ; !(*pulTokenIndex >= ulNbTokens); *pulTokenIndex = *pulTokenIndex + 1u)
  {
    BaseType_t return_value_prvGGDJsoneq=prvGGDJsoneq(prvGGDGetIPOnInterface$$pcJSONFile, &pxTok[(signed long long int)*pulTokenIndex], "HostAddress");
    if(return_value_prvGGDJsoneq == 1)
    {
      xFoundIP = 1;
      pxHostAddressData->pcHostAddress = &prvGGDGetIPOnInterface$$pcJSONFile[(signed long long int)(pxTok + (signed long long int)(*pulTokenIndex + 1u))->start];
      prvGGDGetIPOnInterface$$pcJSONFile[(signed long long int)(pxTok + (signed long long int)(*pulTokenIndex + 1u))->end] = 0;
    }

    BaseType_t return_value_prvGGDJsoneq$0=prvGGDJsoneq(prvGGDGetIPOnInterface$$pcJSONFile, &pxTok[(signed long long int)*pulTokenIndex], "PortNumber");
    if(return_value_prvGGDJsoneq$0 == 1)
    {
      unsigned long int return_value_strtoul=strtoul(&prvGGDGetIPOnInterface$$pcJSONFile[(signed long long int)(pxTok + (signed long long int)(*pulTokenIndex + 1u))->start], ((char **)NULL), 10);
      pxHostAddressData->usPort = (uint16_t)return_value_strtoul;
      xFoundPort = 1;
    }

    if(xFoundIP == 1 && xFoundPort == 1)
    {
      xFoundIP = 0;
      xFoundPort = 0;
      *pucCurrentInterface = *pucCurrentInterface + 1;
      if(*pucCurrentInterface == ucTargetInterface)
      {
        xStatus = 1;
        break;
      }

    }

  }
  *pulTokenIndex = *pulTokenIndex + 1u;
  return xStatus;
}

// prvGGDJsoneq
// file ..\..\..\..\lib\greengrass\aws_greengrass_discovery.c line 589
static BaseType_t prvGGDJsoneq(const char *pcJson, const jsmntok_t * const pxTok, const char *pcString)
{
  uint32_t ulStringSize=(uint32_t)pxTok->end - (uint32_t)pxTok->start;
  BaseType_t xStatus=0;
  if((signed int)pxTok->type == 3)
  {
    size_t return_value_strlen=strlen(pcString);
    if((uint32_t)return_value_strlen == ulStringSize)
    {
      signed int return_value_strncmp=strncmp(&pcJson[(signed long long int)pxTok->start], pcString, (size_t)ulStringSize);
      if((signed int)(int16_t)return_value_strncmp == 0)
        xStatus = 1;

    }

  }

  return xStatus;
}

// prvGenerateDesiredJSON
// file ..\..\..\common\shadow\aws_shadow_lightbulb_on_off.c line 175
static uint32_t prvGenerateDesiredJSON(ShadowQueueData_t * const pxShadowQueueData, const char * const pcTaskName, uint8_t ucBulbState)
{
  TickType_t return_value_xTaskGetTickCount=xTaskGetTickCount();
  static const char * const pColors[2ll]={ "green", "red" };
  signed int return_value_snprintf=snprintf((char *)pxShadowQueueData->pcUpdateBuffer, 128ull, "{\"state\":{\"desired\":{\"%s\":\"%s\"}},\"clientToken\": \"token-%d\"}", pcTaskName, pColors[(signed long long int)ucBulbState], (signed int)return_value_xTaskGetTickCount);
  return (uint32_t)return_value_snprintf;
}

// prvGenerateRandomBytes
// file ..\..\..\..\lib\tls\aws_tls.c line 174
static signed int prvGenerateRandomBytes(void *pvCtx, unsigned char *pucRandom, size_t xRandomLength)
{
  TLSContext_t *pCtx=(TLSContext_t *)pvCtx;
  CK_RV return_value=pCtx->pxP11FunctionList->C_GenerateRandom(pCtx->xP11Session, pucRandom, (CK_ULONG)xRandomLength);
  return (signed int)return_value;
}

// prvGenerateReportedJSON
// file ..\..\..\common\shadow\aws_shadow_lightbulb_on_off.c line 191
static uint32_t prvGenerateReportedJSON(ShadowQueueData_t * const pxShadowQueueData, const char * const pcReportedData, uint32_t ulReportedDataLength)
{
  TickType_t return_value_xTaskGetTickCount=xTaskGetTickCount();
  signed int return_value_snprintf=snprintf((char *)pxShadowQueueData->pcUpdateBuffer, 128ull, "{\"state\":{\"reported\":%.*s},\"clientToken\": \"token-%d\"}", (signed int)ulReportedDataLength, pcReportedData, (signed int)return_value_xTaskGetTickCount);
  return (uint32_t)return_value_snprintf;
}

// prvGetCallbackCatalogEntry
// file ..\..\..\..\lib\shadow\aws_shadow.c line 365
static BaseType_t prvGetCallbackCatalogEntry(CallbackCatalogEntry_t * const pxCallbackCatalog, const char * const pcThingName)
{
  CallbackCatalogEntry_t *pxCallbackCatalogEntry;
  BaseType_t xIterator;
  BaseType_t xReturn=-1;
  BaseType_t xThingNameFound=0;
  size_t xThingNameLengh;
  size_t xThingName_cb_Lengh;
  vPortEnterCritical();
  xIterator = 0;
  for( ; !(xIterator >= 1); xIterator = xIterator + 1l)
  {
    pxCallbackCatalogEntry = &pxCallbackCatalog[(signed long long int)xIterator];
    if(pxCallbackCatalogEntry->xInUse == 0)
      xReturn = xIterator;

    else
    {
      xThingNameLengh=strlen(pxCallbackCatalogEntry->xCallbackInfo.pcThingName);
      xThingName_cb_Lengh=strlen(pcThingName);
      if(xThingNameLengh == xThingName_cb_Lengh)
      {
        signed int return_value_strncmp=strncmp(pcThingName, pxCallbackCatalogEntry->xCallbackInfo.pcThingName, xThingNameLengh);
        if(return_value_strncmp == 0)
        {
          xReturn = xIterator;
          xThingNameFound = 1;
          break;
        }

      }

    }
  }
  vPortExitCritical();
  if(xThingNameFound == 0)
  {
    (pxCallbackCatalog + (signed long long int)xReturn)->xInUse = 1;
    (pxCallbackCatalog + (signed long long int)xReturn)->xCallbackInfo.pcThingName = pcThingName;
  }

  return xReturn;
}

// prvGetCurrentTickCount
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1044
static uint64_t prvGetCurrentTickCount(MQTTContext_t *pxMQTTContext)
{
  uint64_t uxCurrentTickCount=0ull;
  if(!(pxMQTTContext->pxGetTicksFxn == ((MQTTGetTicks_t)NULL)))
    pxMQTTContext->pxGetTicksFxn(&uxCurrentTickCount);

  return uxCurrentTickCount;
}

// prvGetDisinheritPriorityAfterTimeout
// file ..\..\..\..\lib\FreeRTOS\queue.c line 2016
static UBaseType_t prvGetDisinheritPriorityAfterTimeout(const Queue_t * const pxQueue)
{
  UBaseType_t uxHighestPriorityOfWaitingTasks;
  if(pxQueue->xTasksWaitingToReceive.uxNumberOfItems >= 1u)
    uxHighestPriorityOfWaitingTasks = 7u - (&pxQueue->xTasksWaitingToReceive)->xListEnd.pxNext->xItemValue;

  else
    uxHighestPriorityOfWaitingTasks = 0u;
  return uxHighestPriorityOfWaitingTasks;
}

// prvGetErrorCodeAndMessage
// file ..\..\..\..\lib\shadow\aws_shadow.c line 1092
static ShadowReturnCode_t prvGetErrorCodeAndMessage(const char * const pcData, uint32_t ulDataLength, BaseType_t xShadowClientID, const char * const pcOperationName)
{
  ShadowReturnCode_t xErrorCode;
  char *pcErrorMessage;
  uint16_t usErrorMessageLength;
  int16_t return_value_SHADOW_JSONGetErrorCodeAndMessage=SHADOW_JSONGetErrorCodeAndMessage(pcData, ulDataLength, &pcErrorMessage, &usErrorMessageLength);
  xErrorCode = (ShadowReturnCode_t)return_value_SHADOW_JSONGetErrorCodeAndMessage;
  if((signed int)xErrorCode >= 1)
    vLoggingPrintf("[Shadow %d] %s rejected, code %d: %.*s.\r\n", xShadowClientID, pcOperationName, xErrorCode, usErrorMessageLength, pcErrorMessage);

  else
    vLoggingPrintf("[Shadow %d] JSON parse error while parsing error code and message.\r\n", xShadowClientID);
  (void)pcOperationName;
  (void)xShadowClientID;
  if((signed int)xErrorCode == 0)
    xErrorCode = (ShadowReturnCode_t)-2;

  return xErrorCode;
}

// prvGetFreeBuffer
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 843
static MQTTBufferHandle_t prvGetFreeBuffer(MQTTContext_t *pxMQTTContext, uint32_t ulBufferLength)
{
  MQTTBufferHandle_t xFreeBufferHandle=NULL;
  uint32_t ulRequestedBufferLength=0u;
  uint8_t *pucFreeBuffer;
  ulRequestedBufferLength = (uint32_t)((unsigned long long int)ulBufferLength + sizeof(MQTTBufferMetadata_t) /*40ull*/ );
  pucFreeBuffer=pxMQTTContext->xBufferPoolInterface.pxGetBufferFxn(&ulRequestedBufferLength);
  if(!(pucFreeBuffer == ((uint8_t *)NULL)))
  {
    ((MQTTBufferMetadata_t *)pucFreeBuffer)->xLink.pxPrev = ((struct Link *)NULL);
    ((MQTTBufferMetadata_t *)pucFreeBuffer)->xLink.pxNext = ((struct Link *)NULL);
    ((MQTTBufferMetadata_t *)pucFreeBuffer)->ulBufferLength = ulRequestedBufferLength;
    ((MQTTBufferMetadata_t *)pucFreeBuffer)->ulDataLength = 0u;
    xFreeBufferHandle = (MQTTBufferHandle_t)pucFreeBuffer;
  }

  return xFreeBufferHandle;
}

// prvGetFreeConnection
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 752
static BaseType_t prvGetFreeConnection(void)
{
  BaseType_t x;
  vPortEnterCritical();
  x = 0;
  for( ; !(x >= 4); x = x + 1l)
    if(xMQTTConnections[(signed long long int)x].xConnectionInUse == 0)
    {
      xMQTTConnections[(signed long long int)x].xConnectionInUse = 1;
      break;
    }

  vPortExitCritical();
  if(x == 4)
    x = -1;

  return x;
}

// prvGetFreeContext
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1106
static OTA_FileContext_t * prvGetFreeContext(void)
{
  uint32_t i;
  OTA_FileContext_t *C=((OTA_FileContext_t *)NULL);
  i = 0u;
  _Bool tmp_if_expr;
  do
  {
    if(!(i >= 1u))
      tmp_if_expr = astOTA_Files[(signed long long int)i].pacFilepath != ((uint8_t *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr = (_Bool)0;
    if(!tmp_if_expr)
      break;

    i = i + 1u;
  }
  while((_Bool)1);
  if(!(i == 1u))
  {
    void *return_value_memset=memset((void *)&astOTA_Files[(signed long long int)i], 0, sizeof(OTA_FileContext_t) /*96ull*/ );
    C = (OTA_FileContext_t *)return_value_memset;
  }

  return C;
}

// prvGetFreeShadowClient
// file ..\..\..\..\lib\shadow\aws_shadow.c line 343
static BaseType_t prvGetFreeShadowClient(void)
{
  BaseType_t xIterator;
  BaseType_t xReturn=-1;
  vPortEnterCritical();
  xIterator = 0;
  for( ; !(xIterator >= 1); xIterator = xIterator + 1l)
    if(pxShadowClients[(signed long long int)xIterator].xInUse == 0)
    {
      pxShadowClients[(signed long long int)xIterator].xInUse = 1;
      xReturn = xIterator;
      break;
    }

  vPortExitCritical();
  return xReturn;
}

// prvGetHostByName
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DNS.c line 483
static uint32_t prvGetHostByName(const char *pcHostName, TickType_t xIdentifier, TickType_t xReadTimeOut_ms)
{
  struct freertos_sockaddr xAddress;
  Socket_t xDNSSocket;
  uint32_t ulIPAddress=0ul;
  uint8_t *pucUDPPayloadBuffer;
  uint32_t ulAddressLength=(uint32_t)sizeof(struct freertos_sockaddr) /*8u*/ ;
  BaseType_t xAttempt;
  int32_t lBytes;
  size_t xPayloadLength;
  size_t xExpectedPayloadLength;
  TickType_t xWriteTimeOut_ms=100u;
  size_t return_value_strlen=strlen(pcHostName);
  xExpectedPayloadLength = sizeof(DNSMessage_t) /*12ull*/  + return_value_strlen + sizeof(uint16_t) /*2ull*/  + sizeof(uint16_t) /*2ull*/  + 2ull;
  xDNSSocket=prvCreateDNSSocket();
  if(!(xDNSSocket == NULL))
  {
    FreeRTOS_setsockopt(xDNSSocket, 0, 1, (void *)&xWriteTimeOut_ms, sizeof(TickType_t) /*4ull*/ );
    FreeRTOS_setsockopt(xDNSSocket, 0, 0, (void *)&xReadTimeOut_ms, sizeof(TickType_t) /*4ull*/ );
    xAttempt = 0;
    for( ; !(xAttempt >= 2); xAttempt = xAttempt + 1l)
    {
      void *return_value_FreeRTOS_GetUDPPayloadBuffer=FreeRTOS_GetUDPPayloadBuffer(xExpectedPayloadLength, 0xFFFFFFFFul);
      pucUDPPayloadBuffer = (uint8_t *)return_value_FreeRTOS_GetUDPPayloadBuffer;
      if(!(pucUDPPayloadBuffer == ((uint8_t *)NULL)))
      {
        xPayloadLength=prvCreateDNSMessage(pucUDPPayloadBuffer, pcHostName, xIdentifier);
        FreeRTOS_GetAddressConfiguration(((uint32_t *)NULL), ((uint32_t *)NULL), ((uint32_t *)NULL), &ulIPAddress);
        xAddress.sin_addr = ulIPAddress;
        xAddress.sin_port = 13568;
        ulIPAddress = 0ul;
        int32_t return_value_FreeRTOS_sendto=FreeRTOS_sendto(xDNSSocket, (const void *)pucUDPPayloadBuffer, xPayloadLength, 1, &xAddress, (uint32_t)sizeof(struct freertos_sockaddr) /*8u*/ );
        if(!(return_value_FreeRTOS_sendto == 0))
        {
          lBytes=FreeRTOS_recvfrom(xDNSSocket, (void *)&pucUDPPayloadBuffer, 0ull, 1, &xAddress, &ulAddressLength);
          if(lBytes >= 1)
          {
            ulIPAddress=prvParseDNSReply(pucUDPPayloadBuffer, (size_t)lBytes, xIdentifier);
            FreeRTOS_ReleaseUDPPayloadBuffer((void *)pucUDPPayloadBuffer);
            if(!(ulIPAddress == 0ul))
              break;

          }

        }

        else
          FreeRTOS_ReleaseUDPPayloadBuffer((void *)pucUDPPayloadBuffer);
      }

    }
    FreeRTOS_closesocket(xDNSSocket);
  }

  return ulIPAddress;
}

// prvGetJSONValue
// file ..\..\..\..\lib\shadow\aws_shadow_json.c line 193
static uint16_t prvGetJSONValue(const char **ppcValue, const char * const pcKey, const char * const pcDoc, jsmntok_t *pxJSMNTokens, int16_t sTokensParsed)
{
  jsmntok_t *pxJSMNToken;
  uint16_t usReturn=0;
  int16_t sIterator;
  uint16_t usCompareLength;
  BaseType_t xValueFound=0;
  size_t return_value_strlen$0;
  if(!(ppcValue == ((const char **)NULL)))
  {
    sIterator = (int16_t)((signed int)sTokensParsed - 1);
    for( ; (signed int)sIterator >= 0; sIterator = sIterator - 1)
    {
      pxJSMNToken = &pxJSMNTokens[(signed long long int)sIterator];
      size_t return_value_strlen=strlen(pcKey);
      signed int tmp_if_expr;
      if(!((signed int)(uint16_t)return_value_strlen >= (signed int)(uint16_t)pxJSMNToken->end + -((signed int)(uint16_t)pxJSMNToken->start)))
        tmp_if_expr = (signed int)(uint16_t)pxJSMNToken->end - (signed int)(uint16_t)pxJSMNToken->start;

      else
      {
        return_value_strlen$0=strlen(pcKey);
        tmp_if_expr = (signed int)(uint16_t)return_value_strlen$0;
      }
      usCompareLength = (uint16_t)tmp_if_expr;
      signed int return_value_strncmp=strncmp(pcKey, pcDoc + (signed long long int)pxJSMNToken->start, (size_t)usCompareLength);
      if(return_value_strncmp == 0)
      {
        if(pxJSMNToken->size == 1)
        {
          pxJSMNToken = pxJSMNToken + 1ll;
          *ppcValue = (const char *)(pcDoc + (signed long long int)pxJSMNToken->start);
          usReturn = (uint16_t)((signed int)(uint16_t)pxJSMNToken->end - (signed int)(uint16_t)pxJSMNToken->start);
          xValueFound = 1;
          break;
        }

      }

    }
  }

  if(xValueFound == 0)
    usReturn = 0;

  return usReturn;
}

// prvGetNextExpireTime
// file ..\..\..\..\lib\FreeRTOS\timers.c line 598
static TickType_t prvGetNextExpireTime(BaseType_t * const pxListWasEmpty)
{
  TickType_t xNextExpireTime;
  *pxListWasEmpty = (BaseType_t)(pxCurrentTimerList->uxNumberOfItems == 0ul);
  if(*pxListWasEmpty == 0)
    xNextExpireTime = pxCurrentTimerList->xListEnd.pxNext->xItemValue;

  else
    xNextExpireTime = 0u;
  return xNextExpireTime;
}

// prvGetPrivatePortNumber
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 1612
static uint16_t prvGetPrivatePortNumber(BaseType_t xProtocol)
{
  const uint16_t usEphemeralPortCount=(const uint16_t)((65535 - 1024) + 1);
  uint16_t usIterations=usEphemeralPortCount;
  uint32_t ulRandomSeed=0u;
  uint16_t usResult=0;
  const List_t *pxList;
  if(xProtocol == 6)
    pxList = &xBoundTCPSocketsList;

  else
    pxList = &xBoundUDPSocketsList;
  (void)xProtocol;
  ulRandomSeed=ulRand();
  if(!(ulRandomSeed == 0u))
  {
    usResult = (uint16_t)(1024 + (signed int)(uint16_t)ulRandomSeed % (signed int)usEphemeralPortCount);
    do
    {
      const ListItem_t *return_value_pxListFindListItemWithValue=pxListFindListItemWithValue(pxList, (TickType_t)(uint16_t)((signed int)usResult << 8u | (signed int)usResult >> 8u));
      if(return_value_pxListFindListItemWithValue == ((const ListItem_t *)NULL))
      {
        usResult = (uint16_t)((signed int)usResult << 8u | (signed int)usResult >> 8u);
        break;
      }

      if(usResult == 65535)
        usResult = 1024;

      else
        usResult = usResult + 1;
      usIterations = usIterations - 1;
    }
    while((signed int)usIterations >= 1);
    if((signed int)usIterations == 0)
      usResult = 0;

  }

  return usResult;
}

// prvGetSubscribedFlag
// file ..\..\..\..\lib\shadow\aws_shadow.c line 1322
static uint8_t prvGetSubscribedFlag(const ShadowClient_t * const pxShadowClient, ShadowOperationName_t xOperationName)
{
  uint8_t ucReturn=0;
  switch((signed int)xOperationName)
  {
    case 0:
    {
      ucReturn = (uint8_t)pxShadowClient->xUpdateSubscribed;
      break;
    }
    case 1:
    {
      ucReturn = (uint8_t)pxShadowClient->xGetSubscribed;
      break;
    }
    case 2:
    {
      ucReturn = (uint8_t)pxShadowClient->xDeleteSubscribed;
      break;
    }
    default:
      ;
  }
  return ucReturn;
}

// prvGetTopicFilterType
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 2232
static MQTTTopicFilterType_t prvGetTopicFilterType(const uint8_t * const pucTopicFilter, uint16_t usTopicFilterLength)
{
  MQTTTopicFilterType_t xTopicFilterType=/*enum*/eMQTTTopicFilterTypeSimple;
  uint16_t x=0;
  for( ; !((signed int)x >= (signed int)usTopicFilterLength); x = x + 1)
  {
    if(pucTopicFilter[(signed long long int)x] == 43)
    {
      xTopicFilterType = /*enum*/eMQTTTopicFilterTypeWildCard;
      _Bool tmp_if_expr$0;
      if(x == 0)
        tmp_if_expr$0 = (_Bool)1;

      else
        tmp_if_expr$0 = pucTopicFilter[(signed long long int)((signed int)x - 1)] == 47 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$0)
      {
        _Bool tmp_if_expr;
        if((signed int)x == -1 + (signed int)usTopicFilterLength)
          tmp_if_expr = (_Bool)1;

        else
          tmp_if_expr = pucTopicFilter[(signed long long int)((signed int)x + 1)] == 47 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr)
          goto __CPROVER_DUMP_L19;

        else
        {
          xTopicFilterType = /*enum*/eMQTTTopicFilterTypeInvalid;
          break;
        }
      }

      else
      {
        xTopicFilterType = /*enum*/eMQTTTopicFilterTypeInvalid;
        break;
      }
    }

    else
      if(pucTopicFilter[(signed long long int)x] == 35)
      {
        xTopicFilterType = /*enum*/eMQTTTopicFilterTypeWildCard;
        _Bool tmp_if_expr$1;
        if(x == 0)
          tmp_if_expr$1 = (_Bool)1;

        else
          tmp_if_expr$1 = pucTopicFilter[(signed long long int)((signed int)x - 1)] == 47 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$1)
        {
          if((signed int)x == -1 + (signed int)usTopicFilterLength)
            break;

          else
          {
            xTopicFilterType = /*enum*/eMQTTTopicFilterTypeInvalid;
            break;
          }
        }

        else
        {
          xTopicFilterType = /*enum*/eMQTTTopicFilterTypeInvalid;
          break;
        }
      }


  __CPROVER_DUMP_L19:
    ;
  }
  return xTopicFilterType;
}

// prvGracefulSocketClose
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 983
static void prvGracefulSocketClose(MQTTBrokerConnection_t * const pxConnection)
{
  const TickType_t xShortDelay=(TickType_t)((10u * 1000u) / 1000u);
  TickType_t xTicksToWait=xShortDelay * 100u;
  TimeOut_t xTimeOut;
  vLoggingPrintf("About to close socket.\r\n");
  vTaskSetTimeOutState(&xTimeOut);
  SOCKETS_Shutdown(pxConnection->xSocket, 2u);
  int32_t return_value_SOCKETS_Recv;
  do
  {
    return_value_SOCKETS_Recv=SOCKETS_Recv(pxConnection->xSocket, (void *)pxConnection->ucRxBuffer, sizeof(uint8_t [1152ll]) /*1152ull*/ , 0u);
    if(!(return_value_SOCKETS_Recv >= 0))
      break;

    vTaskDelay(xShortDelay);
    BaseType_t return_value_xTaskCheckForTimeOut=xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait);
    if(!(return_value_xTaskCheckForTimeOut == 0))
      break;

  }
  while((_Bool)1);
  SOCKETS_Close(pxConnection->xSocket);
  pxConnection->xSocket = (Socket_t)~0u;
  vLoggingPrintf("Socket closed.\r\n");
  UBaseType_t return_value_uxTaskGetStackHighWaterMark=uxTaskGetStackHighWaterMark(NULL);
  vLoggingPrintf("Stack high watermark for MQTT task: %u\r\n", return_value_uxTaskGetStackHighWaterMark);
}

// prvHandleEstablished
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 2361
static BaseType_t prvHandleEstablished(FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkBuffer, uint32_t ulReceiveLength, UBaseType_t uxOptionsLength)
{
  TCPPacket_t *pxTCPPacket=(TCPPacket_t *)(*ppxNetworkBuffer)->pucEthernetBuffer;
  TCPHeader_t *pxTCPHeader=&pxTCPPacket->xTCPHeader;
  TCPWindow_t *pxTCPWindow=&pxSocket->u.xTCP.xTCPWindow;
  uint8_t ucTCPFlags=pxTCPHeader->ucTCPFlags;
  uint32_t ulSequenceNumber=(uint32_t)((uint32_t)pxTCPHeader->ulSequenceNumber << 24 | ((uint32_t)pxTCPHeader->ulSequenceNumber & 0xFF00ul) << 8 | ((uint32_t)pxTCPHeader->ulSequenceNumber & 0xFF0000ul) >> 8 | (uint32_t)pxTCPHeader->ulSequenceNumber >> 24);
  uint32_t ulCount;
  BaseType_t xSendLength=0;
  BaseType_t xMayClose=0;
  BaseType_t bRxComplete;
  BaseType_t bTxDone;
  int32_t lDistance;
  int32_t lSendResult;
  pxSocket->u.xTCP.ulWindowSize = (uint32_t)(uint16_t)((signed int)pxTCPHeader->usWindow << 8u | (signed int)pxTCPHeader->usWindow >> 8u);
  pxSocket->u.xTCP.ulWindowSize = pxSocket->u.xTCP.ulWindowSize << (signed int)pxSocket->u.xTCP.ucPeerWinScaleFactor;
  if(!((16u & (unsigned int)(signed int)ucTCPFlags) == 0u))
  {
    ulCount=ulTCPWindowTxAck(pxTCPWindow, (uint32_t)((uint32_t)pxTCPPacket->xTCPHeader.ulAckNr << 24 | ((uint32_t)pxTCPPacket->xTCPHeader.ulAckNr & 0xFF00ul) << 8 | ((uint32_t)pxTCPPacket->xTCPHeader.ulAckNr & 0xFF0000ul) >> 8 | (uint32_t)pxTCPPacket->xTCPHeader.ulAckNr >> 24));
    if(!(pxSocket->u.xTCP.txStream == ((const StreamBuffer_t *)NULL)))
    {
      if(ulCount >= 1u)
      {
        size_t return_value_uxStreamBufferGet=uxStreamBufferGet(pxSocket->u.xTCP.txStream, 0ull, ((uint8_t *)NULL), (size_t)ulCount, 0);
        if(!(return_value_uxStreamBufferGet == 0ull))
          pxSocket->xEventBits = pxSocket->xEventBits | 2u;

      }

    }

  }

  if(!(pxSocket->u.xTCP.txStream == ((const StreamBuffer_t *)NULL)))
    prvTCPAddTxData(pxSocket);

  pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
  if(!((1u & (unsigned int)(signed int)ucTCPFlags) == 0u) || !((unsigned int)pxSocket->u.xTCP.bits.bFinAccepted == 0u))
  {
    xMayClose = 1;
    if((unsigned int)pxSocket->u.xTCP.bits.bFinSent == 0u)
    {
      bRxComplete=xTCPWindowRxEmpty(pxTCPWindow);
      bTxDone=xTCPWindowTxDone(pxTCPWindow);
      if(bRxComplete == 0 || bTxDone == 0)
      {
        while((_Bool)0)
          ;
        xMayClose = 0;
      }

      else
      {
        lDistance = (int32_t)((ulSequenceNumber + ulReceiveLength) - pxTCPWindow->rx.ulCurrentSequenceNumber);
        if(lDistance >= 2)
        {
          while((_Bool)0)
            ;
          xMayClose = 0;
        }

      }
    }

    if(xTCPWindowLoggingLevel >= 1)
      while((_Bool)0)
        ;

    if(!(xMayClose == 0))
    {
      pxSocket->u.xTCP.bits.bFinAccepted = 1u;
      xSendLength=prvTCPHandleFin(pxSocket, *ppxNetworkBuffer);
    }

  }

  if(xMayClose == 0)
  {
    pxTCPHeader->ucTCPFlags = 16;
    if(!(ulReceiveLength == 0u))
    {
      xSendLength = (BaseType_t)(20u + 20u + uxOptionsLength);
      pxTCPHeader->ucTCPOffset = (uint8_t)(20u + uxOptionsLength << 2);
      if(!((unsigned int)pxSocket->u.xTCP.bits.bFinSent == 0u))
        pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->tx.ulFINSequenceNumber;

    }

    if(uxOptionsLength == 0u)
    {
      lSendResult=prvTCPPrepareSend(pxSocket, ppxNetworkBuffer, uxOptionsLength);
      if(lSendResult >= 1)
        xSendLength = (BaseType_t)lSendResult;

    }

  }

  return xSendLength;
}

// prvHandleEthernetPacket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 534
static void prvHandleEthernetPacket(NetworkBufferDescriptor_t *pxBuffer)
{
  prvProcessEthernetPacket(pxBuffer);
}

// prvHandleListen
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 3083
static FreeRTOS_Socket_t * prvHandleListen(FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxNetworkBuffer)
{
  TCPPacket_t *pxTCPPacket=(TCPPacket_t *)pxNetworkBuffer->pucEthernetBuffer;
  FreeRTOS_Socket_t *pxReturn=((FreeRTOS_Socket_t *)NULL);
  uint32_t ulInitialSequenceNumber=ulGetNextSequenceNumber(*((uint32_t *)&xDefaultPartUDPPacketHeader.ulWords[(signed long long int)(20ull / sizeof(uint32_t) /*4ull*/ )]), pxSocket->usLocalPort, pxTCPPacket->xIPHeader.ulSourceIPAddress, pxTCPPacket->xTCPHeader.usSourcePort);
  BaseType_t return_value_prvTCPSocketCopy;
  if(!(ulInitialSequenceNumber == 0u))
  {
    if(!((unsigned int)pxSocket->u.xTCP.bits.bReuseSocket == 0u))
    {
      pxReturn = pxSocket;
      pxSocket->u.xTCP.bits.bPassQueued = 1u;
      pxSocket->u.xTCP.pxPeerSocket = pxSocket;
    }

    else
    {
      pxReturn = ((FreeRTOS_Socket_t *)NULL);
      if((signed int)pxSocket->u.xTCP.usChildCount >= (signed int)pxSocket->u.xTCP.usBacklog)
      {
        vLoggingPrintf("Check: Socket %u already has %u / %u child%s\n", pxSocket->usLocalPort, pxSocket->u.xTCP.usChildCount, pxSocket->u.xTCP.usBacklog, (signed int)pxSocket->u.xTCP.usChildCount == 1 ? "" : "ren");
        prvTCPSendReset(pxNetworkBuffer);
      }

      else
      {
        FreeRTOS_Socket_t *pxNewSocket;
        Socket_t return_value_FreeRTOS_socket=FreeRTOS_socket(2, 1, 6);
        pxNewSocket = (FreeRTOS_Socket_t *)return_value_FreeRTOS_socket;
        if(pxNewSocket == ((FreeRTOS_Socket_t *)NULL) || pxNewSocket == (FreeRTOS_Socket_t *)4294967295u)
        {
          while((_Bool)0)
            ;
          prvTCPSendReset(pxNetworkBuffer);
        }

        else
        {
          return_value_prvTCPSocketCopy=prvTCPSocketCopy(pxNewSocket, pxSocket);
          if(!(return_value_prvTCPSocketCopy == 0))
            pxReturn = pxNewSocket;

        }
      }
    }
  }

  if(!(pxReturn == ((FreeRTOS_Socket_t *)NULL)) && !(ulInitialSequenceNumber == 0u))
  {
    pxReturn->u.xTCP.usRemotePort = (uint16_t)((signed int)pxTCPPacket->xTCPHeader.usSourcePort << 8u | (signed int)pxTCPPacket->xTCPHeader.usSourcePort >> 8u);
    pxReturn->u.xTCP.ulRemoteIP = (uint32_t)((uint32_t)pxTCPPacket->xIPHeader.ulSourceIPAddress << 24 | ((uint32_t)pxTCPPacket->xIPHeader.ulSourceIPAddress & 0xFF00ul) << 8 | ((uint32_t)pxTCPPacket->xIPHeader.ulSourceIPAddress & 0xFF0000ul) >> 8 | (uint32_t)pxTCPPacket->xIPHeader.ulSourceIPAddress >> 24);
    pxReturn->u.xTCP.xTCPWindow.ulOurSequenceNumber = ulInitialSequenceNumber;
    pxReturn->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber = (uint32_t)((uint32_t)pxTCPPacket->xTCPHeader.ulSequenceNumber << 24 | ((uint32_t)pxTCPPacket->xTCPHeader.ulSequenceNumber & 0xFF00ul) << 8 | ((uint32_t)pxTCPPacket->xTCPHeader.ulSequenceNumber & 0xFF0000ul) >> 8 | (uint32_t)pxTCPPacket->xTCPHeader.ulSequenceNumber >> 24);
    prvSocketSetMSS(pxReturn);
    prvTCPCreateWindow(pxReturn);
    vTCPStateChange(pxReturn, /*enum*/eSYN_FIRST);
    memcpy((void *)pxReturn->u.xTCP.xPacket.u.ucLastPacket, (const void *)pxNetworkBuffer->pucEthernetBuffer, sizeof(uint8_t [70ll]) /*70ull*/ );
  }

  return pxReturn;
}

// prvHandleSynReceived
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 2258
static BaseType_t prvHandleSynReceived(FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkBuffer, uint32_t ulReceiveLength, UBaseType_t uxOptionsLength)
{
  TCPPacket_t *pxTCPPacket=(TCPPacket_t *)(*ppxNetworkBuffer)->pucEthernetBuffer;
  TCPHeader_t *pxTCPHeader=&pxTCPPacket->xTCPHeader;
  TCPWindow_t *pxTCPWindow=&pxSocket->u.xTCP.xTCPWindow;
  uint8_t ucTCPFlags=pxTCPHeader->ucTCPFlags;
  uint32_t ulSequenceNumber=(uint32_t)((uint32_t)pxTCPHeader->ulSequenceNumber << 24 | ((uint32_t)pxTCPHeader->ulSequenceNumber & 0xFF00ul) << 8 | ((uint32_t)pxTCPHeader->ulSequenceNumber & 0xFF0000ul) >> 8 | (uint32_t)pxTCPHeader->ulSequenceNumber >> 24);
  BaseType_t xSendLength=0;
  uint16_t usExpect=16;
  if((signed int)pxSocket->u.xTCP.ucTCPState == 2)
    usExpect = usExpect | 2;

  if(!((0x17u & (unsigned int)ucTCPFlags) == (unsigned int)usExpect))
  {
    while((_Bool)0)
      ;
    vTCPStateChange(pxSocket, /*enum*/eCLOSE_WAIT);
    pxTCPHeader->ucTCPFlags = pxTCPHeader->ucTCPFlags | 4;
    xSendLength = (BaseType_t)(20u + 20u + uxOptionsLength);
    pxTCPHeader->ucTCPOffset = (uint8_t)(20u + uxOptionsLength << 2);
  }

  else
  {
    pxTCPWindow->usPeerPortNumber = pxSocket->u.xTCP.usRemotePort;
    pxTCPWindow->usOurPortNumber = pxSocket->usLocalPort;
    if((signed int)pxSocket->u.xTCP.ucTCPState == 2)
    {
      TCPPacket_t *pxLastTCPPacket=(TCPPacket_t *)pxSocket->u.xTCP.xPacket.u.ucLastPacket;
      pxLastTCPPacket->xTCPHeader.ucTCPFlags = 16;
      vTCPWindowInit(&pxSocket->u.xTCP.xTCPWindow, ulSequenceNumber, pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber, (uint32_t)pxSocket->u.xTCP.usCurMSS);
      pxTCPWindow->rx.ulHighestSequenceNumber = ulSequenceNumber + 1u;
      pxTCPWindow->rx.ulCurrentSequenceNumber = pxTCPWindow->rx.ulHighestSequenceNumber;
      pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber + 1u;
      pxTCPWindow->ulNextTxSequenceNumber = pxTCPWindow->ulNextTxSequenceNumber + 1u;
    }

    else
      if(ulReceiveLength == 0u)
        pxTCPWindow->rx.ulCurrentSequenceNumber = ulSequenceNumber;

    pxTCPWindow->ulOurSequenceNumber = pxTCPWindow->tx.ulFirstSequenceNumber + 1u;
    while((_Bool)0)
      ;
    if((signed int)pxSocket->u.xTCP.ucTCPState == 2 || !(ulReceiveLength == 0u))
    {
      pxTCPHeader->ucTCPFlags = 16;
      xSendLength = (BaseType_t)(20u + 20u + uxOptionsLength);
      pxTCPHeader->ucTCPOffset = (uint8_t)(20u + uxOptionsLength << 2);
    }

    if((unsigned int)pxSocket->u.xTCP.bits.bWinScaling == 0u)
    {
      pxSocket->u.xTCP.ucMyWinScaleFactor = 0;
      pxSocket->u.xTCP.ucPeerWinScaleFactor = 0;
    }

    vTCPStateChange(pxSocket, /*enum*/eESTABLISHED);
  }
  return xSendLength;
}

// prvHeapInit
// file ..\..\..\..\lib\FreeRTOS\portable\MemMang\heap_4.c line 329
static void prvHeapInit(void)
{
  BlockLink_t *pxFirstFreeBlock;
  uint8_t *pucAlignedHeap;
  size_t uxAddress;
  size_t xTotalHeapSize=(size_t)(2048u * 1024u);
  uxAddress = (size_t)ucHeap;
  if(!((7ull & uxAddress) == 0ull))
  {
    uxAddress = uxAddress + (size_t)(8 - 1);
    uxAddress = uxAddress & ~7ull;
    xTotalHeapSize = xTotalHeapSize - (uxAddress - (size_t)ucHeap);
  }

  pucAlignedHeap = (uint8_t *)uxAddress;
  xStart.pxNextFreeBlock = (struct A_BLOCK_LINK *)(void *)pucAlignedHeap;
  xStart.xBlockSize = 0ull;
  uxAddress = (size_t)pucAlignedHeap + xTotalHeapSize;
  uxAddress = uxAddress - xHeapStructSize;
  uxAddress = uxAddress & ~7ull;
  pxEnd = (BlockLink_t *)(void *)uxAddress;
  pxEnd->xBlockSize = 0ull;
  pxEnd->pxNextFreeBlock = ((struct A_BLOCK_LINK *)NULL);
  pxFirstFreeBlock = (BlockLink_t *)(void *)pucAlignedHeap;
  pxFirstFreeBlock->xBlockSize = uxAddress - (size_t)pxFirstFreeBlock;
  pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
  xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
  xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
  xBlockAllocatedBit = 1ull << sizeof(size_t) /*8ull*/  * 8ull - 1ull;
}

// prvIPTask
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 314
static void prvIPTask(void *pvParameters)
{
  IPStackEvent_t xReceivedEvent;
  TickType_t xNextIPSleep;
  FreeRTOS_Socket_t *pxSocket;
  struct freertos_sockaddr xAddress;
  (void)pvParameters;
  while((_Bool)0)
    ;
  FreeRTOS_NetworkDown();
  prvIPTimerReload(&xTCPTimer, (TickType_t)((1000u * 1000u) / 1000u));
  xIPTaskInitialised = 1;
  while((_Bool)0)
    ;
  while((_Bool)1)
  {
    prvCheckNetworkTimers();
    xNextIPSleep=prvCalculateSleepTime();
    BaseType_t return_value_xQueueReceive=xQueueReceive(xNetworkEventQueue, (void *)&xReceivedEvent, xNextIPSleep);
    if(return_value_xQueueReceive == 0)
      xReceivedEvent.eEventType = /*enum*/eNoEvent;

    switch((signed int)xReceivedEvent.eEventType)
    {
      case 0:
      {
        xNetworkUp = 0;
        prvProcessNetworkDownEvent();
        break;
      }
      case 1:
      {
        prvHandleEthernetPacket((NetworkBufferDescriptor_t *)xReceivedEvent.pvData);
        break;
      }
      case 2:
      {
        vARPAgeCache();
        break;
      }
      case 8:
      {
        pxSocket = (FreeRTOS_Socket_t *)xReceivedEvent.pvData;
        xAddress.sin_addr = 0u;
        xAddress.sin_port = (uint16_t)((signed int)pxSocket->usLocalPort << 8u | (signed int)pxSocket->usLocalPort >> 8u);
        pxSocket->usLocalPort = 0;
        vSocketBind(pxSocket, &xAddress, sizeof(struct freertos_sockaddr) /*8ull*/ , 0);
        pxSocket->xEventBits = pxSocket->xEventBits | 16u;
        vSocketWakeUpUser(pxSocket);
        break;
      }
      case 9:
      {
        vSocketClose((FreeRTOS_Socket_t *)xReceivedEvent.pvData);
        break;
      }
      case 3:
      {
        vProcessGeneratedUDPPacket((NetworkBufferDescriptor_t *)xReceivedEvent.pvData);
        break;
      }
      case 4:
      {
        vDHCPProcess(0);
        break;
      }
      case 10:
        break;
      case 11:
        break;
      case 5:
      {
        xTCPTimer.bExpired = 1u;
        break;
      }
      case 6:
      {
        pxSocket = (FreeRTOS_Socket_t *)xReceivedEvent.pvData;
        BaseType_t return_value_xTCPCheckNewClient=xTCPCheckNewClient(pxSocket);
        if(!(return_value_xTCPCheckNewClient == 0))
        {
          pxSocket->xEventBits = pxSocket->xEventBits | 4u;
          vSocketWakeUpUser(pxSocket);
        }

        break;
      }
      case 7:
      {
        vTCPNetStat();
        break;
      }
      default:
        ;
    }
    if(!(xNetworkDownEventPending == 0))
      FreeRTOS_NetworkDown();

  }
}

// prvIPTimerCheck
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 717
static BaseType_t prvIPTimerCheck(IPTimer_t *pxTimer)
{
  BaseType_t xReturn;
  BaseType_t return_value_xTaskCheckForTimeOut;
  if((unsigned int)pxTimer->bActive == 0u)
    xReturn = 0;

  else
  {
    _Bool tmp_if_expr;
    if(!((unsigned int)pxTimer->bExpired == 0u))
      tmp_if_expr = (_Bool)1;

    else
    {
      return_value_xTaskCheckForTimeOut=xTaskCheckForTimeOut(&pxTimer->xTimeOut, &pxTimer->ulRemainingTime);
      tmp_if_expr = return_value_xTaskCheckForTimeOut != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr)
    {
      prvIPTimerStart(pxTimer, pxTimer->ulReloadTime);
      xReturn = 1;
    }

    else
      xReturn = 0;
  }
  return xReturn;
}

// prvIPTimerReload
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 710
static void prvIPTimerReload(IPTimer_t *pxTimer, TickType_t xTime)
{
  pxTimer->ulReloadTime = xTime;
  prvIPTimerStart(pxTimer, xTime);
}

// prvIPTimerStart
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 692
static void prvIPTimerStart(IPTimer_t *pxTimer, TickType_t xTime)
{
  vTaskSetTimeOutState(&pxTimer->xTimeOut);
  pxTimer->ulRemainingTime = xTime;
  if(xTime == 0u)
    pxTimer->bExpired = 1u;

  else
    pxTimer->bExpired = 0u;
  pxTimer->bActive = 1u;
}

// prvIdleTask
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3295
static void prvIdleTask(void *pvParameters)
{
  (void)pvParameters;
  while((_Bool)1)
  {
    prvCheckTasksWaitingTermination();
    if(pxReadyTasksLists[0ll].uxNumberOfItems >= 2ul)
      vPortGenerateSimulatedInterrupt(0ul);

    vApplicationIdleHook();
  }
}

// prvIngestDataBlock
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1589
static IngestResult_t prvIngestDataBlock(OTA_FileContext_t *C, const char *pacRawMsg, uint32_t iMsgSize)
{
  IngestResult_t eIngestResult=/*enum*/eIngest_Result_Continue;
  signed int lFileId=0;
  signed int lBlockSize=0;
  signed int lBlockIndex=0;
  uint8_t *pucPayload=((uint8_t *)NULL);
  size_t xPayloadSize=0ull;
  _Bool tmp_if_expr;
  if(!(C == ((OTA_FileContext_t *)NULL)))
  {
    _Bool tmp_if_expr$1;
    if(!(C->pacRxBlockBitmap == ((uint8_t *)NULL)))
      tmp_if_expr$1 = C->iBlocksRemaining > 0u ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
    {
      prvStartRequestTimer(C);
      BaseType_t return_value_OTA_CBOR_Decode_GetStreamResponseMessage=OTA_CBOR_Decode_GetStreamResponseMessage((uint8_t *)pacRawMsg, (size_t)iMsgSize, &lFileId, &lBlockIndex, &lBlockSize, &pucPayload, &xPayloadSize);
      if(return_value_OTA_CBOR_Decode_GetStreamResponseMessage == 0)
        eIngestResult = /*enum*/eIngest_Result_BadData;

      else
      {
        uint32_t iLastBlock=(C->iFileSize + (unsigned int)(1024 - 1) >> 8 * (signed int)(1024 > 255) + ((8 - 90 / ((1024 >> 8 * (signed int)(1024 > 255)) / 4 + 14 | 1)) - 2 / ((1024 >> 8 * (signed int)(1024 > 255)) / 2 + 1))) - 1u;
        _Bool tmp_if_expr$0;
        if(lBlockSize == 1024 && !((uint32_t)lBlockIndex >= iLastBlock))
          tmp_if_expr$0 = (_Bool)1;

        else
        {
          if((uint32_t)lBlockIndex == iLastBlock)
            tmp_if_expr = (uint32_t)lBlockSize == C->iFileSize - iLastBlock * 1024u ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr = (_Bool)0;
          tmp_if_expr$0 = tmp_if_expr ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$0)
        {
          vLoggingPrintf("[OTA] Received file block %u, size %u\r\n", lBlockIndex, lBlockSize);
          uint32_t mBit=(uint32_t)(1 << lBlockIndex % 8);
          uint32_t byte=(uint32_t)(lBlockIndex >> (8 - 90 / (8 / 4 + 14 | 1)) - 2 / (8 / 2 + 1));
          if((mBit & (unsigned int)C->pacRxBlockBitmap[(signed long long int)byte]) == 0u)
            vLoggingPrintf("[OTA] block %u is a DUPLICATE\r\n", lBlockIndex);

          else
          {
            if(!(C->$anon0.iFileHandle == 0))
            {
              int32_t iBytesWritten;
              int16_t return_value_prvWriteBlock=prvWriteBlock(C, lBlockIndex * 1024, pucPayload, (uint32_t)lBlockSize);
              iBytesWritten = (int32_t)return_value_prvWriteBlock;
              if(!(iBytesWritten >= 0))
              {
                vLoggingPrintf("[OTA] Error (%d) writing file block\r\n", iBytesWritten);
                eIngestResult = /*enum*/eIngest_Result_WriteBlockFailed;
              }

              else
              {
                C->pacRxBlockBitmap[(signed long long int)byte] = C->pacRxBlockBitmap[(signed long long int)byte] & (uint8_t)~mBit;
                C->iBlocksRemaining = C->iBlocksRemaining - 1u;
              }
            }

            else
            {
              vLoggingPrintf("[OTA] Error: Illegal file handle (%d) therefore unable to write block.\r\n", (int32_t)C->$anon0.iFileHandle);
              eIngestResult = /*enum*/eIngest_Result_BadFileHandle;
            }
            if(C->iBlocksRemaining == 0u)
            {
              prvStopRequestTimer(C);
              vPortFree((void *)C->pacRxBlockBitmap);
              C->pacRxBlockBitmap = ((uint8_t *)NULL);
              if(!(C->$anon0.iFileHandle == 0))
              {
                int32_t iCloseResult;
                OTA_Err_t return_value_prvCloseFile=prvCloseFile(C);
                iCloseResult = (int32_t)return_value_prvCloseFile;
                if(iCloseResult == 0)
                {
                  vLoggingPrintf("[OTA] File receive complete and signature is valid.\r\n");
                  eIngestResult = /*enum*/eIngest_Result_FileComplete;
                }

                else
                {
                  vLoggingPrintf("[OTA] Error (%u:%d) closing OTA file.\r\n", iCloseResult >> 24, iCloseResult & 0xFFFFFF);
                  eIngestResult = /*enum*/eIngest_Result_SigCheckFail;
                }
                C->$anon0.iFileHandle = 0;
              }

              else
              {
                vLoggingPrintf("[OTA] Error: Illegal file handle (%d) after last block received.\r\n", (int32_t)C->$anon0.iFileHandle);
                eIngestResult = /*enum*/eIngest_Result_BadFileHandle;
              }
            }

            else
              vLoggingPrintf("[OTA] Remaining: %u\r\n", C->iBlocksRemaining);
          }
        }

        else
        {
          vLoggingPrintf("[OTA] Error! Block %u out of expected range!\r\n", lBlockIndex);
          eIngestResult = /*enum*/eIngest_Result_BlockOutOfRange;
        }
      }
    }

    else
      eIngestResult = /*enum*/eIngest_Result_UnexpectedBlock;
  }

  else
    eIngestResult = /*enum*/eIngest_Result_NullContext;
  if(!(pucPayload == ((uint8_t *)NULL)))
    vPortFree((void *)pucPayload);

  return eIngestResult;
}

// prvInitialiseDHCP
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DHCP.c line 592
static void prvInitialiseDHCP(void)
{
  xDHCPData.ulTransactionId=ulRand();
  if(!(xDHCPData.ulTransactionId == 0u))
  {
    xDHCPData.xUseBroadcast = 0;
    xDHCPData.ulOfferedIPAddress = 0ul;
    xDHCPData.ulDHCPServerAddress = 0ul;
    xDHCPData.xDHCPTxPeriod = (TickType_t)((5000u * 1000u) / 1000u);
    prvCreateDHCPSocket();
    while((_Bool)0)
      ;
    vIPReloadDHCPTimer((TickType_t)((250u * 1000u) / 1000u));
  }

}

// prvInitialiseMutex
// file ..\..\..\..\lib\FreeRTOS\queue.c line 452
static void prvInitialiseMutex(Queue_t *pxNewQueue)
{
  if(!(pxNewQueue == ((Queue_t *)NULL)))
  {
    pxNewQueue->pcTail = ((int8_t *)NULL);
    pxNewQueue->pcHead = ((int8_t *)NULL);
    pxNewQueue->u.uxRecursiveCallCount = 0ul;
    xQueueGenericSend((QueueHandle_t)pxNewQueue, NULL, 0u, 0);
  }

}

// prvInitialiseNewQueue
// file ..\..\..\..\lib\FreeRTOS\queue.c line 408
static void prvInitialiseNewQueue(const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue)
{
  (void)ucQueueType;
  if(uxItemSize == 0ul)
    pxNewQueue->pcHead = (int8_t *)pxNewQueue;

  else
    pxNewQueue->pcHead = (int8_t *)pucQueueStorage;
  pxNewQueue->uxLength = uxQueueLength;
  pxNewQueue->uxItemSize = uxItemSize;
  xQueueGenericReset((QueueHandle_t)pxNewQueue, 1);
  pxNewQueue->ucQueueType = ucQueueType;
  uint8_t return_value_prvTraceGetObjectType=prvTraceGetObjectType((void *)pxNewQueue);
  traceHandle return_value_prvTraceGetObjectHandle=prvTraceGetObjectHandle(TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType]);
  pxNewQueue->uxQueueNumber = (UBaseType_t)return_value_prvTraceGetObjectHandle;
  uint8_t return_value_prvTraceGetObjectType$0=prvTraceGetObjectType((void *)pxNewQueue);
  traceHandle return_value_prvTraceGetObjectNumber=prvTraceGetObjectNumber((void *)pxNewQueue);
  prvMarkObjectAsUsed(TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$0], return_value_prvTraceGetObjectNumber);
  uint8_t return_value_prvTraceGetObjectType$1=prvTraceGetObjectType((void *)pxNewQueue);
  uint8_t return_value_prvTraceGetObjectType$2=prvTraceGetObjectType((void *)pxNewQueue);
  traceHandle return_value_prvTraceGetObjectNumber$0=prvTraceGetObjectNumber((void *)pxNewQueue);
  prvTraceStoreKernelCall((uint32_t)(uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + (unsigned int)TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$1]), TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$2], (uint32_t)return_value_prvTraceGetObjectNumber$0);
  uint8_t return_value_prvTraceGetObjectType$3=prvTraceGetObjectType((void *)pxNewQueue);
  traceHandle return_value_prvTraceGetObjectNumber$1=prvTraceGetObjectNumber((void *)pxNewQueue);
  prvTraceSetObjectState(TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$3], return_value_prvTraceGetObjectNumber$1, 0);
}

// prvInitialiseNewStreamBuffer
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 1141
static void prvInitialiseNewStreamBuffer(StreamBuffer_t1 * const pxStreamBuffer, uint8_t * const pucBuffer, size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer)
{
  const BaseType_t xWriteValue=0x55;
  void *return_value_memset=memset((void *)pucBuffer, (signed int)xWriteValue, xBufferSizeBytes);
  if(!(return_value_memset == (void *)pucBuffer))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 1156u);

  memset((void *)pxStreamBuffer, 0x0, sizeof(StreamBuffer_t) /*64ull*/ );
  pxStreamBuffer->pucBuffer = pucBuffer;
  pxStreamBuffer->xLength = xBufferSizeBytes;
  pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
  if(!(xIsMessageBuffer == 0))
    pxStreamBuffer->ucFlags = pxStreamBuffer->ucFlags | 1;

}

// prvInitialiseNewTask
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 834
static void prvInitialiseNewTask(TaskFunction_t pxTaskCode, const char * const pcName, const uint32_t ulStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, TCB_t *pxNewTCB, const MemoryRegion_t * const xRegions)
{
  StackType_t *pxTopOfStack;
  UBaseType_t x;
  memset((void *)pxNewTCB->pxStack, 165, (size_t)ulStackDepth * sizeof(StackType_t) /*8ull*/ );
  pxTopOfStack = pxNewTCB->pxStack + (signed long long int)(ulStackDepth - 1u);
  pxTopOfStack = (StackType_t *)((size_t)pxTopOfStack & ~7ull);
  if(!((7ull & (size_t)pxTopOfStack) == 0ull))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 878u);

  pxNewTCB->pxEndOfStack = pxTopOfStack;
  x = 0ul;
  for( ; !(x >= 15ul); x = x + 1ul)
  {
    pxNewTCB->pcTaskName[(signed long long int)x] = pcName[(signed long long int)x];
    if((signed int)pcName[(signed long long int)x] == 0x0)
      break;

  }
  pxNewTCB->pcTaskName[(signed long long int)(15 - 1)] = 0;
  if(uxPriority >= 7ul)
    uxPriority = 7ul - 1u;

  pxNewTCB->uxPriority = uxPriority;
  pxNewTCB->uxBasePriority = uxPriority;
  pxNewTCB->uxMutexesHeld = 0ul;
  vListInitialiseItem(&pxNewTCB->xStateListItem);
  vListInitialiseItem(&pxNewTCB->xEventListItem);
  (&pxNewTCB->xStateListItem)->pvOwner = (void *)pxNewTCB;
  (&pxNewTCB->xEventListItem)->xItemValue = 7u - (TickType_t)uxPriority;
  (&pxNewTCB->xEventListItem)->pvOwner = (void *)pxNewTCB;
  pxNewTCB->ulRunTimeCounter = 0ul;
  (void)xRegions;
  x = 0ul;
  for( ; !(x >= 3ul); x = x + 1ul)
    pxNewTCB->pvThreadLocalStoragePointers[(signed long long int)x] = NULL;
  pxNewTCB->ulNotifiedValue = 0u;
  pxNewTCB->ucNotifyState = 0;
  pxNewTCB->ucDelayAborted = 0;
  pxNewTCB->pxTopOfStack=pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
  if(!(pxCreatedTask == ((TaskHandle_t * const )NULL)))
    *pxCreatedTask = (TaskHandle_t)pxNewTCB;

}

// prvInitialiseNewTimer
// file ..\..\..\..\lib\FreeRTOS\timers.c line 352
static void prvInitialiseNewTimer(const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction, Timer_t *pxNewTimer)
{
  if(!(xTimerPeriodInTicks >= 1u))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\timers.c", 360u);

  if(!(pxNewTimer == ((Timer_t *)NULL)))
  {
    prvCheckForValidListAndQueue();
    pxNewTimer->pcTimerName = pcTimerName;
    pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    pxNewTimer->uxAutoReload = uxAutoReload;
    pxNewTimer->pvTimerID = pvTimerID;
    pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    vListInitialiseItem(&pxNewTimer->xTimerListItem);
    traceHandle return_value_prvTraceGetObjectHandle=prvTraceGetObjectHandle(5);
    ((Timer_t *)pxNewTimer)->uxTimerNumber = (UBaseType_t)return_value_prvTraceGetObjectHandle;
    signed int tmp_if_expr;
    if(!((uint32_t)pxNewTimer == 0u))
      tmp_if_expr = (signed int)(traceHandle)((Timer_t *)pxNewTimer)->uxTimerNumber;

    else
      tmp_if_expr = 0;
    prvTraceSetObjectName(5, (traceHandle)tmp_if_expr, pxNewTimer->pcTimerName);
    signed int tmp_if_expr$0;
    if(!((uint32_t)pxNewTimer == 0u))
      tmp_if_expr$0 = (signed int)(traceHandle)((Timer_t *)pxNewTimer)->uxTimerNumber;

    else
      tmp_if_expr$0 = 0;
    prvTraceStoreKernelCall(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + 0ul, 5, (uint32_t)tmp_if_expr$0);
  }

}

// prvInitialiseTaskLists
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3507
static void prvInitialiseTaskLists(void)
{
  UBaseType_t uxPriority=0u;
  for( ; !(uxPriority >= 7ul); uxPriority = uxPriority + 1ul)
    vListInitialise(&pxReadyTasksLists[(signed long long int)uxPriority]);
  vListInitialise(&xDelayedTaskList1);
  vListInitialise(&xDelayedTaskList2);
  vListInitialise(&xPendingReadyList);
  vListInitialise(&xTasksWaitingTermination);
  vListInitialise(&xSuspendedTaskList);
  pxDelayedTaskList = &xDelayedTaskList1;
  pxOverflowDelayedTaskList = &xDelayedTaskList2;
}

// prvInitialize
// file ..\..\..\common\devmode_key_provisioning\aws_dev_mode_key_provisioning.c line 63
static CK_RV prvInitialize(CK_FUNCTION_LIST_PTR *ppxFunctionList, CK_SLOT_ID *pxSlotId, CK_SESSION_HANDLE *pxSession)
{
  CK_RV xResult=0ul;
  CK_C_GetFunctionList pxCkGetFunctionList=((CK_C_GetFunctionList)NULL);
  CK_ULONG ulCount=1ul;
  (void)pxSession;
  if(xResult == 0u)
  {
    pxCkGetFunctionList = C_GetFunctionList;
    xResult=pxCkGetFunctionList(ppxFunctionList);
  }

  if(xResult == 0u)
    xResult=(*ppxFunctionList)->C_Initialize(NULL);

  if(xResult == 0u)
    xResult=(*ppxFunctionList)->C_GetSlotList(1, pxSlotId, &ulCount);

  return xResult;
}

// prvInitializeClientCredential
// file ..\..\..\..\lib\tls\aws_tls.c line 257
static signed int prvInitializeClientCredential(TLSContext_t *pCtx)
{
  BaseType_t xResult=0;
  CK_C_GetFunctionList pxCkGetFunctionList=((CK_C_GetFunctionList)NULL);
  CK_SLOT_ID xSlotId=0ul;
  CK_ULONG ulCount=1ul;
  CK_ATTRIBUTE xTemplate={ .type=0ul, .pValue=NULL, .ulValueLen=0ul };
  CK_OBJECT_CLASS xObjClass=0ul;
  CK_OBJECT_HANDLE xCertObj=0ul;
  CK_BYTE *pucCertificate=((CK_BYTE *)NULL);
  mbedtls_x509_crt_init(&pCtx->mbedX509Cli);
  if(xResult == 0)
  {
    pxCkGetFunctionList = C_GetFunctionList;
    CK_RV return_value=pxCkGetFunctionList(&pCtx->pxP11FunctionList);
    xResult = (BaseType_t)return_value;
  }

  if(xResult == 0)
  {
    CK_RV return_value$0=pCtx->pxP11FunctionList->C_Initialize(NULL);
    xResult = (BaseType_t)return_value$0;
  }

  if(xResult == 0)
  {
    CK_RV return_value$1=pCtx->pxP11FunctionList->C_GetSlotList(1, &xSlotId, &ulCount);
    xResult = (BaseType_t)return_value$1;
  }

  if(xResult == 0)
  {
    CK_RV return_value$2=pCtx->pxP11FunctionList->C_OpenSession(xSlotId, 0x4ul, NULL, ((CK_NOTIFY)NULL), &pCtx->xP11Session);
    xResult = (BaseType_t)return_value$2;
  }

  if(xResult == 0)
  {
    xTemplate.type = 0x0ul;
    xTemplate.ulValueLen = (CK_ULONG)sizeof(unsigned long int) /*4ul*/ ;
    xTemplate.pValue = (CK_VOID_PTR)&xObjClass;
    xObjClass = 0x3ul;
    CK_RV return_value$3=pCtx->pxP11FunctionList->C_FindObjectsInit(pCtx->xP11Session, &xTemplate, 1ul);
    xResult = (BaseType_t)return_value$3;
  }

  if(xResult == 0)
  {
    CK_RV return_value$4=pCtx->pxP11FunctionList->C_FindObjects(pCtx->xP11Session, &pCtx->xP11PrivateKey, 1ul, &ulCount);
    xResult = (BaseType_t)return_value$4;
  }

  if(xResult == 0)
  {
    CK_RV return_value$5=pCtx->pxP11FunctionList->C_FindObjectsFinal(pCtx->xP11Session);
    xResult = (BaseType_t)return_value$5;
  }

  if(xResult == 0)
  {
    xTemplate.type = 0x80000000ul;
    xTemplate.ulValueLen = (CK_ULONG)sizeof(mbedtls_pk_context) /*16ul*/ ;
    xTemplate.pValue = (CK_VOID_PTR)&pCtx->mbedPkCtx;
    CK_RV return_value$6=pCtx->pxP11FunctionList->C_GetAttributeValue(pCtx->xP11Session, pCtx->xP11PrivateKey, &xTemplate, 1ul);
    xResult = (BaseType_t)return_value$6;
  }

  if(xResult == 0)
  {
    xTemplate.type = 0x121ul;
    xTemplate.ulValueLen = (CK_ULONG)sizeof(CK_ULONG) /*4ul*/ ;
    xTemplate.pValue = (CK_VOID_PTR)&pCtx->ulP11ModulusBytes;
    CK_RV return_value$7=pCtx->pxP11FunctionList->C_GetAttributeValue(pCtx->xP11Session, pCtx->xP11PrivateKey, &xTemplate, 1ul);
    xResult = (BaseType_t)return_value$7;
  }

  if(xResult == 0)
  {
    pCtx->ulP11ModulusBytes = pCtx->ulP11ModulusBytes / 8ul;
    xTemplate.type = 0x0ul;
    xTemplate.ulValueLen = (CK_ULONG)sizeof(unsigned long int) /*4ul*/ ;
    xTemplate.pValue = (CK_VOID_PTR)&xObjClass;
    xObjClass = 0x1ul;
    CK_RV return_value$8=pCtx->pxP11FunctionList->C_FindObjectsInit(pCtx->xP11Session, &xTemplate, 1ul);
    xResult = (BaseType_t)return_value$8;
  }

  if(xResult == 0)
  {
    CK_RV return_value$9=pCtx->pxP11FunctionList->C_FindObjects(pCtx->xP11Session, &xCertObj, 1ul, &ulCount);
    xResult = (BaseType_t)return_value$9;
  }

  if(xResult == 0)
  {
    CK_RV return_value$10=pCtx->pxP11FunctionList->C_FindObjectsFinal(pCtx->xP11Session);
    xResult = (BaseType_t)return_value$10;
  }

  if(xResult == 0)
  {
    xTemplate.type = 0x11ul;
    xTemplate.ulValueLen = 0ul;
    xTemplate.pValue = NULL;
    CK_RV return_value$11=pCtx->pxP11FunctionList->C_GetAttributeValue(pCtx->xP11Session, xCertObj, &xTemplate, 1ul);
    xResult = (BaseType_t)return_value$11;
  }

  if(xResult == 0)
  {
    void *return_value_pvPortMalloc=pvPortMalloc((size_t)xTemplate.ulValueLen);
    pucCertificate = (CK_BYTE_PTR)return_value_pvPortMalloc;
    if(pucCertificate == ((CK_BYTE *)NULL))
      xResult = 2l;

  }

  if(xResult == 0)
  {
    xTemplate.pValue = (CK_VOID_PTR)pucCertificate;
    CK_RV return_value$12=pCtx->pxP11FunctionList->C_GetAttributeValue(pCtx->xP11Session, xCertObj, &xTemplate, 1ul);
    xResult = (BaseType_t)return_value$12;
  }

  if(xResult == 0)
    xResult=mbedtls_x509_crt_parse(&pCtx->mbedX509Cli, (const unsigned char *)pucCertificate, (size_t)xTemplate.ulValueLen);

  if(xResult == 0 && !(clientcredentialJITR_DEVICE_CERTIFICATE_AUTHORITY_PEM == ((const char *)NULL)))
  {
    size_t return_value_strlen=strlen(clientcredentialJITR_DEVICE_CERTIFICATE_AUTHORITY_PEM);
    xResult=mbedtls_x509_crt_parse(&pCtx->mbedX509Cli, (const unsigned char *)clientcredentialJITR_DEVICE_CERTIFICATE_AUTHORITY_PEM, 1ull + return_value_strlen);
  }

  if(xResult == 0)
    xResult=mbedtls_ssl_conf_own_cert(&pCtx->mbedSslConfig, &pCtx->mbedX509Cli, &pCtx->mbedPkCtx);

  if(!(pucCertificate == ((CK_BYTE *)NULL)))
    vPortFree((void *)pucCertificate);

  return xResult;
}

// prvInitializeKey
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 237
static CK_RV prvInitializeKey(P11SessionPtr_t pxSessionObj, const char *pcEncodedKey, const uint32_t ulEncodedKeyLength, const char *pcEncodedCertificate, const uint32_t ulEncodedCertificateLength)
{
  CK_RV xResult=0ul;
  if(pxSessionObj->pxCurrentKey == ((P11KeyPtr_t)NULL))
  {
    void *return_value_pvPortMalloc=pvPortMalloc(sizeof(P11Key_t) /*680ull*/ );
    pxSessionObj->pxCurrentKey = (P11KeyPtr_t)return_value_pvPortMalloc;
    if(pxSessionObj->pxCurrentKey == ((P11KeyPtr_t)NULL))
      xResult = 0x2ul;

  }

  if(xResult == 0x0ul && !(pcEncodedKey == ((const char *)NULL)))
  {
    memset((void *)pxSessionObj->pxCurrentKey, 0, sizeof(P11Key_t) /*680ull*/ );
    mbedtls_pk_init(&pxSessionObj->pxCurrentKey->xMbedPkCtx);
    signed int return_value_mbedtls_pk_parse_key=mbedtls_pk_parse_key(&pxSessionObj->pxCurrentKey->xMbedPkCtx, (const unsigned char *)pcEncodedKey, (size_t)ulEncodedKeyLength, ((const unsigned char *)NULL), 0ull);
    if(!(return_value_mbedtls_pk_parse_key == 0))
      xResult = 0x6ul;

    if(xResult == 0x0ul)
      xResult=prvSetupPkcs11SigningForMbedTls(pxSessionObj, pxSessionObj->pxCurrentKey);

  }

  if(xResult == 0x0ul && !(pcEncodedCertificate == ((const char *)NULL)))
  {
    mbedtls_x509_crt_init(&pxSessionObj->pxCurrentKey->xMbedX509Cli);
    signed int return_value_mbedtls_x509_crt_parse=mbedtls_x509_crt_parse(&pxSessionObj->pxCurrentKey->xMbedX509Cli, (const unsigned char *)pcEncodedCertificate, (size_t)ulEncodedCertificateLength);
    if(!(return_value_mbedtls_x509_crt_parse == 0))
      xResult = 0x6ul;

  }

  return xResult;
}

// prvInitiateMQTTConnect
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1345
static void prvInitiateMQTTConnect(MQTTEventData_t * const pxEventData)
{
  BaseType_t xStatus=0;
  MQTTNotificationData_t *pxNotificationData;
  MQTTConnectParams_t xConnectParams;
  MQTTBrokerConnection_t *pxConnection=&xMQTTConnections[(signed long long int)pxEventData->uxBrokerNumber];
  pxNotificationData=prvStoreNotificationData(pxConnection, pxEventData);
  if(!(pxNotificationData == ((MQTTNotificationData_t *)NULL)))
  {
    pxConnection->pvUserData = pxEventData->u.pxConnectParams->pvUserData;
    pxConnection->pxCallback = pxEventData->u.pxConnectParams->pxCallback;
    _Bool tmp_if_expr;
    if(pxEventData->u.pxConnectParams->xSecuredConnection == 0)
      tmp_if_expr = (pxEventData->u.pxConnectParams->xFlags & 0x2) == 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr = (_Bool)0;
    if(tmp_if_expr)
      pxConnection->uxFlags = pxConnection->uxFlags & ~(1ul << 0ul);

    else
      pxConnection->uxFlags = pxConnection->uxFlags | 1ul << 0ul;
    xStatus=prvSetupConnection(pxEventData);
    if(xStatus == 1)
    {
      xConnectParams.pucClientId = pxEventData->u.pxConnectParams->pucClientId;
      xConnectParams.usClientIdLength = pxEventData->u.pxConnectParams->usClientIdLength;
      xConnectParams.pucUserName = (const uint8_t *)cUserName;
      xConnectParams.usUserNameLength = usUserNameLength;
      xConnectParams.usKeepAliveIntervlSeconds = 1200;
      xConnectParams.ulKeepAliveActualIntervalTicks = (TickType_t)((300000u * 1000u) / 1000u);
      xConnectParams.ulPingRequestTimeoutTicks = 5000u;
      xConnectParams.usPacketIdentifier = (uint16_t)(pxEventData->xNotificationData.ulMessageIdentifier >> 16);
      xConnectParams.ulTimeoutTicks = pxEventData->xTicksToWait;
      MQTTReturnCode_t return_value_MQTT_Connect=MQTT_Connect(&pxConnection->xMQTTContext, &xConnectParams);
      if(!((signed int)return_value_MQTT_Connect == 0))
      {
        vLoggingPrintf("MQTT_Connect failed!\r\n");
        prvGracefulSocketClose(pxConnection);
        xStatus = 0;
      }

    }

  }

  if(xStatus == 0)
  {
    prvNotifyRequestingTask(&pxEventData->xNotificationData, /*enum*/eMQTTCONNCouldNotBeSent, 0ul);
    if(!(pxNotificationData == ((MQTTNotificationData_t *)NULL)))
      pxNotificationData->xTaskToNotify = NULL;

  }

}

// prvInitiateMQTTDisconnect
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1424
static void prvInitiateMQTTDisconnect(MQTTEventData_t * const pxEventData)
{
  MQTTBrokerConnection_t *pxConnection=&xMQTTConnections[(signed long long int)pxEventData->uxBrokerNumber];
  MQTTReturnCode_t return_value_MQTT_Disconnect=MQTT_Disconnect(&pxConnection->xMQTTContext);
  if((signed int)return_value_MQTT_Disconnect == 0)
    prvNotifyRequestingTask(&pxEventData->xNotificationData, /*enum*/eMQTTDISCONNSent, 1ul);

  else
    prvNotifyRequestingTask(&pxEventData->xNotificationData, /*enum*/eMQTTDISCONNCouldNotBeSent, 0ul);
}

// prvInitiateMQTTPublish
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1551
static void prvInitiateMQTTPublish(MQTTEventData_t * const pxEventData)
{
  BaseType_t xStatus=0;
  MQTTNotificationData_t *pxNotificationData=((MQTTNotificationData_t *)NULL);
  MQTTPublishParams_t xPublishParams;
  MQTTBrokerConnection_t *pxConnection=&xMQTTConnections[(signed long long int)pxEventData->uxBrokerNumber];
  if(!((signed int)pxEventData->u.pxPublishParams->xQoS == 0))
    pxNotificationData=prvStoreNotificationData(pxConnection, pxEventData);

  _Bool tmp_if_expr;
  if(!(pxNotificationData == ((MQTTNotificationData_t *)NULL)))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = (signed int)pxEventData->u.pxPublishParams->xQoS == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
  {
    xPublishParams.pucTopic = pxEventData->u.pxPublishParams->pucTopic;
    xPublishParams.usTopicLength = pxEventData->u.pxPublishParams->usTopicLength;
    xPublishParams.xQos = pxEventData->u.pxPublishParams->xQoS;
    xPublishParams.pvData = pxEventData->u.pxPublishParams->pvData;
    xPublishParams.ulDataLength = pxEventData->u.pxPublishParams->ulDataLength;
    xPublishParams.usPacketIdentifier = (uint16_t)(pxEventData->xNotificationData.ulMessageIdentifier >> 16);
    xPublishParams.ulTimeoutTicks = pxEventData->xTicksToWait;
    MQTTReturnCode_t return_value_MQTT_Publish=MQTT_Publish(&pxConnection->xMQTTContext, &xPublishParams);
    if((signed int)return_value_MQTT_Publish == 0)
      xStatus = 1;

    else
      vLoggingPrintf("MQTT_Publish failed!\r\n");
  }

  else
    vLoggingPrintf("Could not get a buffer to store notification data. Too many parallel tasks!\r\n");
  if(xStatus == 1)
  {
    if((signed int)pxEventData->u.pxPublishParams->xQoS == 0)
      prvNotifyRequestingTask(&pxEventData->xNotificationData, /*enum*/eMQTTPUBSent, 1ul);

  }

  if(xStatus == 0)
  {
    prvNotifyRequestingTask(&pxEventData->xNotificationData, /*enum*/eMQTTPUBCouldNotBeSent, 0ul);
    if(!(pxNotificationData == ((MQTTNotificationData_t *)NULL)))
      pxNotificationData->xTaskToNotify = NULL;

  }

}

// prvInitiateMQTTSubscribe
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1445
static void prvInitiateMQTTSubscribe(MQTTEventData_t * const pxEventData)
{
  BaseType_t xStatus=0;
  MQTTNotificationData_t *pxNotificationData;
  MQTTSubscribeParams_t xSubscribeParams;
  MQTTBrokerConnection_t *pxConnection=&xMQTTConnections[(signed long long int)pxEventData->uxBrokerNumber];
  pxNotificationData=prvStoreNotificationData(pxConnection, pxEventData);
  if(!(pxNotificationData == ((MQTTNotificationData_t *)NULL)))
  {
    xSubscribeParams.pucTopic = pxEventData->u.pxSubscribeParams->pucTopic;
    xSubscribeParams.usTopicLength = pxEventData->u.pxSubscribeParams->usTopicLength;
    xSubscribeParams.xQos = pxEventData->u.pxSubscribeParams->xQoS;
    xSubscribeParams.usPacketIdentifier = (uint16_t)(pxEventData->xNotificationData.ulMessageIdentifier >> 16);
    xSubscribeParams.ulTimeoutTicks = pxEventData->xTicksToWait;
    xSubscribeParams.pvPublishCallbackContext = pxEventData->u.pxSubscribeParams->pvPublishCallbackContext;
    xSubscribeParams.pxPublishCallback = pxEventData->u.pxSubscribeParams->pxPublishCallback;
    MQTTReturnCode_t return_value_MQTT_Subscribe=MQTT_Subscribe(&pxConnection->xMQTTContext, &xSubscribeParams);
    if((signed int)return_value_MQTT_Subscribe == 0)
      xStatus = 1;

    else
      vLoggingPrintf("MQTT_Subscribe failed!\r\n");
  }

  else
    vLoggingPrintf("Could not get a buffer to store notification data. Too many parallel tasks!\r\n");
  if(xStatus == 0)
  {
    prvNotifyRequestingTask(&pxEventData->xNotificationData, /*enum*/eMQTTSUBCouldNotBeSent, 0ul);
    if(!(pxNotificationData == ((MQTTNotificationData_t *)NULL)))
      pxNotificationData->xTaskToNotify = NULL;

  }

}

// prvInitiateMQTTUnSubscribe
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1500
static void prvInitiateMQTTUnSubscribe(MQTTEventData_t * const pxEventData)
{
  BaseType_t xStatus=0;
  MQTTNotificationData_t *pxNotificationData;
  MQTTUnsubscribeParams_t xUnsubscribeParams;
  MQTTBrokerConnection_t *pxConnection=&xMQTTConnections[(signed long long int)pxEventData->uxBrokerNumber];
  pxNotificationData=prvStoreNotificationData(pxConnection, pxEventData);
  if(!(pxNotificationData == ((MQTTNotificationData_t *)NULL)))
  {
    xUnsubscribeParams.pucTopic = pxEventData->u.pxUnsubscribeParams->pucTopic;
    xUnsubscribeParams.usTopicLength = pxEventData->u.pxUnsubscribeParams->usTopicLength;
    xUnsubscribeParams.usPacketIdentifier = (uint16_t)(pxEventData->xNotificationData.ulMessageIdentifier >> 16);
    xUnsubscribeParams.ulTimeoutTicks = pxEventData->xTicksToWait;
    MQTTReturnCode_t return_value_MQTT_Unsubscribe=MQTT_Unsubscribe(&pxConnection->xMQTTContext, &xUnsubscribeParams);
    if((signed int)return_value_MQTT_Unsubscribe == 0)
      xStatus = 1;

    else
      vLoggingPrintf("MQTT_Unsubscribe failed!\r\n");
  }

  else
    vLoggingPrintf("Could not get a buffer to store notification data. Too many parallel tasks!\r\n");
  if(xStatus == 0)
  {
    prvNotifyRequestingTask(&pxEventData->xNotificationData, /*enum*/eMQTTUNSUBCouldNotBeSent, 0ul);
    if(!(pxNotificationData == ((MQTTNotificationData_t *)NULL)))
      pxNotificationData->xTaskToNotify = NULL;

  }

}

// prvInsertBlockIntoFreeList
// file ..\..\..\..\lib\FreeRTOS\portable\MemMang\heap_4.c line 377
static void prvInsertBlockIntoFreeList(BlockLink_t *pxBlockToInsert)
{
  BlockLink_t *pxIterator;
  uint8_t *puc;
  pxIterator = &xStart;
  for( ; !(pxIterator->pxNextFreeBlock >= pxBlockToInsert); pxIterator = pxIterator->pxNextFreeBlock)
    ;
  puc = (uint8_t *)pxIterator;
  if(puc + (signed long long int)pxIterator->xBlockSize == (uint8_t *)pxBlockToInsert)
  {
    pxIterator->xBlockSize = pxIterator->xBlockSize + pxBlockToInsert->xBlockSize;
    pxBlockToInsert = pxIterator;
  }

  puc = (uint8_t *)pxBlockToInsert;
  if(puc + (signed long long int)pxBlockToInsert->xBlockSize == (uint8_t *)pxIterator->pxNextFreeBlock)
  {
    if(!(pxIterator->pxNextFreeBlock == pxEnd))
    {
      pxBlockToInsert->xBlockSize = pxBlockToInsert->xBlockSize + pxIterator->pxNextFreeBlock->xBlockSize;
      pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    }

    else
      pxBlockToInsert->pxNextFreeBlock = pxEnd;
  }

  else
    pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
  if(!(pxIterator == pxBlockToInsert))
    pxIterator->pxNextFreeBlock = pxBlockToInsert;

}

// prvInsertTimerInActiveList
// file ..\..\..\..\lib\FreeRTOS\timers.c line 647
static BaseType_t prvInsertTimerInActiveList(Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime)
{
  BaseType_t xProcessTimerNow=0;
  (&pxTimer->xTimerListItem)->xItemValue = xNextExpiryTime;
  (&pxTimer->xTimerListItem)->pvOwner = (void *)pxTimer;
  if(xTimeNow >= xNextExpiryTime)
  {
    if(xTimeNow + -xCommandTime >= pxTimer->xTimerPeriodInTicks)
      xProcessTimerNow = 1;

    else
      vListInsert(pxOverflowTimerList, &pxTimer->xTimerListItem);
  }

  else
    if(xNextExpiryTime >= xCommandTime && !(xTimeNow >= xCommandTime))
      xProcessTimerNow = 1;

    else
      vListInsert(pxCurrentTimerList, &pxTimer->xTimerListItem);
  return xProcessTimerNow;
}

// prvInterruptSimulatorTask
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 500
static void prvInterruptSimulatorTask(void *pvParameters)
{
  struct pcap_pkthdr xHeader;
  const uint8_t *pucPacketData;
  uint8_t ucRecvBuffer[1214ll];
  NetworkBufferDescriptor_t *pxNetworkBuffer;
  IPStackEvent_t xRxEvent={ .eEventType=/*enum*/eNetworkRxEvent, .pvData=NULL };
  eFrameProcessingResult_t eResult;
  (void)pvParameters;
  while((_Bool)1)
  {
    size_t return_value_uxStreamBufferGetSize=uxStreamBufferGetSize$link2(xRecvBuffer);
    if(return_value_uxStreamBufferGetSize >= 17ull)
    {
      uxStreamBufferGet(xRecvBuffer, 0ull, (uint8_t *)&xHeader, sizeof(struct pcap_pkthdr) /*16ull*/ , 0);
      uxStreamBufferGet(xRecvBuffer, 0ull, (uint8_t *)ucRecvBuffer, (size_t)xHeader.len, 0);
      pucPacketData = ucRecvBuffer;
      static struct pcap_pkthdr *pxHeader;
      pxHeader = &xHeader;
      if((unsigned long long int)pxHeader->len >= sizeof(EthernetHeader_t) /*14ull*/ )
        eResult=eConsiderFrameForProcessing(pucPacketData);

      else
        eResult = /*enum*/eReleaseBuffer;
      if((signed int)eResult == 1)
      {
        if(!(pxHeader->len >= 1223ul))
        {
          pxNetworkBuffer=pxGetNetworkBufferWithDescriptor((size_t)pxHeader->len, 0u);
          if(!(pxNetworkBuffer == ((NetworkBufferDescriptor_t *)NULL)))
          {
            memcpy((void *)pxNetworkBuffer->pucEthernetBuffer, (const void *)pucPacketData, (size_t)pxHeader->len);
            pxNetworkBuffer->xDataLength = (size_t)pxHeader->len;
            if(!(pxNetworkBuffer == ((NetworkBufferDescriptor_t *)NULL)))
            {
              xRxEvent.pvData = (void *)pxNetworkBuffer;
              BaseType_t return_value_xSendEventStructToIPTask=xSendEventStructToIPTask(&xRxEvent, 0u);
              if(return_value_xSendEventStructToIPTask == 0)
                vReleaseNetworkBufferAndDescriptor(pxNetworkBuffer);

            }

          }

        }

      }

    }

    else
      vTaskDelay(20u / (1000u / 1000u));
  }
}

// prvInvokeCallback
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1775
static MQTTBool_t prvInvokeCallback(MQTTContext_t *pxMQTTContext, MQTTEventCallbackParams_t *pxEventCallbackParams)
{
  MQTTBool_t xBufferOwnershipTaken=/*enum*/eMQTTFalse;
  MQTTBool_t xSubscriptionCallbackInvoked=/*enum*/eMQTTFalse;
  if((signed int)pxEventCallbackParams->xEventType == 0)
    xBufferOwnershipTaken=prvInvokeSubscriptionCallbacks(pxMQTTContext, &pxEventCallbackParams->u.xPublishData, &xSubscriptionCallbackInvoked);

  if((signed int)xSubscriptionCallbackInvoked == 0)
  {
    if(!(pxMQTTContext->pxCallback == ((MQTTEventCallback_t)NULL)))
      xBufferOwnershipTaken=pxMQTTContext->pxCallback(pxMQTTContext->pvCallbackContext, pxEventCallbackParams);

  }

  return xBufferOwnershipTaken;
}

// prvInvokeSubscriptionCallbacks
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 2133
static MQTTBool_t prvInvokeSubscriptionCallbacks(MQTTContext_t *pxMQTTContext, const MQTTPublishData_t *pxPublishData, MQTTBool_t *pxSubscriptionCallbackInvoked)
{
  MQTTBool_t xBufferOwnershipTaken=/*enum*/eMQTTFalse;
  MQTTSubscription_t *pxSubscription;
  uint32_t x;
  *pxSubscriptionCallbackInvoked = /*enum*/eMQTTFalse;
  x = 0u;
  for( ; !(x >= 8u); x = x + 1u)
    if((signed int)pxMQTTContext->xSubscriptionManager.xSubscriptions[(signed long long int)x].xInUse == 1)
    {
      if((signed int)pxMQTTContext->xSubscriptionManager.xSubscriptions[(signed long long int)x].xTopicFilterType == 1)
      {
        if(pxMQTTContext->xSubscriptionManager.xSubscriptions[(signed long long int)x].usTopicFilterLength == pxPublishData->usTopicLength)
        {
          signed int return_value_memcmp=memcmp((const void *)pxMQTTContext->xSubscriptionManager.xSubscriptions[(signed long long int)x].ucTopicFilter, (const void *)pxPublishData->pucTopic, (size_t)pxPublishData->usTopicLength);
          if(return_value_memcmp == 0)
          {
            pxSubscription = &pxMQTTContext->xSubscriptionManager.xSubscriptions[(signed long long int)x];
            if(!(pxSubscription->pxPublishCallback == ((MQTTPublishCallback_t)NULL)))
            {
              *pxSubscriptionCallbackInvoked = /*enum*/eMQTTTrue;
              xBufferOwnershipTaken=pxSubscription->pxPublishCallback(pxSubscription->pvPublishCallbackContext, pxPublishData);
              if((signed int)xBufferOwnershipTaken == 1)
                break;

            }

          }

        }

      }

    }

  if((signed int)xBufferOwnershipTaken == 0)
  {
    x = 0u;
    for( ; !(x >= 8u); x = x + 1u)
      if((signed int)pxMQTTContext->xSubscriptionManager.xSubscriptions[(signed long long int)x].xInUse == 1)
      {
        if((signed int)pxMQTTContext->xSubscriptionManager.xSubscriptions[(signed long long int)x].xTopicFilterType == 2)
        {
          MQTTBool_t return_value_prvDoesTopicMatchTopicFilter=prvDoesTopicMatchTopicFilter(pxPublishData->pucTopic, pxPublishData->usTopicLength, pxMQTTContext->xSubscriptionManager.xSubscriptions[(signed long long int)x].ucTopicFilter, pxMQTTContext->xSubscriptionManager.xSubscriptions[(signed long long int)x].usTopicFilterLength);
          if((signed int)return_value_prvDoesTopicMatchTopicFilter == 1)
          {
            pxSubscription = &pxMQTTContext->xSubscriptionManager.xSubscriptions[(signed long long int)x];
            if(!(pxSubscription->pxPublishCallback == ((MQTTPublishCallback_t)NULL)))
            {
              *pxSubscriptionCallbackInvoked = /*enum*/eMQTTTrue;
              xBufferOwnershipTaken=pxSubscription->pxPublishCallback(pxSubscription->pvPublishCallbackContext, pxPublishData);
              if((signed int)xBufferOwnershipTaken == 1)
                break;

            }

          }

        }

      }

  }

  return xBufferOwnershipTaken;
}

// prvIsIPaddress
// file ..\..\..\..\lib\greengrass\aws_helper_secure_connect.c line 340
uint32_t prvIsIPaddress(const char *pcIPAddress)
{
  const uint32_t ulDecimalBase=10u;
  uint8_t ucOctet[4ll];
  const char *pcPointerOnEntering;
  uint32_t ulReturn=0ul;
  uint32_t ulValue;
  UBaseType_t uxOctetNumber;
  BaseType_t xResult=1;
  uxOctetNumber = 0u;
  for( ; !(uxOctetNumber >= 4u); uxOctetNumber = uxOctetNumber + 1ul)
  {
    ulValue = 0ul;
    pcPointerOnEntering = pcIPAddress;
    for( ; (signed int)*pcIPAddress >= 48; pcIPAddress = pcIPAddress + 1ll)
    {
      if((signed int)*pcIPAddress >= 58)
        break;

      ulValue = ulValue * ulDecimalBase;
      ulValue = ulValue + ((uint32_t)*pcIPAddress - 48u);
    }
    if(pcIPAddress == pcPointerOnEntering)
      xResult = 0;

    if(ulValue >= 256ul)
      xResult = 0;

    else
    {
      ucOctet[(signed long long int)uxOctetNumber] = (uint8_t)ulValue;
      if(!(uxOctetNumber >= 3u))
      {
        if(!((signed int)*pcIPAddress == 46))
          xResult = 0;

        else
          pcIPAddress = pcIPAddress + 1ll;
      }

    }
    if(xResult == 0)
      break;

  }
  if(!(*pcIPAddress == 0))
    xResult = 0;

  if(!(uxOctetNumber == 4u))
    xResult = 0;

  if(xResult == 1)
    ulReturn = (uint32_t)ucOctet[3ll] << 24ul | (uint32_t)ucOctet[2ll] << 16ul | (uint32_t)ucOctet[1ll] << 8ul | (uint32_t)ucOctet[0ll];

  return ulReturn;
}

// prvIsIPvalid
// file ..\..\..\..\lib\greengrass\aws_greengrass_discovery.c line 791
static BaseType_t prvIsIPvalid(const char *pcIP, uint32_t ulIPlength)
{
  BaseType_t xStatus;
  (void)ulIPlength;
  signed int return_value_strcmp=strcmp("127.0.0.1", pcIP);
  if(!(return_value_strcmp == 0))
    xStatus = 1;

  else
    xStatus = 0;
  return xStatus;
}

// prvIsMsgFromJobTopic
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 826
static uint8_t prvIsMsgFromJobTopic(MQTTPublishData_t xMsgMetaData)
{
  const char *pszTopic=acOTA_GetNextAccepted_Topic;
  uint16_t iLen;
  size_t return_value_strlen=strlen(pszTopic);
  iLen = (uint16_t)return_value_strlen;
  _Bool tmp_if_expr$0;
  signed int return_value_memcmp$0;
  if(iLen == xMsgMetaData.usTopicLength)
  {
    return_value_memcmp$0=memcmp((const void *)pszTopic, (const void *)xMsgMetaData.pucTopic, (size_t)iLen);
    tmp_if_expr$0 = return_value_memcmp$0 == 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$0 = (_Bool)0;
  signed int return_value_memcmp;
  if(tmp_if_expr$0)
    return 1;

  else
  {
    pszTopic = acOTA_NotifyNext_Topic;
    size_t return_value_strlen$0=strlen(pszTopic);
    iLen = (uint16_t)return_value_strlen$0;
    _Bool tmp_if_expr;
    if(iLen == xMsgMetaData.usTopicLength)
    {
      return_value_memcmp=memcmp((const void *)pszTopic, (const void *)xMsgMetaData.pucTopic, (size_t)iLen);
      tmp_if_expr = return_value_memcmp == 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr = (_Bool)0;
    if(tmp_if_expr)
      return 1;

    else
      return 0;
  }
}

// prvIsQueueEmpty
// file ..\..\..\..\lib\FreeRTOS\queue.c line 2258
static BaseType_t prvIsQueueEmpty(const Queue_t *pxQueue)
{
  BaseType_t xReturn;
  vPortEnterCritical();
  if(pxQueue->uxMessagesWaiting == 0ul)
    xReturn = 1;

  else
    xReturn = 0;
  vPortExitCritical();
  return xReturn;
}

// prvIsQueueFull
// file ..\..\..\..\lib\FreeRTOS\queue.c line 2297
static BaseType_t prvIsQueueFull(const Queue_t *pxQueue)
{
  BaseType_t xReturn;
  vPortEnterCritical();
  if(pxQueue->uxMessagesWaiting == pxQueue->uxLength)
    xReturn = 1;

  else
    xReturn = 0;
  vPortExitCritical();
  return xReturn;
}

// prvIsStringEqual
// file ..\..\..\common\shadow\aws_shadow_lightbulb_on_off.c line 205
static BaseType_t prvIsStringEqual(const char * const pcJson, const jsmntok_t * const pxTok, const char * const pcString)
{
  uint32_t ulStringSize=(uint32_t)pxTok->end - (uint32_t)pxTok->start;
  BaseType_t xStatus=0;
  signed int return_value_strncmp;
  if((signed int)pxTok->type == 3)
  {
    if((signed int)pcString[(signed long long int)ulStringSize] == 0)
    {
      return_value_strncmp=strncmp(pcJson + (signed long long int)pxTok->start, pcString, (size_t)ulStringSize);
      if(return_value_strncmp == 0)
        xStatus = 1;

    }

  }

  return xStatus;
}

// prvIsTimeElapsed
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1063
static MQTTBool_t prvIsTimeElapsed(uint64_t *pxRecordedTickCount, uint64_t xCurrentTickCount, uint32_t *pulRemainingTicks)
{
  uint32_t ulElapsedTicks;
  MQTTBool_t xTimeElasped=/*enum*/eMQTTFalse;
  if(*pxRecordedTickCount == 0ull)
    *pxRecordedTickCount = xCurrentTickCount;

  else
  {
    ulElapsedTicks = (uint32_t)(xCurrentTickCount - *pxRecordedTickCount);
    *pxRecordedTickCount = xCurrentTickCount;
    if(ulElapsedTicks >= *pulRemainingTicks)
    {
      xTimeElasped = /*enum*/eMQTTTrue;
      *pulRemainingTicks = 0u;
    }

    else
      *pulRemainingTicks = *pulRemainingTicks - ulElapsedTicks;
  }
  return xTimeElasped;
}

// prvListTasksWithinSingleList
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3666
static UBaseType_t prvListTasksWithinSingleList(TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState)
{
  TCB_t *pxNextTCB;
  TCB_t *pxFirstTCB;
  UBaseType_t uxTask=0ul;
  if(pxList->uxNumberOfItems >= 1ul)
  {
    List_t * const prvListTasksWithinSingleList$$1$$1$$1$$pxConstList=pxList;
    prvListTasksWithinSingleList$$1$$1$$1$$pxConstList->pxIndex = prvListTasksWithinSingleList$$1$$1$$1$$pxConstList->pxIndex->pxNext;
    if((void *)prvListTasksWithinSingleList$$1$$1$$1$$pxConstList->pxIndex == (void *)&prvListTasksWithinSingleList$$1$$1$$1$$pxConstList->xListEnd)
      prvListTasksWithinSingleList$$1$$1$$1$$pxConstList->pxIndex = prvListTasksWithinSingleList$$1$$1$$1$$pxConstList->pxIndex->pxNext;

    pxFirstTCB = (TCB_t *)prvListTasksWithinSingleList$$1$$1$$1$$pxConstList->pxIndex->pvOwner;
    do
    {
      List_t * const pxConstList=pxList;
      pxConstList->pxIndex = pxConstList->pxIndex->pxNext;
      if((void *)pxConstList->pxIndex == (void *)&pxConstList->xListEnd)
        pxConstList->pxIndex = pxConstList->pxIndex->pxNext;

      pxNextTCB = (TCB_t *)pxConstList->pxIndex->pvOwner;
      vTaskGetInfo((TaskHandle_t)pxNextTCB, &pxTaskStatusArray[(signed long long int)uxTask], 1, eState);
      uxTask = uxTask + 1ul;
    }
    while(!(pxNextTCB == pxFirstTCB));
  }

  return uxTask;
}

// prvLoadAndInitializeDefaultCertificateAndKey
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 309
static CK_RV prvLoadAndInitializeDefaultCertificateAndKey(P11SessionPtr_t pxSession)
{
  CK_RV xResult=0ul;
  uint8_t *pucCertificateData=((uint8_t *)NULL);
  uint32_t ulCertificateDataLength=0u;
  BaseType_t xFreeCertificate=0;
  uint8_t *pucKeyData=((uint8_t *)NULL);
  uint32_t ulKeyDataLength=0u;
  BaseType_t xFreeKey=0;
  BaseType_t return_value_PKCS11_PAL_ReadFile=PKCS11_PAL_ReadFile("FreeRTOS_P11_Certificate.dat", &pucCertificateData, &ulCertificateDataLength);
  if(return_value_PKCS11_PAL_ReadFile == 0)
  {
    pucCertificateData = (uint8_t *)clientcredentialCLIENT_CERTIFICATE_PEM;
    ulCertificateDataLength = clientcredentialCLIENT_CERTIFICATE_LENGTH;
  }

  else
    xFreeCertificate = 1;
  BaseType_t return_value_PKCS11_PAL_ReadFile$0=PKCS11_PAL_ReadFile("FreeRTOS_P11_Key.dat", &pucKeyData, &ulKeyDataLength);
  if(return_value_PKCS11_PAL_ReadFile$0 == 0)
  {
    pucKeyData = (uint8_t *)clientcredentialCLIENT_PRIVATE_KEY_PEM;
    ulKeyDataLength = clientcredentialCLIENT_PRIVATE_KEY_LENGTH;
  }

  else
    xFreeKey = 1;
  xResult=prvInitializeKey(pxSession, (const char *)pucKeyData, ulKeyDataLength, (const char *)pucCertificateData, ulCertificateDataLength);
  mbedtls_entropy_update_manual(&pxSession->xMbedEntropyContext, pucKeyData, (size_t)ulKeyDataLength);
  mbedtls_entropy_update_manual(&pxSession->xMbedEntropyContext, pucCertificateData, (size_t)ulCertificateDataLength);
  if(xFreeCertificate == 1 && !(pucCertificateData == ((uint8_t *)NULL)))
    PKCS11_PAL_ReleaseFileData(pucCertificateData, ulCertificateDataLength);

  if(xFreeKey == 1 && !(pucKeyData == ((uint8_t *)NULL)))
    PKCS11_PAL_ReleaseFileData(pucKeyData, ulKeyDataLength);

  return xResult;
}

// prvLogToFile
// file ..\common\application_code\aws_demo_logging.c line 575
static void prvLogToFile(const char *pcMessage, size_t xLength)
{
  if(pxLoggingFileHandle == ((FILE *)NULL))
    pxLoggingFileHandle=fopen(pcLogFileName, "a");

  if(!(pxLoggingFileHandle == ((FILE *)NULL)))
  {
    fwrite((const void *)pcMessage, 1ull, xLength, pxLoggingFileHandle);
    ulSizeOfLoggingFile = ulSizeOfLoggingFile + xLength;
    if(ulSizeOfLoggingFile >= 41943041ull)
    {
      prvFileClose();
      signed int return_value__access=_access(pcFullLogFileName, 00);
      if(return_value__access == 0)
        remove(pcFullLogFileName);

      rename(pcLogFileName, pcFullLogFileName);
      ulSizeOfLoggingFile = 0ull;
    }

  }

}

// prvLoggingFlushBuffer
// file ..\common\application_code\aws_demo_logging.c line 476
static void prvLoggingFlushBuffer(void)
{
  size_t xLength;
  char cPrintString[255ll];
  size_t return_value_uxStreamBufferGetSize;
  BaseType_t return_value_FreeRTOS_IsNetworkUp;
  do
  {
    return_value_uxStreamBufferGetSize=uxStreamBufferGetSize$link3(xLogStreamBuffer);
    if(!(return_value_uxStreamBufferGetSize >= 9ull))
      break;

    memset((void *)cPrintString, 0x0, 255ull);
    uxStreamBufferGet(xLogStreamBuffer, 0ull, (uint8_t *)&xLength, sizeof(size_t) /*8ull*/ , 0);
    uxStreamBufferGet(xLogStreamBuffer, 0ull, (uint8_t *)cPrintString, xLength, 0);
    _Bool tmp_if_expr;
    if(!(xStdoutLoggingUsed == 0))
      tmp_if_expr = (_Bool)1;

    else
    {
      return_value_FreeRTOS_IsNetworkUp=FreeRTOS_IsNetworkUp();
      tmp_if_expr = return_value_FreeRTOS_IsNetworkUp == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr)
    {
      printf("%s", (const void *)cPrintString);
      FILE *return_value___acrt_iob_func=__acrt_iob_func(1u);
      fflush(return_value___acrt_iob_func);
    }

    if(!(xDiskFileLoggingUsed == 0))
      prvLogToFile(cPrintString, xLength);

  }
  while((_Bool)1);
  prvFileClose();
}

// prvMQTTCallback
// file ..\..\..\common\mqtt\aws_hello_world.c line 380
static MQTTBool_t prvMQTTCallback(void *pvUserData, const MQTTPublishData_t * const pxPublishParameters)
{
  char cBuffer[24ll];
  uint32_t ulBytesToCopy=(uint32_t)((20 + 4) - 1);
  (void)pvUserData;
  size_t return_value_strlen=strlen((const char *)(const uint8_t *)"freertos/demos/echo");
  if(!((size_t)pxPublishParameters->usTopicLength == return_value_strlen))
    vAssertCalled("..\\..\\..\\common\\mqtt\\aws_hello_world.c", 392u);

  signed int return_value_memcmp=memcmp((const void *)pxPublishParameters->pucTopic, (const void *)(const uint8_t *)"freertos/demos/echo", (size_t)pxPublishParameters->usTopicLength);
  if(!(return_value_memcmp == 0))
    vAssertCalled("..\\..\\..\\common\\mqtt\\aws_hello_world.c", 393u);

  if(ulBytesToCopy >= pxPublishParameters->ulDataLength)
  {
    ulBytesToCopy = pxPublishParameters->ulDataLength;
    memset((void *)cBuffer, 0x0, sizeof(char [24ll]) /*24ull*/ );
    memcpy((void *)cBuffer, pxPublishParameters->pvData, (size_t)ulBytesToCopy);
    char *return_value_strstr=strstr(cBuffer, (const char *)" ACK");
    if(return_value_strstr == ((char *)NULL))
      xStreamBufferSend((StreamBufferHandle_t)xEchoMessageBuffer, (const void *)cBuffer, (size_t)ulBytesToCopy + 1ull, 0u);

  }

  else
    vLoggingPrintf("[WARN]: Dropping received message as it does not fit in the buffer.\r\n");
  return /*enum*/eMQTTFalse;
}

// prvMQTTCallback$link1
// file ..\..\..\common\mqtt\aws_subscribe_publish_loop.c line 217
static BaseType_t prvMQTTCallback$link1(void *pvUserData$link1, const MQTTAgentCallbackParams_t * const pxCallbackParams)
{
  BaseType_t xTakeOwnership=0;
  (void)pvUserData$link1;
  switch((signed int)pxCallbackParams->xMQTTEvent)
  {
    case 1:
    {
      vLoggingPrintf("MQTT Client got disconnected.\r\n");
      break;
    }
    case 0:
      vLoggingPrintf("WARN: Should not have been called as we are registering topic specific callbacks.\r\n");
  }
  return xTakeOwnership;
}

// prvMQTTClientSocketWakeupCallback
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1026
static void prvMQTTClientSocketWakeupCallback(Socket_t pxSocket)
{
  const TickType_t xTicksToWait=(TickType_t)((20u * 1000u) / 1000u);
  MQTTEventData_t xEventData;
  (void)pxSocket;
  if(xMQTTTaskHandle == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\mqtt\\aws_mqtt_agent.c", 1037u);

  UBaseType_t return_value_uxQueueMessagesWaiting=uxQueueMessagesWaiting(xCommandQueue);
  if(return_value_uxQueueMessagesWaiting == 0ul)
  {
    memset((void *)&xEventData, 0x0, sizeof(MQTTEventData_t) /*48ull*/ );
    xEventData.xEventType = /*enum*/eMQTTServiceSocket;
    vLoggingPrintf("Socket sending wakeup to MQTT task.\r\n");
    xQueueGenericSend(xCommandQueue, (const void *)&xEventData, xTicksToWait, 0);
  }

}

// prvMQTTConnect
// file ..\..\..\common\greengrass_connectivity\aws_greengrass_discovery_demo.c line 150
static BaseType_t prvMQTTConnect(GGD_HostAddressData_t *pxHostAddressData)
{
  MQTTAgentConnectParams_t xConnectParams;
  BaseType_t xResult=1;
  xConnectParams.pucClientId = (const uint8_t *)"Paste AWS IoT Thing name here.";
  size_t return_value_strlen=strlen("Paste AWS IoT Thing name here.");
  xConnectParams.usClientIdLength = (uint16_t)return_value_strlen;
  xConnectParams.pcURL = pxHostAddressData->pcHostAddress;
  xConnectParams.usPort = 8883;
  xConnectParams.xFlags = 0x2 | 0x1;
  xConnectParams.xURLIsIPAddress = 1;
  xConnectParams.pcCertificate = pxHostAddressData->pcCertificate;
  xConnectParams.ulCertificateSize = pxHostAddressData->ulCertificateSize;
  xConnectParams.pvUserData = NULL;
  xConnectParams.pxCallback = ((MQTTAgentCallback_t)NULL);
  xConnectParams.xSecuredConnection = 1;
  MQTTAgentReturnCode_t return_value_MQTT_AGENT_Connect=MQTT_AGENT_Connect(xMQTTClientHandle, &xConnectParams, xMaxCommandTime);
  if(!((signed int)return_value_MQTT_AGENT_Connect == 0))
  {
    vLoggingPrintf("ERROR: Could not connect to the Broker.\r\n");
    xResult = 0;
  }

  return xResult;
}

// prvMQTTConnectAndPublishTask
// file ..\..\..\common\mqtt\aws_hello_world.c line 436
static void prvMQTTConnectAndPublishTask(void *pvParameters)
{
  BaseType_t x;
  BaseType_t xReturned;
  const TickType_t xFiveSeconds=(TickType_t)((5000ul * 1000u) / 1000u);
  const BaseType_t xIterationsInAMinute=60 / 5;
  TaskHandle_t xEchoingTask=NULL;
  (void)pvParameters;
  xReturned=prvCreateClientAndConnectToBroker();
  if(xReturned == 1)
  {
    xReturned=xTaskCreate(prvMessageEchoingTask, "Echoing", (const uint16_t)(60 * 2), NULL, 0u, &xEchoingTask);
    if(!(xReturned == 1))
      vLoggingPrintf("MQTT echoing task could not be created - out of heap space?\r\n");

  }

  else
    vLoggingPrintf("MQTT echo test could not connect to broker.\r\n");
  if(xReturned == 1)
  {
    vLoggingPrintf("MQTT echo test echoing task created.\r\n");
    xReturned=prvSubscribe();
  }

  if(xReturned == 1)
  {
    x = 0;
    for( ; !(x >= xIterationsInAMinute); x = x + 1l)
    {
      prvPublishNextMessage(x);
      vTaskDelay(xFiveSeconds);
    }
  }

  MQTT_AGENT_Disconnect(xMQTTHandle, (TickType_t)((300u * 1000u) / 1000u));
  vLoggingPrintf("MQTT echo demo finished.\r\n");
  vLoggingPrintf("----Demo finished----\r\n");
  vStreamBufferDelete((StreamBufferHandle_t)xEchoMessageBuffer);
  vTaskDelete(xEchoingTask);
  vTaskDelete(NULL);
}

// prvMQTTEventCallback
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 674
static MQTTBool_t prvMQTTEventCallback(void *pvCallbackContext, const MQTTEventCallbackParams_t * const pxParams)
{
  MQTTBool_t xReturn=/*enum*/eMQTTFalse;
  MQTTBrokerConnection_t *pxConnection;
  UBaseType_t uxBrokerNumber=(UBaseType_t)pvCallbackContext;
  if(uxBrokerNumber >= 4ul)
    vAssertCalled("..\\..\\..\\..\\lib\\mqtt\\aws_mqtt_agent.c", 682u);

  pxConnection = &xMQTTConnections[(signed long long int)uxBrokerNumber];
  BaseType_t return_value_prvProcessReceivedPublish;
  switch((signed int)pxParams->xEventType)
  {
    case 1:
    {
      prvProcessReceivedCONNACK(pxConnection, pxParams);
      break;
    }
    case 5:
    {
      prvProcessReceivedSUBACK(pxConnection, pxParams);
      break;
    }
    case 7:
    {
      prvProcessReceivedUNSUBACK(pxConnection, pxParams);
      break;
    }
    case 3:
    {
      prvProcessReceivedPUBACK(pxConnection, pxParams);
      break;
    }
    case 0:
    {
      return_value_prvProcessReceivedPublish=prvProcessReceivedPublish(pxConnection, pxParams);
      if(return_value_prvProcessReceivedPublish == 1)
        xReturn = /*enum*/eMQTTTrue;

      break;
    }
    case 11:
    {
      prvProcessReceivedTimeout(pxConnection, pxParams);
      break;
    }
    case 9:
    {
      prvProcessReceivedDisconnect(pxConnection, pxParams);
      break;
    }
    case 10:
    {
      vLoggingPrintf("[WARN] MQTT Agent dropped a packet. No buffer available.\r\n");
      vLoggingPrintf("Consider adjusting parameters in aws_bufferpool_config.h.\r\n");
      break;
    }
    default:
      ;
  }
  return xReturn;
}

// prvMQTTGetTicks
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 738
static void prvMQTTGetTicks(uint64_t *pxCurrentTickCount)
{
  TimeOut_t xTimeout;
  vTaskSetTimeOutState(&xTimeout);
  *pxCurrentTickCount = (uint64_t)xTimeout.xOverflowCount;
  *pxCurrentTickCount = *pxCurrentTickCount << 32;
  *pxCurrentTickCount = *pxCurrentTickCount | (uint64_t)xTimeout.xTimeOnEntering;
}

// prvMQTTSendCallback
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 616
static uint32_t prvMQTTSendCallback(void *pvSendContext, const uint8_t * const pucData, uint32_t ulDataLength)
{
  MQTTBrokerConnection_t *pxConnection;
  UBaseType_t uxBrokerNumber=(UBaseType_t)pvSendContext;
  int32_t lSendRetVal;
  uint32_t ulBytesSent=0u;
  TimeOut_t xTimestamp;
  TickType_t xTicksToWait=(TickType_t)((2000u * 1000u) / 1000u);
  if(uxBrokerNumber >= 4ul)
    vAssertCalled("..\\..\\..\\..\\lib\\mqtt\\aws_mqtt_agent.c", 628u);

  vTaskSetTimeOutState(&xTimestamp);
  pxConnection = &xMQTTConnections[(signed long long int)uxBrokerNumber];
  while(!(ulBytesSent >= ulDataLength))
  {
    BaseType_t return_value_xTaskCheckForTimeOut=xTaskCheckForTimeOut(&xTimestamp, &xTicksToWait);
    if(return_value_xTaskCheckForTimeOut == 1)
      break;

    lSendRetVal=SOCKETS_Send(pxConnection->xSocket, (const void *)&pucData[(signed long long int)ulBytesSent], (size_t)(ulDataLength - ulBytesSent), 0u);
    if(!(lSendRetVal >= 0))
    {
      if(!(lSendRetVal == -11))
        break;

    }

    else
      ulBytesSent = ulBytesSent + (uint32_t)lSendRetVal;
  }
  return ulBytesSent;
}

// prvMQTTStringPublishCallback
// file ..\..\..\common\mqtt\aws_subscribe_publish_loop.c line 241
static MQTTBool_t prvMQTTStringPublishCallback(void *pvCallbackContext, const MQTTPublishData_t * const pxPublishData)
{
  const char *pcReceivedString;
  const char *pcTopic;
  SubpubUserData_t *pxUserData;
  MQTTBool_t xTakeOwnership=/*enum*/eMQTTFalse;
  pxUserData = (SubpubUserData_t *)pvCallbackContext;
  vLoggingPrintf("Received %.*s on topic %.*s\r\n", pxPublishData->ulDataLength, (char *)pxPublishData->pvData, (size_t)pxPublishData->usTopicLength, (char *)pxPublishData->pucTopic);
  pcReceivedString = (char *)pxPublishData->pvData;
  pcTopic = (const char *)pxPublishData->pucTopic;
  size_t return_value_strlen$0=strlen(pxUserData->pcExpectedString);
  signed int return_value_strncmp$0=strncmp(pcReceivedString, pxUserData->pcExpectedString, return_value_strlen$0);
  if(return_value_strncmp$0 == 0)
  {
    size_t return_value_strlen=strlen(pxUserData->cTopic);
    signed int return_value_strncmp=strncmp(pcTopic, pxUserData->cTopic, return_value_strlen);
    if(return_value_strncmp == 0)
      pxUserData->xCallbackStatus = 1;

  }

  BaseType_t return_value_xQueueGenericSend=xQueueGenericSend((QueueHandle_t)pxUserData->xWakeUpSemaphore, NULL, 0u, 0);
  if(return_value_xQueueGenericSend == 0)
    pxUserData->xCallbackStatus = 0;

  if(!(pxUserData->xCallbackStatus == 1))
    vAssertCalled("..\\..\\..\\common\\mqtt\\aws_subscribe_publish_loop.c", 278u);

  return xTakeOwnership;
}

// prvMQTTTask
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1733
static void prvMQTTTask(void *pvParameters)
{
  MQTTEventData_t xMQTTCommand;
  TickType_t xNextTimeoutTicks=0u;
  (void)pvParameters;
  while((_Bool)1)
  {
    BaseType_t return_value_xQueueReceive=xQueueReceive(xCommandQueue, (void *)&xMQTTCommand, xNextTimeoutTicks);
    if(!(return_value_xQueueReceive == 0))
    {
      vLoggingPrintf("Received message %x from queue.\r\n", xMQTTCommand.xNotificationData.ulMessageIdentifier);
      if(xMQTTCommand.uxBrokerNumber >= 4ul)
        vAssertCalled("..\\..\\..\\..\\lib\\mqtt\\aws_mqtt_agent.c", 1751u);

      BaseType_t return_value_xTaskCheckForTimeOut=xTaskCheckForTimeOut(&xMQTTCommand.xEventCreationTimestamp, &xMQTTCommand.xTicksToWait);
      if(return_value_xTaskCheckForTimeOut == 1)
        prvNotifyRequestingTask(&xMQTTCommand.xNotificationData, /*enum*/eMQTTOperationTimedOut, 0ul);

      else
        switch((signed int)xMQTTCommand.xEventType)
        {
          case 1:
          {
            prvInitiateMQTTConnect(&xMQTTCommand);
            break;
          }
          case 2:
          {
            prvInitiateMQTTDisconnect(&xMQTTCommand);
            break;
          }
          case 3:
          {
            prvInitiateMQTTSubscribe(&xMQTTCommand);
            break;
          }
          case 4:
          {
            prvInitiateMQTTUnSubscribe(&xMQTTCommand);
            break;
          }
          case 5:
          {
            prvInitiateMQTTPublish(&xMQTTCommand);
            break;
          }
          default:
            vLoggingPrintf("Unknown request received on command queue.\r\n");
        }
    }

    xNextTimeoutTicks=prvManageConnections();
  }
}

// prvMQTTUint32PublishCallback
// file ..\..\..\common\mqtt\aws_subscribe_publish_loop.c line 285
static MQTTBool_t prvMQTTUint32PublishCallback(void *pvCallbackContext, const MQTTPublishData_t * const pxPublishData)
{
  const char *pcTopic;
  SubpubUserData_t *pxUserData;
  MQTTBool_t xTakeOwnership=/*enum*/eMQTTFalse;
  pxUserData = (SubpubUserData_t *)pvCallbackContext;
  signed int return_value_memcmp=memcmp((void *)&pxUserData->ulExpectedUint32, pxPublishData->pvData, sizeof(uint32_t) /*4ull*/ );
  if(return_value_memcmp == 0)
  {
    vLoggingPrintf("Received %u on topic %.*s\r\n", pxUserData->ulExpectedUint32, (size_t)pxPublishData->usTopicLength, (char *)pxPublishData->pucTopic);
    pcTopic = (char *)pxPublishData->pucTopic;
    size_t return_value_strlen=strlen(pxUserData->cTopic);
    signed int return_value_strncmp=strncmp(pcTopic, pxUserData->cTopic, return_value_strlen);
    if(return_value_strncmp == 0)
      pxUserData->xCallbackStatus = 1;

  }

  BaseType_t return_value_xQueueGenericSend=xQueueGenericSend((QueueHandle_t)pxUserData->xWakeUpSemaphore, NULL, 0u, 0);
  if(return_value_xQueueGenericSend == 0)
    pxUserData->xCallbackStatus = 0;

  if(!(pxUserData->xCallbackStatus == 1))
    vAssertCalled("..\\..\\..\\common\\mqtt\\aws_subscribe_publish_loop.c", 321u);

  return xTakeOwnership;
}

// prvManageConnections
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1256
static TickType_t prvManageConnections(void)
{
  UBaseType_t uxBrokerNumber;
  MQTTBrokerConnection_t *pxConnection;
  BaseType_t xAnyConnectedClient=0;
  int32_t lBytesReceived;
  TickType_t xNextMQTTPeriodicInvokeTicks;
  TickType_t xNextTimeoutTicks=0xFFFFFFFFul;
  uint64_t prvManageConnections$$1$$xTickCount=0ull;
  uxBrokerNumber = 0ul;
  for( ; !(uxBrokerNumber >= 4ul); uxBrokerNumber = uxBrokerNumber + 1ul)
  {
    pxConnection = &xMQTTConnections[(signed long long int)uxBrokerNumber];
    if(!(pxConnection->xSocket == (Socket_t)4294967295u))
    {
      lBytesReceived=SOCKETS_Recv(pxConnection->xSocket, (void *)pxConnection->ucRxBuffer, (size_t)(1024 + 128), 0u);
      if(lBytesReceived >= 1)
      {
        MQTT_ParseReceivedData(&pxConnection->xMQTTContext, pxConnection->ucRxBuffer, (size_t)lBytesReceived);
        xNextTimeoutTicks = 0u;
      }

      else
        if(!(lBytesReceived >= 0))
        {
          if(!(lBytesReceived == -11))
            MQTT_Disconnect(&pxConnection->xMQTTContext);

        }

    }

    if(xAnyConnectedClient == 0)
    {
      if(!(pxConnection->xSocket == (Socket_t)4294967295u))
        xAnyConnectedClient = 1;

    }

    prvMQTTGetTicks(&prvManageConnections$$1$$xTickCount);
    uint32_t return_value_MQTT_Periodic=MQTT_Periodic(&pxConnection->xMQTTContext, prvManageConnections$$1$$xTickCount);
    xNextMQTTPeriodicInvokeTicks = (TickType_t)return_value_MQTT_Periodic;
    xNextTimeoutTicks = xNextTimeoutTicks < xNextMQTTPeriodicInvokeTicks ? xNextTimeoutTicks : xNextMQTTPeriodicInvokeTicks;
  }
  if(xAnyConnectedClient == 1)
    xNextTimeoutTicks = xNextTimeoutTicks < (TickType_t)~0u ? xNextTimeoutTicks : (TickType_t)~0u;

  return xNextTimeoutTicks;
}

// prvMarkObjectAsUsed
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2411
void prvMarkObjectAsUsed(traceObjectClass objectclass, traceHandle handle)
{
  uint16_t idx=uiIndexOfObject(handle, objectclass);
  RecorderDataPtr->ObjectPropertyTable.objbytes[(signed long long int)idx] = 1;
}

// prvMatchCallbackTopic
// file ..\..\..\..\lib\shadow\aws_shadow.c line 904
static const CallbackCatalogEntry_t * prvMatchCallbackTopic(const ShadowClient_t * const pxShadowClient, const uint8_t * const pucTopic, uint16_t usTopicLength, ShadowOperationName_t * const pxOperationName)
{
  const CallbackCatalogEntry_t *pxReturn=((const CallbackCatalogEntry_t *)NULL);
  BaseType_t xIterator;
  BaseType_t xTopicFound=0;
  uint8_t pucTopicBuffer[(signed long long int)(sizeof(char [39ll]) * 4ul + 11ul) /*167ll*/ ];
  size_t xCompareLength;
  xIterator = 0;
  for( ; !(xIterator >= 1); xIterator = xIterator + 1l)
  {
    pxReturn = &pxShadowClient->pxCallbackCatalog[(signed long long int)xIterator];
    if(pxReturn->xInUse == 1)
    {
      uint16_t return_value_prvCreateTopic=prvCreateTopic((char *)pucTopicBuffer, (const uint16_t)(128 + (signed int)sizeof(char [39ll]) /*39*/ ), "$aws/things/%s/shadow/", pxReturn->xCallbackInfo.pcThingName);
      xCompareLength = (size_t)return_value_prvCreateTopic;
      signed int return_value_strncmp$2=strncmp((const char *)pucTopicBuffer, (const char *)pucTopic, xCompareLength);
      if(return_value_strncmp$2 == 0)
      {
        xTopicFound = 1;
        uint16_t return_value_prvCreateTopic$0=prvCreateTopic((char *)pucTopicBuffer, (const uint16_t)(128 + (signed int)sizeof(char [39ll]) /*39*/ ), "$aws/things/%s/shadow/update/documents", pxReturn->xCallbackInfo.pcThingName);
        xCompareLength = (size_t)return_value_prvCreateTopic$0;
        xCompareLength = xCompareLength > (unsigned long long int)usTopicLength ? xCompareLength : (unsigned long long int)usTopicLength;
        if(!(pxOperationName == ((ShadowOperationName_t *)NULL)))
        {
          signed int return_value_strncmp$1=strncmp((const char *)pucTopicBuffer, (const char *)pucTopic, xCompareLength);
          if(return_value_strncmp$1 == 0)
            *pxOperationName = /*enum*/eShadowOperationUpdateDocuments;

          else
          {
            uint16_t return_value_prvCreateTopic$1=prvCreateTopic((char *)pucTopicBuffer, (const uint16_t)(128 + (signed int)sizeof(char [39ll]) /*39*/ ), "$aws/things/%s/shadow/update/delta", pxReturn->xCallbackInfo.pcThingName);
            xCompareLength = (size_t)return_value_prvCreateTopic$1;
            xCompareLength = xCompareLength > (unsigned long long int)usTopicLength ? xCompareLength : (unsigned long long int)usTopicLength;
            signed int return_value_strncmp$0=strncmp((const char *)pucTopicBuffer, (const char *)pucTopic, xCompareLength);
            if(return_value_strncmp$0 == 0)
              *pxOperationName = /*enum*/eShadowOperationUpdateDelta;

            else
            {
              uint16_t return_value_prvCreateTopic$2=prvCreateTopic((char *)pucTopicBuffer, (const uint16_t)(128 + (signed int)sizeof(char [39ll]) /*39*/ ), "$aws/things/%s/shadow/delete/accepted", pxReturn->xCallbackInfo.pcThingName);
              xCompareLength = (size_t)return_value_prvCreateTopic$2;
              xCompareLength = xCompareLength > (unsigned long long int)usTopicLength ? xCompareLength : (unsigned long long int)usTopicLength;
              signed int return_value_strncmp=strncmp((const char *)pucTopicBuffer, (const char *)pucTopic, xCompareLength);
              if(return_value_strncmp == 0)
                *pxOperationName = /*enum*/eShadowOperationDeletedByAnother;

              else
                *pxOperationName = /*enum*/eShadowOperationOther;
            }
          }
        }

        break;
      }

    }

  }
  if(xTopicFound == 0)
    pxReturn = ((const CallbackCatalogEntry_t *)NULL);

  return pxReturn;
}

// prvMemPrint
// file ..\..\..\..\lib\ota\aws_rsprintf.c line 518
static char * prvMemPrint(uint8_t *ptr, uint32_t len, uint8_t bUseIsPrint, uint8_t bConsoleOut, char *acSmallBuf, char *dptr)
{
  (void)acSmallBuf;
  uint32_t lim=(uint32_t)(11 + 1);
  uint32_t tmp_post;
  signed int return_value_isprint;
  do
  {
    tmp_post = len;
    len = len - 1u;
    if(tmp_post == 0u)
      break;

    uint8_t c3;
    uint8_t *tmp_post$0=ptr;
    ptr = ptr + 1ll;
    c3 = *tmp_post$0;
    if((signed int)bUseIsPrint == 1)
    {
      return_value_isprint=isprint((signed int)c3);
      if(return_value_isprint == 0)
        c3 = 46;

    }

    char *tmp_post$1=dptr;
    dptr = dptr + 1ll;
    *tmp_post$1 = (char)c3;
    if((signed int)bConsoleOut == 1)
    {
      lim = lim - 1u;
      if(lim == 0u)
        lim = (uint32_t)(11 + 1);

    }

  }
  while((_Bool)1);
  return dptr;
}

// prvMessageEchoingTask
// file ..\..\..\common\mqtt\aws_hello_world.c line 282
static void prvMessageEchoingTask(void *pvParameters)
{
  MQTTAgentPublishParams_t xPublishParameters;
  MQTTAgentReturnCode_t xReturned;
  char cDataBuffer[24ll];
  size_t xBytesReceived;
  (void)pvParameters;
  if(xMQTTHandle == NULL)
    vAssertCalled("..\\..\\..\\common\\mqtt\\aws_hello_world.c", 293u);

  if(xEchoMessageBuffer == NULL)
    vAssertCalled("..\\..\\..\\common\\mqtt\\aws_hello_world.c", 294u);

  xPublishParameters.pucTopic = (const uint8_t *)"freertos/demos/echo";
  size_t return_value_strlen=strlen((const char *)(const uint8_t *)"freertos/demos/echo");
  xPublishParameters.usTopicLength = (uint16_t)return_value_strlen;
  xPublishParameters.pvData = (const void *)cDataBuffer;
  xPublishParameters.xQoS = /*enum*/eMQTTQoS1;
  while((_Bool)1)
  {
    memset((void *)cDataBuffer, 0x0, sizeof(char [24ll]) /*24ull*/ );
    xBytesReceived=xStreamBufferReceive((StreamBufferHandle_t)xEchoMessageBuffer, (void *)cDataBuffer, sizeof(char [24ll]) /*24ull*/ , 0xFFFFFFFFul);
    if(!(xBytesReceived >= 21ull))
    {
      strcat(cDataBuffer, (const char *)" ACK");
      size_t return_value_strlen$0=strlen(cDataBuffer);
      xPublishParameters.ulDataLength = (uint32_t)return_value_strlen$0;
      xReturned=MQTT_AGENT_Publish(xMQTTHandle, &xPublishParameters, (TickType_t)((300u * 1000u) / 1000u));
      if((signed int)xReturned == 0)
        vLoggingPrintf("Message returned with ACK: '%s'\r\n", (const void *)cDataBuffer);

      else
        vLoggingPrintf("ERROR:  Could not return message with ACK: '%s'\r\n", (const void *)cDataBuffer);
    }

    else
      vLoggingPrintf("ERROR:  Buffer is not big enough to return message with ACK: '%s'\r\n", (const void *)cDataBuffer);
  }
}

// prvMiscInitialisation
// file ..\common\application_code\main.c line 265
static void prvMiscInitialisation(void)
{
  uint32_t ulLoggingIPAddress;
  vTraceEnable(1);
  ulLoggingIPAddress = 6u << 24ul | 2u << 16ul | 168u << 8ul | 192u;
  vLoggingInit(xLogToStdout, xLogToFile, xLogToUDP, ulLoggingIPAddress, 15000);
}

// prvNetworkRecv
// file ..\..\..\..\lib\secure_sockets\portable\freertos_plus_tcp\aws_secure_sockets.c line 74
static BaseType_t prvNetworkRecv(void *pvContext, unsigned char *pucReceiveBuffer, size_t xReceiveLength)
{
  SSOCKETContextPtr_t pxContext=(SSOCKETContextPtr_t)pvContext;
  BaseType_t return_value_FreeRTOS_recv=FreeRTOS_recv(pxContext->xSocket, (void *)pucReceiveBuffer, xReceiveLength, pxContext->xRecvFlags);
  return return_value_FreeRTOS_recv;
}

// prvNetworkRecv$link1
// file ..\..\..\..\lib\tls\aws_tls.c line 156
static signed int prvNetworkRecv$link1(void *pvContext$link1, unsigned char *pucReceiveBuffer$link1, size_t xReceiveLength$link1)
{
  TLSContext_t *pCtx=(TLSContext_t *)pvContext$link1;
  BaseType_t return_value=pCtx->pxNetworkRecv(pCtx->pvCallerContext, pucReceiveBuffer$link1, xReceiveLength$link1);
  return (signed int)return_value;
}

// prvNetworkSend
// file ..\..\..\..\lib\secure_sockets\portable\freertos_plus_tcp\aws_secure_sockets.c line 61
static BaseType_t prvNetworkSend(void *pvContext, const unsigned char *pucData, size_t xDataLength)
{
  SSOCKETContextPtr_t pxContext=(SSOCKETContextPtr_t)pvContext;
  BaseType_t return_value_FreeRTOS_send=FreeRTOS_send(pxContext->xSocket, (const void *)pucData, xDataLength, pxContext->xSendFlags);
  return return_value_FreeRTOS_send;
}

// prvNetworkSend$link1
// file ..\..\..\..\lib\tls\aws_tls.c line 138
static signed int prvNetworkSend$link1(void *pvContext$link1, const unsigned char *pucData$link1, size_t xDataLength$link1)
{
  TLSContext_t *pCtx=(TLSContext_t *)pvContext$link1;
  BaseType_t return_value=pCtx->pxNetworkSend(pCtx->pvCallerContext, pucData$link1, xDataLength$link1);
  return (signed int)return_value;
}

// prvNotifyRequestingTask
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1232
static void prvNotifyRequestingTask(MQTTNotificationData_t * const pxNotificationData, MQTTNotifyCodes_t xNotificationCode, UBaseType_t uxStatus)
{
  if(!(pxNotificationData->xTaskToNotify == NULL))
  {
    vLoggingPrintf("Notifying task.\r\n");
    pxNotificationData->ulMessageIdentifier = pxNotificationData->ulMessageIdentifier | (UBaseType_t)xNotificationCode;
    pxNotificationData->ulMessageIdentifier = pxNotificationData->ulMessageIdentifier | uxStatus;
    xTaskGenericNotify(pxNotificationData->xTaskToNotify, pxNotificationData->ulMessageIdentifier, /*enum*/eSetValueWithoutOverwrite, ((uint32_t *)NULL));
    pxNotificationData->xTaskToNotify = NULL;
  }

}

// prvOTAPublishCallback
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 788
static MQTTBool_t prvOTAPublishCallback(void *pvCallbackContext, const MQTTPublishData_t * const pxPublishData)
{
  MQTTBool_t xTakeOwnership=/*enum*/eMQTTFalse;
  BaseType_t xReturn;
  (void)pvCallbackContext;
  if(!(xOTA_EventFlags == NULL))
  {
    xReturn=xQueueGenericSend(xOTA_MsgQ, (const void *)pxPublishData, 0u, 0);
    if(xReturn == 1)
    {
      ulOTA_PacketsQueued = ulOTA_PacketsQueued + 1u;
      xEventGroupSetBits(xOTA_EventFlags, 1u);
      xTakeOwnership = /*enum*/eMQTTTrue;
    }

    else
      ulOTA_PacketsDropped = ulOTA_PacketsDropped + 1u;
  }

  else
  {
    vLoggingPrintf("[OTA] Warning: Received MQTT message before agent is ready.\r\n");
    ulOTA_PacketsDropped = ulOTA_PacketsDropped + 1u;
  }
  return xTakeOwnership;
}

// prvOTAUpdateTask
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 849
static void prvOTAUpdateTask(MQTTAgentHandle_t xPubSubClientHandle)
{
  EventBits_t uxBits;
  OTA_FileContext_t *C=((OTA_FileContext_t *)NULL);
  uint16_t iLen;
  OTA_Err_t eErr;
  char acOTA_DynamicTopic[256ll];
  (void)xPubSubClientHandle;
  MQTTPublishData_t xMsgMetaData;
  uint8_t return_value_prvSubscribeToJobNotificationTopic=prvSubscribeToJobNotificationTopic();
  BaseType_t return_value_xQueueReceive;
  OTA_ImageState_t return_value_OTA_GetImageState;
  signed int return_value_memcmp;
  if((signed int)return_value_prvSubscribeToJobNotificationTopic == 1)
  {
    xOTA_EventFlags=xEventGroupCreate();
    if(!(xOTA_EventFlags == NULL))
    {
      OTA_CheckForUpdate();
      eOTA_AgentState = /*enum*/eOTA_AgentState_Ready;
      while((_Bool)1)
      {
        uxBits=xEventGroupWaitBits(xOTA_EventFlags, (const EventBits_t)(0x1 | 0x2 | 0x4), 1, 0, (TickType_t)~0);
        (void)uxBits;
        if(!((2u & uxBits) == 0u))
        {
          prvAgentShutdown();
          break;
        }

        if(!((4u & uxBits) == 0u) && !(C == ((OTA_FileContext_t *)NULL)))
        {
          eErr=prvPublishGetStreamMessage(C, acOTA_DynamicTopic);
          if(!(eErr == 0u))
          {
            OTA_SetImageState(/*enum*/eOTA_ImageState_Aborted);
            prvOTA_Close(C);
            C = ((OTA_FileContext_t *)NULL);
          }

        }

        if(!((1u & uxBits) == 0u))
        {
          xMsgMetaData.xBuffer = NULL;
          if((signed int)eOTA_AgentState == 1)
            do
            {
              return_value_xQueueReceive=xQueueReceive(xOTA_MsgQ, (void *)&xMsgMetaData, 0u);
              if(return_value_xQueueReceive == 0)
                break;

              uint8_t return_value_prvIsMsgFromJobTopic=prvIsMsgFromJobTopic(xMsgMetaData);
              if((signed int)return_value_prvIsMsgFromJobTopic == 1)
              {
                if(!(C == ((OTA_FileContext_t *)NULL)))
                  prvOTA_Close(C);

                C=prvProcessOTAJobMsg((char *)xMsgMetaData.pvData, xMsgMetaData.ulDataLength);
                if(C == ((OTA_FileContext_t *)NULL))
                {
                  return_value_OTA_GetImageState=OTA_GetImageState();
                  if((signed int)return_value_OTA_GetImageState == 1)
                    pxOTAJobCompleteCallback(/*enum*/eOTA_ImageState_Testing);

                }

              }

              else
                if(!(C == ((OTA_FileContext_t *)NULL)))
                {
                  uint32_t return_value_prvBuildDataStreamTopicName=prvBuildDataStreamTopicName(acOTA_DynamicTopic, 256u, C);
                  iLen = (uint16_t)return_value_prvBuildDataStreamTopicName;
                  if(iLen == xMsgMetaData.usTopicLength)
                  {
                    return_value_memcmp=memcmp((const void *)acOTA_DynamicTopic, (const void *)xMsgMetaData.pucTopic, (size_t)iLen);
                    if(return_value_memcmp == 0)
                    {
                      IngestResult_t result=prvIngestDataBlock(C, (const char *)xMsgMetaData.pvData, xMsgMetaData.ulDataLength);
                      if(!((signed int)result >= 0))
                      {
                        if((signed int)result == -1)
                          prvUpdateJobStatus(C, acOTA_DynamicTopic, /*enum*/eJobStatus_InProgress, 1);

                        else
                        {
                          vLoggingPrintf("[OTA] Aborting due to prvIngestDataBlock error %d\r\n", (int32_t)result);
                          prvUpdateJobStatus(C, acOTA_DynamicTopic, /*enum*/eJobStatus_FailedWithVal, (int32_t)result);
                        }
                        prvUnSubscribeFromDataStream(C);
                        prvOTA_Close(C);
                        C = ((OTA_FileContext_t *)NULL);
                        pxOTAJobCompleteCallback((OTA_ImageState_t)((signed int)result == -1 ? 2 : 3));
                        if(!(pacOTA_Singleton_ActiveJobName == ((uint8_t *)NULL)))
                        {
                          vPortFree((void *)pacOTA_Singleton_ActiveJobName);
                          pacOTA_Singleton_ActiveJobName = ((uint8_t *)NULL);
                        }

                      }

                      else
                      {
                        C->ulRequestMomentum = 0u;
                        prvUpdateJobStatus(C, acOTA_DynamicTopic, /*enum*/eJobStatus_InProgress, 0);
                      }
                    }

                  }

                }

                else
                  OTA_CheckForUpdate();
              if(!(xMsgMetaData.xBuffer == NULL))
              {
                ulOTA_PacketsProcessed = ulOTA_PacketsProcessed + 1u;
                MQTTAgentReturnCode_t return_value_MQTT_AGENT_ReturnBuffer=MQTT_AGENT_ReturnBuffer(pvPubSubClient, xMsgMetaData.xBuffer);
                if((signed int)return_value_MQTT_AGENT_ReturnBuffer == 0)
                  vLoggingPrintf("[OTA] Returned buffer to MQTT Client.\r\n");

                else
                {
                  vLoggingPrintf("[OTA] MQTT_AGENT_ReturnBuffer() Failed.\r\n");
                  break;
                }
              }

            }
            while((_Bool)1);

        }

      }
      vEventGroupDelete(xOTA_EventFlags);
    }

  }

  eOTA_AgentState = /*enum*/eOTA_AgentState_NotReady;
  vTaskDelete(NULL);
}

// prvOTA_Close
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1057
static uint8_t prvOTA_Close(OTA_FileContext_t * const C)
{
  if(!(C->pvRequestTimer == NULL))
  {
    xTimerGenericCommand(C->pvRequestTimer, 3, 0u, ((BaseType_t *)NULL), 0u);
    xTimerGenericCommand(C->pvRequestTimer, 5, 0u, ((BaseType_t *)NULL), 0u);
    C->pvRequestTimer = NULL;
  }

  if(!(C->pacStreamName == ((uint8_t *)NULL)))
  {
    prvUnSubscribeFromDataStream(C);
    vPortFree((void *)C->pacStreamName);
    C->pacStreamName = ((uint8_t *)NULL);
  }

  if(!(C->pacJobName == ((uint8_t *)NULL)))
  {
    vPortFree((void *)C->pacJobName);
    C->pacJobName = ((uint8_t *)NULL);
  }

  if(!(C->pacRxBlockBitmap == ((uint8_t *)NULL)))
  {
    vPortFree((void *)C->pacRxBlockBitmap);
    C->pacRxBlockBitmap = ((uint8_t *)NULL);
  }

  if(!(C->pacSignature == ((uint8_t *)NULL)))
  {
    vPortFree((void *)C->pacSignature);
    C->pacSignature = ((uint8_t *)NULL);
  }

  if(!(C->pacFilepath == ((uint8_t *)NULL)))
  {
    vPortFree((void *)C->pacFilepath);
    C->pacFilepath = ((uint8_t *)NULL);
  }

  if(!(C->pacCertFilepath == ((uint8_t *)NULL)))
  {
    vPortFree((void *)C->pacCertFilepath);
    C->pacCertFilepath = ((uint8_t *)NULL);
  }

  prvAbort(C);
  memset((void *)C, 0, sizeof(OTA_FileContext_t) /*96ull*/ );
  return 1;
}

// prvOpenInterface
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 302
static signed int prvOpenInterface(const char *pucName)
{
  static char pucInterfaceName[256ll];
  if(!(pucName == ((const char *)NULL)))
    strncpy(pucInterfaceName, pucName, sizeof(char [256ll]) /*256ull*/ );

  pxOpenedInterfaceHandle=pcap_open(pucInterfaceName, (signed int)(1200u + 14u + 4ul + 4ul), 1, 100, ((struct pcap_rmtauth *)NULL), cErrorBuffer);
  if(pxOpenedInterfaceHandle == ((pcap_t *)NULL))
  {
    printf("\n%s is not supported by WinPcap and cannot be opened\n", (const void *)pucInterfaceName);
    return 1;
  }

  else
    prvConfigureCaptureBehaviour();
  return 0;
}

// prvOpenSelectedNetworkInterface
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 340
static void prvOpenSelectedNetworkInterface(pcap_if_t *pxAllNetworkInterfaces)
{
  pcap_if_t *xInterface;
  int32_t x;
  xInterface = pxAllNetworkInterfaces;
  if(xConfigNextworkInterfaceToUse == 0)
    while(!(xInterface == ((pcap_if_t *)NULL)))
    {
      xInterface = xInterface->next;
      signed int return_value_prvOpenInterface=prvOpenInterface(xInterface->name);
      if(return_value_prvOpenInterface == 0)
        break;

    }

  else
  {
    x = 1l;
    for( ; !(x >= xConfigNextworkInterfaceToUse); x = x + 1)
      xInterface = xInterface->next;
    prvOpenInterface(xInterface->name);
  }
  pcap_freealldevs(pxAllNetworkInterfaces);
}

// prvPacketTypeFlagsGetTxBuffer
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 891
static MQTTBufferHandle_t prvPacketTypeFlagsGetTxBuffer(MQTTContext_t *pxMQTTContext, uint8_t ucPacketType, uint8_t ucFlags)
{
  Link_t *pxLink;
  MQTTBufferHandle_t xBuffer=NULL;
  MQTTBool_t xFound=/*enum*/eMQTTFalse;
  pxLink = (&pxMQTTContext->xTxBufferListHead)->pxNext;
  for( ; !(pxLink == &pxMQTTContext->xTxBufferListHead); pxLink = pxLink->pxNext)
  {
    xBuffer = (MQTTBufferHandle_t)(MQTTBufferMetadata_t *)((uint8_t *)pxLink - (uint8_t *)&((MQTTBufferMetadata_t *)NULL)->xLink);
    if((240 & (signed int)((uint8_t *)xBuffer)[(signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ]) == (signed int)ucPacketType)
    {
      if((15 & (signed int)((uint8_t *)xBuffer)[(signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ]) == (signed int)ucFlags)
      {
        xFound = /*enum*/eMQTTTrue;
        break;
      }

    }

  }
  if((signed int)xFound == 0)
    xBuffer = NULL;

  return xBuffer;
}

// prvPacketTypeFlagsIdentifierGetTxBuffer
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 924
static MQTTBufferHandle_t prvPacketTypeFlagsIdentifierGetTxBuffer(MQTTContext_t *pxMQTTContext, uint8_t ucPacketType, uint8_t ucFlags, uint16_t prvPacketTypeFlagsIdentifierGetTxBuffer$$usPacketIdentifier)
{
  Link_t *pxLink;
  MQTTBufferHandle_t xBuffer=NULL;
  MQTTBool_t xFound=/*enum*/eMQTTFalse;
  pxLink = (&pxMQTTContext->xTxBufferListHead)->pxNext;
  for( ; !(pxLink == &pxMQTTContext->xTxBufferListHead); pxLink = pxLink->pxNext)
  {
    xBuffer = (MQTTBufferHandle_t)(MQTTBufferMetadata_t *)((uint8_t *)pxLink - (uint8_t *)&((MQTTBufferMetadata_t *)NULL)->xLink);
    if((240 & (signed int)((uint8_t *)xBuffer)[(signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ]) == (signed int)ucPacketType)
    {
      if((15 & (signed int)((uint8_t *)xBuffer)[(signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ]) == (signed int)ucFlags)
      {
        if(((MQTTBufferMetadata_t *)xBuffer)->xBufferState.usPacketIdentifier == prvPacketTypeFlagsIdentifierGetTxBuffer$$usPacketIdentifier)
        {
          xFound = /*enum*/eMQTTTrue;
          break;
        }

      }

    }

  }
  if((signed int)xFound == 0)
    xBuffer = NULL;

  return xBuffer;
}

// prvPacketTypeIdentifierGetTxBuffer
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 959
static MQTTBufferHandle_t prvPacketTypeIdentifierGetTxBuffer(MQTTContext_t *pxMQTTContext, uint8_t ucPacketType, uint16_t prvPacketTypeIdentifierGetTxBuffer$$usPacketIdentifier)
{
  Link_t *pxLink;
  MQTTBufferHandle_t xBuffer=NULL;
  MQTTBool_t xFound=/*enum*/eMQTTFalse;
  pxLink = (&pxMQTTContext->xTxBufferListHead)->pxNext;
  for( ; !(pxLink == &pxMQTTContext->xTxBufferListHead); pxLink = pxLink->pxNext)
  {
    xBuffer = (MQTTBufferHandle_t)(MQTTBufferMetadata_t *)((uint8_t *)pxLink - (uint8_t *)&((MQTTBufferMetadata_t *)NULL)->xLink);
    if((240 & (signed int)((uint8_t *)xBuffer)[(signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ]) == (signed int)ucPacketType)
    {
      if(((MQTTBufferMetadata_t *)xBuffer)->xBufferState.usPacketIdentifier == prvPacketTypeIdentifierGetTxBuffer$$usPacketIdentifier)
      {
        xFound = /*enum*/eMQTTTrue;
        break;
      }

    }

  }
  if((signed int)xFound == 0)
    xBuffer = NULL;

  return xBuffer;
}

// prvParseDNSReply
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DNS.c line 858
uint32_t prvParseDNSReply(uint8_t *pucUDPPayloadBuffer, size_t xBufferLength, TickType_t xIdentifier)
{
  DNSMessage_t *pxDNSMessageHeader;
  DNSAnswerRecord_t *pxDNSAnswerRecord;
  uint32_t ulIPAddress=0ul;
  uint8_t *pucByte;
  size_t xSourceBytesRemaining;
  uint16_t x;
  uint16_t usDataLength;
  uint16_t usQuestions;
  char pcName[254ll]={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  if(!(xBufferLength >= sizeof(DNSMessage_t) /*12ull*/ ))
    return 0ul;

  else
    xSourceBytesRemaining = xBufferLength;
  pxDNSMessageHeader = (DNSMessage_t *)pucUDPPayloadBuffer;
  uint16_t return_value_usChar2u16;
  if(pxDNSMessageHeader->usIdentifier == (uint16_t)xIdentifier)
  {
    pucByte = pucUDPPayloadBuffer + (signed long long int)sizeof(DNSMessage_t) /*12ll*/ ;
    xSourceBytesRemaining = xSourceBytesRemaining - sizeof(DNSMessage_t) /*12ull*/ ;
    usQuestions = (uint16_t)((signed int)pxDNSMessageHeader->usQuestions << 8u | (signed int)pxDNSMessageHeader->usQuestions >> 8u);
    x = 0;
    for( ; !((signed int)x >= (signed int)usQuestions); x = x + 1)
    {
      if((signed int)x == 0)
      {
        pucByte=prvReadNameField(pucByte, xSourceBytesRemaining, pcName, sizeof(char [254ll]) /*254ull*/ );
        if(pucByte == ((uint8_t *)NULL))
          return 0ul;

        else
          xSourceBytesRemaining = (size_t)((pucUDPPayloadBuffer + (signed long long int)xBufferLength) - pucByte);
      }

      else
      {
        pucByte=prvSkipNameField(pucByte, xSourceBytesRemaining);
        if(pucByte == ((uint8_t *)NULL))
          return 0ul;

        else
          xSourceBytesRemaining = (size_t)((pucUDPPayloadBuffer + (signed long long int)xBufferLength) - pucByte);
      }
      if(xSourceBytesRemaining >= sizeof(uint32_t) /*4ull*/ )
      {
        pucByte = pucByte + (signed long long int)sizeof(uint32_t) /*4ll*/ ;
        xSourceBytesRemaining = xSourceBytesRemaining - sizeof(uint32_t) /*4ull*/ ;
      }

      else
        return 0ul;
    }
    pxDNSMessageHeader->usAnswers = (uint16_t)((signed int)pxDNSMessageHeader->usAnswers << 8u | (signed int)pxDNSMessageHeader->usAnswers >> 8u);
    if((0xF80 & (signed int)pxDNSMessageHeader->usFlags) == 0x80)
    {
      x = 0;
      for( ; !((signed int)x >= (signed int)pxDNSMessageHeader->usAnswers); x = x + 1)
      {
        pucByte=prvSkipNameField(pucByte, xSourceBytesRemaining);
        if(pucByte == ((uint8_t *)NULL))
          return 0ul;

        else
          xSourceBytesRemaining = (size_t)((pucUDPPayloadBuffer + (signed long long int)xBufferLength) - pucByte);
        _Bool tmp_if_expr;
        if(xSourceBytesRemaining >= sizeof(uint32_t) * 3ul + 2ul /*14ull*/ )
        {
          return_value_usChar2u16=usChar2u16(pucByte);
          tmp_if_expr = (signed int)return_value_usChar2u16 == 0x1 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr = (_Bool)0;
        if(tmp_if_expr)
        {
          pxDNSAnswerRecord = (DNSAnswerRecord_t *)pucByte;
          if((unsigned long long int)((uint16_t)((signed int)pxDNSAnswerRecord->usDataLength >> 8u) | (uint16_t)((signed int)pxDNSAnswerRecord->usDataLength << 8u)) == sizeof(uint32_t) /*4ull*/ )
          {
            memcpy((void *)&ulIPAddress, (const void *)(pucByte + (signed long long int)sizeof(DNSAnswerRecord_t) /*10ll*/ ), sizeof(uint32_t) /*4ull*/ );
            prvProcessDNSCache(pcName, &ulIPAddress, pxDNSAnswerRecord->ulTTL, 0);
          }

          pucByte = pucByte + (signed long long int)(sizeof(DNSAnswerRecord_t) /*10ull*/  + sizeof(uint32_t) /*4ull*/ );
          xSourceBytesRemaining = xSourceBytesRemaining - (sizeof(DNSAnswerRecord_t) /*10ull*/  + sizeof(uint32_t) /*4ull*/ );
          break;
        }

        else
          if(xSourceBytesRemaining >= sizeof(DNSAnswerRecord_t) /*10ull*/ )
          {
            pxDNSAnswerRecord = (DNSAnswerRecord_t *)pucByte;
            pucByte = pucByte + (signed long long int)sizeof(DNSAnswerRecord_t) /*10ll*/ ;
            xSourceBytesRemaining = xSourceBytesRemaining - sizeof(DNSAnswerRecord_t) /*10ull*/ ;
            usDataLength = (uint16_t)((signed int)pxDNSAnswerRecord->usDataLength << 8u | (signed int)pxDNSAnswerRecord->usDataLength >> 8u);
            if(xSourceBytesRemaining >= (unsigned long long int)usDataLength)
            {
              pucByte = pucByte + (signed long long int)usDataLength;
              xSourceBytesRemaining = xSourceBytesRemaining - (size_t)usDataLength;
            }

            else
              return 0ul;
          }

      }
    }

  }

  return ulIPAddress;
}

// prvParseJSON
// file ..\..\..\..\lib\shadow\aws_shadow_json.c line 175
static int16_t prvParseJSON(const char * const pcDoc, uint32_t ulDocLength, jsmntok_t *pxJSMNTokens)
{
  jsmn_parser xJSMNParser;
  int16_t sReturn;
  jsmn_init(&xJSMNParser);
  signed int return_value_jsmn_parse=jsmn_parse(&xJSMNParser, pcDoc, (size_t)ulDocLength, pxJSMNTokens, 64u);
  sReturn = (int16_t)return_value_jsmn_parse;
  return sReturn;
}

// prvParseJobDocFromJSON
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1164
static OTA_FileContext_t * prvParseJobDocFromJSON(const char *pacRawMsg, uint32_t iMsgLen)
{
  OTA_FileContext_t *C;
  OTA_FileContext_t *pxFinalFile;
  jsmn_parser xParser;
  jsmntok_t *pxTokens;
  jsmntok_t *pxValTok;
  uint32_t ulNumTokens;
  uint32_t ulTokenLen;
  uint32_t ulValueDest;
  uint32_t a;
  uint32_t i;
  uint32_t ulParamsReceivedBitmap;
  uint32_t ulParamsRequiredBitmap;
  OTA_JobParseErr_t xErr=/*enum*/eOTA_JobParseErr_None;
  const JobParamDeterminer_t *pxJobDocModel=xJobDocModel;
  pxFinalFile = ((OTA_FileContext_t *)NULL);
  C=prvGetFreeContext();
  signed int iRoot;
  uint32_t tmp_post;
  _Bool tmp_if_expr;
  unsigned long int return_value_strtoul;
  if(!(C == ((OTA_FileContext_t *)NULL)))
  {
    jsmn_init(&xParser);
    signed int return_value_jsmn_parse=jsmn_parse(&xParser, pacRawMsg, (size_t)iMsgLen, ((jsmntok_t *)NULL), 1u);
    ulNumTokens = (uint32_t)return_value_jsmn_parse;
    if(ulNumTokens >= 1u)
    {
      if(!(ulNumTokens >= 65u))
      {
        void *return_value_pvPortMalloc=pvPortMalloc((unsigned long long int)ulNumTokens * sizeof(jsmntok_t) /*20ull*/ );
        pxTokens = (jsmntok_t *)return_value_pvPortMalloc;
        if(!(pxTokens == ((jsmntok_t *)NULL)))
        {
          jsmn_init(&xParser);
          signed int return_value_jsmn_parse$0=jsmn_parse(&xParser, pacRawMsg, (size_t)iMsgLen, pxTokens, ulNumTokens);
          i = (uint32_t)return_value_jsmn_parse$0;
          if(i == ulNumTokens)
          {
            ulParamsReceivedBitmap = 0u;
            ulParamsRequiredBitmap = 0u;
            a = 0u;
            for( ; !(a >= 16u); a = a + 1u)
              if((signed int)(pxJobDocModel + (signed long long int)a)->bRequired == 1)
                ulParamsRequiredBitmap = ulParamsRequiredBitmap | (uint32_t)(1 << a);

            i = 0u;
            for( ; (signed int)xErr == 0 && !(i >= ulNumTokens); i = i + 1u)
            {
              if((signed int)(pxTokens + (signed long long int)i)->type == 3)
              {
                a = 0u;
                for( ; !(a >= 16u); a = a + 1u)
                {
                  ulTokenLen = (uint32_t)((pxTokens + (signed long long int)i)->end - (pxTokens + (signed long long int)i)->start);
                  uint8_t return_value_JSON_IsCStringEqual=JSON_IsCStringEqual(&pacRawMsg[(signed long long int)(pxTokens + (signed long long int)i)->start], ulTokenLen, (pxJobDocModel + (signed long long int)a)->pcSrcKey);
                  if((signed int)return_value_JSON_IsCStringEqual == 1)
                  {
                    if(!((ulParamsReceivedBitmap & (unsigned int)(1 << a)) == 0u))
                      xErr = /*enum*/eOTA_JobParseErr_DuplicatesNotAllowed;

                    else
                      ulParamsReceivedBitmap = ulParamsReceivedBitmap | (uint32_t)(1 << a);
                    break;
                  }

                }
                if((signed int)xErr == 0)
                {
                  if(a == 16u)
                  {
                    tmp_post = i;
                    i = i + 1u;
                    iRoot = (signed int)tmp_post;
                    for( ; !(i >= ulNumTokens); i = i + 1u)
                      if(!((pxTokens + (signed long long int)i)->parent >= iRoot))
                        break;

                    i = i - 1u;
                    goto __CPROVER_DUMP_L38;
                  }

                  else
                  {
                    pxValTok = &pxTokens[(signed long long int)(i + 1u)];
                    if(!(pxValTok->type == (pxJobDocModel + (signed long long int)a)->eJasmineType))
                    {
                      vLoggingPrintf("[OTA] Job doc parameter type mismatch [ %s : type %u, expected %u ]\r\n", (pxJobDocModel + (signed long long int)a)->pcSrcKey, pxValTok->type, (pxJobDocModel + (signed long long int)a)->eJasmineType);
                      xErr = /*enum*/eOTA_JobParseErr_FieldTypeMismatch;
                      break;
                    }

                    else
                      if((pxJobDocModel + (signed long long int)a)->ulDestOffset == 0xFFFFFFFFu)
                        goto __CPROVER_DUMP_L38;

                      else
                      {
                        ulValueDest = (uint32_t)(pxJobDocModel + (signed long long int)a)->ulDestOffset;
                        if(!((unsigned long long int)ulValueDest >= sizeof(OTA_FileContext_t) /*96ull*/ ))
                          ulValueDest = ulValueDest + (uint32_t)C;

                        if((signed int)(pxJobDocModel + (signed long long int)a)->eModelParamType == 0)
                        {
                          ulTokenLen = (uint32_t)(pxValTok->end - pxValTok->start);
                          void *return_value_pvPortMalloc$0=pvPortMalloc((size_t)(ulTokenLen + 1u));
                          *((char **)ulValueDest) = (char *)return_value_pvPortMalloc$0;
                          if(!(*((char **)ulValueDest) == ((char *)NULL)))
                          {
                            memcpy((void *)*((char **)ulValueDest), (const void *)(char *)&pacRawMsg[(signed long long int)pxValTok->start], (size_t)ulTokenLen);
                            (*((char **)ulValueDest))[(signed long long int)ulTokenLen] = 0;
                            vLoggingPrintf("[OTA] Set job doc parameter [ %s: %s ]\r\n", (pxJobDocModel + (signed long long int)a)->pcSrcKey, *((char **)ulValueDest));
                          }

                          else
                          {
                            xErr = /*enum*/eOTA_JobParseErr_OutOfMemory;
                            break;
                          }
                        }

                        if((signed int)(pxJobDocModel + (signed long long int)a)->eModelParamType == 1)
                        {
                          *((char **)ulValueDest) = (char *)&pacRawMsg[(signed long long int)pxValTok->start];
                          if(!(*((char **)ulValueDest) == ((char *)NULL)))
                          {
                            ulTokenLen = (uint32_t)(pxValTok->end - pxValTok->start);
                            vLoggingPrintf("[OTA] Set job doc parameter [ %s: %.*s ]\r\n", (pxJobDocModel + (signed long long int)a)->pcSrcKey, ulTokenLen, *((char **)ulValueDest));
                          }

                        }

                        else
                          if((signed int)(pxJobDocModel + (signed long long int)a)->eModelParamType == 4)
                          {
                            char *pEnd;
                            const char *pStart=&pacRawMsg[(signed long long int)pxValTok->start];
                            *((uint32_t *)ulValueDest)=strtoul(pStart, &pEnd, 0);
                            if(pEnd == pacRawMsg + (signed long long int)pxValTok->end)
                              vLoggingPrintf("[OTA] Set job doc parameter [ %s: %u ]\r\n", (pxJobDocModel + (signed long long int)a)->pcSrcKey, *((uint32_t *)ulValueDest));

                            else
                              xErr = /*enum*/eOTA_JobParseErr_InvalidNumChar;
                          }

                          else
                            if((signed int)(pxJobDocModel + (signed long long int)a)->eModelParamType == 5)
                            {
                              void *return_value_pvPortMalloc$1=pvPortMalloc(256ull);
                              *((char **)ulValueDest) = (char *)return_value_pvPortMalloc$1;
                              if(!(*((char **)ulValueDest) == ((char *)NULL)))
                              {
                                size_t xActualLen;
                                ulTokenLen = (uint32_t)(pxValTok->end - pxValTok->start);
                                signed int return_value_mbedtls_base64_decode=mbedtls_base64_decode(*((uint8_t **)ulValueDest), 256ull, &xActualLen, (const uint8_t *)&pacRawMsg[(signed long long int)pxValTok->start], (size_t)ulTokenLen);
                                if(!(return_value_mbedtls_base64_decode == 0))
                                {
                                  vLoggingPrintf("[OTA] mbedtls_base64_decode failed.\r\n");
                                  xErr = /*enum*/eOTA_JobParseErr_Base64Decode;
                                  break;
                                }

                                C->usSigSize = (uint16_t)xActualLen;
                                vLoggingPrintf("[OTA] Set job doc parameter [ %s: %.32s ]\r\n", (pxJobDocModel + (signed long long int)a)->pcSrcKey, &pacRawMsg[(signed long long int)pxValTok->start]);
                              }

                              else
                                xErr = /*enum*/eOTA_JobParseErr_OutOfMemory;
                            }

                            else
                              if((signed int)(pxJobDocModel + (signed long long int)a)->eModelParamType == 6)
                              {
                                vLoggingPrintf("[OTA] Identified job doc parameter [ %s ]\r\n", (pxJobDocModel + (signed long long int)a)->pcSrcKey);
                                *((uint8_t *)ulValueDest) = 1;
                              }

                      }
                  }
                }

              }


            __CPROVER_DUMP_L38:
              ;
            }
            vPortFree((void *)pxTokens);
            if((signed int)xErr == 0)
            {
              uint32_t ulMissingParams=ulParamsReceivedBitmap & ulParamsRequiredBitmap ^ ulParamsRequiredBitmap;
              if(!(ulMissingParams == 0u))
              {
                a = 0u;
                for( ; !(a >= 16u); a = a + 1u)
                  if(!((ulMissingParams & (unsigned int)(1 << a)) == 0u))
                    vLoggingPrintf("[OTA] Missing job parameter: %s\r\n", (pxJobDocModel + (signed long long int)a)->pcSrcKey);

                xErr = /*enum*/eOTA_JobParseErr_MalformedJobDoc;
              }

              else
              {
                if(C->iFileSize == 0u)
                {
                  vLoggingPrintf("[OTA] Zero file size is not allowed!\r\n");
                  xErr = /*enum*/eOTA_JobParseErr_ZeroFileSize;
                }

                else
                  if(!(pacOTA_Singleton_ActiveJobName == ((uint8_t *)NULL)))
                  {
                    if(!(C->pacJobName == ((uint8_t *)NULL)))
                    {
                      signed int return_value_strcmp=strcmp((char *)pacOTA_Singleton_ActiveJobName, (char *)C->pacJobName);
                      if(!(return_value_strcmp == 0))
                      {
                        vLoggingPrintf("[OTA] Busy with existing job. Ignoring.\r\n");
                        xErr = /*enum*/eOTA_JobParseErr_BusyWithExistingJob;
                      }

                      else
                      {
                        vLoggingPrintf("[OTA] Superfluous report of current job.\r\n");
                        vPortFree((void *)C->pacJobName);
                        C->pacJobName = ((uint8_t *)NULL);
                      }
                    }

                  }

                  else
                  {
                    pacOTA_Singleton_ActiveJobName = C->pacJobName;
                    C->pacJobName = ((uint8_t *)NULL);
                  }
                if((signed int)xErr == 0)
                {
                  if((signed int)bOTA_Singleton_SelfTestMode == 1)
                  {
                    vLoggingPrintf("[OTA] Job is ready for self test.\r\n");
                    if(!(C->ulUpdaterVersion >= xAppFirmwareVersion.u.ulVersion32))
                      OTA_SetImageState(/*enum*/eOTA_ImageState_Testing);

                    else
                      if(!(xAppFirmwareVersion.u.ulVersion32 >= C->ulUpdaterVersion))
                      {
                        vLoggingPrintf("[OTA] Rejecting job. Job updater is from the future.\r\n");
                        OTA_SetImageState(/*enum*/eOTA_ImageState_Rejected);
                      }

                      else
                      {
                        _Bool tmp_if_expr$0;
                        if(pacClientTokenFromJob == ((char *)NULL))
                          tmp_if_expr$0 = (_Bool)1;

                        else
                        {
                          if(!(pacClientTokenFromJob == ((char *)NULL)))
                          {
                            return_value_strtoul=strtoul(pacClientTokenFromJob, ((char **)NULL), 0);
                            tmp_if_expr = return_value_strtoul == 0u ? (_Bool)1 : (_Bool)0;
                          }

                          else
                            tmp_if_expr = (_Bool)0;
                          tmp_if_expr$0 = tmp_if_expr ? (_Bool)1 : (_Bool)0;
                        }
                        if(tmp_if_expr$0)
                        {
                          vLoggingPrintf("[OTA] Rejecting job. We rebooted and it is no different.\r\n");
                          OTA_SetImageState(/*enum*/eOTA_ImageState_Rejected);
                        }

                        else
                          vLoggingPrintf("[OTA] Ignoring job. Device must be rebooted first.\r\n");
                      }
                  }

                  else
                  {
                    vLoggingPrintf("[OTA] Job was accepted. Attempting to start transfer.\r\n");
                    pxFinalFile = C;
                  }
                }

                else
                  vLoggingPrintf("[OTA] Error (%u) parsing job document.\r\n", (uint32_t)xErr);
              }
            }

            else
              vLoggingPrintf("[OTA] Error (%u) parsing job document.\r\n", (uint32_t)xErr);
          }

          else
            vLoggingPrintf("[OTA] jsmn_parse didn't match token count when parsing.\r\n");
        }

        else
          vLoggingPrintf("[OTA] No memory for JSON tokens.\r\n");
      }

      else
        vLoggingPrintf("[OTA] Job document has too many keys.\r\n");
    }

    else
      vLoggingPrintf("[OTA] Invalid job document.\r\n");
  }

  if(!((signed int)xErr == 0))
  {
    if(!(C->pacJobName == ((uint8_t *)NULL)))
    {
      pacOTA_Singleton_ActiveJobName = C->pacJobName;
      C->pacJobName = ((uint8_t *)NULL);
      vLoggingPrintf("[OTA] Rejecting job.\r\n");
      OTA_SetImageState(/*enum*/eOTA_ImageState_Rejected);
    }

  }

  if(pxFinalFile == ((OTA_FileContext_t *)NULL))
    prvOTA_Close(C);

  return pxFinalFile;
}

// prvParseShadowOperationStatus
// file ..\..\..\..\lib\shadow\aws_shadow.c line 869
static ShadowReturnCode_t prvParseShadowOperationStatus(const uint8_t * const pucTopic, uint16_t usTopicLength)
{
  ShadowReturnCode_t xResult=3;
  const uint8_t *pucTopicStatus;
  size_t xCompareLength=strlen("/accepted");
  pucTopicStatus = (pucTopic + (signed long long int)usTopicLength) - (signed long long int)xCompareLength;
  signed int return_value_strncmp$0=strncmp((const char *)pucTopicStatus, "/accepted", xCompareLength);
  if(return_value_strncmp$0 == 0)
    xResult = 0;

  else
  {
    xCompareLength=strlen("/rejected");
    pucTopicStatus = (pucTopic + (signed long long int)usTopicLength) - (signed long long int)xCompareLength;
    signed int return_value_strncmp=strncmp((const char *)pucTopicStatus, "/rejected", xCompareLength);
    if(return_value_strncmp == 0)
      xResult = 2;

  }
  return xResult;
}

// prvPrintAvailableNetworkInterfaces
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 231
static pcap_if_t * prvPrintAvailableNetworkInterfaces(void)
{
  pcap_if_t *pxAllNetworkInterfaces=((pcap_if_t *)NULL);
  pcap_if_t *xInterface;
  int32_t lInterfaceNumber=1;
  char cBuffer[512ll];
  static BaseType_t xInvalidInterfaceDetected=0;
  if(xInvalidInterfaceDetected == 0)
  {
    signed int return_value_pcap_findalldevs_ex=pcap_findalldevs_ex("rpcap://", ((struct pcap_rmtauth *)NULL), &pxAllNetworkInterfaces, cErrorBuffer);
    if(return_value_pcap_findalldevs_ex == -1)
    {
      printf("Could not obtain a list of network interfaces\n%s\n", (const void *)cErrorBuffer);
      pxAllNetworkInterfaces = ((pcap_if_t *)NULL);
    }

    else
      printf("\r\n\r\nThe following network interfaces are available:\r\n\r\n");
    if(!(pxAllNetworkInterfaces == ((pcap_if_t *)NULL)))
    {
      xInterface = pxAllNetworkInterfaces;
      for( ; !(xInterface == ((pcap_if_t *)NULL)); xInterface = xInterface->next)
      {
        const char *return_value_prvRemoveSpaces=prvRemoveSpaces(cBuffer, (signed int)sizeof(char [512ll]) /*512*/ , xInterface->name);
        printf("Interface %d - %s\n", lInterfaceNumber, return_value_prvRemoveSpaces);
        char *tmp_if_expr;
        if(!(xInterface->description == ((char *)NULL)))
          tmp_if_expr = xInterface->description;

        else
          tmp_if_expr = "No description";
        const char *return_value_prvRemoveSpaces$0=prvRemoveSpaces(cBuffer, (signed int)sizeof(char [512ll]) /*512*/ , tmp_if_expr);
        printf("              (%s)\n", return_value_prvRemoveSpaces$0);
        printf("\n");
        lInterfaceNumber = lInterfaceNumber + 1;
      }
    }

    if(lInterfaceNumber == 1)
    {
      printf(" \nNo network interfaces were found.\n");
      pxAllNetworkInterfaces = ((pcap_if_t *)NULL);
    }

    printf("\r\nThe interface that will be opened is set by ");
    printf("\"configNETWORK_INTERFACE_TO_USE\", which\r\nshould be defined in FreeRTOSConfig.h\r\n");
    if(xConfigNextworkInterfaceToUse >= lInterfaceNumber || !(xConfigNextworkInterfaceToUse >= 0l))
    {
      printf("\r\nERROR:  configNETWORK_INTERFACE_TO_USE is set to %d, which is an invalid value.\r\n", xConfigNextworkInterfaceToUse);
      printf("Please set configNETWORK_INTERFACE_TO_USE to one of the interface numbers listed above,\r\n");
      printf("then re-compile and re-start the application.  Only Ethernet (as opposed to WiFi)\r\n");
      printf("interfaces are supported.\r\n\r\nHALTING\r\n\r\n\r\n");
      xInvalidInterfaceDetected = 1;
      if(!(pxAllNetworkInterfaces == ((pcap_if_t *)NULL)))
      {
        pcap_freealldevs(pxAllNetworkInterfaces);
        pxAllNetworkInterfaces = ((pcap_if_t *)NULL);
      }

    }

    else
      printf("Attempting to open interface number %d.\n", xConfigNextworkInterfaceToUse);
  }

  return pxAllNetworkInterfaces;
}

// prvPrivateKeySigningCallback
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 168
static signed int prvPrivateKeySigningCallback(void *pvContext, mbedtls_md_type_t xMdAlg, const unsigned char *pucHash, unsigned int uiHashLen, unsigned char *pucSig, size_t *pxSigLen, signed int (*piRng)(void *, unsigned char *, size_t), void *pvRng)
{
  BaseType_t xResult=0;
  P11SessionPtr_t pxSession=(P11SessionPtr_t)pvContext;
  CK_MECHANISM xMech={ .mechanism=0ul, .pParameter=NULL, .ulParameterLen=0ul };
  (void)piRng;
  (void)pvRng;
  (void)xMdAlg;
  xMech.mechanism = 0x250ul;
  CK_RV return_value_C_SignInit=C_SignInit((CK_SESSION_HANDLE)pxSession, &xMech, (CK_OBJECT_HANDLE)pxSession->pxCurrentKey);
  xResult = (BaseType_t)return_value_C_SignInit;
  if(xResult == 0)
  {
    CK_RV return_value_C_Sign=C_Sign((CK_SESSION_HANDLE)pxSession, (CK_BYTE_PTR)pucHash, uiHashLen, pucSig, (CK_ULONG_PTR)pxSigLen);
    xResult = (BaseType_t)return_value_C_Sign;
  }

  return xResult;
}

// prvProcessDHCPReplies
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DHCP.c line 615
static BaseType_t prvProcessDHCPReplies(BaseType_t xExpectedMessageType)
{
  uint8_t *pucUDPPayload;
  uint8_t *pucLastByte;
  struct freertos_sockaddr xClient;
  uint32_t xClientLength=(uint32_t)sizeof(struct freertos_sockaddr) /*8u*/ ;
  int32_t lBytes;
  DHCPMessage_t *pxDHCPMessage;
  uint8_t *pucByte;
  uint8_t ucOptionCode;
  uint8_t ucLength;
  uint32_t ulProcessed;
  uint32_t ulParameter;
  BaseType_t xReturn=0;
  const uint32_t ulMandatoryOptions=2ul;
  lBytes=FreeRTOS_recvfrom(xDHCPData.xDHCPSocket, (void *)&pucUDPPayload, 0ull, 1, &xClient, &xClientLength);
  if(lBytes >= 1)
  {
    pxDHCPMessage = (DHCPMessage_t *)pucUDPPayload;
    if((unsigned long long int)lBytes >= sizeof(DHCPMessage_t) /*241ull*/ )
    {
      if(pxDHCPMessage->ulDHCPCookie == 0x63538263ul)
      {
        if(pxDHCPMessage->ucOpcode == 2)
        {
          if(pxDHCPMessage->ulTransactionID == ((0xFF0000ul & xDHCPData.ulTransactionId) >> 8 | xDHCPData.ulTransactionId >> 24 | (0xFF00ul & xDHCPData.ulTransactionId) << 8 | xDHCPData.ulTransactionId << 24))
          {
            signed int return_value_memcmp=memcmp((void *)&pxDHCPMessage->ucClientHardwareAddress, (void *)xDefaultPartUDPPacketHeader.ucBytes, sizeof(MACAddress_t) /*6ull*/ );
            if(return_value_memcmp == 0)
            {
              ulProcessed = 0ul;
              pucByte = &pxDHCPMessage->ucFirstOptionByte;
              pucLastByte = &pucUDPPayload[(signed long long int)(lBytes - 2l)];
              while(!(pucByte >= pucLastByte))
              {
                ucOptionCode = pucByte[0ll];
                if((unsigned int)ucOptionCode == 0xFFu)
                  break;

                if((unsigned int)ucOptionCode == 0u)
                  pucByte = pucByte + 1ll;

                else
                {
                  if(!(pucByte >= pucLastByte + -1ll))
                  {
                    ucLength = pucByte[1ll];
                    pucByte = pucByte + 2ll;
                    if(pucByte >= pucLastByte + -((signed long long int)ucLength))
                      break;

                  }

                  else
                    break;
                  if((unsigned long long int)ucLength >= sizeof(uint32_t) /*4ull*/ )
                    memcpy((void *)&ulParameter, (void *)pucByte, sizeof(uint32_t) /*4ull*/ );

                  else
                    ulParameter = 0u;
                  switch((signed int)ucOptionCode)
                  {
                    case 53:
                    {
                      if(*pucByte == (uint8_t)xExpectedMessageType)
                        ulProcessed = ulProcessed + 1u;

                      else
                        if(*pucByte == 6)
                        {
                          if(xExpectedMessageType == 5)
                            xDHCPData.eDHCPState = /*enum*/eWaitingSendFirstDiscover;

                        }

                      break;
                    }
                    case 1:
                    {
                      if((unsigned long long int)ucLength == sizeof(uint32_t) /*4ull*/ )
                        xNetworkAddressing.ulNetMask = ulParameter;

                      break;
                    }
                    case 3:
                    {
                      if((unsigned long long int)ucLength == sizeof(uint32_t) /*4ull*/ )
                        xNetworkAddressing.ulGatewayAddress = ulParameter;

                      break;
                    }
                    case 6:
                    {
                      xNetworkAddressing.ulDNSServerAddress = ulParameter;
                      break;
                    }
                    case 54:
                    {
                      if((unsigned long long int)ucLength == sizeof(uint32_t) /*4ull*/ )
                      {
                        if(xExpectedMessageType == 2)
                        {
                          ulProcessed = ulProcessed + 1u;
                          xDHCPData.ulDHCPServerAddress = ulParameter;
                        }

                        else
                          if(xDHCPData.ulDHCPServerAddress == ulParameter)
                            ulProcessed = ulProcessed + 1u;

                      }

                      break;
                    }
                    case 51:
                    {
                      if((unsigned long long int)ucLength == sizeof(uint32_t) /*4ull*/ )
                      {
                        xDHCPData.ulLeaseTime = (uint32_t)((uint32_t)ulParameter << 24 | ((uint32_t)ulParameter & 0xFF00ul) << 8 | ((uint32_t)ulParameter & 0xFF0000ul) >> 8 | (uint32_t)ulParameter >> 24);
                        xDHCPData.ulLeaseTime = xDHCPData.ulLeaseTime >> 1ul;
                        xDHCPData.ulLeaseTime = 1000u * xDHCPData.ulLeaseTime;
                      }

                      break;
                    }
                    default:
                      ;
                  }
                  if((unsigned int)ucLength == 0u)
                    break;

                  else
                    pucByte = pucByte + (signed long long int)ucLength;
                }
              }
              if(ulProcessed >= ulMandatoryOptions)
              {
                xDHCPData.ulOfferedIPAddress = pxDHCPMessage->ulYourIPAddress_yiaddr;
                vLoggingPrintf("vDHCPProcess: offer %lxip\n", (uint32_t)((uint32_t)xDHCPData.ulOfferedIPAddress << 24 | ((uint32_t)xDHCPData.ulOfferedIPAddress & 0xFF00ul) << 8 | ((uint32_t)xDHCPData.ulOfferedIPAddress & 0xFF0000ul) >> 8 | (uint32_t)xDHCPData.ulOfferedIPAddress >> 24));
                xReturn = 1;
              }

            }

          }

        }

      }

    }

    FreeRTOS_ReleaseUDPPayloadBuffer((void *)pucUDPPayload);
  }

  return xReturn;
}

// prvProcessDNSCache
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DNS.c line 1340
static void prvProcessDNSCache(const char *pcName, uint32_t *pulIP, uint32_t ulTTL, BaseType_t xLookUp)
{
  BaseType_t x;
  BaseType_t xFound=0;
  uint32_t ulCurrentTimeSeconds;
  TickType_t return_value_xTaskGetTickCount=xTaskGetTickCount();
  ulCurrentTimeSeconds = (return_value_xTaskGetTickCount / (1000u / 1000u)) / 1000u;
  x = 0;
  for( ; !(x >= 1); x = x + 1l)
  {
    if((signed int)xDNSCache[(signed long long int)x].pcName[0ll] == 0)
      break;

    signed int return_value_strcmp=strcmp(xDNSCache[(signed long long int)x].pcName, pcName);
    if(return_value_strcmp == 0)
    {
      if(!(xLookUp == 0))
      {
        if(!(ulCurrentTimeSeconds >= ((0xFF0000ul & xDNSCache[(signed long long int)x].ulTTL) >> 8 | xDNSCache[(signed long long int)x].ulTTL >> 24 | (0xFF00ul & xDNSCache[(signed long long int)x].ulTTL) << 8 | xDNSCache[(signed long long int)x].ulTTL << 24) + xDNSCache[(signed long long int)x].ulTimeWhenAddedInSeconds))
          *pulIP = xDNSCache[(signed long long int)x].ulIPAddress;

        else
          xDNSCache[(signed long long int)x].pcName[0ll] = 0;
      }

      else
      {
        xDNSCache[(signed long long int)x].ulIPAddress = *pulIP;
        xDNSCache[(signed long long int)x].ulTTL = ulTTL;
        xDNSCache[(signed long long int)x].ulTimeWhenAddedInSeconds = ulCurrentTimeSeconds;
      }
      xFound = 1;
      break;
    }

  }
  if(xFound == 0)
  {
    if(!(xLookUp == 0))
      *pulIP = 0u;

    else
    {
      size_t return_value_strlen=strlen(pcName);
      if(!(return_value_strlen >= 254ull))
      {
        static BaseType_t xFreeEntry=0;
        strcpy(xDNSCache[(signed long long int)xFreeEntry].pcName, pcName);
        xDNSCache[(signed long long int)xFreeEntry].ulIPAddress = *pulIP;
        xDNSCache[(signed long long int)xFreeEntry].ulTTL = ulTTL;
        xDNSCache[(signed long long int)xFreeEntry].ulTimeWhenAddedInSeconds = ulCurrentTimeSeconds;
        xFreeEntry = xFreeEntry + 1l;
        if(xFreeEntry == 1)
          xFreeEntry = 0;

      }

    }
  }

  _Bool tmp_if_expr;
  if(xLookUp == 0)
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = *pulIP != 0u ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
    while((_Bool)0)
      ;

}

// prvProcessEthernetPacket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 1345
static void prvProcessEthernetPacket(NetworkBufferDescriptor_t * const pxNetworkBuffer)
{
  EthernetHeader_t *pxEthernetHeader;
  eFrameProcessingResult_t eReturned=/*enum*/eReleaseBuffer;
  if(pxNetworkBuffer == ((NetworkBufferDescriptor_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS-Plus-TCP\\source\\FreeRTOS_IP.c", 1350u);

  if(pxNetworkBuffer->xDataLength >= sizeof(EthernetHeader_t) /*14ull*/ )
  {
    eReturned = /*enum*/eProcessBuffer;
    pxEthernetHeader = (EthernetHeader_t *)pxNetworkBuffer->pucEthernetBuffer;
    if((signed int)eReturned == 1)
      switch((signed int)pxEthernetHeader->usFrameType)
      {
        case 1544:
        {
          if(pxNetworkBuffer->xDataLength >= sizeof(ARPPacket_t) /*42ull*/ )
            eReturned=eARPProcessPacket((ARPPacket_t *)pxNetworkBuffer->pucEthernetBuffer);

          else
            eReturned = /*enum*/eReleaseBuffer;
          break;
        }
        case 8:
        {
          if(pxNetworkBuffer->xDataLength >= sizeof(IPPacket_t) /*34ull*/ )
            eReturned=prvProcessIPPacket((IPPacket_t *)pxNetworkBuffer->pucEthernetBuffer, pxNetworkBuffer);

          else
            eReturned = /*enum*/eReleaseBuffer;
          break;
        }
        default:
          eReturned = /*enum*/eReleaseBuffer;
      }

  }

  switch((signed int)eReturned)
  {
    case 2:
    {
      vReturnEthernetFrame(pxNetworkBuffer, 1);
      break;
    }
    case 3:
      break;
    default:
      vReleaseNetworkBufferAndDescriptor(pxNetworkBuffer);
  }
}

// prvProcessExpiredTimer
// file ..\..\..\..\lib\FreeRTOS\timers.c line 462
static void prvProcessExpiredTimer(const TickType_t xNextExpireTime, const TickType_t xTimeNow)
{
  BaseType_t xResult;
  Timer_t * const pxTimer=(Timer_t *)(&pxCurrentTimerList->xListEnd)->pxNext->pvOwner;
  uxListRemove(&pxTimer->xTimerListItem);
  if(pxTimer->uxAutoReload == 1ul)
  {
    BaseType_t return_value_prvInsertTimerInActiveList=prvInsertTimerInActiveList(pxTimer, xNextExpireTime + pxTimer->xTimerPeriodInTicks, xTimeNow, xNextExpireTime);
    if(!(return_value_prvInsertTimerInActiveList == 0))
    {
      xResult=xTimerGenericCommand((TimerHandle_t)pxTimer, 0, xNextExpireTime, ((BaseType_t *)NULL), 0u);
      if(xResult == 0)
        vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\timers.c", 484u);

      (void)xResult;
    }

  }

  pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
}

// prvProcessICMPEchoRequest
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 1713
static eFrameProcessingResult_t prvProcessICMPEchoRequest(ICMPPacket_t * const pxICMPPacket)
{
  ICMPHeader_t *pxICMPHeader;
  IPHeader_t *pxIPHeader;
  uint16_t usRequest;
  pxICMPHeader = &pxICMPPacket->xICMPHeader;
  pxIPHeader = &pxICMPPacket->xIPHeader;
  pxICMPHeader->ucTypeOfMessage = 0;
  pxIPHeader->ulDestinationIPAddress = pxIPHeader->ulSourceIPAddress;
  pxIPHeader->ulSourceIPAddress = *((uint32_t *)&xDefaultPartUDPPacketHeader.ulWords[(signed long long int)(20ull / sizeof(uint32_t) /*4ull*/ )]);
  usRequest = (uint16_t)(8 << 8);
  if((signed int)pxICMPHeader->usChecksum >= (signed int)((uint16_t)(0xFFFFu + -((unsigned int)usRequest) >> 8u) | (uint16_t)(0xFFFFu + -((unsigned int)usRequest) << 8u)))
    pxICMPHeader->usChecksum = (uint16_t)((uint32_t)pxICMPHeader->usChecksum + (unsigned int)(uint16_t)((unsigned int)usRequest + 1ul << 8u | (unsigned int)usRequest + 1ul >> 8u));

  else
    pxICMPHeader->usChecksum = (uint16_t)((uint32_t)pxICMPHeader->usChecksum + (unsigned int)(uint16_t)((signed int)usRequest << 8u | (signed int)usRequest >> 8u));
  return /*enum*/eReturnEthernetFrame;
}

// prvProcessICMPPacket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 1761
static eFrameProcessingResult_t prvProcessICMPPacket(ICMPPacket_t * const pxICMPPacket)
{
  eFrameProcessingResult_t eReturn=/*enum*/eReleaseBuffer;
  switch((signed int)pxICMPPacket->xICMPHeader.ucTypeOfMessage)
  {
    case 8:
    {
      eReturn=prvProcessICMPEchoRequest(pxICMPPacket);
      break;
    }
    case 0:
      break;
    default:
      ;
  }
  return eReturn;
}

// prvProcessIPPacket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 1509
static eFrameProcessingResult_t prvProcessIPPacket(IPPacket_t * const pxIPPacket, NetworkBufferDescriptor_t * const pxNetworkBuffer)
{
  eFrameProcessingResult_t eReturn;
  IPHeader_t *pxIPHeader=&pxIPPacket->xIPHeader;
  UBaseType_t uxHeaderLength=(UBaseType_t)(((unsigned int)pxIPHeader->ucVersionHeaderLength & 0xFu) << 2);
  uint8_t ucProtocol;
  if(!(18446744073709551602ull + pxNetworkBuffer->xDataLength >= (unsigned long long int)uxHeaderLength) || !(uxHeaderLength >= 20u))
    return /*enum*/eReleaseBuffer;

  else
  {
    ucProtocol = pxIPPacket->xIPHeader.ucProtocol;
    eReturn=prvAllowIPPacket(pxIPPacket, pxNetworkBuffer, uxHeaderLength);
    if((signed int)eReturn == 1)
    {
      if(uxHeaderLength >= 21u)
      {
        const size_t optlen=(size_t)uxHeaderLength - 20ull;
        uint8_t *pucSource=(uint8_t *)(pxNetworkBuffer->pucEthernetBuffer + (signed long long int)sizeof(EthernetHeader_t) /*14ll*/  + (signed long long int)uxHeaderLength);
        uint8_t *pucTarget=(uint8_t *)(pxNetworkBuffer->pucEthernetBuffer + (signed long long int)sizeof(EthernetHeader_t) /*14ll*/  + 20ll);
        const size_t xMoveLen=((pxNetworkBuffer->xDataLength - optlen) - 20ull) - 14ull;
        memmove((void *)pucTarget, (const void *)pucSource, xMoveLen);
        pxNetworkBuffer->xDataLength = pxNetworkBuffer->xDataLength - optlen;
        pxIPHeader->ucVersionHeaderLength = (uint8_t)((unsigned int)((signed int)pxIPHeader->ucVersionHeaderLength & 0xF0) | 20u >> 2 & 15u);
      }

      if(!(ucProtocol == 17))
        vARPRefreshCacheEntry(&pxIPPacket->xEthernetHeader.xSourceAddress, pxIPHeader->ulSourceIPAddress);

      switch((signed int)ucProtocol)
      {
        case 1:
        {
          if(pxNetworkBuffer->xDataLength >= sizeof(ICMPPacket_t) /*42ull*/ )
          {
            ICMPPacket_t *pxICMPPacket=(ICMPPacket_t *)pxNetworkBuffer->pucEthernetBuffer;
            if(pxIPHeader->ulDestinationIPAddress == xDefaultPartUDPPacketHeader.ulWords[5ll])
              eReturn=prvProcessICMPPacket(pxICMPPacket);

          }

          else
            eReturn = /*enum*/eReleaseBuffer;
          break;
        }
        case 17:
        {
          UDPPacket_t *pxUDPPacket=(UDPPacket_t *)pxNetworkBuffer->pucEthernetBuffer;
          if(pxNetworkBuffer->xDataLength >= sizeof(UDPPacket_t) /*42ull*/ )
          {
            pxNetworkBuffer->xDataLength = pxNetworkBuffer->xDataLength - sizeof(UDPPacket_t) /*42ull*/ ;
            if(!(18446744073709551608ull + (unsigned long long int)((uint16_t)((signed int)pxUDPPacket->xUDPHeader.usLength >> 8u) | (uint16_t)((signed int)pxUDPPacket->xUDPHeader.usLength << 8u)) >= pxNetworkBuffer->xDataLength))
              pxNetworkBuffer->xDataLength = (unsigned long long int)(uint16_t)((signed int)pxUDPPacket->xUDPHeader.usLength << 8u | (signed int)pxUDPPacket->xUDPHeader.usLength >> 8u) - sizeof(UDPHeader_t) /*8ull*/ ;

            pxNetworkBuffer->usPort = pxUDPPacket->xUDPHeader.usSourcePort;
            pxNetworkBuffer->ulIPAddress = pxUDPPacket->xIPHeader.ulSourceIPAddress;
            BaseType_t return_value_xProcessReceivedUDPPacket=xProcessReceivedUDPPacket(pxNetworkBuffer, pxUDPPacket->xUDPHeader.usDestinationPort);
            if(return_value_xProcessReceivedUDPPacket == 1)
              eReturn = /*enum*/eFrameConsumed;

          }

          else
            eReturn = /*enum*/eReleaseBuffer;
          break;
        }
        case 6:
        {
          BaseType_t return_value_xProcessReceivedTCPPacket=xProcessReceivedTCPPacket(pxNetworkBuffer);
          if(return_value_xProcessReceivedTCPPacket == 1)
            eReturn = /*enum*/eFrameConsumed;

          xProcessedTCPMessage = xProcessedTCPMessage + 1l;
          break;
        }
        default:
          ;
      }
    }

    return eReturn;
  }
}

// prvProcessNetworkDownEvent
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 1271
static void prvProcessNetworkDownEvent(void)
{
  xARPTimer.bActive = 0u;
  static BaseType_t xCallEventHook=0;
  if(xCallEventHook == 1)
    vApplicationIPNetworkEventHook(/*enum*/eNetworkDown);

  xCallEventHook = 1;
  BaseType_t return_value_xNetworkInterfaceInitialise=xNetworkInterfaceInitialise();
  if(!(return_value_xNetworkInterfaceInitialise == 1))
  {
    vTaskDelay((TickType_t)((3000u * 1000u) / 1000u));
    FreeRTOS_NetworkDown();
  }

  else
  {
    vDHCPProcess(1);
    xSendEventToIPTask(/*enum*/eDHCPEvent);
  }
}

// prvProcessOTAJobMsg
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1511
static OTA_FileContext_t * prvProcessOTAJobMsg(const char *pacRawMsg, uint32_t iMsgLen)
{
  uint32_t i;
  uint32_t iNumBlocks;
  uint32_t iBitmapLen;
  OTA_FileContext_t *pstUpdateFile=((OTA_FileContext_t *)NULL);
  pstUpdateFile=prvParseJobDocFromJSON(pacRawMsg, iMsgLen);
  if(!(pstUpdateFile == ((OTA_FileContext_t *)NULL)))
  {
    if(!(pstUpdateFile->pacRxBlockBitmap == ((uint8_t *)NULL)))
    {
      vPortFree((void *)pstUpdateFile->pacRxBlockBitmap);
      pstUpdateFile->pacRxBlockBitmap = ((uint8_t *)NULL);
    }

    iNumBlocks = pstUpdateFile->iFileSize + (unsigned int)(1024 - 1) >> 8 * (signed int)(1024 > 255) + ((8 - 90 / ((1024 >> 8 * (signed int)(1024 > 255)) / 4 + 14 | 1)) - 2 / ((1024 >> 8 * (signed int)(1024 > 255)) / 2 + 1));
    iBitmapLen = iNumBlocks + (unsigned int)(8 - 1) >> (8 - 90 / (8 / 4 + 14 | 1)) - 2 / (8 / 2 + 1);
    void *return_value_pvPortMalloc=pvPortMalloc((size_t)iBitmapLen);
    pstUpdateFile->pacRxBlockBitmap = (uint8_t *)return_value_pvPortMalloc;
    if(!(pstUpdateFile->pacRxBlockBitmap == ((uint8_t *)NULL)))
    {
      uint8_t return_value_prvSubscribeToDataStream=prvSubscribeToDataStream(pstUpdateFile);
      if((signed int)return_value_prvSubscribeToDataStream == 1)
      {
        memset((void *)pstUpdateFile->pacRxBlockBitmap, 0xFF, (size_t)iBitmapLen);
        uint32_t bit=(uint32_t)(1 << 8 - 1);
        uint32_t n=iBitmapLen * 8u - iNumBlocks;
        i = 0u;
        for( ; !(i >= n); i = i + 1u)
        {
          pstUpdateFile->pacRxBlockBitmap[(signed long long int)(iBitmapLen - 1u)] = pstUpdateFile->pacRxBlockBitmap[(signed long long int)(iBitmapLen - 1u)] & (uint8_t)~bit;
          bit = bit >> 1;
        }
        pstUpdateFile->iBlocksRemaining = iNumBlocks;
        prvStartRequestTimer(pstUpdateFile);
        uint8_t return_value_prvCreateFileForRx=prvCreateFileForRx(pstUpdateFile);
        if((signed int)return_value_prvCreateFileForRx == 0)
        {
          OTA_SetImageState(/*enum*/eOTA_ImageState_Rejected);
          prvOTA_Close(pstUpdateFile);
          pstUpdateFile = ((OTA_FileContext_t *)NULL);
        }

      }

      else
      {
        prvOTA_Close(pstUpdateFile);
        pstUpdateFile = ((OTA_FileContext_t *)NULL);
      }
    }

    else
    {
      prvOTA_Close(pstUpdateFile);
      pstUpdateFile = ((OTA_FileContext_t *)NULL);
    }
  }

  return pstUpdateFile;
}

// prvProcessReceivedCONNACK
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1055
static void prvProcessReceivedCONNACK(MQTTBrokerConnection_t * const pxConnection, const MQTTEventCallbackParams_t * const pxParams)
{
  MQTTNotificationData_t *pxNotificationData=prvRetrieveNotificationData(pxConnection, pxParams->u.xMQTTConnACKData.usPacketIdentifier);
  if(!(pxNotificationData == ((MQTTNotificationData_t *)NULL)))
  {
    if((signed int)pxParams->u.xMQTTConnACKData.xConnACkReturnCode == 0)
    {
      vLoggingPrintf("MQTT Connect was accepted. Connection established.\r\n");
      prvNotifyRequestingTask(pxNotificationData, /*enum*/eMQTTCONNACKConnectionAccepted, 1ul);
    }

    else
      vLoggingPrintf("MQTT Connect was rejected with error %d.\r\n", pxParams->u.xMQTTConnACKData.xConnACkReturnCode);
  }

}

// prvProcessReceivedCONNACK$link1
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1190
static void prvProcessReceivedCONNACK$link1(MQTTContext_t *pxMQTTContext)
{
  MQTTBufferHandle_t xConnectTxBuffer;
  MQTTEventCallbackParams_t xEventCallbackParams;
  MQTTBool_t xConnectionEstablished=/*enum*/eMQTTFalse;
  MQTTBool_t xConnectionRefused=/*enum*/eMQTTFalse;
  MQTTBool_t xMalformedPacket=/*enum*/eMQTTFalse;
  uint8_t ucReturnCode;
  xConnectTxBuffer=prvPacketTypeFlagsGetTxBuffer(pxMQTTContext, (uint8_t)(1 << 4), 0);
  if(xConnectTxBuffer == NULL)
  {
    xEventCallbackParams.xEventType = /*enum*/eMQTTUnexpectedConnACK;
    prvInvokeCallback(pxMQTTContext, &xEventCallbackParams);
  }

  else
  {
    if((unsigned long long int)((MQTTBufferMetadata_t *)pxMQTTContext->xRxBuffer)->ulDataLength >= sizeof(const uint8_t [4ll]) /*4ull*/ )
    {
      static const uint8_t ucDefaultCONNACKParameters[4ll]={ (const uint8_t)(2 << 4 | 0), 2, 0, 0 };
      signed int return_value_memcmp=memcmp((const void *)ucDefaultCONNACKParameters, (const void *)(uint8_t *)((uint8_t *)pxMQTTContext->xRxBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ), (size_t)(1 + 1));
      if(return_value_memcmp == 0)
      {
        xEventCallbackParams.xEventType = /*enum*/eMQTTConnACK;
        ucReturnCode = ((uint8_t *)((uint8_t *)pxMQTTContext->xRxBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[3ll];
        if(ucReturnCode == 0)
        {
          xEventCallbackParams.xEventType = /*enum*/eMQTTConnACK;
          xEventCallbackParams.u.xMQTTConnACKData.xConnACkReturnCode = /*enum*/eMQTTConnACKConnectionAccepted;
          xEventCallbackParams.u.xMQTTConnACKData.usPacketIdentifier = ((MQTTBufferMetadata_t *)xConnectTxBuffer)->xBufferState.usPacketIdentifier;
          prvInvokeCallback(pxMQTTContext, &xEventCallbackParams);
          xConnectionEstablished = /*enum*/eMQTTTrue;
        }

        else
          if((signed int)ucReturnCode >= 1 && !((signed int)ucReturnCode >= 6))
          {
            xEventCallbackParams.xEventType = /*enum*/eMQTTConnACK;
            if(ucReturnCode == 1)
              xEventCallbackParams.u.xMQTTConnACKData.xConnACkReturnCode = /*enum*/eMQTTConnACKUnacceptableProtocolVersion;

            else
              if(ucReturnCode == 2)
                xEventCallbackParams.u.xMQTTConnACKData.xConnACkReturnCode = /*enum*/eMQTTConnACKIdentifierRejected;

              else
                if(ucReturnCode == 3)
                  xEventCallbackParams.u.xMQTTConnACKData.xConnACkReturnCode = /*enum*/eMQTTConnACKServerUnavailable;

                else
                  if(ucReturnCode == 4)
                    xEventCallbackParams.u.xMQTTConnACKData.xConnACkReturnCode = /*enum*/eMQTTConnACKBadUsernameOrPassword;

                  else
                    xEventCallbackParams.u.xMQTTConnACKData.xConnACkReturnCode = /*enum*/eMQTTConnACKUnauthorized;
            xEventCallbackParams.u.xMQTTConnACKData.usPacketIdentifier = ((MQTTBufferMetadata_t *)xConnectTxBuffer)->xBufferState.usPacketIdentifier;
            prvInvokeCallback(pxMQTTContext, &xEventCallbackParams);
            xConnectionRefused = /*enum*/eMQTTTrue;
          }

          else
            xMalformedPacket = /*enum*/eMQTTTrue;
      }

      else
        xMalformedPacket = /*enum*/eMQTTTrue;
    }

    else
      xMalformedPacket = /*enum*/eMQTTTrue;
    prvReturnBuffer(pxMQTTContext, xConnectTxBuffer);
  }
  if((signed int)xConnectionRefused == 1 || (signed int)xMalformedPacket == 1)
  {
    prvResetMQTTContext(pxMQTTContext);
    xEventCallbackParams.xEventType = /*enum*/eMQTTClientDisconnected;
    if((signed int)xMalformedPacket == 1)
      xEventCallbackParams.u.xDisconnectData.xDisconnectReason = /*enum*/eMQTTDisconnectReasonMalformedPacket;

    else
      xEventCallbackParams.u.xDisconnectData.xDisconnectReason = /*enum*/eMQTTDisconnectReasonBrokerRefusedConnection;
    prvInvokeCallback(pxMQTTContext, &xEventCallbackParams);
  }

  if((signed int)xConnectionEstablished == 1)
  {
    pxMQTTContext->xConnectionState = /*enum*/eMQTTConnected;
    pxMQTTContext->xLastSentMessageTimestamp=prvGetCurrentTickCount(pxMQTTContext);
    pxMQTTContext->ulNextPeriodicInvokeTicks = pxMQTTContext->ulKeepAliveActualIntervalTicks;
    pxMQTTContext->xWaitingForPingResp = /*enum*/eMQTTFalse;
  }

  prvReturnBuffer(pxMQTTContext, pxMQTTContext->xRxBuffer);
}

// prvProcessReceivedCommands
// file ..\..\..\..\lib\FreeRTOS\timers.c line 688
static void prvProcessReceivedCommands(void)
{
  DaemonTaskMessage_t xMessage;
  Timer_t *pxTimer;
  BaseType_t xTimerListsWereSwitched;
  BaseType_t xResult;
  TickType_t xTimeNow;
  BaseType_t return_value_xQueueReceive;
  BaseType_t return_value_prvInsertTimerInActiveList;
  do
  {
    return_value_xQueueReceive=xQueueReceive(xTimerQueue, (void *)&xMessage, 0u);
    if(return_value_xQueueReceive == 0)
      break;

    if(!(xMessage.xMessageID >= 0))
    {
      const CallbackParameters_t * const pxCallback=&xMessage.u.xCallbackParameters;
      if(pxCallback == ((const CallbackParameters_t *)NULL))
        vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\timers.c", 707u);

      pxCallback->pxCallbackFunction(pxCallback->pvParameter1, pxCallback->ulParameter2);
    }

    if(xMessage.xMessageID >= 0)
    {
      pxTimer = xMessage.u.xTimerParameters.pxTimer;
      if(!(pxTimer->xTimerListItem.pvContainer == NULL))
        uxListRemove(&pxTimer->xTimerListItem);

      xTimeNow=prvSampleTimeNow(&xTimerListsWereSwitched);
      switch(xMessage.xMessageID)
      {
        case 1:

        case 6:

        case 2:

        case 7:

        case 0:
        {
          return_value_prvInsertTimerInActiveList=prvInsertTimerInActiveList(pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue);
          if(!(return_value_prvInsertTimerInActiveList == 0))
          {
            pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
            if(pxTimer->uxAutoReload == 1ul)
            {
              xResult=xTimerGenericCommand((TimerHandle_t)pxTimer, 0, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, ((BaseType_t *)NULL), 0u);
              if(xResult == 0)
                vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\timers.c", 765u);

              (void)xResult;
            }

          }

          break;
        }
        case 3:

        case 8:
          break;
        case 4:

        case 9:
        {
          pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
          if(!(pxTimer->xTimerPeriodInTicks >= 1u))
            vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\timers.c", 788u);

          prvInsertTimerInActiveList(pxTimer, xTimeNow + pxTimer->xTimerPeriodInTicks, xTimeNow, xTimeNow);
          break;
        }
        case 5:
        {
          if(pxTimer->ucStaticallyAllocated == 0)
            vPortFree((void *)pxTimer);

          break;
        }
        default:
          ;
      }
    }

  }
  while((_Bool)1);
}

// prvProcessReceivedDisconnect
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1189
static void prvProcessReceivedDisconnect(MQTTBrokerConnection_t * const pxConnection, const MQTTEventCallbackParams_t * const pxParams)
{
  UBaseType_t x;
  MQTTAgentCallbackParams_t xCallbackParams;
  (void)pxParams;
  if(!(pxConnection->xSocket == (Socket_t)4294967295u))
  {
    if(!(pxConnection->pxCallback == ((MQTTAgentCallback_t)NULL)))
    {
      xCallbackParams.xMQTTEvent = /*enum*/eMQTTAgentDisconnect;
      pxConnection->pxCallback(pxConnection->pvUserData, &xCallbackParams);
    }

    prvGracefulSocketClose(pxConnection);
  }

  x = 0ul;
  for( ; !(x >= 5ul); x = x + 1ul)
    if(!(pxConnection->xWaitingTasks[(signed long long int)x].xTaskToNotify == NULL))
      prvNotifyRequestingTask(&pxConnection->xWaitingTasks[(signed long long int)x], /*enum*/eMQTTClientGotDisconnected, 0ul);

}

// prvProcessReceivedFixedHeaderOnlyMQTTPacket
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1124
static void prvProcessReceivedFixedHeaderOnlyMQTTPacket(MQTTContext_t *pxMQTTContext)
{
  MQTTEventCallbackParams_t xEventCallbackParams;
  if(pxMQTTContext->ucRxFixedHeaderBuffer[0ll] == 208)
    prvProcessReceivedPINGRESP(pxMQTTContext);

  else
  {
    prvResetMQTTContext(pxMQTTContext);
    xEventCallbackParams.xEventType = /*enum*/eMQTTClientDisconnected;
    xEventCallbackParams.u.xDisconnectData.xDisconnectReason = /*enum*/eMQTTDisconnectReasonMalformedPacket;
    prvInvokeCallback(pxMQTTContext, &xEventCallbackParams);
  }
}

// prvProcessReceivedMQTTPacket
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1147
static void prvProcessReceivedMQTTPacket(MQTTContext_t *pxMQTTContext)
{
  MQTTEventCallbackParams_t xEventCallbackParams;
  if((240 & (signed int)((uint8_t *)pxMQTTContext->xRxBuffer)[(signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ]) == 48)
    prvProcessReceivedPublish$link1(pxMQTTContext);

  else
    if(((uint8_t *)pxMQTTContext->xRxBuffer)[(signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ] == 32)
      prvProcessReceivedCONNACK$link1(pxMQTTContext);

    else
      if(((uint8_t *)pxMQTTContext->xRxBuffer)[(signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ] == 64)
        prvProcessReceivedPUBACK$link1(pxMQTTContext);

      else
        if(((uint8_t *)pxMQTTContext->xRxBuffer)[(signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ] == 144)
          prvProcessReceivedSUBACK$link1(pxMQTTContext);

        else
          if(((uint8_t *)pxMQTTContext->xRxBuffer)[(signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ] == 176)
            prvProcessReceivedUNSUBACK$link1(pxMQTTContext);

          else
          {
            prvResetMQTTContext(pxMQTTContext);
            xEventCallbackParams.xEventType = /*enum*/eMQTTClientDisconnected;
            xEventCallbackParams.u.xDisconnectData.xDisconnectReason = /*enum*/eMQTTDisconnectReasonMalformedPacket;
            prvInvokeCallback(pxMQTTContext, &xEventCallbackParams);
          }
}

// prvProcessReceivedPINGRESP
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1618
static void prvProcessReceivedPINGRESP(MQTTContext_t *pxMQTTContext)
{
  MQTTEventCallbackParams_t xEventCallbackParams;
  MQTTBool_t xValidPingResponse=/*enum*/eMQTTFalse;
  if((unsigned long long int)pxMQTTContext->ulRxMessageReceivedLength >= sizeof(const uint8_t [2ll]) /*2ull*/ )
  {
    static const uint8_t ucPingRespPacket[2ll]={ (const uint8_t)(13 << 4 | 0), 0 };
    signed int return_value_memcmp=memcmp((const void *)pxMQTTContext->ucRxFixedHeaderBuffer, (const void *)ucPingRespPacket, sizeof(const uint8_t [2ll]) /*2ull*/ );
    if(return_value_memcmp == 0)
      xValidPingResponse = /*enum*/eMQTTTrue;

  }

  if((signed int)xValidPingResponse == 1)
  {
    if((signed int)pxMQTTContext->xWaitingForPingResp == 1)
    {
      pxMQTTContext->xWaitingForPingResp = /*enum*/eMQTTFalse;
      pxMQTTContext->xLastSentMessageTimestamp=prvGetCurrentTickCount(pxMQTTContext);
      pxMQTTContext->ulNextPeriodicInvokeTicks = pxMQTTContext->ulKeepAliveActualIntervalTicks;
    }

  }

  else
  {
    prvResetMQTTContext(pxMQTTContext);
    xEventCallbackParams.xEventType = /*enum*/eMQTTClientDisconnected;
    xEventCallbackParams.u.xDisconnectData.xDisconnectReason = /*enum*/eMQTTDisconnectReasonMalformedPacket;
    prvInvokeCallback(pxMQTTContext, &xEventCallbackParams);
  }
}

// prvProcessReceivedPUBACK
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1130
static void prvProcessReceivedPUBACK(MQTTBrokerConnection_t * const pxConnection, const MQTTEventCallbackParams_t * const pxParams)
{
  MQTTNotificationData_t *pxNotificationData=prvRetrieveNotificationData(pxConnection, pxParams->u.xMQTTPubACKData.usPacketIdentifier);
  if(!(pxNotificationData == ((MQTTNotificationData_t *)NULL)))
  {
    vLoggingPrintf("MQTT Publish was successful.\r\n");
    prvNotifyRequestingTask(pxNotificationData, /*enum*/eMQTTPUBACKReceived, 1ul);
  }

}

// prvProcessReceivedPUBACK$link1
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1538
static void prvProcessReceivedPUBACK$link1(MQTTContext_t *pxMQTTContext)
{
  MQTTBufferHandle_t xPublishTxBuffer;
  MQTTEventCallbackParams_t xEventCallbackParams;
  MQTTBool_t xMalformedPacket=/*enum*/eMQTTFalse;
  uint16_t prvProcessReceivedPUBACK$$1$$usPacketIdentifier;
  if((unsigned long long int)((MQTTBufferMetadata_t *)pxMQTTContext->xRxBuffer)->ulDataLength >= sizeof(const uint8_t [2ll]) * 2ul /*4ull*/ )
  {
    static const uint8_t ucPUBACKFixedHeader[2ll]={ (const uint8_t)(4 << 4 | 0), 2 };
    signed int return_value_memcmp=memcmp((const void *)ucPUBACKFixedHeader, (const void *)(uint8_t *)((uint8_t *)pxMQTTContext->xRxBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ), sizeof(const uint8_t [2ll]) /*2ull*/ );
    if(return_value_memcmp == 0)
    {
      prvProcessReceivedPUBACK$$1$$usPacketIdentifier = (uint16_t)(uint8_t)((uint8_t *)((uint8_t *)pxMQTTContext->xRxBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)((2u + (uint32_t)pxMQTTContext->xRxMessageState.ucRemaingingLengthFieldBytes) - 1u)];
      prvProcessReceivedPUBACK$$1$$usPacketIdentifier = prvProcessReceivedPUBACK$$1$$usPacketIdentifier << 8;
      prvProcessReceivedPUBACK$$1$$usPacketIdentifier = prvProcessReceivedPUBACK$$1$$usPacketIdentifier | (uint16_t)(uint8_t)((uint8_t *)((uint8_t *)pxMQTTContext->xRxBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)((3u + (uint32_t)pxMQTTContext->xRxMessageState.ucRemaingingLengthFieldBytes) - 1u)];
      xPublishTxBuffer=prvPacketTypeIdentifierGetTxBuffer(pxMQTTContext, (uint8_t)(3 << 4), prvProcessReceivedPUBACK$$1$$usPacketIdentifier);
      if(xPublishTxBuffer == NULL)
      {
        xEventCallbackParams.xEventType = /*enum*/eMQTTUnexpectedPubACK;
        prvInvokeCallback(pxMQTTContext, &xEventCallbackParams);
      }

      else
      {
        xEventCallbackParams.xEventType = /*enum*/eMQTTPubACK;
        xEventCallbackParams.u.xMQTTPubACKData.usPacketIdentifier = prvProcessReceivedPUBACK$$1$$usPacketIdentifier;
        prvInvokeCallback(pxMQTTContext, &xEventCallbackParams);
        prvReturnBuffer(pxMQTTContext, xPublishTxBuffer);
      }
    }

    else
      xMalformedPacket = /*enum*/eMQTTTrue;
  }

  else
    xMalformedPacket = /*enum*/eMQTTTrue;
  if((signed int)xMalformedPacket == 1)
  {
    prvResetMQTTContext(pxMQTTContext);
    xEventCallbackParams.xEventType = /*enum*/eMQTTClientDisconnected;
    xEventCallbackParams.u.xDisconnectData.xDisconnectReason = /*enum*/eMQTTDisconnectReasonMalformedPacket;
    prvInvokeCallback(pxMQTTContext, &xEventCallbackParams);
  }

  prvReturnBuffer(pxMQTTContext, pxMQTTContext->xRxBuffer);
}

// prvProcessReceivedPublish
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1148
static BaseType_t prvProcessReceivedPublish(MQTTBrokerConnection_t * const pxConnection, const MQTTEventCallbackParams_t * const pxParams)
{
  BaseType_t xReturn=0;
  MQTTAgentCallbackParams_t xCallbackParams;
  if(!(pxConnection->pxCallback == ((MQTTAgentCallback_t)NULL)))
  {
    xCallbackParams.xMQTTEvent = /*enum*/eMQTTAgentPublish;
    xCallbackParams.u.xPublishData = pxParams->u.xPublishData;
    xReturn=pxConnection->pxCallback(pxConnection->pvUserData, &xCallbackParams);
  }

  return xReturn;
}

// prvProcessReceivedPublish$link1
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1672
static void prvProcessReceivedPublish$link1(MQTTContext_t *pxMQTTContext)
{
  MQTTEventCallbackParams_t xEventCallbackParams;
  uint8_t ucPacketIdentiferLength;
  uint8_t ucQos;
  xEventCallbackParams.xEventType = /*enum*/eMQTTPublish;
  ucQos = (uint8_t)((signed int)((uint8_t *)((uint8_t *)pxMQTTContext->xRxBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[0ll] >> 1 & 3);
  if(ucQos == 0 || ucQos == 1)
  {
    xEventCallbackParams.u.xPublishData.xQos = (MQTTQoS_t)(ucQos == 0 ? 0 : 1);
    if((signed int)xEventCallbackParams.u.xPublishData.xQos == 0)
      ucPacketIdentiferLength = 0;

    else
      ucPacketIdentiferLength = 2;
    xEventCallbackParams.u.xPublishData.usTopicLength = (uint16_t)((uint8_t *)((uint8_t *)pxMQTTContext->xRxBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)((2u + (uint32_t)pxMQTTContext->xRxMessageState.ucRemaingingLengthFieldBytes) - 1u)];
    xEventCallbackParams.u.xPublishData.usTopicLength = xEventCallbackParams.u.xPublishData.usTopicLength << 8;
    xEventCallbackParams.u.xPublishData.usTopicLength = xEventCallbackParams.u.xPublishData.usTopicLength | (uint16_t)((uint8_t *)((uint8_t *)pxMQTTContext->xRxBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)((3u + (uint32_t)pxMQTTContext->xRxMessageState.ucRemaingingLengthFieldBytes) - 1u)];
    xEventCallbackParams.u.xPublishData.pucTopic = &((uint8_t *)((uint8_t *)pxMQTTContext->xRxBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)((4u + (uint32_t)pxMQTTContext->xRxMessageState.ucRemaingingLengthFieldBytes) - 1u)];
    xEventCallbackParams.u.xPublishData.pvData = (void *)&((uint8_t *)((uint8_t *)pxMQTTContext->xRxBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)(((4u + (uint32_t)pxMQTTContext->xRxMessageState.ucRemaingingLengthFieldBytes) - 1u) + (unsigned int)xEventCallbackParams.u.xPublishData.usTopicLength + (unsigned int)ucPacketIdentiferLength)];
    xEventCallbackParams.u.xPublishData.ulDataLength = pxMQTTContext->xRxMessageState.ulTotalMessageLength - (((4u + (uint32_t)pxMQTTContext->xRxMessageState.ucRemaingingLengthFieldBytes) - 1u) + (unsigned int)xEventCallbackParams.u.xPublishData.usTopicLength + (unsigned int)ucPacketIdentiferLength);
    xEventCallbackParams.u.xPublishData.xBuffer = pxMQTTContext->xRxBuffer;
    if((signed int)xEventCallbackParams.u.xPublishData.xQos == 1)
    {
      static uint8_t ucPUBACKPacket[4ll]={ (uint8_t)(4 << 4 | 0), 2, 0, 0 };
      ucPUBACKPacket[2ll] = ((uint8_t *)((uint8_t *)pxMQTTContext->xRxBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)(((4u + (uint32_t)pxMQTTContext->xRxMessageState.ucRemaingingLengthFieldBytes) - 1u) + (unsigned int)xEventCallbackParams.u.xPublishData.usTopicLength)];
      ucPUBACKPacket[3ll] = ((uint8_t *)((uint8_t *)pxMQTTContext->xRxBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)(((4u + (uint32_t)pxMQTTContext->xRxMessageState.ucRemaingingLengthFieldBytes) - 1u) + (unsigned int)xEventCallbackParams.u.xPublishData.usTopicLength + 1u)];
      prvSendData$link1(pxMQTTContext, ucPUBACKPacket, (uint32_t)sizeof(uint8_t [4ll]) /*4u*/ );
    }

    MQTTBool_t return_value_prvInvokeCallback=prvInvokeCallback(pxMQTTContext, &xEventCallbackParams);
    if((signed int)return_value_prvInvokeCallback == 0)
      prvReturnBuffer(pxMQTTContext, pxMQTTContext->xRxBuffer);

  }

  else
  {
    prvResetMQTTContext(pxMQTTContext);
    xEventCallbackParams.xEventType = /*enum*/eMQTTClientDisconnected;
    xEventCallbackParams.u.xDisconnectData.xDisconnectReason = /*enum*/eMQTTDisconnectReasonMalformedPacket;
    prvInvokeCallback(pxMQTTContext, &xEventCallbackParams);
  }
}

// prvProcessReceivedSUBACK
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1087
static void prvProcessReceivedSUBACK(MQTTBrokerConnection_t * const pxConnection, const MQTTEventCallbackParams_t * const pxParams)
{
  MQTTNotificationData_t *pxNotificationData=prvRetrieveNotificationData(pxConnection, pxParams->u.xMQTTSubACKData.usPacketIdentifier);
  if(!(pxNotificationData == ((MQTTNotificationData_t *)NULL)))
  {
    if(!((signed int)pxParams->u.xMQTTSubACKData.xSubACKReturnCode == 128))
    {
      vLoggingPrintf("MQTT Subscribe was accepted. Subscribed.\r\n");
      prvNotifyRequestingTask(pxNotificationData, /*enum*/eMQTTSUBACKSubscriptionAccepted, 1ul);
    }

    else
    {
      vLoggingPrintf("MQTT Subscribe was rejected.\r\n");
      prvNotifyRequestingTask(pxNotificationData, /*enum*/eMQTTSUBACKSubscriptionRejected, 0ul);
    }
  }

}

// prvProcessReceivedSUBACK$link1
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1346
static void prvProcessReceivedSUBACK$link1(MQTTContext_t *pxMQTTContext)
{
  MQTTBufferHandle_t xSubscribeTxBuffer;
  MQTTEventCallbackParams_t xEventCallbackParams;
  MQTTBool_t xMalformedPacket=/*enum*/eMQTTFalse;
  uint8_t ucReturnCode;
  uint16_t prvProcessReceivedSUBACK$$1$$usPacketIdentifier;
  if(!(3u + (uint32_t)pxMQTTContext->xRxMessageState.ucRemaingingLengthFieldBytes >= ((MQTTBufferMetadata_t *)pxMQTTContext->xRxBuffer)->ulDataLength))
  {
    prvProcessReceivedSUBACK$$1$$usPacketIdentifier = (uint16_t)((uint8_t *)((uint8_t *)pxMQTTContext->xRxBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)((2u + (uint32_t)pxMQTTContext->xRxMessageState.ucRemaingingLengthFieldBytes) - 1u)];
    prvProcessReceivedSUBACK$$1$$usPacketIdentifier = prvProcessReceivedSUBACK$$1$$usPacketIdentifier << 8;
    prvProcessReceivedSUBACK$$1$$usPacketIdentifier = prvProcessReceivedSUBACK$$1$$usPacketIdentifier | (uint16_t)(uint8_t)((uint8_t *)((uint8_t *)pxMQTTContext->xRxBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)((3u + (uint32_t)pxMQTTContext->xRxMessageState.ucRemaingingLengthFieldBytes) - 1u)];
    xSubscribeTxBuffer=prvPacketTypeFlagsIdentifierGetTxBuffer(pxMQTTContext, (uint8_t)(8 << 4), 2, prvProcessReceivedSUBACK$$1$$usPacketIdentifier);
    if(xSubscribeTxBuffer == NULL)
    {
      xEventCallbackParams.xEventType = /*enum*/eMQTTUnexpectedSubACK;
      prvInvokeCallback(pxMQTTContext, &xEventCallbackParams);
    }

    else
    {
      ucReturnCode = ((uint8_t *)((uint8_t *)pxMQTTContext->xRxBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)((4u + (uint32_t)pxMQTTContext->xRxMessageState.ucRemaingingLengthFieldBytes) - 1u)];
      if(ucReturnCode == 128 || !((signed int)ucReturnCode >= 2))
      {
        xEventCallbackParams.xEventType = /*enum*/eMQTTSubACK;
        if(ucReturnCode == 0)
          xEventCallbackParams.u.xMQTTSubACKData.xSubACKReturnCode = /*enum*/eMQTTSubACKSuccessQos0;

        else
          if(ucReturnCode == 1)
            xEventCallbackParams.u.xMQTTSubACKData.xSubACKReturnCode = /*enum*/eMQTTSubACKSuccessQos1;

          else
            xEventCallbackParams.u.xMQTTSubACKData.xSubACKReturnCode = /*enum*/eMQTTSubACKFailure;
        xEventCallbackParams.u.xMQTTSubACKData.usPacketIdentifier = prvProcessReceivedSUBACK$$1$$usPacketIdentifier;
        prvInvokeCallback(pxMQTTContext, &xEventCallbackParams);
        if(ucReturnCode == 128)
          prvRemoveSubscriptionForSubscribeOrUnsubscribeBuffer(pxMQTTContext, xSubscribeTxBuffer);

        prvReturnBuffer(pxMQTTContext, xSubscribeTxBuffer);
      }

      else
        xMalformedPacket = /*enum*/eMQTTTrue;
    }
  }

  else
    xMalformedPacket = /*enum*/eMQTTTrue;
  if((signed int)xMalformedPacket == 1)
  {
    prvResetMQTTContext(pxMQTTContext);
    xEventCallbackParams.xEventType = /*enum*/eMQTTClientDisconnected;
    xEventCallbackParams.u.xDisconnectData.xDisconnectReason = /*enum*/eMQTTDisconnectReasonMalformedPacket;
    prvInvokeCallback(pxMQTTContext, &xEventCallbackParams);
  }

  prvReturnBuffer(pxMQTTContext, pxMQTTContext->xRxBuffer);
}

// prvProcessReceivedTimeout
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1171
static void prvProcessReceivedTimeout(MQTTBrokerConnection_t * const pxConnection, const MQTTEventCallbackParams_t * const pxParams)
{
  MQTTNotificationData_t *pxNotificationData=prvRetrieveNotificationData(pxConnection, pxParams->u.xTimeoutData.usPacketIdentifier);
  if(!(pxNotificationData == ((MQTTNotificationData_t *)NULL)))
  {
    vLoggingPrintf("MQTT Timeout.\r\n");
    prvNotifyRequestingTask(pxNotificationData, /*enum*/eMQTTOperationTimedOut, 0ul);
  }

}

// prvProcessReceivedUNSUBACK
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1112
static void prvProcessReceivedUNSUBACK(MQTTBrokerConnection_t * const pxConnection, const MQTTEventCallbackParams_t * const pxParams)
{
  MQTTNotificationData_t *pxNotificationData=prvRetrieveNotificationData(pxConnection, pxParams->u.xMQTTUnSubACKData.usPacketIdentifier);
  if(!(pxNotificationData == ((MQTTNotificationData_t *)NULL)))
  {
    vLoggingPrintf("MQTT Unsubscribe was successful.\r\n");
    prvNotifyRequestingTask(pxNotificationData, /*enum*/eMQTTUNSUBACKReceived, 1ul);
  }

}

// prvProcessReceivedUNSUBACK$link1
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1450
static void prvProcessReceivedUNSUBACK$link1(MQTTContext_t *pxMQTTContext)
{
  MQTTBufferHandle_t xUnsubscribeTxBuffer;
  MQTTEventCallbackParams_t xEventCallbackParams;
  MQTTBool_t xMalformedPacket=/*enum*/eMQTTFalse;
  uint16_t prvProcessReceivedUNSUBACK$$1$$usPacketIdentifier;
  if((unsigned long long int)((MQTTBufferMetadata_t *)pxMQTTContext->xRxBuffer)->ulDataLength >= sizeof(const uint8_t [2ll]) * 2ul /*4ull*/ )
  {
    static const uint8_t ucUNSUBACKFixedHeader[2ll]={ (const uint8_t)(11 << 4 | 0), 2 };
    signed int return_value_memcmp=memcmp((const void *)ucUNSUBACKFixedHeader, (const void *)(uint8_t *)((uint8_t *)pxMQTTContext->xRxBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ), sizeof(const uint8_t [2ll]) /*2ull*/ );
    if(return_value_memcmp == 0)
    {
      prvProcessReceivedUNSUBACK$$1$$usPacketIdentifier = (uint16_t)(uint8_t)((uint8_t *)((uint8_t *)pxMQTTContext->xRxBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)((2u + (uint32_t)pxMQTTContext->xRxMessageState.ucRemaingingLengthFieldBytes) - 1u)];
      prvProcessReceivedUNSUBACK$$1$$usPacketIdentifier = prvProcessReceivedUNSUBACK$$1$$usPacketIdentifier << 8;
      prvProcessReceivedUNSUBACK$$1$$usPacketIdentifier = prvProcessReceivedUNSUBACK$$1$$usPacketIdentifier | (uint16_t)(uint8_t)((uint8_t *)((uint8_t *)pxMQTTContext->xRxBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)((3u + (uint32_t)pxMQTTContext->xRxMessageState.ucRemaingingLengthFieldBytes) - 1u)];
      xUnsubscribeTxBuffer=prvPacketTypeFlagsIdentifierGetTxBuffer(pxMQTTContext, (uint8_t)(10 << 4), 2, prvProcessReceivedUNSUBACK$$1$$usPacketIdentifier);
      if(xUnsubscribeTxBuffer == NULL)
      {
        xEventCallbackParams.xEventType = /*enum*/eMQTTUnexpectedUnSubACK;
        prvInvokeCallback(pxMQTTContext, &xEventCallbackParams);
      }

      else
      {
        xEventCallbackParams.xEventType = /*enum*/eMQTTUnSubACK;
        xEventCallbackParams.u.xMQTTUnSubACKData.usPacketIdentifier = prvProcessReceivedUNSUBACK$$1$$usPacketIdentifier;
        prvInvokeCallback(pxMQTTContext, &xEventCallbackParams);
        prvRemoveSubscriptionForSubscribeOrUnsubscribeBuffer(pxMQTTContext, xUnsubscribeTxBuffer);
        prvReturnBuffer(pxMQTTContext, xUnsubscribeTxBuffer);
      }
    }

    else
      xMalformedPacket = /*enum*/eMQTTTrue;
  }

  else
    xMalformedPacket = /*enum*/eMQTTTrue;
  if((signed int)xMalformedPacket == 1)
  {
    prvResetMQTTContext(pxMQTTContext);
    xEventCallbackParams.xEventType = /*enum*/eMQTTClientDisconnected;
    xEventCallbackParams.u.xDisconnectData.xDisconnectReason = /*enum*/eMQTTDisconnectReasonMalformedPacket;
    prvInvokeCallback(pxMQTTContext, &xEventCallbackParams);
  }

  prvReturnBuffer(pxMQTTContext, pxMQTTContext->xRxBuffer);
}

// prvProcessSimulatedInterrupts
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 350
static void prvProcessSimulatedInterrupts(void)
{
  uint32_t ulSwitchRequired;
  uint32_t i;
  xThreadState *pxThreadState;
  void *pvObjectList[2ll];
  CONTEXT xContext;
  pvObjectList[0ll] = pvInterruptEventMutex;
  pvObjectList[1ll] = pvInterruptEvent;
  ulPendingInterrupts = ulPendingInterrupts | (volatile uint32_t)(1 << 1ul);
  SetEvent(pvInterruptEvent);
  xPortRunning = 1;
  while((_Bool)1)
  {
    WaitForMultipleObjects((DWORD)(sizeof(void *[2ll]) /*16ull*/  / sizeof(void *) /*8ull*/ ), pvObjectList, 1, 0xFFFFFFFFu);
    ulSwitchRequired = 0u;
    i = 0u;
    for( ; !(i >= (uint32_t)(sizeof(uint32_t) * 8ul) /*32u*/ ); i = i + 1u)
      if(!((1ul << i & ulPendingInterrupts) == 0u))
      {
        if(!(ulIsrHandler[(signed long long int)i] == ((uint32_t (*)(void))NULL)))
        {
          uint32_t return_value=ulIsrHandler[(signed long long int)i]();
          if(!(return_value == 0u))
            ulSwitchRequired = ulSwitchRequired | (uint32_t)(1 << i);

        }

        ulPendingInterrupts = ulPendingInterrupts & ~(1ul << i);
      }

    if(!(ulSwitchRequired == 0u))
    {
      void *pvOldCurrentTCB=pxCurrentTCB;
      vTaskSwitchContext();
      if(!(pvOldCurrentTCB == pxCurrentTCB))
      {
        pxThreadState = (xThreadState *)*((size_t *)pvOldCurrentTCB);
        if(!(pxThreadState->pvThread == NULL))
        {
          SuspendThread(pxThreadState->pvThread);
          xContext.ContextFlags = (DWORD)(0x10000l | 0x2l);
          GetThreadContext(pxThreadState->pvThread, &xContext);
        }

        pxThreadState = (xThreadState *)*((size_t *)pxCurrentTCB);
        ResumeThread(pxThreadState->pvThread);
      }

    }

    ReleaseMutex(pvInterruptEventMutex);
  }
}

// prvProcessTickInterrupt
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 338
static uint32_t prvProcessTickInterrupt(void)
{
  uint32_t ulSwitchRequired;
  if(xPortRunning == 0)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\portable\\MSVC-MingW\\port.c", 343u);

  BaseType_t return_value_xTaskIncrementTick=xTaskIncrementTick();
  ulSwitchRequired = (uint32_t)return_value_xTaskIncrementTick;
  return ulSwitchRequired;
}

// prvProcessTimerOrBlockTask
// file ..\..\..\..\lib\FreeRTOS\timers.c line 538
static void prvProcessTimerOrBlockTask(const TickType_t xNextExpireTime, BaseType_t xListWasEmpty)
{
  TickType_t xTimeNow;
  BaseType_t xTimerListsWereSwitched;
  vTaskSuspendAll();
  xTimeNow=prvSampleTimeNow(&xTimerListsWereSwitched);
  if(xTimerListsWereSwitched == 0)
  {
    if(xListWasEmpty == 0 && xTimeNow >= xNextExpireTime)
    {
      xTaskResumeAll();
      prvProcessExpiredTimer(xNextExpireTime, xTimeNow);
    }

    else
    {
      if(!(xListWasEmpty == 0))
        xListWasEmpty = (BaseType_t)(pxOverflowTimerList->uxNumberOfItems == 0ul);

      vQueueWaitForMessageRestricted(xTimerQueue, xNextExpireTime - xTimeNow, xListWasEmpty);
      BaseType_t return_value_xTaskResumeAll=xTaskResumeAll();
      if(return_value_xTaskResumeAll == 0)
        vPortGenerateSimulatedInterrupt(0ul);

    }
  }

  else
    xTaskResumeAll();
}

// prvProcessYieldInterrupt
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 332
static uint32_t prvProcessYieldInterrupt(void)
{
  return 1u;
}

// prvPublishGetStreamMessage
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 714
static OTA_Err_t prvPublishGetStreamMessage(OTA_FileContext_t *C, char *pcOTA_DynamicTopic)
{
  size_t iMsgSize;
  uint32_t iNumBlocks;
  uint32_t iBitmapLen;
  uint32_t ulRequestTopicLen;
  int16_t iResult;
  OTA_Err_t eErr=0u;
  char acMsg[384ll];
  if(!(C == ((OTA_FileContext_t *)NULL)))
  {
    if(!(C->ulRequestMomentum >= 32u))
    {
      iNumBlocks = C->iFileSize + (unsigned int)(1024 - 1) >> 8 * (signed int)(1024 > 255) + ((8 - 90 / ((1024 >> 8 * (signed int)(1024 > 255)) / 4 + 14 | 1)) - 2 / ((1024 >> 8 * (signed int)(1024 > 255)) / 2 + 1));
      iBitmapLen = iNumBlocks + (unsigned int)(8 - 1) >> (8 - 90 / (8 / 4 + 14 | 1)) - 2 / (8 / 2 + 1);
      iResult = (int16_t)-1;
      BaseType_t return_value_OTA_CBOR_Encode_GetStreamRequestMessage=OTA_CBOR_Encode_GetStreamRequestMessage((uint8_t *)acMsg, sizeof(char [384ll]) /*384ull*/ , &iMsgSize, "rdy", (signed int)C->ulServerFileID, 1024, 0, C->pacRxBlockBitmap, (size_t)iBitmapLen);
      if(return_value_OTA_CBOR_Encode_GetStreamRequestMessage == 1)
      {
        C->ulRequestMomentum = C->ulRequestMomentum + 1u;
        ulRequestTopicLen=prvBuildDataRequestTopicName(pcOTA_DynamicTopic, 256u, C);
        if(ulRequestTopicLen >= 1u)
        {
          MQTTAgentReturnCode_t return_value_prvPublishMessage=prvPublishMessage(pvPubSubClient, pcOTA_DynamicTopic, (uint16_t)ulRequestTopicLen, acMsg, (uint32_t)iMsgSize, /*enum*/eMQTTQoS0);
          iResult = (int16_t)return_value_prvPublishMessage;
        }

        if(!((signed int)iResult >= 0))
          vLoggingPrintf("[OTA] Failed to publish message on request topic.\r\n");

        else
        {
          vLoggingPrintf("[OTA] Published file request to %s\r\n", pcOTA_DynamicTopic);
          prvStartRequestTimer(C);
        }
      }

      else
      {
        vLoggingPrintf("[OTA] Failed to CBOR encode GetStream message.\r\n");
        eErr = 553648128u;
      }
    }

    else
      eErr = 570425344u;
  }

  return eErr;
}

// prvPublishMessage
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1923
static MQTTAgentReturnCode_t prvPublishMessage(void * const pvClient, const char * const pacTopic, uint16_t usTopicLen, char *pacMsg, uint32_t ulMsgSize, MQTTQoS_t eQOS)
{
  MQTTAgentPublishParams_t xPublishParams;
  xPublishParams.pucTopic = (const uint8_t *)pacTopic;
  xPublishParams.usTopicLength = usTopicLen;
  xPublishParams.xQoS = eQOS;
  xPublishParams.pvData = (const void *)pacMsg;
  xPublishParams.ulDataLength = ulMsgSize;
  MQTTAgentReturnCode_t return_value_MQTT_AGENT_Publish=MQTT_AGENT_Publish(pvClient, &xPublishParams, (TickType_t)((10000ul * 1000u) / 1000u));
  return return_value_MQTT_AGENT_Publish;
}

// prvPublishNextMessage
// file ..\..\..\common\mqtt\aws_hello_world.c line 240
static void prvPublishNextMessage(BaseType_t xMessageNumber)
{
  MQTTAgentPublishParams_t xPublishParameters;
  MQTTAgentReturnCode_t xReturned;
  char cDataBuffer[20ll];
  if(xMQTTHandle == NULL)
    vAssertCalled("..\\..\\..\\common\\mqtt\\aws_hello_world.c", 248u);

  snprintf(cDataBuffer, 20ull, "Hello World %d", (signed int)xMessageNumber);
  memset((void *)&xPublishParameters, 0x0, sizeof(MQTTAgentPublishParams_t) /*32ull*/ );
  xPublishParameters.pucTopic = (const uint8_t *)"freertos/demos/echo";
  xPublishParameters.pvData = (const void *)cDataBuffer;
  size_t return_value_strlen=strlen((const char *)(const uint8_t *)"freertos/demos/echo");
  xPublishParameters.usTopicLength = (uint16_t)return_value_strlen;
  size_t return_value_strlen$0=strlen(cDataBuffer);
  xPublishParameters.ulDataLength = (uint32_t)return_value_strlen$0;
  xPublishParameters.xQoS = /*enum*/eMQTTQoS1;
  xReturned=MQTT_AGENT_Publish(xMQTTHandle, &xPublishParameters, (TickType_t)((300u * 1000u) / 1000u));
  if((signed int)xReturned == 0)
    vLoggingPrintf("Echo successfully published '%s'\r\n", (const void *)cDataBuffer);

  else
    vLoggingPrintf("ERROR:  Echo failed to publish '%s'\r\n", (const void *)cDataBuffer);
  (void)xReturned;
}

// prvPublishSubscribeTask
// file ..\..\..\common\mqtt\aws_subscribe_publish_loop.c line 683
static void prvPublishSubscribeTask(void *pvParameters)
{
  BaseType_t xSecureConnection;
  MQTTAgentHandle_t prvPublishSubscribeTask$$1$$xMQTTClientHandle;
  xSecureConnection = (BaseType_t)pvParameters;
  vLoggingPrintf("Creating MQTT Client...\r\n");
  MQTTAgentReturnCode_t return_value_MQTT_AGENT_Create=MQTT_AGENT_Create(&prvPublishSubscribeTask$$1$$xMQTTClientHandle);
  if((signed int)return_value_MQTT_AGENT_Create == 0)
  {
    vLoggingPrintf("MQTT Client Created.\r\n");
    prvSubscribePublishDemo(prvPublishSubscribeTask$$1$$xMQTTClientHandle, xSecureConnection);
  }

  else
    vLoggingPrintf("ERROR:  MQTT_AGENT_Create() Failed.\r\n");
  MQTTAgentReturnCode_t return_value_MQTT_AGENT_Delete=MQTT_AGENT_Delete(prvPublishSubscribeTask$$1$$xMQTTClientHandle);
  if((signed int)return_value_MQTT_AGENT_Delete == 0)
    vLoggingPrintf("Deleted Client.\r\n");

  else
    vLoggingPrintf("ERROR:  MQTT_AGENT_Delete() Failed.\r\n");
  vTaskDelete(NULL);
}

// prvReadAndAssumeCertificate
// file ..\..\..\..\lib\ota\portable\pc\windows\aws_ota_pal.c line 196
static uint8_t * prvReadAndAssumeCertificate(const uint8_t * const pucCertName, int32_t * const lSignerCertSize)
{
  FILE *pstFile;
  uint8_t *pucSignerCert=((uint8_t *)NULL);
  int32_t lSize;
  pstFile=fopen((const char *)pucCertName, "rb");
  if(!(pstFile == ((FILE *)NULL)))
  {
    fseek(pstFile, 0, 2);
    signed long int return_value_ftell=ftell(pstFile);
    lSize = (int32_t)return_value_ftell;
    fseek(pstFile, 0, 0);
    void *return_value_pvPortMalloc=pvPortMalloc((size_t)(lSize + 1));
    pucSignerCert = (uint8_t *)return_value_pvPortMalloc;
    if(!(pucSignerCert == ((uint8_t *)NULL)))
    {
      size_t return_value_fread=fread((void *)pucSignerCert, 1ull, (size_t)lSize, pstFile);
      if(return_value_fread == (size_t)lSize)
      {
        *lSignerCertSize = lSize + 1;
        pucSignerCert[(signed long long int)lSize] = 0;
      }

      else
      {
        free((void *)pucSignerCert);
        pucSignerCert = ((uint8_t *)NULL);
      }
    }

    fclose(pstFile);
  }

  return pucSignerCert;
}

// prvReadBytesFromBuffer
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 1066
static size_t prvReadBytesFromBuffer(StreamBuffer_t1 *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable)
{
  size_t xCount;
  size_t xFirstLength;
  size_t xNextTail;
  xCount = xBytesAvailable < xMaxCount ? xBytesAvailable : xMaxCount;
  if(xCount >= 1ull)
  {
    xNextTail = pxStreamBuffer->xTail;
    size_t tmp_if_expr;
    if(!(pxStreamBuffer->xLength + -xNextTail >= xCount))
      tmp_if_expr = pxStreamBuffer->xLength - xNextTail;

    else
      tmp_if_expr = xCount;
    xFirstLength = tmp_if_expr;
    if(!(xMaxCount >= xFirstLength))
      vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 1084u);

    if(!(pxStreamBuffer->xLength >= xFirstLength + xNextTail))
      vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 1085u);

    memcpy((void *)pucData, (const void *)&pxStreamBuffer->pucBuffer[(signed long long int)xNextTail], xFirstLength);
    if(!(xFirstLength >= xCount))
    {
      if(!(xMaxCount >= xCount))
        vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 1093u);

      memcpy((void *)&pucData[(signed long long int)xFirstLength], (void *)pxStreamBuffer->pucBuffer, xCount - xFirstLength);
    }

    xNextTail = xNextTail + xCount;
    if(xNextTail >= pxStreamBuffer->xLength)
      xNextTail = xNextTail - pxStreamBuffer->xLength;

    pxStreamBuffer->xTail = xNextTail;
  }

  return xCount;
}

// prvReadMessageFromBuffer
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 852
static size_t prvReadMessageFromBuffer(StreamBuffer_t1 *pxStreamBuffer, void *pvRxData, size_t xBufferLengthBytes, size_t xBytesAvailable, size_t xBytesToStoreMessageLength)
{
  size_t xOriginalTail;
  size_t xReceivedLength;
  size_t xNextMessageLength;
  if(!(xBytesToStoreMessageLength == 0ull))
  {
    xOriginalTail = pxStreamBuffer->xTail;
    prvReadBytesFromBuffer(pxStreamBuffer, (uint8_t *)&xNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable);
    xBytesAvailable = xBytesAvailable - xBytesToStoreMessageLength;
    if(!(xBufferLengthBytes >= xNextMessageLength))
    {
      pxStreamBuffer->xTail = xOriginalTail;
      xNextMessageLength = 0ull;
    }

  }

  else
    xNextMessageLength = xBufferLengthBytes;
  xReceivedLength=prvReadBytesFromBuffer(pxStreamBuffer, (uint8_t *)pvRxData, xNextMessageLength, xBytesAvailable);
  return xReceivedLength;
}

// prvReadNameField
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DNS.c line 675
static uint8_t * prvReadNameField(uint8_t *pucByte, size_t xSourceLen, char *pcName, size_t xDestLen)
{
  size_t xNameLen=0ull;
  BaseType_t xCount;
  BaseType_t tmp_post$1;
  if(xSourceLen == 0ull)
    return ((uint8_t *)NULL);

  else
  {
    if((192 & (signed int)*pucByte) == 192)
    {
      if(xSourceLen >= 3ull)
        pucByte = pucByte + (signed long long int)sizeof(uint16_t) /*2ll*/ ;

      else
        pucByte = ((uint8_t *)NULL);
    }

    else
    {
      while(!(pucByte == ((uint8_t *)NULL)))
      {
        if((signed int)*pucByte == 0x0)
          break;

        if(!(xSourceLen >= 2ull))
          break;

        if(xNameLen >= 1ull && !(xNameLen >= 18446744073709551615ull + xDestLen))
        {
          size_t tmp_post=xNameLen;
          xNameLen = xNameLen + 1ull;
          pcName[(signed long long int)tmp_post] = '.';
        }

        uint8_t *tmp_post$0=pucByte;
        pucByte = pucByte + 1ll;
        xCount = (BaseType_t)*tmp_post$0;
        xSourceLen = xSourceLen - 1ull;
        do
        {
          tmp_post$1 = xCount;
          xCount = xCount - 1l;
          if(!(xSourceLen >= 2ull) || tmp_post$1 == 0l)
            break;

          if(!(xNameLen >= 18446744073709551615ull + xDestLen))
          {
            size_t tmp_post$2=xNameLen;
            xNameLen = xNameLen + 1ull;
            pcName[(signed long long int)tmp_post$2] = *((char *)pucByte);
          }

          else
          {
            pucByte = ((uint8_t *)NULL);
            break;
          }
          pucByte = pucByte + 1ll;
          xSourceLen = xSourceLen - 1ull;
        }
        while((_Bool)1);
      }
      if(!(pucByte == ((uint8_t *)NULL)))
      {
        if((signed int)*pucByte == 0x0)
        {
          pucByte = pucByte + 1ll;
          xSourceLen = xSourceLen - 1ull;
          size_t tmp_post$3=xNameLen;
          xNameLen = xNameLen + 1ull;
          pcName[(signed long long int)tmp_post$3] = 0;
        }

        else
          pucByte = ((uint8_t *)NULL);
      }

    }
    return pucByte;
  }
}

// prvRegisterCallback
// file ..\..\..\..\lib\shadow\aws_shadow.c line 511
static ShadowReturnCode_t prvRegisterCallback(BaseType_t xShadowClientID, const void ** const ppvOldCallback, const void ** const ppvNewCallback, const char * const pcThingName, const uint8_t * const pucTopicFormat, TickType_t xTimeoutTicks)
{
  uint8_t pucTopicString[(signed long long int)(sizeof(char [39ll]) * 4ul + 11ul) /*167ll*/ ];
  ShadowReturnCode_t xReturn=0;
  MQTTAgentSubscribeParams_t xSubscribeParams;
  MQTTAgentUnsubscribeParams_t xUnsubscribeParams;
  ShadowClient_t *pxShadowClient;
  MQTTAgentReturnCode_t xMQTTReturn;
  uint16_t usTopicLength=prvCreateTopic((char *)pucTopicString, (const uint16_t)(128 + (signed int)sizeof(char [39ll]) /*39*/ ), (const char *)pucTopicFormat, pcThingName);
  pxShadowClient = &pxShadowClients[(signed long long int)xShadowClientID];
  if(!(*ppvOldCallback == NULL))
  {
    xUnsubscribeParams.usTopicLength = usTopicLength;
    xUnsubscribeParams.pucTopic = pucTopicString;
    xMQTTReturn=MQTT_AGENT_Unsubscribe(pxShadowClient->xMQTTClient, &xUnsubscribeParams, xTimeoutTicks);
    xReturn=prvConvertMQTTReturnCode(xMQTTReturn, (ShadowClientHandle_t)xShadowClientID, "Unsubscribe from callback topic");
  }

  if(!(*ppvNewCallback == NULL))
  {
    xSubscribeParams.usTopicLength = usTopicLength;
    xSubscribeParams.pucTopic = pucTopicString;
    xSubscribeParams.pvPublishCallbackContext = NULL;
    xSubscribeParams.pxPublishCallback = ((MQTTPublishCallback_t)NULL);
    xSubscribeParams.xQoS = /*enum*/eMQTTQoS1;
    xMQTTReturn=MQTT_AGENT_Subscribe(pxShadowClient->xMQTTClient, &xSubscribeParams, xTimeoutTicks);
    xReturn=prvConvertMQTTReturnCode(xMQTTReturn, (ShadowClientHandle_t)xShadowClientID, "Subscribe to callback topic");
  }

  if((signed int)xReturn == 0)
    *ppvOldCallback = *ppvNewCallback;

  return xReturn;
}

// prvRemoveSpaces
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 608
static const char * prvRemoveSpaces(char *pcBuffer, signed int aBuflen, const char *pcMessage)
{
  char *pcTarget=pcBuffer;
  signed int return_value_isspace;
  while(!((signed int)*pcMessage == 0))
  {
    if(pcTarget >= pcBuffer + (signed long long int)aBuflen + -1ll)
      break;

    char *tmp_post=pcTarget;
    pcTarget = pcTarget + 1ll;
    *tmp_post = *pcMessage;
    signed int return_value_isspace$0=isspace((signed int)*pcMessage);
    if(!(return_value_isspace$0 == 0))
      do
      {
        return_value_isspace=isspace((signed int)*pcMessage);
        if(return_value_isspace == 0)
          break;

        pcMessage = pcMessage + 1ll;
      }
      while((_Bool)1);

    else
      pcMessage = pcMessage + 1ll;
  }
  *pcTarget = 0;
  return pcBuffer;
}

// prvRemoveSubscription
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 2063
static void prvRemoveSubscription(MQTTContext_t *pxMQTTContext, const uint8_t * const pucTopic, uint16_t usTopicLength)
{
  uint32_t x=0u;
  for( ; !(x >= 8u); x = x + 1u)
    if((signed int)pxMQTTContext->xSubscriptionManager.xSubscriptions[(signed long long int)x].xInUse == 1)
    {
      if(pxMQTTContext->xSubscriptionManager.xSubscriptions[(signed long long int)x].usTopicFilterLength == usTopicLength)
      {
        signed int return_value_memcmp=memcmp((const void *)pxMQTTContext->xSubscriptionManager.xSubscriptions[(signed long long int)x].ucTopicFilter, (const void *)pucTopic, (size_t)usTopicLength);
        if(return_value_memcmp == 0)
        {
          pxMQTTContext->xSubscriptionManager.xSubscriptions[(signed long long int)x].xInUse = /*enum*/eMQTTFalse;
          pxMQTTContext->xSubscriptionManager.ulInUseSubscriptions = pxMQTTContext->xSubscriptionManager.ulInUseSubscriptions - 1u;
          break;
        }

      }

    }

}

// prvRemoveSubscriptionForSubscribeOrUnsubscribeBuffer
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 2098
static void prvRemoveSubscriptionForSubscribeOrUnsubscribeBuffer(MQTTContext_t *pxMQTTContext, MQTTBufferHandle_t xBuffer)
{
  uint8_t ucRemaingingLengthFieldBytes;
  uint16_t usTopicLength;
  ucRemaingingLengthFieldBytes=prvDecodeRemainingLength(&((uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[1ll], ((uint32_t *)NULL));
  usTopicLength = (uint16_t)(uint8_t)((uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)((4u + (uint32_t)ucRemaingingLengthFieldBytes) - 1u)];
  usTopicLength = usTopicLength << 8;
  usTopicLength = usTopicLength | (uint16_t)(uint8_t)((uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)(((uint32_t)(4 + 1) + (uint32_t)ucRemaingingLengthFieldBytes) - 1u)];
  prvRemoveSubscription(pxMQTTContext, &((uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ))[(signed long long int)(((uint32_t)(4 + 2) + (uint32_t)ucRemaingingLengthFieldBytes) - 1u)], usTopicLength);
}

// prvRequestTimer_Callback
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1003
static void prvRequestTimer_Callback(TimerHandle_t T)
{
  (void)T;
  if(!(xOTA_EventFlags == NULL))
    xEventGroupSetBits(xOTA_EventFlags, 4u);

}

// prvResetMQTTContext
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1004
static void prvResetMQTTContext(MQTTContext_t *pxMQTTContext)
{
  Link_t *pxLink;
  Link_t *pxTempLink;
  MQTTBufferHandle_t xBufferHandle;
  uint32_t x;
  pxMQTTContext->xConnectionState = /*enum*/eMQTTNotConnected;
  pxLink = (&pxMQTTContext->xTxBufferListHead)->pxNext;
  pxTempLink = pxLink->pxNext;
  for( ; !(pxLink == &pxMQTTContext->xTxBufferListHead); pxTempLink = pxLink->pxNext)
  {
    xBufferHandle = (MQTTBufferHandle_t)(MQTTBufferMetadata_t *)((uint8_t *)pxLink - (uint8_t *)&((MQTTBufferMetadata_t *)NULL)->xLink);
    prvReturnBuffer(pxMQTTContext, xBufferHandle);
    pxLink = pxTempLink;
  }
  prvReturnBuffer(pxMQTTContext, pxMQTTContext->xRxBuffer);
  prvResetRxMessageState(pxMQTTContext);
  x = 0u;
  for( ; !(x >= 8u); x = x + 1u)
    pxMQTTContext->xSubscriptionManager.xSubscriptions[(signed long long int)x].xInUse = /*enum*/eMQTTFalse;
  pxMQTTContext->xSubscriptionManager.ulInUseSubscriptions = 0u;
}

// prvResetNextTaskUnblockTime
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3801
static void prvResetNextTaskUnblockTime(void)
{
  TCB_t *pxTCB;
  if(pxDelayedTaskList->uxNumberOfItems == 0ul)
    xNextTaskUnblockTime = 0xFFFFFFFFul;

  else
  {
    pxTCB = (TCB_t *)(&pxDelayedTaskList->xListEnd)->pxNext->pvOwner;
    xNextTaskUnblockTime = (&pxTCB->xStateListItem)->xItemValue;
  }
}

// prvResetRxMessageState
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 992
static void prvResetRxMessageState(MQTTContext_t *pxMQTTContext)
{
  pxMQTTContext->xRxMessageState.ucRemaingingLengthFieldBytes = 0;
  pxMQTTContext->xRxMessageState.ulTotalMessageLength = 0u;
  pxMQTTContext->xRxMessageState.xRxMessageAction = /*enum*/eMQTTRxMessageStore;
  pxMQTTContext->xRxMessageState.xRxNextByte = /*enum*/eMQTTRxNextBytePacketType;
  pxMQTTContext->ulRxMessageReceivedLength = 0u;
  pxMQTTContext->xRxBuffer = NULL;
}

// prvRetrieveNotificationData
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 823
static MQTTNotificationData_t * prvRetrieveNotificationData(MQTTBrokerConnection_t * const pxConnection, uint16_t prvRetrieveNotificationData$$usPacketIdentifier)
{
  UBaseType_t x;
  MQTTNotificationData_t *pxNotificationData=((MQTTNotificationData_t *)NULL);
  x = 0ul;
  for( ; !(x >= 5ul); x = x + 1ul)
    if(!(pxConnection->xWaitingTasks[(signed long long int)x].xTaskToNotify == NULL))
    {
      if(prvRetrieveNotificationData$$usPacketIdentifier == (uint16_t)(pxConnection->xWaitingTasks[(signed long long int)x].ulMessageIdentifier >> 16))
      {
        pxNotificationData = &pxConnection->xWaitingTasks[(signed long long int)x];
        break;
      }

    }

  return pxNotificationData;
}

// prvReturnBuffer
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 874
static void prvReturnBuffer(MQTTContext_t *pxMQTTContext, MQTTBufferHandle_t xBuffer)
{
  if(!(xBuffer == NULL))
  {
    memset((void *)(uint8_t *)((uint8_t *)xBuffer + (signed long long int)sizeof(MQTTBufferMetadata_t) /*40ll*/ ), 0x0, (unsigned long long int)((MQTTBufferMetadata_t *)xBuffer)->ulBufferLength - sizeof(MQTTBufferMetadata_t) /*40ull*/ );
    if(!(((MQTTBufferMetadata_t *)xBuffer)->xLink.pxNext == ((struct Link *)NULL)))
    {
      if(!(((MQTTBufferMetadata_t *)xBuffer)->xLink.pxPrev == ((struct Link *)NULL)))
      {
        (&((MQTTBufferMetadata_t *)xBuffer)->xLink)->pxPrev->pxNext = (&((MQTTBufferMetadata_t *)xBuffer)->xLink)->pxNext;
        (&((MQTTBufferMetadata_t *)xBuffer)->xLink)->pxNext->pxPrev = (&((MQTTBufferMetadata_t *)xBuffer)->xLink)->pxPrev;
      }

    }

    (&((MQTTBufferMetadata_t *)xBuffer)->xLink)->pxPrev = ((struct Link *)NULL);
    (&((MQTTBufferMetadata_t *)xBuffer)->xLink)->pxNext = ((struct Link *)NULL);
    pxMQTTContext->xBufferPoolInterface.pxReturnBufferFxn((uint8_t *)xBuffer);
  }

}

// prvReturnConnection
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 785
static void prvReturnConnection(UBaseType_t uxBrokerNumber)
{
  if(uxBrokerNumber >= 4ul)
    vAssertCalled("..\\..\\..\\..\\lib\\mqtt\\aws_mqtt_agent.c", 787u);

  vPortEnterCritical();
  xMQTTConnections[(signed long long int)uxBrokerNumber].xConnectionInUse = 0;
  vPortExitCritical();
}

// prvSampleTimeNow
// file ..\..\..\..\lib\FreeRTOS\timers.c line 624
static TickType_t prvSampleTimeNow(BaseType_t * const pxTimerListsWereSwitched)
{
  TickType_t xTimeNow;
  xTimeNow=xTaskGetTickCount();
  static TickType_t xLastTime=0u;
  if(!(xTimeNow >= xLastTime))
  {
    prvSwitchTimerLists();
    *pxTimerListsWereSwitched = 1;
  }

  else
    *pxTimerListsWereSwitched = 0;
  xLastTime = xTimeNow;
  return xTimeNow;
}

// prvSaveTraceFile
// file ..\common\application_code\main.c line 456
static void prvSaveTraceFile(void)
{
  FILE *pxOutputFile;
  fopen_s(&pxOutputFile, "Trace.dump", "wb");
  if(!(pxOutputFile == ((FILE *)NULL)))
  {
    fwrite((const void *)RecorderDataPtr, sizeof(RecorderDataType) /*79804ull*/ , 1ull, pxOutputFile);
    fclose(pxOutputFile);
    printf("\r\nTrace output saved to Trace.dump\r\n");
  }

  else
    printf("\r\nFailed to create trace dump file\r\n");
}

// prvSendCommandToMQTTTask
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 1616
static MQTTAgentReturnCode_t prvSendCommandToMQTTTask(MQTTEventData_t *pxEventData)
{
  BaseType_t xReturn;
  MQTTAgentReturnCode_t xReturnCode=/*enum*/eMQTTAgentFailure;
  uint32_t ulReceivedMessageIdentifier;
  if(xCommandQueue == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\mqtt\\aws_mqtt_agent.c", 1624u);

  pxEventData->xNotificationData.xTaskToNotify=xTaskGetCurrentTaskHandle();
  if(!(pxEventData->xNotificationData.xTaskToNotify == xMQTTTaskHandle))
  {
    vPortEnterCritical();
    pxEventData->xNotificationData.ulMessageIdentifier = ulQueueMessageIdentifier;
    ulQueueMessageIdentifier = ulQueueMessageIdentifier + 0x10000ul;
    if(ulQueueMessageIdentifier >= 0xFFFF0000ul)
      ulQueueMessageIdentifier = 0x10000ul;

    vPortExitCritical();
    vTaskSetTimeOutState(&pxEventData->xEventCreationTimestamp);
    xTaskNotifyStateClear(NULL);
    vLoggingPrintf("Sending command to MQTT task.\r\n");
    xReturn=xQueueGenericSend(xCommandQueue, (const void *)pxEventData, pxEventData->xTicksToWait, 0);
    if(!(xReturn == 0))
    {
      ulReceivedMessageIdentifier = ~pxEventData->xNotificationData.ulMessageIdentifier;
      while((_Bool)1)
      {
        xTaskNotifyWait(0ul, 0ul, &ulReceivedMessageIdentifier, 0xFFFFFFFFul);
        if(pxEventData->xNotificationData.ulMessageIdentifier == (0xFFFF0000ul & ulReceivedMessageIdentifier))
        {
          if(!((0x1ul & ulReceivedMessageIdentifier) == 1u))
          {
            if((0xFFFEul & ulReceivedMessageIdentifier) == 32u)
              xReturnCode = /*enum*/eMQTTAgentTimeout;

            vLoggingPrintf("Command sent to MQTT task failed.\r\n");
          }

          else
          {
            vLoggingPrintf("Command sent to MQTT task passed.\r\n");
            xReturnCode = /*enum*/eMQTTAgentSuccess;
          }
          break;
        }

        else
          vLoggingPrintf("Unexpected notification received.\r\n");
      }
    }

    else
      vLoggingPrintf("Attempt to write to the MQTT command queue failed.\r\n");
  }

  else
  {
    vLoggingPrintf("MQTT Agent API called from MQTT task ( possibly from callback ) !!.\r\n");
    xReturnCode = /*enum*/eMQTTAgentAPICalledFromCallback;
  }
  return xReturnCode;
}

// prvSendDHCPDiscover
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DHCP.c line 938
static void prvSendDHCPDiscover(void)
{
  uint8_t *pucUDPPayloadBuffer;
  struct freertos_sockaddr xAddress;
  size_t xOptionsLength=sizeof(const uint8_t [17ll]) /*17ull*/ ;
  static const uint8_t ucDHCPDiscoverOptions[17ll]={ 53, 1, 1, 61, 6, 0, 0, 0, 0, 0, 0, 55, 3, 1, 3, 6, 255 };
  pucUDPPayloadBuffer=prvCreatePartDHCPMessage(&xAddress, 1, ucDHCPDiscoverOptions, &xOptionsLength);
  while((_Bool)0)
    ;
  int32_t return_value_FreeRTOS_sendto=FreeRTOS_sendto(xDHCPData.xDHCPSocket, (const void *)pucUDPPayloadBuffer, sizeof(DHCPMessage_t) /*241ull*/  + xOptionsLength, 1, &xAddress, (uint32_t)sizeof(struct freertos_sockaddr) /*8u*/ );
  if(return_value_FreeRTOS_sendto == 0)
    FreeRTOS_ReleaseUDPPayloadBuffer((void *)pucUDPPayloadBuffer);

}

// prvSendDHCPRequest
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DHCP.c line 899
static void prvSendDHCPRequest(void)
{
  uint8_t *pucUDPPayloadBuffer;
  struct freertos_sockaddr xAddress;
  size_t xOptionsLength=sizeof(const uint8_t [24ll]) /*24ull*/ ;
  static const uint8_t ucDHCPRequestOptions[24ll]={ 53, 1, 3, 61, 6, 0, 0, 0, 0, 0, 0, 50, 4, 0, 0, 0, 0, 54, 4, 0, 0, 0, 0, 255 };
  pucUDPPayloadBuffer=prvCreatePartDHCPMessage(&xAddress, 1, ucDHCPRequestOptions, &xOptionsLength);
  memcpy((void *)&pucUDPPayloadBuffer[(signed long long int)(0xF0 + 13)], (void *)&xDHCPData.ulOfferedIPAddress, sizeof(uint32_t) /*4ull*/ );
  memcpy((void *)&pucUDPPayloadBuffer[(signed long long int)(0xF0 + 19)], (void *)&xDHCPData.ulDHCPServerAddress, sizeof(uint32_t) /*4ull*/ );
  while((_Bool)0)
    ;
  int32_t return_value_FreeRTOS_sendto=FreeRTOS_sendto(xDHCPData.xDHCPSocket, (const void *)pucUDPPayloadBuffer, sizeof(DHCPMessage_t) /*241ull*/  + xOptionsLength, 1, &xAddress, (uint32_t)sizeof(struct freertos_sockaddr) /*8u*/ );
  if(return_value_FreeRTOS_sendto == 0)
    FreeRTOS_ReleaseUDPPayloadBuffer((void *)pucUDPPayloadBuffer);

}

// prvSendData
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 2521
static BaseType_t prvSendData(FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkBuffer, uint32_t ulReceiveLength, BaseType_t xSendLength)
{
  TCPPacket_t *pxTCPPacket=(TCPPacket_t *)(*ppxNetworkBuffer)->pucEthernetBuffer;
  TCPHeader_t *pxTCPHeader=&pxTCPPacket->xTCPHeader;
  TCPWindow_t *pxTCPWindow=&pxSocket->u.xTCP.xTCPWindow;
  uint32_t ulFrontSpace;
  int32_t lRxSpace;
  int32_t lMinLength;
  pxSocket->u.xTCP.ulRxCurWinSize = pxTCPWindow->xSize.ulRxWindowLength - (pxTCPWindow->rx.ulHighestSequenceNumber - pxTCPWindow->rx.ulCurrentSequenceNumber);
  if(!(pxSocket->u.xTCP.rxStream == ((const StreamBuffer_t *)NULL)))
  {
    size_t return_value_uxStreamBufferFrontSpace=uxStreamBufferFrontSpace$link1(pxSocket->u.xTCP.rxStream);
    ulFrontSpace = (uint32_t)return_value_uxStreamBufferFrontSpace;
  }

  else
    ulFrontSpace = (uint32_t)pxSocket->u.xTCP.uxRxStreamSize;
  pxSocket->u.xTCP.ulRxCurWinSize=FreeRTOS_min_uint32$link2(ulFrontSpace, pxSocket->u.xTCP.ulRxCurWinSize);
  lRxSpace = (int32_t)(pxSocket->u.xTCP.ulHighestRxAllowed - pxTCPWindow->rx.ulCurrentSequenceNumber);
  lMinLength = 2 * (int32_t)pxSocket->u.xTCP.usCurMSS;
  _Bool tmp_if_expr$0;
  if(lRxSpace >= lMinLength && ulReceiveLength >= 1u)
    tmp_if_expr$0 = (unsigned int)pxSocket->u.xTCP.bits.bFinSent == 0u ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$0 = (_Bool)0;
  _Bool tmp_if_expr$1;
  if((unsigned int)xSendLength == 40u && tmp_if_expr$0)
    tmp_if_expr$1 = (signed int)pxSocket->u.xTCP.ucTCPState == 5 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (unsigned int)pxTCPHeader->ucTCPFlags == 0x10u ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
  {
    if(!(pxSocket->u.xTCP.pxAckMessage == *ppxNetworkBuffer))
    {
      if(!(pxSocket->u.xTCP.pxAckMessage == ((NetworkBufferDescriptor_t *)NULL)))
        vReleaseNetworkBufferAndDescriptor(pxSocket->u.xTCP.pxAckMessage);

      pxSocket->u.xTCP.pxAckMessage = *ppxNetworkBuffer;
    }

    _Bool tmp_if_expr;
    if(!(ulReceiveLength >= (uint32_t)pxSocket->u.xTCP.usCurMSS))
      tmp_if_expr = (_Bool)1;

    else
      tmp_if_expr = lRxSpace < (int32_t)(2u * (unsigned int)pxSocket->u.xTCP.usCurMSS) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr)
      pxSocket->u.xTCP.usTimeout = (uint16_t)((TickType_t)((2u * 1000u) / 1000u) < 1u ? 1u : (TickType_t)((2u * 1000u) / 1000u));

    else
      pxSocket->u.xTCP.usTimeout = (uint16_t)((TickType_t)((20u * 1000u) / 1000u) < 1u ? 1u : (TickType_t)((20u * 1000u) / 1000u));
    if(xTCPWindowLoggingLevel >= 2)
    {
      if(!((unsigned int)pxSocket->usLocalPort == 23u))
        while((_Bool)0)
          ;

    }

    *ppxNetworkBuffer = ((NetworkBufferDescriptor_t *)NULL);
    xSendLength = 0;
  }

  else
    if(!(pxSocket->u.xTCP.pxAckMessage == ((NetworkBufferDescriptor_t *)NULL)))
    {
      if(!(pxSocket->u.xTCP.pxAckMessage == *ppxNetworkBuffer))
        vReleaseNetworkBufferAndDescriptor(pxSocket->u.xTCP.pxAckMessage);

      pxSocket->u.xTCP.pxAckMessage = ((NetworkBufferDescriptor_t *)NULL);
    }

  if(!(xSendLength == 0))
  {
    if(xTCPWindowLoggingLevel >= 2)
    {
      if(!((unsigned int)pxSocket->usLocalPort == 23u))
        while((_Bool)0)
          ;

    }

    prvTCPReturnPacket(pxSocket, *ppxNetworkBuffer, (uint32_t)xSendLength, 0);
  }

  return xSendLength;
}

// prvSendData$link1
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1102
static MQTTReturnCode_t prvSendData$link1(MQTTContext_t *pxMQTTContext, const uint8_t * const pucData, uint32_t ulDataLength)
{
  MQTTReturnCode_t xReturnCode=/*enum*/eMQTTSendFailed;
  uint32_t return_value=pxMQTTContext->pxMQTTSendFxn(pxMQTTContext->pvSendContext, pucData, ulDataLength);
  if(return_value == ulDataLength)
  {
    xReturnCode = /*enum*/eMQTTSuccess;
    pxMQTTContext->xLastSentMessageTimestamp=prvGetCurrentTickCount(pxMQTTContext);
    pxMQTTContext->ulNextPeriodicInvokeTicks = pxMQTTContext->ulKeepAliveActualIntervalTicks;
  }

  return xReturnCode;
}

// prvSendMessageToGGC
// file ..\..\..\common\greengrass_connectivity\aws_greengrass_discovery_demo.c line 92
static void prvSendMessageToGGC(GGD_HostAddressData_t *pxHostAddressData)
{
  const char *pcTopic="freertos/demos/ggd";
  MQTTAgentPublishParams_t xPublishParams;
  MQTTAgentReturnCode_t xReturnCode;
  uint32_t ulMessageCounter;
  char cBuffer[500ll];
  BaseType_t return_value_prvMQTTConnect=prvMQTTConnect(pxHostAddressData);
  if(return_value_prvMQTTConnect == 1)
  {
    xPublishParams.xQoS = /*enum*/eMQTTQoS0;
    xPublishParams.pucTopic = (const uint8_t *)pcTopic;
    size_t return_value_strlen=strlen(pcTopic);
    xPublishParams.usTopicLength = (uint16_t)return_value_strlen;
    ulMessageCounter = 0u;
    for( ; !(ulMessageCounter >= 3u); ulMessageCounter = ulMessageCounter + 1u)
    {
      signed int return_value_sprintf=sprintf(cBuffer, "{\"message\":\"Hello #%lu from Amazon FreeRTOS to Greengrass Core.\"}", (unsigned long int)ulMessageCounter);
      xPublishParams.ulDataLength = (uint32_t)return_value_sprintf;
      xPublishParams.pvData = (const void *)cBuffer;
      xReturnCode=MQTT_AGENT_Publish(xMQTTClientHandle, &xPublishParams, xMaxCommandTime);
      if(!((signed int)xReturnCode == 0))
        vLoggingPrintf("mqtt_client - Failure to publish \n");

      vTaskDelay(xTimeBetweenPublish);
    }
    vLoggingPrintf("Disconnecting from broker.\r\n");
    MQTTAgentReturnCode_t return_value_MQTT_AGENT_Disconnect=MQTT_AGENT_Disconnect(xMQTTClientHandle, xMaxCommandTime);
    if((signed int)return_value_MQTT_AGENT_Disconnect == 0)
    {
      vLoggingPrintf("Disconnected from the broker.\r\n");
      MQTTAgentReturnCode_t return_value_MQTT_AGENT_Delete=MQTT_AGENT_Delete(xMQTTClientHandle);
      if((signed int)return_value_MQTT_AGENT_Delete == 0)
        vLoggingPrintf("Deleted Client.\r\n");

      else
        vLoggingPrintf("ERROR:  MQTT_AGENT_Delete() Failed.\r\n");
    }

    else
      vLoggingPrintf("ERROR:  Did not disconnected from the broker.\r\n");
  }

}

// prvServerConnectionInstance
// file ..\..\..\common\tcp\aws_simple_tcp_echo_server.c line 160
static void prvServerConnectionInstance(void *pvParameters)
{
  int32_t lBytes;
  int32_t lSent;
  int32_t lTotalSent;
  uint8_t cReceivedString[1160ll];
  Socket_t xConnectedSocket;
  TickType_t xTimeOnShutdown;
  ulConnectionCount = ulConnectionCount + 1u;
  xConnectedSocket = (Socket_t)pvParameters;
  static const TickType_t prvServerConnectionInstance$$1$$xReceiveTimeOut=(TickType_t)((5000u * 1000u) / 1000u);
  FreeRTOS_setsockopt(xConnectedSocket, 0, 0, (const void *)&prvServerConnectionInstance$$1$$xReceiveTimeOut, sizeof(const TickType_t) /*4ull*/ );
  static const TickType_t prvServerConnectionInstance$$1$$xSendTimeOut=(TickType_t)((5000u * 1000u) / 1000u);
  FreeRTOS_setsockopt(xConnectedSocket, 0, 1, (const void *)&prvServerConnectionInstance$$1$$xSendTimeOut, sizeof(const TickType_t) /*4ull*/ );
  while((_Bool)1)
  {
    memset((void *)cReceivedString, 0x0, sizeof(uint8_t [1160ll]) /*1160ull*/ );
    lBytes=FreeRTOS_recv(xConnectedSocket, (void *)cReceivedString, sizeof(uint8_t [1160ll]) /*1160ull*/ , 0);
    if(lBytes >= 0)
    {
      lSent = 0;
      lTotalSent = 0;
      for( ; lSent >= 0 && !(lTotalSent >= lBytes); lTotalSent = lTotalSent + lSent)
        lSent=FreeRTOS_send(xConnectedSocket, (const void *)cReceivedString, (size_t)(lBytes - lTotalSent), 0);
      if(!(lSent >= 0))
        break;

    }

    else
      break;
  }
  FreeRTOS_shutdown(xConnectedSocket, 2);
  xTimeOnShutdown=xTaskGetTickCount();
  TickType_t return_value_xTaskGetTickCount;
  do
  {
    BaseType_t return_value_FreeRTOS_recv=FreeRTOS_recv(xConnectedSocket, (void *)cReceivedString, (size_t)((1200u - 20u) - 20u), 0);
    if(!(return_value_FreeRTOS_recv >= 0))
      break;

    return_value_xTaskGetTickCount=xTaskGetTickCount();
  }
  while(!(return_value_xTaskGetTickCount + -xTimeOnShutdown >= 5000u));
  FreeRTOS_closesocket(xConnectedSocket);
  vTaskDelete(NULL);
}

// prvSessionPointerFromHandle
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 149
P11SessionPtr_t prvSessionPointerFromHandle(CK_SESSION_HANDLE xSession)
{
  return (P11SessionPtr_t)xSession;
}

// prvSetImageState
// file ..\..\..\..\lib\ota\portable\pc\windows\aws_ota_pal.c line 115
static OTA_Err_t prvSetImageState(OTA_ImageState_t eState)
{
  (void)eState;
  return 0u;
}

// prvSetOptions
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 2204
static UBaseType_t prvSetOptions(FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxNetworkBuffer)
{
  TCPPacket_t *pxTCPPacket=(TCPPacket_t *)pxNetworkBuffer->pucEthernetBuffer;
  TCPHeader_t *pxTCPHeader=&pxTCPPacket->xTCPHeader;
  TCPWindow_t *pxTCPWindow=&pxSocket->u.xTCP.xTCPWindow;
  UBaseType_t uxOptionsLength=(UBaseType_t)pxTCPWindow->ucOptionLength;
  if(!(uxOptionsLength == 0u))
  {
    if(xTCPWindowLoggingLevel >= 0)
      while((_Bool)0)
        ;

    memcpy((void *)pxTCPHeader->ucOptdata, (const void *)pxTCPWindow->ulOptionsData, (size_t)uxOptionsLength);
    pxTCPHeader->ucTCPOffset = (uint8_t)(20u + uxOptionsLength << 2);
  }

  else
    if((signed int)pxSocket->u.xTCP.ucTCPState >= 5)
    {
      if(!((unsigned int)pxSocket->u.xTCP.bits.bMssChange == 0u))
      {
        pxSocket->u.xTCP.bits.bMssChange = 0u;
        if(xTCPWindowLoggingLevel >= 0)
          while((_Bool)0)
            ;

        pxTCPHeader->ucOptdata[0ll] = 2;
        pxTCPHeader->ucOptdata[1ll] = 4;
        pxTCPHeader->ucOptdata[2ll] = (uint8_t)((signed int)pxSocket->u.xTCP.usCurMSS >> 8);
        pxTCPHeader->ucOptdata[3ll] = (uint8_t)((unsigned int)pxSocket->u.xTCP.usCurMSS & 0xFFu);
        uxOptionsLength = 4u;
        pxTCPHeader->ucTCPOffset = (uint8_t)(20u + uxOptionsLength << 2);
      }

    }

  return uxOptionsLength;
}

// prvSetSubscribedFlag
// file ..\..\..\..\lib\shadow\aws_shadow.c line 1296
static void prvSetSubscribedFlag(ShadowClient_t * const pxShadowClient, ShadowOperationName_t xOperationName, BaseType_t ucValue)
{
  switch((signed int)xOperationName)
  {
    case 0:
    {
      pxShadowClient->xUpdateSubscribed = ucValue;
      break;
    }
    case 1:
    {
      pxShadowClient->xGetSubscribed = ucValue;
      break;
    }
    case 2:
    {
      pxShadowClient->xDeleteSubscribed = ucValue;
      break;
    }
    default:
      ;
  }
}

// prvSetSynAckOptions
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 1356
static UBaseType_t prvSetSynAckOptions(FreeRTOS_Socket_t *pxSocket, TCPPacket_t *pxTCPPacket)
{
  TCPHeader_t *pxTCPHeader=&pxTCPPacket->xTCPHeader;
  uint16_t usMSS=pxSocket->u.xTCP.usInitMSS;
  UBaseType_t uxOptionsLength;
  pxTCPHeader->ucOptdata[0ll] = 2;
  pxTCPHeader->ucOptdata[1ll] = 4;
  pxTCPHeader->ucOptdata[2ll] = (uint8_t)((signed int)usMSS >> 8);
  pxTCPHeader->ucOptdata[3ll] = (uint8_t)((unsigned int)usMSS & 0xFFu);
  pxSocket->u.xTCP.ucMyWinScaleFactor=prvWinScaleFactor(pxSocket);
  pxTCPHeader->ucOptdata[4ll] = 1;
  pxTCPHeader->ucOptdata[5ll] = 3;
  pxTCPHeader->ucOptdata[6ll] = 3;
  pxTCPHeader->ucOptdata[7ll] = (uint8_t)pxSocket->u.xTCP.ucMyWinScaleFactor;
  uxOptionsLength = 8u;
  pxTCPHeader->ucOptdata[(signed long long int)(uxOptionsLength + 0u)] = 1;
  pxTCPHeader->ucOptdata[(signed long long int)(uxOptionsLength + 1u)] = 1;
  pxTCPHeader->ucOptdata[(signed long long int)(uxOptionsLength + 2u)] = 4;
  pxTCPHeader->ucOptdata[(signed long long int)(uxOptionsLength + 3u)] = 2;
  uxOptionsLength = uxOptionsLength + 4u;
  return uxOptionsLength;
}

// prvSetupConnection
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 847
static BaseType_t prvSetupConnection(const MQTTEventData_t * const pxEventData)
{
  SocketsSockaddr_t xMQTTServerAddress={ .ucLength=0, .ucSocketDomain=0, .usPort=0, .ulAddress=0u };
  BaseType_t xStatus=1;
  size_t xURLLength;
  MQTTBrokerConnection_t *pxConnection=&xMQTTConnections[(signed long long int)pxEventData->uxBrokerNumber];
  char *ppcAlpns[1ll]={ "x-amzn-mqtt-ca" };
  if(!(pxConnection->xSocket == (Socket_t)4294967295u))
    vAssertCalled("..\\..\\..\\..\\lib\\mqtt\\aws_mqtt_agent.c", 857u);

  xURLLength=strlen(pxEventData->u.pxConnectParams->pcURL);
  if(!(xURLLength >= 254ull))
  {
    if(!((0x4 & pxEventData->u.pxConnectParams->xFlags) == 0))
      xMQTTServerAddress.usPort = (uint16_t)(443 << 8u | 443 >> 8u);

    else
      xMQTTServerAddress.usPort = (uint16_t)((signed int)pxEventData->u.pxConnectParams->usPort << 8u | (signed int)pxEventData->u.pxConnectParams->usPort >> 8u);
    xMQTTServerAddress.ulAddress=SOCKETS_GetHostByName(pxEventData->u.pxConnectParams->pcURL);
    xMQTTServerAddress.ucSocketDomain = 2;
    pxConnection->xSocket=SOCKETS_Socket(2, 1, 6);
    if(!(pxConnection->xSocket == (Socket_t)4294967295u))
    {
      SOCKETS_SetSockOpt(pxConnection->xSocket, 0, 17, (void *)prvMQTTClientSocketWakeupCallback, sizeof(void (*)(Socket_t)) /*8ull*/ );
      if((1ul & pxConnection->uxFlags) == 1ul)
      {
        int32_t return_value_SOCKETS_SetSockOpt=SOCKETS_SetSockOpt(pxConnection->xSocket, 0, 8, NULL, 0ull);
        if(!(return_value_SOCKETS_SetSockOpt == 0))
          xStatus = 0;

        if(xStatus == 1)
        {
          if(!(pxEventData->u.pxConnectParams->pcCertificate == ((char *)NULL)))
          {
            int32_t return_value_SOCKETS_SetSockOpt$0=SOCKETS_SetSockOpt(pxConnection->xSocket, 0, 7, (const void *)pxEventData->u.pxConnectParams->pcCertificate, (size_t)pxEventData->u.pxConnectParams->ulCertificateSize);
            if(!(return_value_SOCKETS_SetSockOpt$0 == 0))
              xStatus = 0;

          }

        }

        if(xStatus == 1)
        {
          if((0x1 & pxEventData->u.pxConnectParams->xFlags) == 0)
          {
            if(pxEventData->u.pxConnectParams->xURLIsIPAddress == 0)
            {
              int32_t return_value_SOCKETS_SetSockOpt$1=SOCKETS_SetSockOpt(pxConnection->xSocket, 0, 6, (const void *)pxEventData->u.pxConnectParams->pcURL, 1ull + xURLLength);
              if(!(return_value_SOCKETS_SetSockOpt$1 == 0))
                xStatus = 0;

            }

          }

        }

        if(xStatus == 1)
        {
          if(!((0x4 & pxEventData->u.pxConnectParams->xFlags) == 0))
          {
            int32_t return_value_SOCKETS_SetSockOpt$2=SOCKETS_SetSockOpt(pxConnection->xSocket, 0, 10, (const void *)ppcAlpns, sizeof(char *[1ll]) /*8ull*/  / sizeof(char *) /*8ull*/ );
            if(!(return_value_SOCKETS_SetSockOpt$2 == 0))
              xStatus = 0;

          }

        }

      }

      if(xStatus == 1)
      {
        int32_t return_value_SOCKETS_Connect=SOCKETS_Connect(pxConnection->xSocket, &xMQTTServerAddress, (uint32_t)sizeof(SocketsSockaddr_t) /*8u*/ );
        if(!(return_value_SOCKETS_Connect == 0))
          xStatus = 0;

      }

      if(xStatus == 1)
        SOCKETS_SetSockOpt(pxConnection->xSocket, 0, 9, NULL, 0ull);

      else
        prvGracefulSocketClose(pxConnection);
    }

  }

  else
  {
    vLoggingPrintf("Malformed URL %s.\r\n", pxEventData->u.pxConnectParams->pcURL);
    xStatus = 0;
  }
  return xStatus;
}

// prvSetupPkcs11SigningForMbedTls
// file ..\..\..\..\lib\pkcs11\mbedtls\aws_pkcs11_mbedtls.c line 213
static CK_RV prvSetupPkcs11SigningForMbedTls(P11SessionPtr_t pxSessionObj, P11KeyPtr_t pxKeyObj)
{
  memcpy((void *)&pxKeyObj->xMbedPkInfo, (const void *)pxKeyObj->xMbedPkCtx.pk_info, sizeof(mbedtls_pk_info_t) /*96ull*/ );
  pxKeyObj->pfnSavedMbedSign = pxKeyObj->xMbedPkInfo.sign_func;
  pxKeyObj->xMbedPkInfo.sign_func = (signed int (*)(void *, mbedtls_md_type_t, const unsigned char *, size_t, unsigned char *, size_t *, signed int (*)(void *, unsigned char *, size_t), void *))prvPrivateKeySigningCallback;
  pxKeyObj->xMbedPkCtx.pk_info = &pxKeyObj->xMbedPkInfo;
  pxKeyObj->pvSavedMbedPkCtx = pxKeyObj->xMbedPkCtx.pk_ctx;
  pxKeyObj->xMbedPkCtx.pk_ctx = (void *)pxSessionObj;
  return 0x0ul;
}

// prvShadowClientCreateConnect
// file ..\..\..\common\shadow\aws_shadow_lightbulb_on_off.c line 331
static ShadowReturnCode_t prvShadowClientCreateConnect(void)
{
  MQTTAgentConnectParams_t xConnectParams;
  ShadowCreateParams_t xCreateParams;
  ShadowReturnCode_t xReturn;
  xCreateParams.xMQTTClientType = /*enum*/eDedicatedMQTTClient;
  xReturn=SHADOW_ClientCreate(&xClientHandle, &xCreateParams);
  if((signed int)xReturn == 0)
  {
    memset((void *)&xConnectParams, 0x0, sizeof(MQTTAgentConnectParams_t) /*72ull*/ );
    xConnectParams.pcURL = clientcredentialMQTT_BROKER_ENDPOINT$link4;
    xConnectParams.usPort = 8883;
    xConnectParams.xFlags = 0x2 | 0x4;
    xConnectParams.pcCertificate = ((char *)NULL);
    xConnectParams.ulCertificateSize = 0u;
    xConnectParams.pxCallback = ((MQTTAgentCallback_t)NULL);
    xConnectParams.pvUserData = (void *)&xClientHandle;
    xConnectParams.pucClientId = (const uint8_t *)"Paste AWS IoT Thing name here.";
    size_t return_value_strlen=strlen("Paste AWS IoT Thing name here.");
    xConnectParams.usClientIdLength = (uint16_t)return_value_strlen;
    xReturn=SHADOW_ClientConnect(xClientHandle, &xConnectParams, (TickType_t)((30000ul * 1000u) / 1000u));
    if(!((signed int)xReturn == 0))
      vLoggingPrintf("Shadow_ClientConnect unsuccessful, returned %d.\r\n", xReturn);

  }

  else
    vLoggingPrintf("Shadow_ClientCreate unsuccessful, returned %d.\r\n", xReturn);
  return xReturn;
}

// prvShadowDeleteCallback
// file ..\..\..\..\lib\shadow\aws_shadow.c line 1070
static void prvShadowDeleteCallback(BaseType_t xShadowClientID, ShadowReturnCode_t xResult, const char * const pcData, uint32_t ulDataLength)
{
  ShadowClient_t *pxShadowClient=&pxShadowClients[(signed long long int)xShadowClientID];
  pxShadowClient->xOperationResult = xResult;
  if((signed int)xResult == 2)
    pxShadowClient->xOperationResult=prvGetErrorCodeAndMessage(pcData, ulDataLength, xShadowClientID, "delete");

  BaseType_t return_value_xQueueGenericSend=xQueueGenericSend((QueueHandle_t)pxShadowClient->xCallbackSemaphore, NULL, 0u, 0);
  if(!(return_value_xQueueGenericSend == 1))
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1088u);

}

// prvShadowGetCallback
// file ..\..\..\..\lib\shadow\aws_shadow.c line 1036
static void prvShadowGetCallback(BaseType_t xShadowClientID, ShadowReturnCode_t xResult, ShadowOperationParams_t * const pxParams, const char * const pcData, uint32_t ulDataLength, MQTTBufferHandle_t xBuffer)
{
  ShadowClient_t *pxShadowClient=&pxShadowClients[(signed long long int)xShadowClientID];
  pxShadowClient->xOperationResult = xResult;
  if((signed int)xResult == 0)
  {
    pxParams->pcData = pcData;
    pxParams->ulDataLength = ulDataLength;
    pxParams->xBuffer = xBuffer;
  }

  else
  {
    pxShadowClient->xOperationResult=prvGetErrorCodeAndMessage(pcData, ulDataLength, xShadowClientID, "get");
    pxParams->pcData = ((const char *)NULL);
    pxParams->ulDataLength = 0u;
  }
  BaseType_t return_value_xQueueGenericSend=xQueueGenericSend((QueueHandle_t)pxShadowClient->xCallbackSemaphore, NULL, 0u, 0);
  if(!(return_value_xQueueGenericSend == 1))
    vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1066u);

}

// prvShadowInitTask
// file ..\..\..\common\shadow\aws_shadow_lightbulb_on_off.c line 428
static void prvShadowInitTask(void *pvParameters)
{
  uint8_t ucTask;
  ShadowReturnCode_t xReturn;
  ShadowOperationParams_t xOperationParams;
  ShadowCallbackParams_t xCallbackParams;
  (void)pvParameters;
  xUpdateQueue=xQueueGenericCreateStatic((const UBaseType_t)(4 * 2), (const UBaseType_t)sizeof(ShadowQueueData_t) /*144ul*/ , ucQueueStorageArea, &xStaticQueue, 0);
  xReturn=prvShadowClientCreateConnect();
  if((signed int)xReturn == 0)
  {
    xOperationParams.pcThingName = "Paste AWS IoT Thing name here.";
    xOperationParams.xQoS = /*enum*/eMQTTQoS0;
    xOperationParams.pcData = ((const char *)NULL);
    xOperationParams.ucKeepSubscriptions = 0;
    xReturn=SHADOW_Delete(xClientHandle, &xOperationParams, (TickType_t)((30000ul * 1000u) / 1000u));
    if((signed int)xReturn == 0 || (signed int)xReturn == 404)
    {
      xCallbackParams.pcThingName = "Paste AWS IoT Thing name here.";
      xCallbackParams.xShadowUpdatedCallback = ((ShadowUpdatedCallback_t)NULL);
      xCallbackParams.xShadowDeletedCallback = ((ShadowDeletedCallback_t)NULL);
      xCallbackParams.xShadowDeltaCallback = prvDeltaCallback;
      xReturn=SHADOW_RegisterCallbacks(xClientHandle, &xCallbackParams, (TickType_t)((30000ul * 1000u) / 1000u));
    }

  }

  if((signed int)xReturn == 0)
  {
    vLoggingPrintf("Shadow client initialized.\r\n");
    xTaskCreate(prvUpdateQueueTask, "ShDemoUpdt", (const uint16_t)(60 * 5), NULL, 0u, ((TaskHandle_t * const )NULL));
    ucTask = 0;
    for( ; !((signed int)ucTask >= 4); ucTask = ucTask + 1)
    {
      snprintf((char *)(&xShadowTaskParamBuffer[(signed long long int)ucTask])->cTaskName, 15ull, "Shd-IOT-%d", ucTask);
      xTaskCreate(prvChangeDesiredTask, (const char *)(&xShadowTaskParamBuffer[(signed long long int)ucTask])->cTaskName, (const uint16_t)(60 * 4), (void *)&xShadowTaskParamBuffer[(signed long long int)ucTask], 0u, &xShadowTaskParamBuffer[(signed long long int)ucTask].xTaskHandle);
    }
  }

  else
    vLoggingPrintf("Failed to initialize Shadow client.\r\n");
  vTaskDelete(NULL);
}

// prvShadowMQTTCallback
// file ..\..\..\..\lib\shadow\aws_shadow.c line 715
static BaseType_t prvShadowMQTTCallback(void *pvUserData, const MQTTAgentCallbackParams_t * const pxCallbackParams)
{
  BaseType_t xOperationMatched=0;
  ShadowClient_t *pxShadowClient;
  const MQTTPublishData_t *pxPublishData;
  ShadowOperationName_t xOperationName;
  ShadowReturnCode_t xResult;
  const CallbackCatalogEntry_t *pxCallbackCatalogEntry;
  BaseType_t xReturn=0;
  BaseType_t xCompareLen;
  BaseType_t xShadowClientID=*((BaseType_t *)pvUserData);
  pxShadowClient = &pxShadowClients[(signed long long int)xShadowClientID];
  size_t return_value_strlen$0;
  if((signed int)pxCallbackParams->xMQTTEvent == 0)
  {
    pxPublishData = &pxCallbackParams->u.xPublishData;
    UBaseType_t return_value_uxQueueMessagesWaiting=uxQueueMessagesWaiting((QueueHandle_t)pxShadowClient->xOperationMutex);
    if((uint16_t)return_value_uxQueueMessagesWaiting == 0)
    {
      size_t return_value_strlen=strlen((const char *)pxShadowClient->pucTopicBuffer);
      BaseType_t tmp_if_expr;
      if(!((BaseType_t)return_value_strlen >= (BaseType_t)pxPublishData->usTopicLength))
      {
        return_value_strlen$0=strlen((const char *)pxShadowClient->pucTopicBuffer);
        tmp_if_expr = (BaseType_t)return_value_strlen$0;
      }

      else
        tmp_if_expr = (BaseType_t)pxPublishData->usTopicLength;
      xCompareLen = (BaseType_t)tmp_if_expr;
      signed int return_value_strncmp=strncmp((const char *)pxPublishData->pucTopic, (const char *)pxShadowClient->pucTopicBuffer, (size_t)xCompareLen);
      if(return_value_strncmp == 0)
      {
        xOperationName = pxShadowClient->pxOperationData->xOperationInProgress;
        xResult=prvParseShadowOperationStatus(pxPublishData->pucTopic, pxPublishData->usTopicLength);
        if(!((signed int)xOperationName == 6) && !((signed int)xResult == 3))
        {
          xOperationMatched = 1;
          switch((signed int)xOperationName)
          {
            case 0:
            {
              prvShadowUpdateCallback(xShadowClientID, xResult, pxShadowClient->pxOperationData->pxOperationParams, (const char *)pxPublishData->pvData, pxPublishData->ulDataLength);
              break;
            }
            case 1:
            {
              prvShadowGetCallback(xShadowClientID, xResult, pxShadowClient->pxOperationData->pxOperationParams, (const char *)pxPublishData->pvData, pxPublishData->ulDataLength, pxPublishData->xBuffer);
              if((signed int)xResult == 0)
                xReturn = 1;

              break;
            }
            case 2:
            {
              prvShadowDeleteCallback(xShadowClientID, xResult, (const char *)pxPublishData->pvData, pxPublishData->ulDataLength);
              break;
            }
            default:
              ;
          }
        }

      }

    }

    if(xOperationMatched == 0)
    {
      pxCallbackCatalogEntry=prvMatchCallbackTopic(pxShadowClient, pxPublishData->pucTopic, pxPublishData->usTopicLength, &xOperationName);
      if(!(pxCallbackCatalogEntry == ((const CallbackCatalogEntry_t *)NULL)))
        switch((signed int)xOperationName)
        {
          case 3:
            xReturn=pxCallbackCatalogEntry->xCallbackInfo.xShadowUpdatedCallback(pvUserData, pxCallbackCatalogEntry->xCallbackInfo.pcThingName, (const char *)pxPublishData->pvData, pxPublishData->ulDataLength, pxPublishData->xBuffer);
          case 4:
            xReturn=pxCallbackCatalogEntry->xCallbackInfo.xShadowDeltaCallback(pvUserData, pxCallbackCatalogEntry->xCallbackInfo.pcThingName, (const char *)pxPublishData->pvData, pxPublishData->ulDataLength, pxPublishData->xBuffer);
          case 5:
            pxCallbackCatalogEntry->xCallbackInfo.xShadowDeletedCallback(pvUserData, pxCallbackCatalogEntry->xCallbackInfo.pcThingName);
        }

    }

  }

  else
    if((signed int)pxCallbackParams->xMQTTEvent == 1)
    {
      vLoggingPrintf("[Shadow %d] Warning: got an MQTT disconnect message.\r\n", xShadowClientID);
      prvSetSubscribedFlag(pxShadowClient, /*enum*/eShadowOperationUpdate, 0);
      prvSetSubscribedFlag(pxShadowClient, /*enum*/eShadowOperationGet, 0);
      prvSetSubscribedFlag(pxShadowClient, /*enum*/eShadowOperationDelete, 0);
    }

  return xReturn;
}

// prvShadowOperation
// file ..\..\..\..\lib\shadow\aws_shadow.c line 1137
static ShadowReturnCode_t prvShadowOperation(ShadowOperationCallParams_t *pxParams)
{
  ShadowReturnCode_t xReturn=2;
  MQTTAgentPublishParams_t xPublishParams;
  ShadowClient_t *pxShadowClient;
  TimeOutData_t xTimeOutData;
  ShadowOperationData_t xOperationData;
  MQTTAgentReturnCode_t xMQTTReturn;
  xTimeOutData.xTicksRemaining = pxParams->xTimeoutTicks;
  pxShadowClient = &pxShadowClients[(signed long long int)pxParams->xShadowClientID];
  BaseType_t return_value_xQueueSemaphoreTake$1=xQueueSemaphoreTake(pxShadowClient->xOperationMutex, xTimeOutData.xTicksRemaining);
  if(return_value_xQueueSemaphoreTake$1 == 1)
  {
    uint8_t return_value_prvGetSubscribedFlag=prvGetSubscribedFlag(pxShadowClient, pxParams->xOperationName);
    if((BaseType_t)return_value_prvGetSubscribedFlag == 0)
      xReturn=prvShadowSubscribeToAcceptedRejected(pxParams->xShadowClientID, pxParams->pxOperationParams->pcThingName, pxParams->pcOperationAcceptedTopic, pxParams->pcOperationRejectedTopic, &xTimeOutData);

    else
      xReturn = 0;
    if((signed int)xReturn == 0)
    {
      prvSetSubscribedFlag(pxShadowClient, pxParams->xOperationName, 1);
      BaseType_t return_value_xQueueSemaphoreTake=xQueueSemaphoreTake(pxShadowClient->xCallbackSemaphore, xTimeOutData.xTicksRemaining);
      if(!(return_value_xQueueSemaphoreTake == 1))
        vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1179u);

      xPublishParams.usTopicLength=prvCreateTopic((char *)pxShadowClient->pucTopicBuffer, (const uint16_t)(128 + (signed int)sizeof(char [39ll]) /*39*/ ), pxParams->pcOperationTopic, pxParams->pxOperationParams->pcThingName);
      xPublishParams.pucTopic = pxShadowClient->pucTopicBuffer;
      xPublishParams.pvData = (const void *)pxParams->pcPublishMessage;
      xPublishParams.ulDataLength = pxParams->ulPublishMessageLength;
      xPublishParams.xQoS = pxParams->pxOperationParams->xQoS;
      xOperationData.xOperationInProgress = pxParams->xOperationName;
      xOperationData.pxOperationParams = pxParams->pxOperationParams;
      pxShadowClient->pxOperationData = &xOperationData;
      xMQTTReturn=MQTT_AGENT_Publish(pxShadowClient->xMQTTClient, &xPublishParams, xTimeOutData.xTicksRemaining);
      xReturn=prvConvertMQTTReturnCode(xMQTTReturn, (ShadowClientHandle_t)pxParams->xShadowClientID, "Publish to operation topic");
      if((signed int)xReturn == 0)
      {
        BaseType_t return_value_xQueueSemaphoreTake$0=xQueueSemaphoreTake(pxShadowClient->xCallbackSemaphore, xTimeOutData.xTicksRemaining);
        if(!(return_value_xQueueSemaphoreTake$0 == 1))
        {
          vLoggingPrintf("[Shadow %d] Timeout waiting on %s accepted/rejected.\r\n", pxParams->xShadowClientID, pxParams->pcOperationName);
          xReturn = 1;
        }

        else
          xReturn = pxShadowClient->xOperationResult;
      }

      BaseType_t return_value_xQueueGenericSend=xQueueGenericSend((QueueHandle_t)pxShadowClient->xCallbackSemaphore, NULL, 0u, 0);
      if(!(return_value_xQueueGenericSend == 1))
        vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1228u);

    }

    if(pxParams->pxOperationParams->ucKeepSubscriptions == 0)
    {
      xTimeOutData.xTicksRemaining = xTimeOutData.xTicksRemaining > (TickType_t)((5000ul * 1000u) / 1000u) ? xTimeOutData.xTicksRemaining : (TickType_t)((5000ul * 1000u) / 1000u);
      if((signed int)pxParams->xOperationName == 2)
      {
        prvCreateTopic((char *)pxShadowClient->pucTopicBuffer, (const uint16_t)(128 + (signed int)sizeof(char [39ll]) /*39*/ ), "$aws/things/%s/shadow/delete/accepted", pxParams->pxOperationParams->pcThingName);
        size_t return_value_strlen=strlen((const char *)pxShadowClient->pucTopicBuffer);
        const CallbackCatalogEntry_t *return_value_prvMatchCallbackTopic=prvMatchCallbackTopic(pxShadowClient, pxShadowClient->pucTopicBuffer, (uint16_t)return_value_strlen, ((ShadowOperationName_t *)NULL));
        if(return_value_prvMatchCallbackTopic == ((const CallbackCatalogEntry_t *)NULL))
        {
          ShadowReturnCode_t return_value_prvShadowUnsubscribeFromAcceptedRejected=prvShadowUnsubscribeFromAcceptedRejected(pxParams->xShadowClientID, pxParams->pxOperationParams->pcThingName, ((const char *)NULL), pxParams->pcOperationRejectedTopic, &xTimeOutData);
          if((signed int)return_value_prvShadowUnsubscribeFromAcceptedRejected == 0)
            prvSetSubscribedFlag(pxShadowClient, pxParams->xOperationName, 0);

        }

      }

      else
      {
        ShadowReturnCode_t return_value_prvShadowUnsubscribeFromAcceptedRejected$0=prvShadowUnsubscribeFromAcceptedRejected(pxParams->xShadowClientID, pxParams->pxOperationParams->pcThingName, pxParams->pcOperationAcceptedTopic, pxParams->pcOperationRejectedTopic, &xTimeOutData);
        if((signed int)return_value_prvShadowUnsubscribeFromAcceptedRejected$0 == 0)
          prvSetSubscribedFlag(pxShadowClient, pxParams->xOperationName, 0);

      }
    }

    pxShadowClient->pxOperationData = ((ShadowOperationData_t *)NULL);
    pxShadowClient->xOperationResult = 0;
    memset((void *)pxShadowClient->pucTopicBuffer, 0, (size_t)(128 + (signed int)sizeof(char [39ll]) /*39*/ ));
    BaseType_t return_value_xQueueGenericSend$0=xQueueGenericSend((QueueHandle_t)pxShadowClient->xOperationMutex, NULL, 0u, 0);
    if(!(return_value_xQueueGenericSend$0 == 1))
      vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1288u);

  }

  return xReturn;
}

// prvShadowSubscribeToAcceptedRejected
// file ..\..\..\..\lib\shadow\aws_shadow.c line 578
static ShadowReturnCode_t prvShadowSubscribeToAcceptedRejected(BaseType_t xShadowClientID, const char * const pcThingName, const char * const pcAcceptedTopic, const char * const pcRejectedTopic, TimeOutData_t * const pxTimeOutData)
{
  ShadowReturnCode_t xReturn;
  ShadowClient_t *pxShadowClient;
  MQTTAgentSubscribeParams_t xSubscribeParams;
  MQTTAgentUnsubscribeParams_t xUnsubscribeParams;
  MQTTAgentReturnCode_t xMQTTReturn;
  TickType_t xTimeoutTicks;
  pxShadowClient = &pxShadowClients[(signed long long int)xShadowClientID];
  xSubscribeParams.pucTopic = pxShadowClient->pucTopicBuffer;
  xSubscribeParams.xQoS = /*enum*/eMQTTQoS1;
  xSubscribeParams.pvPublishCallbackContext = NULL;
  xSubscribeParams.pxPublishCallback = ((MQTTPublishCallback_t)NULL);
  xSubscribeParams.usTopicLength=prvCreateTopic((char *)pxShadowClient->pucTopicBuffer, (const uint16_t)(128 + (signed int)sizeof(char [39ll]) /*39*/ ), pcAcceptedTopic, pcThingName);
  xMQTTReturn=MQTT_AGENT_Subscribe(pxShadowClient->xMQTTClient, &xSubscribeParams, pxTimeOutData->xTicksRemaining);
  xReturn=prvConvertMQTTReturnCode(xMQTTReturn, (ShadowClientHandle_t)xShadowClientID, "Subscribe to accepted topic");
  if((signed int)xReturn == 0)
  {
    xSubscribeParams.usTopicLength=prvCreateTopic((char *)pxShadowClient->pucTopicBuffer, (const uint16_t)(128 + (signed int)sizeof(char [39ll]) /*39*/ ), pcRejectedTopic, pcThingName);
    xMQTTReturn=MQTT_AGENT_Subscribe(pxShadowClient->xMQTTClient, &xSubscribeParams, pxTimeOutData->xTicksRemaining);
    xReturn=prvConvertMQTTReturnCode(xMQTTReturn, (ShadowClientHandle_t)xShadowClientID, "Subscribe to rejected topic");
    if(!((signed int)xReturn == 0))
    {
      xUnsubscribeParams.usTopicLength=prvCreateTopic((char *)pxShadowClient->pucTopicBuffer, (const uint16_t)(128 + (signed int)sizeof(char [39ll]) /*39*/ ), pcAcceptedTopic, pcThingName);
      xUnsubscribeParams.pucTopic = pxShadowClient->pucTopicBuffer;
      xTimeoutTicks = (TickType_t)((5000ul * 1000u) / 1000u);
      MQTT_AGENT_Unsubscribe(pxShadowClient->xMQTTClient, &xUnsubscribeParams, xTimeoutTicks);
      prvConvertMQTTReturnCode(xMQTTReturn, (ShadowClientHandle_t)xShadowClientID, "Cleanup: Unsubscribe from accepted topic");
    }

  }

  return xReturn;
}

// prvShadowUnsubscribeFromAcceptedRejected
// file ..\..\..\..\lib\shadow\aws_shadow.c line 659
static ShadowReturnCode_t prvShadowUnsubscribeFromAcceptedRejected(BaseType_t xShadowClientID, const char * const pcThingName, const char * const pcAcceptedTopic, const char * const pcRejectedTopic, TimeOutData_t * const pxTimeOutData)
{
  ShadowReturnCode_t xReturn=2;
  ShadowClient_t *pxShadowClient;
  MQTTAgentUnsubscribeParams_t xUnsubscribeParams;
  MQTTAgentReturnCode_t xMQTTReturn;
  pxShadowClient = &pxShadowClients[(signed long long int)xShadowClientID];
  xUnsubscribeParams.pucTopic = pxShadowClient->pucTopicBuffer;
  if(!(pcAcceptedTopic == ((const char *)NULL)))
  {
    xUnsubscribeParams.usTopicLength=prvCreateTopic((char *)pxShadowClient->pucTopicBuffer, (const uint16_t)(128 + (signed int)sizeof(char [39ll]) /*39*/ ), pcAcceptedTopic, pcThingName);
    xMQTTReturn=MQTT_AGENT_Unsubscribe(pxShadowClient->xMQTTClient, &xUnsubscribeParams, pxTimeOutData->xTicksRemaining);
    xReturn=prvConvertMQTTReturnCode(xMQTTReturn, (ShadowClientHandle_t)xShadowClientID, "Unsubscribe from accepted topic");
  }

  if(!(pcRejectedTopic == ((const char *)NULL)))
  {
    xUnsubscribeParams.usTopicLength=prvCreateTopic((char *)pxShadowClient->pucTopicBuffer, (const uint16_t)(128 + (signed int)sizeof(char [39ll]) /*39*/ ), pcRejectedTopic, pcThingName);
    xMQTTReturn=MQTT_AGENT_Unsubscribe(pxShadowClient->xMQTTClient, &xUnsubscribeParams, pxTimeOutData->xTicksRemaining);
    xReturn=prvConvertMQTTReturnCode(xMQTTReturn, (ShadowClientHandle_t)xShadowClientID, "Unsubscribe from rejected topic");
  }

  return xReturn;
}

// prvShadowUpdateCallback
// file ..\..\..\..\lib\shadow\aws_shadow.c line 996
static void prvShadowUpdateCallback(BaseType_t xShadowClientID, ShadowReturnCode_t xResult, const ShadowOperationParams_t * const pxParams, const char * const pcData, uint32_t ulDataLength)
{
  (void)pxParams;
  ShadowClient_t *pxShadowClient;
  BaseType_t xReturn;
  pxShadowClient = &pxShadowClients[(signed long long int)xShadowClientID];
  xReturn=SHADOW_JSONDocClientTokenMatch(pxParams->pcData, pxParams->ulDataLength, pcData, ulDataLength);
  if(xReturn == 1)
  {
    pxShadowClient->xOperationResult = xResult;
    if((signed int)xResult == 2)
      pxShadowClient->xOperationResult=prvGetErrorCodeAndMessage(pcData, ulDataLength, xShadowClientID, "update");

    BaseType_t return_value_xQueueGenericSend=xQueueGenericSend((QueueHandle_t)pxShadowClient->xCallbackSemaphore, NULL, 0u, 0);
    if(!(return_value_xQueueGenericSend == 1))
      vAssertCalled("..\\..\\..\\..\\lib\\shadow\\aws_shadow.c", 1030u);

  }

}

// prvSimulatedPeripheralTimer
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 126
static DWORD prvSimulatedPeripheralTimer(LPVOID lpParameter)
{
  TickType_t xMinimumWindowsBlockTime;
  TIMECAPS xTimeCaps;
  MMRESULT return_value_timeGetDevCaps=timeGetDevCaps(&xTimeCaps, (UINT)sizeof(TIMECAPS) /*8u*/ );
  if(return_value_timeGetDevCaps == 0u)
  {
    xMinimumWindowsBlockTime = (TickType_t)xTimeCaps.wPeriodMin;
    timeBeginPeriod(xTimeCaps.wPeriodMin);
    SetConsoleCtrlHandler(prvEndProcess, 1);
  }

  else
    xMinimumWindowsBlockTime = 20u;
  (void)lpParameter;
  while((_Bool)1)
  {
    if(xMinimumWindowsBlockTime >= 2u)
      Sleep(xMinimumWindowsBlockTime);

    else
      Sleep(1000u / 1000u);
    if(xPortRunning == 0)
      vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\portable\\MSVC-MingW\\port.c", 166u);

    WaitForSingleObject(pvInterruptEventMutex, 0xFFFFFFFFu);
    ulPendingInterrupts = ulPendingInterrupts | (volatile uint32_t)(1 << 1ul);
    if(ulCriticalNesting == 0u)
      SetEvent(pvInterruptEvent);

    ReleaseMutex(pvInterruptEventMutex);
  }
}

// prvSizeOfRemainingLength
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1848
static uint8_t prvSizeOfRemainingLength(uint32_t ulRemainingLength)
{
  uint8_t ucRemainingLengthFieldBytes=0;
  if(!(ulRemainingLength >= 128u))
    ucRemainingLengthFieldBytes = 1;

  else
    if(ulRemainingLength >= 128u && !(ulRemainingLength >= 16384u))
      ucRemainingLengthFieldBytes = 2;

    else
      if(ulRemainingLength >= 16384u && !(ulRemainingLength >= 2097152u))
        ucRemainingLengthFieldBytes = 3;

      else
        if(ulRemainingLength >= 2097152u && !(ulRemainingLength >= 268435456u))
          ucRemainingLengthFieldBytes = 4;

  return ucRemainingLengthFieldBytes;
}

// prvSkipNameField
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DNS.c line 750
static uint8_t * prvSkipNameField(uint8_t *pucByte, size_t xSourceLen)
{
  size_t xChunkLength;
  if(xSourceLen == 0ull)
    return ((uint8_t *)NULL);

  else
  {
    if((192 & (signed int)*pucByte) == 192)
    {
      if(xSourceLen >= 3ull)
        pucByte = pucByte + (signed long long int)sizeof(uint16_t) /*2ll*/ ;

      else
        pucByte = ((uint8_t *)NULL);
    }

    else
    {
      while(!((signed int)*pucByte == 0x0))
      {
        if(!(xSourceLen >= 2ull))
          break;

        xChunkLength = (size_t)((signed int)*pucByte + 1);
        if(!(xChunkLength >= xSourceLen))
        {
          xSourceLen = xSourceLen - xChunkLength;
          pucByte = pucByte + (signed long long int)xChunkLength;
        }

        else
        {
          pucByte = ((uint8_t *)NULL);
          break;
        }
      }
      if(!(pucByte == ((uint8_t *)NULL)))
      {
        if((signed int)*pucByte == 0x0)
          pucByte = pucByte + 1ll;

        else
          pucByte = ((uint8_t *)NULL);
      }

    }
    return pucByte;
  }
}

// prvSocketSetMSS
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 2869
static void prvSocketSetMSS(FreeRTOS_Socket_t *pxSocket)
{
  uint32_t ulMSS=(1200u - 20u) - 20u;
  if(!(((((0xFF0000ul & pxSocket->u.xTCP.ulRemoteIP) >> 8 | pxSocket->u.xTCP.ulRemoteIP >> 24 | (0xFF00ul & pxSocket->u.xTCP.ulRemoteIP) << 8 | pxSocket->u.xTCP.ulRemoteIP << 24) ^ xDefaultPartUDPPacketHeader.ulWords[5ll]) & xNetworkAddressing.ulNetMask) == 0ul))
    ulMSS=FreeRTOS_min_uint32$link2(1400u, ulMSS);

  while((_Bool)0)
    ;
  pxSocket->u.xTCP.usCurMSS = (uint16_t)ulMSS;
  pxSocket->u.xTCP.usInitMSS = pxSocket->u.xTCP.usCurMSS;
}

// prvSocketsGetCryptoSession
// file ..\..\..\..\lib\secure_sockets\portable\freertos_plus_tcp\aws_secure_sockets.c line 525
static CK_RV prvSocketsGetCryptoSession(CK_SESSION_HANDLE *pxSession, CK_FUNCTION_LIST_PTR_PTR ppxFunctionList)
{
  CK_RV xResult=0ul;
  CK_C_GetFunctionList pxCkGetFunctionList=((CK_C_GetFunctionList)NULL);
  CK_ULONG ulCount=1ul;
  CK_SLOT_ID xSlotId=0ul;
  vPortEnterCritical();
  static CK_FUNCTION_LIST_PTR pxPkcs11FunctionList=((CK_FUNCTION_LIST_PTR)NULL);
  static CK_SESSION_HANDLE xPkcs11Session=0ul;
  if(xPkcs11Session == 0u)
  {
    if(xResult == 0u)
    {
      pxCkGetFunctionList = C_GetFunctionList;
      xResult=pxCkGetFunctionList(&pxPkcs11FunctionList);
    }

    if(xResult == 0u)
      xResult=pxPkcs11FunctionList->C_Initialize(NULL);

    if(xResult == 0u)
      xResult=pxPkcs11FunctionList->C_GetSlotList(1, &xSlotId, &ulCount);

    if(xResult == 0u)
      xResult=pxPkcs11FunctionList->C_OpenSession(xSlotId, 0x4ul, NULL, ((CK_NOTIFY)NULL), &xPkcs11Session);

  }

  vPortExitCritical();
  *ppxFunctionList = pxPkcs11FunctionList;
  *pxSession = xPkcs11Session;
  return xResult;
}

// prvStartRequestTimer
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1018
static void prvStartRequestTimer(OTA_FileContext_t *C)
{
  BaseType_t lTimerStarted=0;
  if(C->pvRequestTimer == NULL)
  {
    C->pvRequestTimer=xTimerCreate("OTA_FW", (TickType_t)((2000u * 1000u) / 1000u), 0ul, (void *)C, prvRequestTimer_Callback);
    if(!(C->pvRequestTimer == NULL))
    {
      TickType_t return_value_xTaskGetTickCount=xTaskGetTickCount();
      lTimerStarted=xTimerGenericCommand(C->pvRequestTimer, 1, return_value_xTaskGetTickCount, ((BaseType_t *)NULL), 0u);
    }

  }

  else
  {
    TickType_t return_value_xTaskGetTickCount$0=xTaskGetTickCount();
    lTimerStarted=xTimerGenericCommand(C->pvRequestTimer, 2, return_value_xTaskGetTickCount$0, ((BaseType_t *)NULL), 0xFFFFFFFFul);
  }
  if(lTimerStarted == 0)
    vLoggingPrintf("[OTA] ERROR: RTOS call failed to reset or start the file request timer.\r\n");

}

// prvStopRequestTimer
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1045
static void prvStopRequestTimer(OTA_FileContext_t *C)
{
  if(!(C->pvRequestTimer == NULL))
  {
    xTimerGenericCommand(C->pvRequestTimer, 3, 0u, ((BaseType_t *)NULL), 0u);
    vLoggingPrintf("[OTA] Stopping the file request timer.\r\n");
  }

}

// prvStoreNotificationData
// file ..\..\..\..\lib\mqtt\aws_mqtt_agent.c line 799
static MQTTNotificationData_t * prvStoreNotificationData(MQTTBrokerConnection_t * const pxConnection, const MQTTEventData_t * const pxEventData)
{
  UBaseType_t x;
  MQTTNotificationData_t *pxNotificationData=((MQTTNotificationData_t *)NULL);
  x = 0ul;
  for( ; !(x >= 5ul); x = x + 1ul)
    if(pxConnection->xWaitingTasks[(signed long long int)x].xTaskToNotify == NULL)
    {
      pxNotificationData = &pxConnection->xWaitingTasks[(signed long long int)x];
      memcpy((void *)pxNotificationData, (const void *)&pxEventData->xNotificationData, sizeof(MQTTNotificationData_t) /*16ull*/ );
      break;
    }

  return pxNotificationData;
}

// prvStoreRxData
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 2127
static BaseType_t prvStoreRxData(FreeRTOS_Socket_t *pxSocket, uint8_t *pucRecvData, NetworkBufferDescriptor_t *pxNetworkBuffer, uint32_t ulReceiveLength)
{
  TCPPacket_t *pxTCPPacket=(TCPPacket_t *)pxNetworkBuffer->pucEthernetBuffer;
  TCPHeader_t *pxTCPHeader=&pxTCPPacket->xTCPHeader;
  TCPWindow_t *pxTCPWindow=&pxSocket->u.xTCP.xTCPWindow;
  uint32_t ulSequenceNumber;
  uint32_t ulSpace;
  int32_t lOffset;
  int32_t lStored;
  BaseType_t xResult=0;
  ulSequenceNumber = (uint32_t)((uint32_t)pxTCPHeader->ulSequenceNumber << 24 | ((uint32_t)pxTCPHeader->ulSequenceNumber & 0xFF00ul) << 8 | ((uint32_t)pxTCPHeader->ulSequenceNumber & 0xFF0000ul) >> 8 | (uint32_t)pxTCPHeader->ulSequenceNumber >> 24);
  _Bool tmp_if_expr;
  if(ulReceiveLength >= 1u)
    tmp_if_expr = (signed int)pxSocket->u.xTCP.ucTCPState >= 4 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr = (_Bool)0;
  if(tmp_if_expr)
  {
    if(!(pxSocket->u.xTCP.rxStream == ((const StreamBuffer_t *)NULL)))
    {
      size_t return_value_uxStreamBufferGetSpace=uxStreamBufferGetSpace$link2(pxSocket->u.xTCP.rxStream);
      ulSpace = (uint32_t)return_value_uxStreamBufferGetSpace;
    }

    else
      ulSpace = (uint32_t)pxSocket->u.xTCP.uxRxStreamSize;
    lOffset=lTCPWindowRxCheck(pxTCPWindow, ulSequenceNumber, ulReceiveLength, ulSpace);
    if(lOffset >= 0)
    {
      lStored=lTCPAddRxdata(pxSocket, (size_t)(uint32_t)lOffset, pucRecvData, ulReceiveLength);
      if(!(lStored == (int32_t)ulReceiveLength))
      {
        while((_Bool)0)
          ;
        prvTCPSendReset(pxNetworkBuffer);
        xResult = -1;
      }

    }

    if(xResult == 0)
    {
      if(pxTCPWindow->ulUserDataLength >= 1u)
      {
        lTCPAddRxdata(pxSocket, 0ull, ((const uint8_t *)NULL), pxTCPWindow->ulUserDataLength);
        pxTCPWindow->ulUserDataLength = 0u;
      }

    }

  }

  else
    pxTCPWindow->ucOptionLength = 0;
  return xResult;
}

// prvStoreSubscription
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1982
static MQTTBool_t prvStoreSubscription(MQTTContext_t *pxMQTTContext, const uint8_t * const pucTopic, uint16_t usTopicLength, void *pvPublishCallbackContext, MQTTPublishCallback_t pxPublishCallback)
{
  uint32_t x;
  MQTTBool_t xSubscriptionStored=/*enum*/eMQTTFalse;
  MQTTTopicFilterType_t xTopicFilterType;
  if(!(pxMQTTContext->xSubscriptionManager.ulInUseSubscriptions >= 8u))
  {
    if(!((signed int)usTopicLength >= 129))
    {
      xTopicFilterType=prvGetTopicFilterType(pucTopic, usTopicLength);
      if(!((signed int)xTopicFilterType == 0))
      {
        prvRemoveSubscription(pxMQTTContext, pucTopic, usTopicLength);
        x = 0u;
        for( ; !(x >= 8u); x = x + 1u)
          if((signed int)pxMQTTContext->xSubscriptionManager.xSubscriptions[(signed long long int)x].xInUse == 0)
          {
            pxMQTTContext->xSubscriptionManager.xSubscriptions[(signed long long int)x].xInUse = /*enum*/eMQTTTrue;
            memcpy((void *)pxMQTTContext->xSubscriptionManager.xSubscriptions[(signed long long int)x].ucTopicFilter, (const void *)pucTopic, (size_t)usTopicLength);
            pxMQTTContext->xSubscriptionManager.xSubscriptions[(signed long long int)x].usTopicFilterLength = usTopicLength;
            pxMQTTContext->xSubscriptionManager.xSubscriptions[(signed long long int)x].pvPublishCallbackContext = pvPublishCallbackContext;
            pxMQTTContext->xSubscriptionManager.xSubscriptions[(signed long long int)x].pxPublishCallback = pxPublishCallback;
            pxMQTTContext->xSubscriptionManager.xSubscriptions[(signed long long int)x].xTopicFilterType = xTopicFilterType;
            pxMQTTContext->xSubscriptionManager.ulInUseSubscriptions = pxMQTTContext->xSubscriptionManager.ulInUseSubscriptions + 1u;
            xSubscriptionStored = /*enum*/eMQTTTrue;
            break;
          }

      }

    }

  }

  return xSubscriptionStored;
}

// prvStringPublishSubscribe
// file ..\..\..\common\mqtt\aws_subscribe_publish_loop.c line 458
static BaseType_t prvStringPublishSubscribe(MQTTAgentConnectParams_t *pxConnectParams, MQTTQoS_t xQOS, MQTTAgentHandle_t prvStringPublishSubscribe$$xMQTTClientHandle, SubpubUserData_t *pxUserData)
{
  MQTTAgentSubscribeParams_t xSubscribeParams;
  MQTTAgentPublishParams_t xPublishParams;
  MQTTAgentUnsubscribeParams_t xUnsubscribeParams;
  BaseType_t xResult=1;
  char *return_value_pcTaskGetName=pcTaskGetName(NULL);
  strncpy((char *)pxUserData->cTopic, (char *)return_value_pcTaskGetName, 10ull);
  strncat((char *)pxUserData->cTopic, (char *)"/string/", sizeof(char [9ll]) /*9ull*/ );
  MQTTAgentReturnCode_t return_value_MQTT_AGENT_Connect=MQTT_AGENT_Connect(prvStringPublishSubscribe$$xMQTTClientHandle, pxConnectParams, xMaxCommandTime$link1);
  if((signed int)return_value_MQTT_AGENT_Connect == 0)
  {
    vLoggingPrintf("%s connected to broker.\r\n", (const void *)"prvStringPublishSubscribe");
    xSubscribeParams.pucTopic = (const uint8_t *)pxUserData->cTopic;
    size_t return_value_strlen=strlen(pxUserData->cTopic);
    xSubscribeParams.usTopicLength = (uint16_t)return_value_strlen;
    xSubscribeParams.xQoS = xQOS;
    xSubscribeParams.pvPublishCallbackContext = (void *)pxUserData;
    xSubscribeParams.pxPublishCallback = prvMQTTStringPublishCallback;
    MQTTAgentReturnCode_t return_value_MQTT_AGENT_Subscribe=MQTT_AGENT_Subscribe(prvStringPublishSubscribe$$xMQTTClientHandle, &xSubscribeParams, xMaxCommandTime$link1);
    if((signed int)return_value_MQTT_AGENT_Subscribe == 0)
    {
      vLoggingPrintf("%s subscribed to topic %s.\r\n", (const void *)"prvStringPublishSubscribe", xSubscribeParams.pucTopic);
      xPublishParams.xQoS = xQOS;
      xPublishParams.pucTopic = (const uint8_t *)pxUserData->cTopic;
      size_t return_value_strlen$0=strlen(pxUserData->cTopic);
      xPublishParams.usTopicLength = (uint16_t)return_value_strlen$0;
      xPublishParams.pvData = (const void *)"prvStringPublishSubscribe";
      size_t return_value_strlen$1=strlen("prvStringPublishSubscribe");
      xPublishParams.ulDataLength = (uint32_t)(uint16_t)return_value_strlen$1;
      pxUserData->pcExpectedString = "prvStringPublishSubscribe";
      pxUserData->xCallbackStatus = 0;
      MQTTAgentReturnCode_t return_value_MQTT_AGENT_Publish=MQTT_AGENT_Publish(prvStringPublishSubscribe$$xMQTTClientHandle, &xPublishParams, xMaxCommandTime$link1);
      if((signed int)return_value_MQTT_AGENT_Publish == 0)
        vLoggingPrintf("%s published to topic %s\r\n", (const void *)"prvStringPublishSubscribe", xPublishParams.pucTopic);

      else
      {
        vLoggingPrintf("ERROR %s did not published to topic %s\r\n", (const void *)"prvStringPublishSubscribe", xPublishParams.pucTopic);
        xResult = 0;
      }
      BaseType_t return_value_xQueueSemaphoreTake=xQueueSemaphoreTake(pxUserData->xWakeUpSemaphore, xMaxCommandTime$link1);
      if(return_value_xQueueSemaphoreTake == 0)
        xResult = 0;

      if(!(pxUserData->xCallbackStatus == 1))
        xResult = 0;

      pxUserData->pcExpectedString = pcLongString;
      xPublishParams.pvData = (const void *)pcLongString;
      size_t return_value_strlen$2=strlen(pcLongString);
      xPublishParams.ulDataLength = (uint32_t)(uint16_t)return_value_strlen$2;
      pxUserData->xCallbackStatus = 0;
      MQTTAgentReturnCode_t return_value_MQTT_AGENT_Publish$0=MQTT_AGENT_Publish(prvStringPublishSubscribe$$xMQTTClientHandle, &xPublishParams, xMaxCommandTime$link1);
      if((signed int)return_value_MQTT_AGENT_Publish$0 == 0)
        vLoggingPrintf("%s published to topic %s\r\n", (const void *)"prvStringPublishSubscribe", xPublishParams.pucTopic);

      else
      {
        vLoggingPrintf("ERROR %s did not published to topic %s\r\n", (const void *)"prvStringPublishSubscribe", xPublishParams.pucTopic);
        xResult = 0;
      }
      BaseType_t return_value_xQueueSemaphoreTake$0=xQueueSemaphoreTake(pxUserData->xWakeUpSemaphore, xMaxCommandTime$link1);
      if(return_value_xQueueSemaphoreTake$0 == 0)
        xResult = 0;

      if(!(pxUserData->xCallbackStatus == 1))
        xResult = 0;

      xUnsubscribeParams.pucTopic = (const uint8_t *)pxUserData->cTopic;
      size_t return_value_strlen$3=strlen(pxUserData->cTopic);
      xUnsubscribeParams.usTopicLength = (uint16_t)return_value_strlen$3;
      MQTTAgentReturnCode_t return_value_MQTT_AGENT_Unsubscribe=MQTT_AGENT_Unsubscribe(prvStringPublishSubscribe$$xMQTTClientHandle, &xUnsubscribeParams, xMaxCommandTime$link1);
      if((signed int)return_value_MQTT_AGENT_Unsubscribe == 0)
        vLoggingPrintf("%s unsubscribed from topic %s\r\n", (const void *)"prvStringPublishSubscribe", xUnsubscribeParams.pucTopic);

      else
      {
        vLoggingPrintf("ERROR:  %s did not unsubscribed from topic %s\r\n", (const void *)"prvStringPublishSubscribe", xUnsubscribeParams.pucTopic);
        xResult = 0;
      }
    }

    else
      vLoggingPrintf("ERROR %s did not subscribe to topic %s.\r\n", (const void *)"prvStringPublishSubscribe", xSubscribeParams.pucTopic);
    vLoggingPrintf("Disconnecting from broker.\r\n");
    MQTTAgentReturnCode_t return_value_MQTT_AGENT_Disconnect=MQTT_AGENT_Disconnect(prvStringPublishSubscribe$$xMQTTClientHandle, xMaxCommandTime$link1);
    if((signed int)return_value_MQTT_AGENT_Disconnect == 0)
      vLoggingPrintf("Disconnected from the broker.\r\n");

    else
    {
      vLoggingPrintf("ERROR:  Did not disconnected from the broker.\r\n");
      xResult = 0;
    }
  }

  return xResult;
}

// prvStrncpy
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2422
static void prvStrncpy(char *dst, const char *src, uint32_t maxLength)
{
  uint32_t i=0u;
  for( ; !(i >= maxLength); i = i + 1u)
  {
    dst[(signed long long int)i] = src[(signed long long int)i];
    if((signed int)src[(signed long long int)i] == 0)
      break;

  }
}

// prvSubscribe
// file ..\..\..\common\mqtt\aws_hello_world.c line 347
static BaseType_t prvSubscribe(void)
{
  MQTTAgentReturnCode_t xReturned;
  BaseType_t xReturn;
  MQTTAgentSubscribeParams_t xSubscribeParams;
  xSubscribeParams.pucTopic = (const uint8_t *)"freertos/demos/echo";
  xSubscribeParams.pvPublishCallbackContext = NULL;
  xSubscribeParams.pxPublishCallback = prvMQTTCallback;
  size_t return_value_strlen=strlen((const char *)(const uint8_t *)"freertos/demos/echo");
  xSubscribeParams.usTopicLength = (uint16_t)return_value_strlen;
  xSubscribeParams.xQoS = /*enum*/eMQTTQoS1;
  xReturned=MQTT_AGENT_Subscribe(xMQTTHandle, &xSubscribeParams, (TickType_t)((300u * 1000u) / 1000u));
  if((signed int)xReturned == 0)
  {
    vLoggingPrintf("MQTT Echo demo subscribed to %s\r\n", (const uint8_t *)"freertos/demos/echo");
    xReturn = 1;
  }

  else
  {
    vLoggingPrintf("ERROR:  MQTT Echo demo could not subscribe to %s\r\n", (const uint8_t *)"freertos/demos/echo");
    xReturn = 0;
  }
  return xReturn;
}

// prvSubscribePublishDemo
// file ..\..\..\common\mqtt\aws_subscribe_publish_loop.c line 595
static void prvSubscribePublishDemo(MQTTAgentHandle_t prvSubscribePublishDemo$$xMQTTClientHandle, BaseType_t xSecureConnection)
{
  BaseType_t xResult;
  MQTTAgentConnectParams_t xConnectParams;
  TaskStatus_t xTaskStatus;
  SemaphoreHandle_t xCallbackSemaphore=NULL;
  SubpubUserData_t xUserData;
  xCallbackSemaphore=xQueueGenericCreate(1ul, 0ul, 3);
  xUserData.xWakeUpSemaphore = xCallbackSemaphore;
  char *return_value_pcTaskGetName=pcTaskGetName(NULL);
  xConnectParams.pucClientId = (const uint8_t *)return_value_pcTaskGetName;
  size_t return_value_strlen=strlen("Paste AWS IoT Thing name here.");
  xConnectParams.usClientIdLength = (uint16_t)return_value_strlen;
  xConnectParams.usPort = 8883;
  xConnectParams.xFlags = 0;
  xConnectParams.xURLIsIPAddress = 0;
  xConnectParams.xSecuredConnection = 0;
  xConnectParams.pcCertificate = ((char *)NULL);
  xConnectParams.ulCertificateSize = 0u;
  xConnectParams.pvUserData = NULL;
  xConnectParams.pxCallback = prvMQTTCallback$link1;
  if(xSecureConnection == 1)
  {
    xConnectParams.xFlags = xConnectParams.xFlags | 0x2;
    xConnectParams.pcURL = clientcredentialMQTT_BROKER_ENDPOINT$link2;
    xConnectParams.usPort = 8883;
  }

  else
  {
    xConnectParams.pcURL = "Paste your unsecure MQTT Broker endpoint here.";
    xConnectParams.usPort = 443;
  }
  xResult=prvStringPublishSubscribe(&xConnectParams, /*enum*/eMQTTQoS0, prvSubscribePublishDemo$$xMQTTClientHandle, &xUserData);
  if(xResult == 0)
    vAssertCalled("..\\..\\..\\common\\mqtt\\aws_subscribe_publish_loop.c", 637u);

  if(!(xResult == 0))
    xResult=prvStringPublishSubscribe(&xConnectParams, /*enum*/eMQTTQoS1, prvSubscribePublishDemo$$xMQTTClientHandle, &xUserData);

  if(!(xResult == 0))
    xResult=prvUint32PublishSubscribe(&xConnectParams, /*enum*/eMQTTQoS0, prvSubscribePublishDemo$$xMQTTClientHandle, &xUserData);

  if(!(xResult == 0))
    xResult=prvUint32PublishSubscribe(&xConnectParams, /*enum*/eMQTTQoS1, prvSubscribePublishDemo$$xMQTTClientHandle, &xUserData);

  if(xResult == 1)
  {
    vTaskGetInfo(NULL, &xTaskStatus, 1, /*enum*/eInvalid);
    size_t return_value_xPortGetMinimumEverFreeHeapSize=xPortGetMinimumEverFreeHeapSize();
    vLoggingPrintf("Heap low-water mark %u, Stack high-water mark %u.\r\n", return_value_xPortGetMinimumEverFreeHeapSize, xTaskStatus.usStackHighWaterMark);
    vLoggingPrintf("All the MQTT tests passed! \r\n");
  }

  else
    vLoggingPrintf("Some of the MQTT tests failed! \r\n");
  vLoggingPrintf("Task MQTT_Functions completed and deleting itself.\r\n");
  if(!(xResult == 1))
    vAssertCalled("..\\..\\..\\common\\mqtt\\aws_subscribe_publish_loop.c", 678u);

  (void)xResult;
}

// prvSubscribeToDataStream
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1835
static uint8_t prvSubscribeToDataStream(OTA_FileContext_t *C)
{
  uint8_t bResult=0;
  char acOTA_RxStreamTopic[256ll];
  MQTTAgentSubscribeParams_t stOTAUpdateDataSubscription;
  memset((void *)&stOTAUpdateDataSubscription, 0, sizeof(MQTTAgentSubscribeParams_t) /*32ull*/ );
  stOTAUpdateDataSubscription.xQoS = /*enum*/eMQTTQoS1;
  stOTAUpdateDataSubscription.pucTopic = (const uint8_t *)acOTA_RxStreamTopic;
  uint32_t return_value_prvBuildDataStreamTopicName=prvBuildDataStreamTopicName(acOTA_RxStreamTopic, 256u, C);
  stOTAUpdateDataSubscription.usTopicLength = (uint16_t)return_value_prvBuildDataStreamTopicName;
  stOTAUpdateDataSubscription.pxPublishCallback = prvOTAPublishCallback;
  if((signed int)stOTAUpdateDataSubscription.usTopicLength >= 1)
  {
    MQTTAgentReturnCode_t return_value_MQTT_AGENT_Subscribe=MQTT_AGENT_Subscribe(pvPubSubClient, &stOTAUpdateDataSubscription, (TickType_t)((30000ul * 1000u) / 1000u));
    if(!((signed int)return_value_MQTT_AGENT_Subscribe == 0))
    {
      vLoggingPrintf("[OTA] Error when subscribing to topic: %s\n\r", stOTAUpdateDataSubscription.pucTopic);
      MQTT_AGENT_Disconnect(pvPubSubClient, 0u);
    }

    else
    {
      vLoggingPrintf("[OTA] Subscribed to topic: %s\n\r", stOTAUpdateDataSubscription.pucTopic);
      bResult = 1;
    }
  }

  return bResult;
}

// prvSubscribeToJobNotificationTopic
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1805
static uint8_t prvSubscribeToJobNotificationTopic(void)
{
  uint8_t bResult=0;
  MQTTAgentReturnCode_t return_value_MQTT_AGENT_Subscribe=MQTT_AGENT_Subscribe(pvPubSubClient, &stJobsNotificationSubscription, (TickType_t)((30000ul * 1000u) / 1000u));
  if(!((signed int)return_value_MQTT_AGENT_Subscribe == 0))
  {
    vLoggingPrintf("[OTA] Error when subscribing to topic: %s\n\r", stJobsNotificationSubscription.pucTopic);
    MQTT_AGENT_Disconnect(pvPubSubClient, 0u);
  }

  else
  {
    vLoggingPrintf("[OTA] Subscribed to topic: %s\n\r", stJobsNotificationSubscription.pucTopic);
    bResult = 1;
  }
  MQTTAgentReturnCode_t return_value_MQTT_AGENT_Subscribe$0=MQTT_AGENT_Subscribe(pvPubSubClient, &stJobsNotifyNextSubscription, (TickType_t)((30000ul * 1000u) / 1000u));
  if(!((signed int)return_value_MQTT_AGENT_Subscribe$0 == 0))
  {
    vLoggingPrintf("[OTA] Error when subscribing to topic: %s\n\r", stJobsNotifyNextSubscription.pucTopic);
    MQTT_AGENT_Disconnect(pvPubSubClient, 0u);
  }

  else
  {
    vLoggingPrintf("[OTA] Subscribed to topic: %s\n\r", stJobsNotifyNextSubscription.pucTopic);
    bResult = 1;
  }
  return bResult;
}

// prvSwitchTimerLists
// file ..\..\..\..\lib\FreeRTOS\timers.c line 835
static void prvSwitchTimerLists(void)
{
  TickType_t xNextExpireTime;
  TickType_t xReloadTime;
  List_t *pxTemp;
  Timer_t *pxTimer;
  BaseType_t xResult;
  if(!(pxCurrentTimerList->uxNumberOfItems == 0ul))
  {
    xNextExpireTime = pxCurrentTimerList->xListEnd.pxNext->xItemValue;
    pxTimer = (Timer_t *)(&pxCurrentTimerList->xListEnd)->pxNext->pvOwner;
    uxListRemove(&pxTimer->xTimerListItem);
    pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    if(pxTimer->uxAutoReload == 1ul)
    {
      xReloadTime = xNextExpireTime + pxTimer->xTimerPeriodInTicks;
      if(!(xNextExpireTime >= xReloadTime))
      {
        (&pxTimer->xTimerListItem)->xItemValue = xReloadTime;
        (&pxTimer->xTimerListItem)->pvOwner = (void *)pxTimer;
        vListInsert(pxCurrentTimerList, &pxTimer->xTimerListItem);
      }

      else
      {
        xResult=xTimerGenericCommand((TimerHandle_t)pxTimer, 0, xNextExpireTime, ((BaseType_t *)NULL), 0u);
        if(xResult == 0)
          vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\timers.c", 878u);

        (void)xResult;
      }
    }

  }

  pxTemp = pxCurrentTimerList;
  pxCurrentTimerList = pxOverflowTimerList;
  pxOverflowTimerList = pxTemp;
}

// prvTCPAddTxData
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 1926
static void prvTCPAddTxData(FreeRTOS_Socket_t *pxSocket)
{
  int32_t lCount;
  int32_t lLength;
  size_t return_value_uxStreamBufferMidSpace=uxStreamBufferMidSpace(pxSocket->u.xTCP.txStream);
  lLength = (int32_t)return_value_uxStreamBufferMidSpace;
  if(lLength >= 1)
  {
    lCount=lTCPWindowTxAdd(&pxSocket->u.xTCP.xTCPWindow, (uint32_t)lLength, (int32_t)pxSocket->u.xTCP.txStream->uxMid, (int32_t)pxSocket->u.xTCP.txStream->LENGTH);
    if(lCount >= 1)
      vStreamBufferMoveMid(pxSocket->u.xTCP.txStream, (size_t)lCount);

  }

}

// prvTCPBufferResize
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 1606
static NetworkBufferDescriptor_t * prvTCPBufferResize(FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxNetworkBuffer, int32_t lDataLen, UBaseType_t uxOptionsLength)
{
  NetworkBufferDescriptor_t *pxReturn;
  int32_t lNeeded;
  BaseType_t xResize;
  if(!(xBufferAllocFixedSize == 0))
  {
    lNeeded = (int32_t)(1200u + 14u + 4ul + 4ul);
    xResize = (BaseType_t)(pxNetworkBuffer == ((NetworkBufferDescriptor_t *)NULL));
  }

  else
  {
    lNeeded=FreeRTOS_max_int32((int32_t)sizeof(uint8_t [70ll]) /*70*/ , (int32_t)(14u + 20u + 20u + uxOptionsLength) + lDataLen);
    _Bool tmp_if_expr;
    if(pxNetworkBuffer == ((NetworkBufferDescriptor_t *)NULL))
      tmp_if_expr = (_Bool)1;

    else
      tmp_if_expr = pxNetworkBuffer->xDataLength < (size_t)lNeeded ? (_Bool)1 : (_Bool)0;
    xResize = (BaseType_t)tmp_if_expr;
  }
  if(!(xResize == 0))
  {
    pxReturn=pxGetNetworkBufferWithDescriptor((size_t)(uint32_t)lNeeded, 0u);
    if(!(pxReturn == ((NetworkBufferDescriptor_t *)NULL)))
    {
      pxReturn->xDataLength = (size_t)lNeeded;
      if(!(pxNetworkBuffer == ((NetworkBufferDescriptor_t *)NULL)))
      {
        memcpy((void *)pxReturn->pucEthernetBuffer, (const void *)pxNetworkBuffer->pucEthernetBuffer, pxNetworkBuffer->xDataLength);
        vReleaseNetworkBufferAndDescriptor(pxNetworkBuffer);
      }

      else
        memcpy((void *)pxReturn->pucEthernetBuffer, (const void *)pxSocket->u.xTCP.xPacket.u.ucLastPacket, sizeof(uint8_t [70ll]) /*70ull*/ );
    }

  }

  else
  {
    pxReturn = pxNetworkBuffer;
    pxNetworkBuffer->xDataLength = (size_t)(14u + 20u + 20u + uxOptionsLength) + (size_t)lDataLen;
  }
  return pxReturn;
}

// prvTCPConnectStart
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 1935
static BaseType_t prvTCPConnectStart(FreeRTOS_Socket_t *pxSocket, struct freertos_sockaddr *pxAddress)
{
  BaseType_t xResult=0;
  BaseType_t return_value_prvValidSocket=prvValidSocket(pxSocket, 6, 0);
  BaseType_t return_value_FreeRTOS_issocketconnected;
  if(return_value_prvValidSocket == 0)
    xResult = -9;

  else
  {
    return_value_FreeRTOS_issocketconnected=FreeRTOS_issocketconnected((Socket_t)pxSocket);
    if(return_value_FreeRTOS_issocketconnected >= 1)
      xResult = -127;

    else
      if(pxSocket->xBoundSocketListItem.pvContainer == NULL)
        xResult=FreeRTOS_bind((Socket_t)pxSocket, ((struct freertos_sockaddr *)NULL), 0u);

  }
  if(xResult == 0)
  {
    xResult=bMayConnect(pxSocket);
    if(xResult == 0)
    {
      pxSocket->u.xTCP.bits.bConnPrepared = 0u;
      pxSocket->u.xTCP.ucRepCount = 0;
      while((_Bool)0)
        ;
      pxSocket->u.xTCP.usRemotePort = (uint16_t)((signed int)pxAddress->sin_port << 8u | (signed int)pxAddress->sin_port >> 8u);
      pxSocket->u.xTCP.ulRemoteIP = (uint32_t)((uint32_t)pxAddress->sin_addr << 24 | ((uint32_t)pxAddress->sin_addr & 0xFF00ul) << 8 | ((uint32_t)pxAddress->sin_addr & 0xFF0000ul) >> 8 | (uint32_t)pxAddress->sin_addr >> 24);
      vTCPStateChange(pxSocket, /*enum*/eCONNECT_SYN);
      pxSocket->u.xTCP.usTimeout = 1;
      BaseType_t return_value_xSendEventToIPTask=xSendEventToIPTask(/*enum*/eTCPTimerEvent);
      if(!(return_value_xSendEventToIPTask == 1))
        xResult = -140;

    }

  }

  return xResult;
}

// prvTCPCreateStream
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 2879
static const StreamBuffer_t * prvTCPCreateStream(FreeRTOS_Socket_t *pxSocket, BaseType_t xIsInputStream)
{
  StreamBuffer_t *pxBuffer;
  size_t uxLength;
  size_t uxSize;
  if(!(xIsInputStream == 0))
  {
    uxLength = pxSocket->u.xTCP.uxRxStreamSize;
    if(pxSocket->u.xTCP.uxLittleSpace == 0ull)
      pxSocket->u.xTCP.uxLittleSpace = (1ull * pxSocket->u.xTCP.uxRxStreamSize) / 5ull;

    if(pxSocket->u.xTCP.uxEnoughSpace == 0ull)
      pxSocket->u.xTCP.uxEnoughSpace = (4ull * pxSocket->u.xTCP.uxRxStreamSize) / 5ull;

  }

  else
    uxLength = pxSocket->u.xTCP.uxTxStreamSize;
  uxLength = uxLength + sizeof(size_t) /*8ull*/ ;
  uxLength = uxLength & ~(sizeof(size_t) /*8ull*/  - 1ull);
  uxSize = (sizeof(const StreamBuffer_t) /*48ull*/  - sizeof(uint8_t [8ll]) /*8ull*/ ) + uxLength;
  void *return_value_pvPortMalloc=pvPortMalloc(uxSize);
  pxBuffer = ( StreamBuffer_t *)return_value_pvPortMalloc;
  if(pxBuffer == (( StreamBuffer_t *)NULL))
  {
    while((_Bool)0)
      ;
    pxSocket->u.xTCP.bits.bMallocError = 1u;
    vTCPStateChange(pxSocket, /*enum*/eCLOSE_WAIT);
  }

  else
  {
    memset((void *)pxBuffer, 0, sizeof(const StreamBuffer_t) /*48ull*/  - sizeof(uint8_t [8ll]) /*8ull*/ );
    pxBuffer->LENGTH = (size_t)uxLength;
    if(!(xTCPWindowLoggingLevel == 0))
      while((_Bool)0)
        ;

    if(!(xIsInputStream == 0))
      pxSocket->u.xTCP.rxStream = pxBuffer;

    else
      pxSocket->u.xTCP.txStream = pxBuffer;
  }
  return pxBuffer;
}

// prvTCPCreateWindow
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 953
static void prvTCPCreateWindow(FreeRTOS_Socket_t *pxSocket)
{
  if(!(xTCPWindowLoggingLevel == 0l))
    while((_Bool)0)
      ;

  vTCPWindowCreate(&pxSocket->u.xTCP.xTCPWindow, (uint32_t)((unsigned long long int)((1200u - 20u) - 20u) * pxSocket->u.xTCP.uxRxWinSize), (uint32_t)((unsigned long long int)((1200u - 20u) - 20u) * pxSocket->u.xTCP.uxTxWinSize), pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber, pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber, (uint32_t)pxSocket->u.xTCP.usInitMSS);
}

// prvTCPHandleFin
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 1967
static BaseType_t prvTCPHandleFin(FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxNetworkBuffer)
{
  TCPPacket_t *pxTCPPacket=(TCPPacket_t *)pxNetworkBuffer->pucEthernetBuffer;
  TCPHeader_t *pxTCPHeader=&pxTCPPacket->xTCPHeader;
  uint8_t ucTCPFlags=pxTCPHeader->ucTCPFlags;
  TCPWindow_t *pxTCPWindow=&pxSocket->u.xTCP.xTCPWindow;
  BaseType_t xSendLength=0;
  uint32_t ulAckNr=(uint32_t)((uint32_t)pxTCPHeader->ulAckNr << 24 | ((uint32_t)pxTCPHeader->ulAckNr & 0xFF00ul) << 8 | ((uint32_t)pxTCPHeader->ulAckNr & 0xFF0000ul) >> 8 | (uint32_t)pxTCPHeader->ulAckNr >> 24);
  if(!((0x1u & (unsigned int)ucTCPFlags) == 0u))
    pxTCPWindow->rx.ulCurrentSequenceNumber = pxTCPWindow->rx.ulFINSequenceNumber + 1u;

  if((unsigned int)pxSocket->u.xTCP.bits.bFinSent == 0u)
  {
    pxTCPWindow->tx.ulFINSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
    pxSocket->u.xTCP.bits.bFinSent = 1u;
  }

  else
    if(ulAckNr == 1u + pxTCPWindow->tx.ulFINSequenceNumber)
      pxSocket->u.xTCP.bits.bFinAcked = 1u;

  if((unsigned int)pxSocket->u.xTCP.bits.bFinAcked == 0u)
  {
    pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->tx.ulFINSequenceNumber;
    pxTCPHeader->ucTCPFlags = (uint8_t)(0x10u | 0x1u);
    vTCPStateChange(pxSocket, /*enum*/eLAST_ACK);
  }

  else
  {
    pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->tx.ulFINSequenceNumber + 1u;
    if((unsigned int)pxSocket->u.xTCP.bits.bFinRecv == 0u)
      pxTCPHeader->ucTCPFlags = 0;

    else
    {
      if((unsigned int)pxSocket->u.xTCP.bits.bFinLast == 0u)
        pxTCPHeader->ucTCPFlags = 16;

      else
        pxTCPHeader->ucTCPFlags = 0;
      vTCPStateChange(pxSocket, /*enum*/eCLOSE_WAIT);
    }
  }
  pxTCPWindow->ulOurSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
  if(!((unsigned int)pxTCPHeader->ucTCPFlags == 0u))
    xSendLength = (BaseType_t)(20u + 20u + (unsigned int)pxTCPWindow->ucOptionLength);

  pxTCPHeader->ucTCPOffset = (uint8_t)(20u + (unsigned int)pxTCPWindow->ucOptionLength << 2);
  if(!(xTCPWindowLoggingLevel == 0))
    while((_Bool)0)
      ;

  return xSendLength;
}

// prvTCPHandleState
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 2674
static BaseType_t prvTCPHandleState(FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkBuffer)
{
  TCPPacket_t *pxTCPPacket=(TCPPacket_t *)(*ppxNetworkBuffer)->pucEthernetBuffer;
  TCPHeader_t *pxTCPHeader=&pxTCPPacket->xTCPHeader;
  BaseType_t xSendLength=0;
  uint32_t ulReceiveLength;
  uint8_t *pucRecvData;
  uint32_t ulSequenceNumber=(uint32_t)((uint32_t)pxTCPHeader->ulSequenceNumber << 24 | ((uint32_t)pxTCPHeader->ulSequenceNumber & 0xFF00ul) << 8 | ((uint32_t)pxTCPHeader->ulSequenceNumber & 0xFF0000ul) >> 8 | (uint32_t)pxTCPHeader->ulSequenceNumber >> 24);
  UBaseType_t uxOptionsLength=0u;
  uint8_t ucTCPFlags=pxTCPHeader->ucTCPFlags;
  TCPWindow_t *pxTCPWindow=&pxSocket->u.xTCP.xTCPWindow;
  BaseType_t return_value_prvCheckRxData=prvCheckRxData(*ppxNetworkBuffer, &pucRecvData);
  ulReceiveLength = (uint32_t)return_value_prvCheckRxData;
  if((signed int)pxSocket->u.xTCP.ucTCPState >= 5)
  {
    if(pxTCPWindow->rx.ulCurrentSequenceNumber == 1u + ulSequenceNumber)
      pxSocket->u.xTCP.bits.bWinChange = 1u;

  }

  if((int32_t)ulReceiveLength + (int32_t)ulSequenceNumber + -((int32_t)pxTCPWindow->rx.ulHighestSequenceNumber) >= 1)
    pxTCPWindow->rx.ulHighestSequenceNumber = ulSequenceNumber + ulReceiveLength;

  BaseType_t return_value_prvStoreRxData=prvStoreRxData(pxSocket, pucRecvData, *ppxNetworkBuffer, ulReceiveLength);
  if(!(return_value_prvStoreRxData >= 0))
    xSendLength = -1;

  else
  {
    uxOptionsLength=prvSetOptions(pxSocket, *ppxNetworkBuffer);
    if((signed int)pxSocket->u.xTCP.ucTCPState == 4)
    {
      if((0x1Fu & (unsigned int)ucTCPFlags) == 0x2u)
      {
        while((_Bool)0)
          ;
        vTCPStateChange(pxSocket, /*enum*/eSYN_FIRST);
      }

    }

    if(!((0x1u & (unsigned int)ucTCPFlags) == 0u))
    {
      if((unsigned int)pxSocket->u.xTCP.bits.bFinRecv == 0u)
      {
        pxTCPWindow->rx.ulFINSequenceNumber = ulSequenceNumber + ulReceiveLength;
        pxSocket->u.xTCP.bits.bFinRecv = 1u;
        if((unsigned int)pxSocket->u.xTCP.bits.bFinSent == 0u)
          pxSocket->u.xTCP.bits.bFinLast = 1u;

      }

    }

    switch((signed int)pxSocket->u.xTCP.ucTCPState)
    {
      case 0:
        break;
      case 1:
        break;
      case 3:
      {
        uxOptionsLength=prvSetSynAckOptions(pxSocket, pxTCPPacket);
        pxTCPHeader->ucTCPFlags = (uint8_t)(0x2u | 0x10u);
        xSendLength = (BaseType_t)(20u + 20u + uxOptionsLength);
        pxTCPHeader->ucTCPOffset = (uint8_t)(20u + uxOptionsLength << 2);
        vTCPStateChange(pxSocket, /*enum*/eSYN_RECEIVED);
        pxTCPWindow->rx.ulHighestSequenceNumber = ulSequenceNumber + 1u;
        pxTCPWindow->rx.ulCurrentSequenceNumber = pxTCPWindow->rx.ulHighestSequenceNumber;
        pxTCPWindow->ulNextTxSequenceNumber = pxTCPWindow->tx.ulFirstSequenceNumber + 1u;
        pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->ulNextTxSequenceNumber;
        break;
      }
      case 2:

      case 4:
      {
        xSendLength=prvHandleSynReceived(pxSocket, ppxNetworkBuffer, ulReceiveLength, uxOptionsLength);
        break;
      }
      case 5:
      {
        xSendLength=prvHandleEstablished(pxSocket, ppxNetworkBuffer, ulReceiveLength, uxOptionsLength);
        break;
      }
      case 10:

      case 6:

      case 7:
      {
        xSendLength=prvTCPHandleFin(pxSocket, *ppxNetworkBuffer);
        break;
      }
      case 8:
        break;
      case 9:
        break;
      case 11:
        break;
      default:
        ;
    }
  }
  if(xSendLength >= 1)
    xSendLength=prvSendData(pxSocket, ppxNetworkBuffer, ulReceiveLength, xSendLength);

  return xSendLength;
}

// prvTCPNextTimeout
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 1863
static TickType_t prvTCPNextTimeout(FreeRTOS_Socket_t *pxSocket)
{
  TickType_t ulDelayMs=20000u;
  if((signed int)pxSocket->u.xTCP.ucTCPState == 2)
  {
    if(!(pxSocket->u.xTCP.bits.bConnPrepared == 0u))
    {
      if(!((unsigned int)pxSocket->u.xTCP.ucRepCount >= 3u))
        ulDelayMs = 3000ul << (unsigned int)pxSocket->u.xTCP.ucRepCount - 1u;

      else
        ulDelayMs = 11000ul;
    }

    else
      ulDelayMs = 500ul;
    while((_Bool)0)
      ;
    pxSocket->u.xTCP.usTimeout = (uint16_t)((TickType_t)(((TickType_t)ulDelayMs * 1000u) / 1000u) < 1u ? 1u : (TickType_t)(((TickType_t)ulDelayMs * 1000u) / 1000u));
  }

  else
    if((unsigned int)pxSocket->u.xTCP.usTimeout == 0u)
    {
      BaseType_t xResult=xTCPWindowTxHasData(&pxSocket->u.xTCP.xTCPWindow, pxSocket->u.xTCP.ulWindowSize, &ulDelayMs);
      if(ulDelayMs == 0u)
      {
        if(!(xResult == 0))
          ulDelayMs = 1ul;

        else
          ulDelayMs = 20000u;
      }

      pxSocket->u.xTCP.usTimeout = (uint16_t)((TickType_t)(((TickType_t)ulDelayMs * 1000u) / 1000u) < 1u ? 1u : (TickType_t)(((TickType_t)ulDelayMs * 1000u) / 1000u));
    }

  return (TickType_t)pxSocket->u.xTCP.usTimeout;
}

// prvTCPPrepareConnect
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 977
static BaseType_t prvTCPPrepareConnect(FreeRTOS_Socket_t *pxSocket)
{
  TCPPacket_t *pxTCPPacket;
  IPHeader_t *pxIPHeader;
  eARPLookupResult_t eReturned;
  uint32_t ulRemoteIP;
  MACAddress_t xEthAddress;
  BaseType_t xReturn=1;
  uint32_t ulInitialSequenceNumber=0u;
  memset((void *)xEthAddress.ucBytes, 0, sizeof(uint8_t [6ll]) /*6ull*/ );
  ulRemoteIP = (uint32_t)((uint32_t)pxSocket->u.xTCP.ulRemoteIP << 24 | ((uint32_t)pxSocket->u.xTCP.ulRemoteIP & 0xFF00ul) << 8 | ((uint32_t)pxSocket->u.xTCP.ulRemoteIP & 0xFF0000ul) >> 8 | (uint32_t)pxSocket->u.xTCP.ulRemoteIP >> 24);
  eReturned=eARPGetCacheEntry(&ulRemoteIP, &xEthAddress);
  if(!((signed int)eReturned == 1))
  {
    if((signed int)eReturned == 0 || (signed int)eReturned == 2)
      goto __CPROVER_DUMP_L2;

  }

  else
    goto __CPROVER_DUMP_L4;

__CPROVER_DUMP_L2:
  ;
  pxSocket->u.xTCP.ucRepCount = pxSocket->u.xTCP.ucRepCount + 1;
  while((_Bool)0)
    ;
  FreeRTOS_OutputARPRequest(ulRemoteIP);
  xReturn = 0;

__CPROVER_DUMP_L4:
  ;
  if(!(xReturn == 0))
  {
    ulInitialSequenceNumber=ulGetNextSequenceNumber(*((uint32_t *)&xDefaultPartUDPPacketHeader.ulWords[(signed long long int)(20ull / sizeof(uint32_t) /*4ull*/ )]), pxSocket->usLocalPort, pxSocket->u.xTCP.ulRemoteIP, pxSocket->u.xTCP.usRemotePort);
    if(ulInitialSequenceNumber == 0u)
      xReturn = 0;

  }

  if(!(xReturn == 0))
  {
    pxTCPPacket = (TCPPacket_t *)pxSocket->u.xTCP.xPacket.u.ucLastPacket;
    pxIPHeader = &pxTCPPacket->xIPHeader;
    pxSocket->u.xTCP.ucRepCount = 0;
    pxSocket->u.xTCP.bits.bConnPrepared = 1u;
    memset((void *)pxSocket->u.xTCP.xPacket.u.ucLastPacket, 0, sizeof(uint8_t [70ll]) /*70ull*/ );
    memcpy((void *)&pxTCPPacket->xEthernetHeader.xSourceAddress, (const void *)&xEthAddress, sizeof(MACAddress_t) /*6ull*/ );
    pxTCPPacket->xEthernetHeader.usFrameType = 8;
    pxIPHeader->ucVersionHeaderLength = 69;
    pxIPHeader->usLength = (uint16_t)(sizeof(TCPPacket_t) /*70ull*/  - sizeof(EthernetHeader_t) /*14ull*/  << 8u | sizeof(TCPPacket_t) /*70ull*/  - sizeof(EthernetHeader_t) /*14ull*/  >> 8u);
    pxIPHeader->ucTimeToLive = 128;
    pxIPHeader->ucProtocol = 6;
    pxIPHeader->ulDestinationIPAddress = *((uint32_t *)&xDefaultPartUDPPacketHeader.ulWords[(signed long long int)(20ull / sizeof(uint32_t) /*4ull*/ )]);
    pxIPHeader->ulSourceIPAddress = (uint32_t)((uint32_t)pxSocket->u.xTCP.ulRemoteIP << 24 | ((uint32_t)pxSocket->u.xTCP.ulRemoteIP & 0xFF00ul) << 8 | ((uint32_t)pxSocket->u.xTCP.ulRemoteIP & 0xFF0000ul) >> 8 | (uint32_t)pxSocket->u.xTCP.ulRemoteIP >> 24);
    pxTCPPacket->xTCPHeader.usSourcePort = (uint16_t)((signed int)pxSocket->u.xTCP.usRemotePort << 8u | (signed int)pxSocket->u.xTCP.usRemotePort >> 8u);
    pxTCPPacket->xTCPHeader.usDestinationPort = (uint16_t)((signed int)pxSocket->usLocalPort << 8u | (signed int)pxSocket->usLocalPort >> 8u);
    pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber = 0ul;
    pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber = ulInitialSequenceNumber;
    pxTCPPacket->xTCPHeader.ucTCPOffset = 80;
    pxTCPPacket->xTCPHeader.ucTCPFlags = 2;
    prvSocketSetMSS(pxSocket);
    pxSocket->u.xTCP.ulRxCurWinSize = (uint32_t)pxSocket->u.xTCP.usInitMSS;
    prvTCPCreateWindow(pxSocket);
  }

  return xReturn;
}

// prvTCPPrepareSend
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 1678
static int32_t prvTCPPrepareSend(FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkBuffer, UBaseType_t uxOptionsLength)
{
  int32_t lDataLen;
  uint8_t *pucEthernetBuffer;
  uint8_t *pucSendData;
  TCPPacket_t *pxTCPPacket;
  size_t uxOffset;
  uint32_t ulDataGot;
  uint32_t ulDistance;
  TCPWindow_t *pxTCPWindow;
  NetworkBufferDescriptor_t *pxNewBuffer;
  int32_t lStreamPos;
  if(!(*ppxNetworkBuffer == ((NetworkBufferDescriptor_t *)NULL)))
    pucEthernetBuffer = (*ppxNetworkBuffer)->pucEthernetBuffer;

  else
    pucEthernetBuffer = pxSocket->u.xTCP.xPacket.u.ucLastPacket;
  pxTCPPacket = (TCPPacket_t *)pucEthernetBuffer;
  pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
  lDataLen = 0;
  lStreamPos = 0;
  pxTCPPacket->xTCPHeader.ucTCPFlags = pxTCPPacket->xTCPHeader.ucTCPFlags | 16;
  if(!(pxSocket->u.xTCP.txStream == ((const StreamBuffer_t *)NULL)))
  {
    if((unsigned int)pxSocket->u.xTCP.usCurMSS >= 2u)
    {
      uint32_t return_value_ulTCPWindowTxGet=ulTCPWindowTxGet(pxTCPWindow, pxSocket->u.xTCP.ulWindowSize, &lStreamPos);
      lDataLen = (int32_t)return_value_ulTCPWindowTxGet;
    }

    if(lDataLen >= 1)
    {
      pxNewBuffer=prvTCPBufferResize(pxSocket, *ppxNetworkBuffer, lDataLen, uxOptionsLength);
      if(!(pxNewBuffer == ((NetworkBufferDescriptor_t *)NULL)))
      {
        *ppxNetworkBuffer = pxNewBuffer;
        pucEthernetBuffer = pxNewBuffer->pucEthernetBuffer;
        pxTCPPacket = (TCPPacket_t *)pucEthernetBuffer;
        pucSendData = pucEthernetBuffer + 14ll + 20ll + 20ll + (signed long long int)uxOptionsLength;
        uxOffset=uxStreamBufferDistance$link2(pxSocket->u.xTCP.txStream, pxSocket->u.xTCP.txStream->uxTail, (size_t)lStreamPos);
        size_t return_value_uxStreamBufferGet=uxStreamBufferGet(pxSocket->u.xTCP.txStream, uxOffset, pucSendData, (size_t)lDataLen, 1);
        ulDataGot = (uint32_t)return_value_uxStreamBufferGet;
        if(!((unsigned int)pxSocket->u.xTCP.bits.bCloseRequested == 0u))
        {
          if((unsigned int)pxSocket->u.xTCP.bits.bFinSent == 0u)
          {
            size_t return_value_uxStreamBufferDistance=uxStreamBufferDistance$link2(pxSocket->u.xTCP.txStream, (size_t)lStreamPos, pxSocket->u.xTCP.txStream->uxHead);
            ulDistance = (uint32_t)return_value_uxStreamBufferDistance;
            if(ulDistance == ulDataGot)
            {
              pxTCPPacket->xTCPHeader.ucTCPFlags = pxTCPPacket->xTCPHeader.ucTCPFlags | 1;
              pxTCPWindow->tx.ulFINSequenceNumber = pxTCPWindow->ulOurSequenceNumber + (uint32_t)lDataLen;
              pxSocket->u.xTCP.bits.bFinSent = 1u;
            }

          }

        }

      }

      else
        lDataLen = -1;
    }

  }

  BaseType_t return_value_xTCPWindowTxDone;
  if(lDataLen >= 0)
  {
    if((signed int)pxSocket->u.xTCP.ucTCPState == 5)
    {
      if(!((unsigned int)pxSocket->u.xTCP.bits.bUserShutdown == 0u))
      {
        return_value_xTCPWindowTxDone=xTCPWindowTxDone(pxTCPWindow);
        if(!(return_value_xTCPWindowTxDone == 0))
        {
          pxSocket->u.xTCP.bits.bUserShutdown = 0u;
          pxTCPPacket->xTCPHeader.ucTCPFlags = pxTCPPacket->xTCPHeader.ucTCPFlags | 1;
          pxSocket->u.xTCP.bits.bFinSent = 1u;
          pxSocket->u.xTCP.bits.bWinChange = 1u;
          pxTCPWindow->tx.ulFINSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
          vTCPStateChange(pxSocket, /*enum*/eFIN_WAIT_1);
        }

      }

      if((unsigned int)pxSocket->u.xTCP.ucKeepRepCount >= 4u)
      {
        while((_Bool)0)
          ;
        vTCPStateChange(pxSocket, /*enum*/eCLOSE_WAIT);
        lDataLen = -1;
      }

      if(lDataLen == 0)
      {
        if((unsigned int)pxSocket->u.xTCP.bits.bWinChange == 0u)
        {
          TickType_t xAge;
          TickType_t return_value_xTaskGetTickCount=xTaskGetTickCount();
          xAge = return_value_xTaskGetTickCount - pxSocket->u.xTCP.xLastAliveTime;
          TickType_t xMax=20u * 1000u;
          if(!(pxSocket->u.xTCP.ucKeepRepCount == 0))
            xMax = 3u * 1000u;

          if(!(xMax >= xAge))
          {
            pxSocket->u.xTCP.xLastAliveTime=xTaskGetTickCount();
            if(!(xTCPWindowLoggingLevel == 0l))
              while((_Bool)0)
                ;

            pxSocket->u.xTCP.bits.bSendKeepAlive = 1u;
            pxSocket->u.xTCP.usTimeout = (uint16_t)(TickType_t)((2500u * 1000u) / 1000u);
            pxSocket->u.xTCP.ucKeepRepCount = pxSocket->u.xTCP.ucKeepRepCount + 1;
          }

        }

      }

    }

  }

  _Bool tmp_if_expr;
  if(lDataLen >= 1)
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = (unsigned int)pxSocket->u.xTCP.bits.bWinChange != 0u ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$0;
  if(tmp_if_expr)
    tmp_if_expr$0 = (_Bool)1;

  else
    tmp_if_expr$0 = (unsigned int)pxSocket->u.xTCP.bits.bSendKeepAlive != 0u ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$0)
  {
    pxTCPPacket->xTCPHeader.ucTCPFlags = pxTCPPacket->xTCPHeader.ucTCPFlags & (uint8_t)~0x8u;
    pxTCPPacket->xTCPHeader.ucTCPOffset = (uint8_t)(20u + uxOptionsLength << 2);
    pxTCPPacket->xTCPHeader.ucTCPFlags = pxTCPPacket->xTCPHeader.ucTCPFlags | 16;
    if(!(lDataLen == 0l))
      pxTCPPacket->xTCPHeader.ucTCPFlags = pxTCPPacket->xTCPHeader.ucTCPFlags | 8;

    lDataLen = lDataLen + (int32_t)(20u + 20u + uxOptionsLength);
  }

  return lDataLen;
}

// prvTCPReturnPacket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 677
static void prvTCPReturnPacket(FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxNetworkBuffer, uint32_t ulLen, BaseType_t xReleaseAfterSend)
{
  TCPPacket_t *pxTCPPacket;
  IPHeader_t *pxIPHeader;
  EthernetHeader_t *pxEthernetHeader;
  uint32_t ulFrontSpace;
  uint32_t ulSpace;
  uint32_t ulSourceAddress;
  uint32_t ulWinSize;
  TCPWindow_t *pxTCPWindow;
  NetworkBufferDescriptor_t xTempBuffer;
  if(pxNetworkBuffer == ((NetworkBufferDescriptor_t *)NULL))
  {
    pxNetworkBuffer = &xTempBuffer;
    xTempBuffer.pucEthernetBuffer = pxSocket->u.xTCP.xPacket.u.ucLastPacket;
    xTempBuffer.xDataLength = sizeof(uint8_t [70ll]) /*70ull*/ ;
    xReleaseAfterSend = 0;
  }

  if(!(pxNetworkBuffer == ((NetworkBufferDescriptor_t *)NULL)))
  {
    pxTCPPacket = (TCPPacket_t *)pxNetworkBuffer->pucEthernetBuffer;
    pxIPHeader = &pxTCPPacket->xIPHeader;
    pxEthernetHeader = &pxTCPPacket->xEthernetHeader;
    if(!(pxSocket == ((FreeRTOS_Socket_t *)NULL)))
    {
      pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
      if(!(pxSocket->u.xTCP.rxStream == ((const StreamBuffer_t *)NULL)))
      {
        size_t return_value_uxStreamBufferFrontSpace=uxStreamBufferFrontSpace$link1(pxSocket->u.xTCP.rxStream);
        ulFrontSpace = (uint32_t)return_value_uxStreamBufferFrontSpace;
      }

      else
        ulFrontSpace = (uint32_t)pxSocket->u.xTCP.uxRxStreamSize;
      ulSpace=FreeRTOS_min_uint32$link2(pxSocket->u.xTCP.ulRxCurWinSize, pxTCPWindow->xSize.ulRxWindowLength);
      _Bool tmp_if_expr;
      if(!((unsigned int)pxSocket->u.xTCP.bits.bLowWater == 0u))
        tmp_if_expr = (_Bool)1;

      else
        tmp_if_expr = (unsigned int)pxSocket->u.xTCP.bits.bRxStopped != 0u ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr)
        ulSpace = 0u;

      if(!(ulSpace >= (unsigned int)pxSocket->u.xTCP.usCurMSS))
      {
        if(ulFrontSpace >= (unsigned int)pxSocket->u.xTCP.usCurMSS)
          ulSpace = (uint32_t)pxSocket->u.xTCP.usCurMSS;

      }

      ulWinSize = ulSpace >> (signed int)pxSocket->u.xTCP.ucMyWinScaleFactor;
      if(ulWinSize >= 65533ul)
        ulWinSize = 0xFFFCul;

      pxTCPPacket->xTCPHeader.usWindow = (uint16_t)((signed int)(uint16_t)ulWinSize << 8u | (signed int)(uint16_t)ulWinSize >> 8u);
      pxSocket->u.xTCP.bits.bWinChange = 0u;
      pxSocket->u.xTCP.ulHighestRxAllowed = pxTCPWindow->rx.ulCurrentSequenceNumber + ulSpace;
      if(!((unsigned int)pxSocket->u.xTCP.bits.bSendKeepAlive == 0u))
      {
        pxSocket->u.xTCP.bits.bSendKeepAlive = 0u;
        pxSocket->u.xTCP.bits.bWaitKeepAlive = 1u;
        pxTCPPacket->xTCPHeader.ulSequenceNumber = pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber - 1ul;
        pxTCPPacket->xTCPHeader.ulSequenceNumber = (uint32_t)((uint32_t)pxTCPPacket->xTCPHeader.ulSequenceNumber << 24 | ((uint32_t)pxTCPPacket->xTCPHeader.ulSequenceNumber & 0xFF00ul) << 8 | ((uint32_t)pxTCPPacket->xTCPHeader.ulSequenceNumber & 0xFF0000ul) >> 8 | (uint32_t)pxTCPPacket->xTCPHeader.ulSequenceNumber >> 24);
      }

      else
      {
        pxTCPPacket->xTCPHeader.ulSequenceNumber = (uint32_t)((uint32_t)pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber << 24 | ((uint32_t)pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber & 0xFF00ul) << 8 | ((uint32_t)pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber & 0xFF0000ul) >> 8 | (uint32_t)pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber >> 24);
        if(!((1u & (unsigned int)(signed int)pxTCPPacket->xTCPHeader.ucTCPFlags) == 0u))
        {
          uint32_t ulDataLen=(uint32_t)(ulLen - (20u + 20u));
          if(!(pxTCPWindow->ulOurSequenceNumber + ulDataLen == pxTCPWindow->tx.ulFINSequenceNumber))
          {
            pxTCPPacket->xTCPHeader.ucTCPFlags = pxTCPPacket->xTCPHeader.ucTCPFlags & (uint8_t)~0x1u;
            while((_Bool)0)
              ;
          }

        }

      }
      pxTCPPacket->xTCPHeader.ulAckNr = (uint32_t)((uint32_t)pxTCPWindow->rx.ulCurrentSequenceNumber << 24 | ((uint32_t)pxTCPWindow->rx.ulCurrentSequenceNumber & 0xFF00ul) << 8 | ((uint32_t)pxTCPWindow->rx.ulCurrentSequenceNumber & 0xFF0000ul) >> 8 | (uint32_t)pxTCPWindow->rx.ulCurrentSequenceNumber >> 24);
    }

    else
      do
      {
        uint32_t prvTCPReturnPacket$$1$$2$$2$$1$$tmp=pxTCPPacket->xTCPHeader.ulSequenceNumber;
        pxTCPPacket->xTCPHeader.ulSequenceNumber = pxTCPPacket->xTCPHeader.ulAckNr;
        pxTCPPacket->xTCPHeader.ulAckNr = prvTCPReturnPacket$$1$$2$$2$$1$$tmp;
      }
      while((_Bool)0);
    pxIPHeader->ucTimeToLive = 128;
    pxIPHeader->usLength = (uint16_t)(ulLen << 8u | ulLen >> 8u);
    _Bool tmp_if_expr$0;
    if(pxSocket == ((FreeRTOS_Socket_t *)NULL))
      tmp_if_expr$0 = (_Bool)1;

    else
      tmp_if_expr$0 = *((uint32_t *)&xDefaultPartUDPPacketHeader.ulWords[(signed long long int)(20ull / sizeof(uint32_t) /*4ull*/ )]) == 0ul ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$0)
      ulSourceAddress = pxIPHeader->ulDestinationIPAddress;

    else
      ulSourceAddress = *((uint32_t *)&xDefaultPartUDPPacketHeader.ulWords[(signed long long int)(20ull / sizeof(uint32_t) /*4ull*/ )]);
    pxIPHeader->ulDestinationIPAddress = pxIPHeader->ulSourceIPAddress;
    pxIPHeader->ulSourceIPAddress = ulSourceAddress;
    do
    {
      uint16_t prvTCPReturnPacket$$1$$2$$5$$tmp=pxTCPPacket->xTCPHeader.usSourcePort;
      pxTCPPacket->xTCPHeader.usSourcePort = pxTCPPacket->xTCPHeader.usDestinationPort;
      pxTCPPacket->xTCPHeader.usDestinationPort = prvTCPReturnPacket$$1$$2$$5$$tmp;
    }
    while((_Bool)0);
    pxIPHeader->usIdentification = (uint16_t)((signed int)usPacketIdentifier << 8u | (signed int)usPacketIdentifier >> 8u);
    usPacketIdentifier = usPacketIdentifier + 1;
    pxIPHeader->usFragmentOffset = 0;
    pxIPHeader->usHeaderChecksum = 0;
    pxIPHeader->usHeaderChecksum=usGenerateChecksum(0ul, (uint8_t *)&pxIPHeader->ucVersionHeaderLength, 20ull);
    pxIPHeader->usHeaderChecksum = (uint16_t)~((signed int)(uint16_t)((signed int)pxIPHeader->usHeaderChecksum << 8u | (signed int)pxIPHeader->usHeaderChecksum >> 8u));
    usGenerateProtocolChecksum((uint8_t *)pxTCPPacket, pxNetworkBuffer->xDataLength, 1);
    if((unsigned int)pxTCPPacket->xTCPHeader.usChecksum == 0x0u)
      pxTCPPacket->xTCPHeader.usChecksum = 65535;

    pxNetworkBuffer->xDataLength = (size_t)(ulLen + 14u);
    memcpy((void *)&pxEthernetHeader->xDestinationAddress, (void *)&pxEthernetHeader->xSourceAddress, sizeof(MACAddress_t) /*6ull*/ );
    memcpy((void *)&pxEthernetHeader->xSourceAddress, (void *)xDefaultPartUDPPacketHeader.ucBytes, 6ull);
    xNetworkInterfaceOutput(pxNetworkBuffer, xReleaseAfterSend);
    if(xReleaseAfterSend == 0)
    {
      do
      {
        uint16_t tmp=pxTCPPacket->xTCPHeader.usSourcePort;
        pxTCPPacket->xTCPHeader.usSourcePort = pxTCPPacket->xTCPHeader.usDestinationPort;
        pxTCPPacket->xTCPHeader.usDestinationPort = tmp;
      }
      while((_Bool)0);
      pxTCPPacket->xIPHeader.ulSourceIPAddress = pxTCPPacket->xIPHeader.ulDestinationIPAddress;
      memcpy((void *)pxEthernetHeader->xSourceAddress.ucBytes, (const void *)pxEthernetHeader->xDestinationAddress.ucBytes, 6ull);
    }

  }

}

// prvTCPSendCheck
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 2367
static int32_t prvTCPSendCheck(FreeRTOS_Socket_t *pxSocket, size_t xDataLength)
{
  int32_t xResult=1;
  BaseType_t return_value_prvValidSocket=prvValidSocket(pxSocket, 6, 1);
  if(return_value_prvValidSocket == 0)
    xResult = -22;

  else
    if(!((unsigned int)pxSocket->u.xTCP.bits.bMallocError == 0u))
      xResult = -12;

    else
      if((signed int)pxSocket->u.xTCP.ucTCPState == 0)
        xResult = -128;

      else
        if(!((unsigned int)pxSocket->u.xTCP.bits.bFinSent == 0u))
          xResult = 0;

        else
          if(xDataLength == 0ull)
            xResult = 0;

          else
            if(pxSocket->u.xTCP.txStream == ((const StreamBuffer_t *)NULL))
            {
              prvTCPCreateStream(pxSocket, 0);
              if(pxSocket->u.xTCP.txStream == ((const StreamBuffer_t *)NULL))
                xResult = -12;

            }

  return xResult;
}

// prvTCPSendPacket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 562
static int32_t prvTCPSendPacket(FreeRTOS_Socket_t *pxSocket)
{
  int32_t lResult=0;
  UBaseType_t uxOptionsLength;
  TCPPacket_t *pxTCPPacket;
  NetworkBufferDescriptor_t *pxNetworkBuffer;
  _Bool tmp_if_expr;
  BaseType_t return_value_prvTCPPrepareConnect;
  if(!((signed int)pxSocket->u.xTCP.ucTCPState == 2))
  {
    pxNetworkBuffer = ((NetworkBufferDescriptor_t *)NULL);
    lResult=prvTCPSendRepeated(pxSocket, &pxNetworkBuffer);
    if(!(pxNetworkBuffer == ((NetworkBufferDescriptor_t *)NULL)))
      vReleaseNetworkBufferAndDescriptor(pxNetworkBuffer);

  }

  else
    if((unsigned int)pxSocket->u.xTCP.ucRepCount >= 3u)
    {
      while((_Bool)0)
        ;
      vTCPStateChange(pxSocket, /*enum*/eCLOSE_WAIT);
    }

    else
    {
      if(!((unsigned int)pxSocket->u.xTCP.bits.bConnPrepared == 0u))
        tmp_if_expr = (_Bool)1;

      else
      {
        return_value_prvTCPPrepareConnect=prvTCPPrepareConnect(pxSocket);
        tmp_if_expr = return_value_prvTCPPrepareConnect == 1 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr)
      {
        pxTCPPacket = (TCPPacket_t *)pxSocket->u.xTCP.xPacket.u.ucLastPacket;
        uxOptionsLength=prvSetSynAckOptions(pxSocket, pxTCPPacket);
        lResult = (BaseType_t)(20u + 20u + uxOptionsLength);
        pxTCPPacket->xTCPHeader.ucTCPOffset = (uint8_t)(20u + uxOptionsLength << 2);
        pxSocket->u.xTCP.ucRepCount = pxSocket->u.xTCP.ucRepCount + 1;
        prvTCPReturnPacket(pxSocket, ((NetworkBufferDescriptor_t *)NULL), (uint32_t)lResult, 0);
      }

    }
  return lResult;
}

// prvTCPSendRepeated
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 637
static int32_t prvTCPSendRepeated(FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkBuffer)
{
  UBaseType_t uxIndex;
  int32_t lResult=0;
  UBaseType_t uxOptionsLength=0u;
  int32_t xSendLength;
  uxIndex = 0u;
  for( ; !(uxIndex >= 8ul); uxIndex = uxIndex + 1ul)
  {
    xSendLength=prvTCPPrepareSend(pxSocket, ppxNetworkBuffer, uxOptionsLength);
    if(!(xSendLength >= 1))
      break;

    prvTCPReturnPacket(pxSocket, *ppxNetworkBuffer, (uint32_t)xSendLength, 0);
    lResult = lResult + xSendLength;
  }
  return lResult;
}

// prvTCPSendReset
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 2847
static BaseType_t prvTCPSendReset(NetworkBufferDescriptor_t *pxNetworkBuffer)
{
  TCPPacket_t *pxTCPPacket=(TCPPacket_t *)pxNetworkBuffer->pucEthernetBuffer;
  const BaseType_t xSendLength=(BaseType_t)(20u + 20u + 0u);
  pxTCPPacket->xTCPHeader.ucTCPFlags = (uint8_t)(0x10u | 0x4u);
  pxTCPPacket->xTCPHeader.ucTCPOffset = (uint8_t)(20u + 0u << 2);
  prvTCPReturnPacket(((FreeRTOS_Socket_t *)NULL), pxNetworkBuffer, (uint32_t)xSendLength, 0);
  (void)pxNetworkBuffer;
  return 0;
}

// prvTCPSetSocketCount
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 1244
static void prvTCPSetSocketCount(FreeRTOS_Socket_t *pxSocketToDelete)
{
  const ListItem_t *pxIterator;
  const MiniListItem_t *prvTCPSetSocketCount$$1$$pxEnd=(const MiniListItem_t *)(const ListItem_t *)&(&xBoundTCPSocketsList)->xListEnd;
  FreeRTOS_Socket_t *pxOtherSocket;
  uint16_t usLocalPort=pxSocketToDelete->usLocalPort;
  pxIterator = (const ListItem_t *)prvTCPSetSocketCount$$1$$pxEnd->pxNext;
  for( ; !(pxIterator == (const ListItem_t *)prvTCPSetSocketCount$$1$$pxEnd); pxIterator = (const ListItem_t *)pxIterator->pxNext)
  {
    pxOtherSocket = (FreeRTOS_Socket_t *)pxIterator->pvOwner;
    if((signed int)pxOtherSocket->u.xTCP.ucTCPState == 1)
    {
      if(pxOtherSocket->usLocalPort == usLocalPort)
      {
        if(!(pxOtherSocket->u.xTCP.usChildCount == 0))
        {
          pxOtherSocket->u.xTCP.usChildCount = pxOtherSocket->u.xTCP.usChildCount - 1;
          while((_Bool)0)
            ;
          break;
        }

      }

    }

  }
}

// prvTCPSocketCopy
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 3171
static BaseType_t prvTCPSocketCopy(FreeRTOS_Socket_t *pxNewSocket, FreeRTOS_Socket_t *pxSocket)
{
  struct freertos_sockaddr xAddress;
  pxNewSocket->xReceiveBlockTime = pxSocket->xReceiveBlockTime;
  pxNewSocket->xSendBlockTime = pxSocket->xSendBlockTime;
  pxNewSocket->ucSocketOptions = pxSocket->ucSocketOptions;
  pxNewSocket->u.xTCP.uxRxStreamSize = pxSocket->u.xTCP.uxRxStreamSize;
  pxNewSocket->u.xTCP.uxTxStreamSize = pxSocket->u.xTCP.uxTxStreamSize;
  pxNewSocket->u.xTCP.uxLittleSpace = pxSocket->u.xTCP.uxLittleSpace;
  pxNewSocket->u.xTCP.uxEnoughSpace = pxSocket->u.xTCP.uxEnoughSpace;
  pxNewSocket->u.xTCP.uxRxWinSize = pxSocket->u.xTCP.uxRxWinSize;
  pxNewSocket->u.xTCP.uxTxWinSize = pxSocket->u.xTCP.uxTxWinSize;
  xAddress.sin_addr = *((uint32_t *)&xDefaultPartUDPPacketHeader.ulWords[(signed long long int)(20ull / sizeof(uint32_t) /*4ull*/ )]);
  xAddress.sin_port = (uint16_t)((signed int)pxSocket->usLocalPort << 8u | (signed int)pxSocket->usLocalPort >> 8u);
  pxNewSocket->u.xTCP.bits.bPassQueued = 1u;
  pxNewSocket->u.xTCP.pxPeerSocket = pxSocket;
  pxSocket->u.xTCP.usChildCount = pxSocket->u.xTCP.usChildCount + 1;
  while((_Bool)0)
    ;
  BaseType_t return_value_vSocketBind=vSocketBind(pxNewSocket, &xAddress, sizeof(struct freertos_sockaddr) /*8ull*/ , 1);
  if(!(return_value_vSocketBind == 0))
  {
    while((_Bool)0)
      ;
    vSocketClose(pxNewSocket);
    return 0;
  }

  else
    return 1;
}

// prvTCPSocketIsActive
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 366
static BaseType_t prvTCPSocketIsActive(UBaseType_t uxStatus)
{
  if(uxStatus == 0ul || uxStatus == 7ul || uxStatus == 8ul || uxStatus == 9ul || uxStatus == 11ul)
    return 0;

  else
    return 1;
}

// prvTCPStatusAgeCheck
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 384
static BaseType_t prvTCPStatusAgeCheck(FreeRTOS_Socket_t *pxSocket)
{
  BaseType_t xResult;
  switch((signed int)pxSocket->u.xTCP.ucTCPState)
  {
    case 5:
    {
      xResult = 0;
      break;
    }
    case 0:

    case 1:

    case 8:
    {
      xResult = 0;
      break;
    }
    default:
      xResult = 1;
  }
  if(!(xResult == 0))
  {
    TickType_t xAge;
    TickType_t return_value_xTaskGetTickCount=xTaskGetTickCount();
    xAge = return_value_xTaskGetTickCount - pxSocket->u.xTCP.xLastActTime;
    if(xAge >= 30001u)
    {
      vTCPStateChange(pxSocket, /*enum*/eCLOSE_WAIT);
      if(!((unsigned int)pxSocket->u.xTCP.bits.bPassQueued == 0u))
      {
        if((unsigned int)pxSocket->u.xTCP.bits.bReuseSocket == 0u)
          vSocketClose(pxSocket);

        xResult = -1;
      }

    }

  }

  return xResult;
}

// prvTCPTouchSocket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 1407
static void prvTCPTouchSocket(FreeRTOS_Socket_t *pxSocket)
{
  pxSocket->u.xTCP.xLastActTime=xTaskGetTickCount();
  pxSocket->u.xTCP.bits.bWaitKeepAlive = 0u;
  pxSocket->u.xTCP.bits.bSendKeepAlive = 0u;
  pxSocket->u.xTCP.ucKeepRepCount = 0;
  pxSocket->u.xTCP.xLastAliveTime=xTaskGetTickCount();
  (void)pxSocket;
}

// prvTCPWindowFastRetransmit
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 1578
static uint32_t prvTCPWindowFastRetransmit(TCPWindow_t *pxWindow, uint32_t ulFirst)
{
  const ListItem_t *pxIterator;
  const MiniListItem_t *prvTCPWindowFastRetransmit$$1$$pxEnd;
  TCPSegment_t *pxSegment;
  uint32_t ulCount=0ul;
  prvTCPWindowFastRetransmit$$1$$pxEnd = (const MiniListItem_t *)(const ListItem_t *)&(&pxWindow->xWaitQueue)->xListEnd;
  pxIterator = (const ListItem_t *)prvTCPWindowFastRetransmit$$1$$pxEnd->pxNext;
  BaseType_t return_value_xSequenceLessThan;
  while(!(pxIterator == (const ListItem_t *)prvTCPWindowFastRetransmit$$1$$pxEnd))
  {
    pxSegment = (TCPSegment_t *)pxIterator->pvOwner;
    pxIterator = (const ListItem_t *)pxIterator->pxNext;
    if((unsigned int)pxSegment->u.bits.bAcked == 0u)
    {
      return_value_xSequenceLessThan=xSequenceLessThan(pxSegment->ulSequenceNumber, ulFirst);
      if(!(return_value_xSequenceLessThan == 0))
      {
        pxSegment->u.bits.ucDupAckCount = (uint32_t)pxSegment->u.bits.ucDupAckCount + 1u;
        if((uint32_t)pxSegment->u.bits.ucDupAckCount == 3u)
        {
          pxSegment->u.bits.ucTransmitCount = 0u;
          if(xTCPWindowLoggingLevel >= 0)
          {
            if(!((unsigned int)pxWindow->usOurPortNumber == 23u))
            {
              while((_Bool)0)
                ;
              while((_Bool)0)
                ;
            }

          }

          uxListRemove(&pxSegment->xQueueItem);
          vListInsertFifo(&pxWindow->xPriorityQueue, &pxSegment->xQueueItem);
          ulCount = ulCount + 1u;
        }

      }

    }

  }
  return ulCount;
}

// prvTCPWindowTxCheckAck
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 1427
static uint32_t prvTCPWindowTxCheckAck(TCPWindow_t *pxWindow, uint32_t ulFirst, uint32_t ulLast)
{
  uint32_t ulBytesConfirmed=0u;
  uint32_t ulSequenceNumber=ulFirst;
  uint32_t ulDataLength;
  const ListItem_t *pxIterator;
  const MiniListItem_t *prvTCPWindowTxCheckAck$$1$$pxEnd=(const MiniListItem_t *)(const ListItem_t *)&(&pxWindow->xTxSegments)->xListEnd;
  BaseType_t xDoUnlink;
  TCPSegment_t *pxSegment;
  pxIterator = (const ListItem_t *)prvTCPWindowTxCheckAck$$1$$pxEnd->pxNext;
  _Bool tmp_if_expr;
  BaseType_t return_value_xSequenceLessThan;
  do
  {
    if(!(pxIterator == (const ListItem_t *)prvTCPWindowTxCheckAck$$1$$pxEnd))
    {
      return_value_xSequenceLessThan=xSequenceLessThan(ulSequenceNumber, ulLast);
      tmp_if_expr = return_value_xSequenceLessThan != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr = (_Bool)0;
    if(!tmp_if_expr)
      break;

    xDoUnlink = 0;
    pxSegment = (TCPSegment_t *)pxIterator->pvOwner;
    pxIterator = (const ListItem_t *)pxIterator->pxNext;
    BaseType_t return_value_xSequenceGreaterThan=xSequenceGreaterThan(ulSequenceNumber, pxSegment->ulSequenceNumber);
    if(return_value_xSequenceGreaterThan == 0)
    {
      if(!(ulSequenceNumber == pxSegment->ulSequenceNumber))
        break;

      ulDataLength = (uint32_t)pxSegment->lDataLength;
      if((unsigned int)pxSegment->u.bits.bAcked == 0u)
      {
        BaseType_t return_value_xSequenceGreaterThan$0=xSequenceGreaterThan(pxSegment->ulSequenceNumber + (uint32_t)ulDataLength, ulLast);
        if(!(return_value_xSequenceGreaterThan$0 == 0))
          break;

        pxSegment->u.bits.bAcked = 1u;
        if((signed int)pxSegment->u.bits.ucTransmitCount == 1)
        {
          if(pxSegment->ulSequenceNumber + ulDataLength == ulLast)
          {
            int32_t mS;
            uint32_t return_value_ulTimerGetAge=ulTimerGetAge(&pxSegment->xTransmitTimer);
            mS = (int32_t)return_value_ulTimerGetAge;
            if(pxWindow->lSRTT >= mS)
              pxWindow->lSRTT = (1 * mS + 7 * pxWindow->lSRTT) / (1 + 7);

            else
              pxWindow->lSRTT = (2 * mS + 6 * pxWindow->lSRTT) / (2 + 6);
            if(!(pxWindow->lSRTT >= 50))
              pxWindow->lSRTT = 50;

          }

        }

        xDoUnlink = 1;
      }

      if(ulSequenceNumber == pxWindow->tx.ulCurrentSequenceNumber)
      {
        if(xTCPWindowLoggingLevel >= 2)
        {
          if(!((unsigned int)pxWindow->usOurPortNumber == 23u))
            while((_Bool)0)
              ;

        }

        pxWindow->tx.ulCurrentSequenceNumber = pxWindow->tx.ulCurrentSequenceNumber + ulDataLength;
        ulBytesConfirmed = ulBytesConfirmed + ulDataLength;
        vTCPWindowFree(pxSegment);
        xDoUnlink = 0;
      }

      if(!(xDoUnlink == 0))
      {
        if(!(pxSegment->xQueueItem.pvContainer == NULL))
          uxListRemove(&pxSegment->xQueueItem);

      }

      ulSequenceNumber = ulSequenceNumber + ulDataLength;
    }

  }
  while((_Bool)1);
  return ulBytesConfirmed;
}

// prvTCPWindowTxHasSpace
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 1124
static BaseType_t prvTCPWindowTxHasSpace(TCPWindow_t *pxWindow, uint32_t ulWindowSize)
{
  uint32_t ulTxOutstanding;
  BaseType_t xHasSpace;
  TCPSegment_t *pxSegment=xTCPWindowPeekHead(&pxWindow->xTxQueue);
  if(pxSegment == ((TCPSegment_t *)NULL))
    xHasSpace = 0;

  else
  {
    if(pxWindow->tx.ulHighestSequenceNumber >= pxWindow->tx.ulCurrentSequenceNumber)
      ulTxOutstanding = pxWindow->tx.ulHighestSequenceNumber - pxWindow->tx.ulCurrentSequenceNumber;

    else
      ulTxOutstanding = 0ul;
    uint32_t return_value_FreeRTOS_min_uint32=FreeRTOS_min_uint32$link3(ulWindowSize, ulTxOutstanding);
    ulWindowSize = ulWindowSize - return_value_FreeRTOS_min_uint32;
    if(ulWindowSize >= (uint32_t)pxSegment->lDataLength)
      xHasSpace = 1;

    else
      xHasSpace = 0;
    if(!(ulTxOutstanding == 0ul))
    {
      if(!(pxWindow->xSize.ulTxWindowLength >= ulTxOutstanding + (uint32_t)pxSegment->lDataLength))
        xHasSpace = 0;

    }

  }
  return xHasSpace;
}

// prvTaskCheckFreeStackSpace
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3699
static uint16_t prvTaskCheckFreeStackSpace(const uint8_t *pucStackByte)
{
  uint32_t ulCount=0u;
  for( ; *pucStackByte == 165; ulCount = ulCount + 1u)
    pucStackByte = pucStackByte - (signed long long int)-1;
  ulCount = ulCount / (uint32_t)sizeof(StackType_t) /*8u*/ ;
  return (uint16_t)ulCount;
}

// prvTaskIsTaskSuspended
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 1742
static BaseType_t prvTaskIsTaskSuspended(const TaskHandle_t xTask)
{
  BaseType_t xReturn=0;
  const TCB_t * const pxTCB=(TCB_t *)xTask;
  if(xTask == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 1751u);

  if(pxTCB->xStateListItem.pvContainer == (void *)&xSuspendedTaskList)
  {
    if(!(pxTCB->xEventListItem.pvContainer == (void *)&xPendingReadyList))
    {
      if(pxTCB->xEventListItem.pvContainer == NULL)
        xReturn = 1;

    }

  }

  return xReturn;
}

// prvTestWaitCondition
// file ..\..\..\..\lib\FreeRTOS\event_groups.c line 656
static BaseType_t prvTestWaitCondition(const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits)
{
  BaseType_t xWaitConditionMet=0;
  if(xWaitForAllBits == 0)
  {
    if(!((uxBitsToWaitFor & uxCurrentEventBits) == 0u))
      xWaitConditionMet = 1;

  }

  else
    if((uxBitsToWaitFor & uxCurrentEventBits) == uxBitsToWaitFor)
      xWaitConditionMet = 1;

  return xWaitConditionMet;
}

// prvTimerTask
// file ..\..\..\..\lib\FreeRTOS\timers.c line 502
static void prvTimerTask(void *pvParameters)
{
  TickType_t xNextExpireTime;
  BaseType_t xListWasEmpty;
  (void)pvParameters;
  while((_Bool)1)
  {
    xNextExpireTime=prvGetNextExpireTime(&xListWasEmpty);
    prvProcessTimerOrBlockTask(xNextExpireTime, xListWasEmpty);
    prvProcessReceivedCommands();
  }
}

// prvTraceCreateSymbolTableEntry
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2812
static uint16_t prvTraceCreateSymbolTableEntry(const char *name, uint8_t crc6, uint8_t len, traceString channel)
{
  uint16_t ret=0;
  if(name == ((const char *)NULL))
  {
    prvTraceError("TRACE_ASSERT: prvTraceCreateSymbolTableEntry: name == NULL");
    return 0;
  }

  else
    if((signed int)len == 0)
    {
      prvTraceError("TRACE_ASSERT: prvTraceCreateSymbolTableEntry: len == 0");
      return 0;
    }

    else
    {
      if(4u + RecorderDataPtr->SymbolTable.nextFreeSymbolIndex + (unsigned int)len >= 5000u)
      {
        prvTraceError("Symbol table full. Increase TRC_CFG_SYMBOL_TABLE_SIZE in trcConfig.h");
        ret = 0;
      }

      else
      {
        RecorderDataPtr->SymbolTable.symbytes[(signed long long int)RecorderDataPtr->SymbolTable.nextFreeSymbolIndex] = (uint8_t)((signed int)RecorderDataPtr->SymbolTable.latestEntryOfChecksum[(signed long long int)crc6] & 0xFF);
        RecorderDataPtr->SymbolTable.symbytes[(signed long long int)(RecorderDataPtr->SymbolTable.nextFreeSymbolIndex + 1u)] = (uint8_t)((signed int)RecorderDataPtr->SymbolTable.latestEntryOfChecksum[(signed long long int)crc6] / 0x100);
        RecorderDataPtr->SymbolTable.symbytes[(signed long long int)(RecorderDataPtr->SymbolTable.nextFreeSymbolIndex + 2u)] = (uint8_t)((signed int)channel & 0xFF);
        RecorderDataPtr->SymbolTable.symbytes[(signed long long int)(RecorderDataPtr->SymbolTable.nextFreeSymbolIndex + 3u)] = (uint8_t)((signed int)channel / 0x100);
        prvStrncpy((char *)&RecorderDataPtr->SymbolTable.symbytes[(signed long long int)(RecorderDataPtr->SymbolTable.nextFreeSymbolIndex + 4u)], name, (uint32_t)len);
        RecorderDataPtr->SymbolTable.symbytes[(signed long long int)(RecorderDataPtr->SymbolTable.nextFreeSymbolIndex + 4u + (unsigned int)len)] = 0;
        RecorderDataPtr->SymbolTable.latestEntryOfChecksum[(signed long long int)crc6] = (uint16_t)RecorderDataPtr->SymbolTable.nextFreeSymbolIndex;
        RecorderDataPtr->SymbolTable.nextFreeSymbolIndex = RecorderDataPtr->SymbolTable.nextFreeSymbolIndex + (uint32_t)((signed int)len + 5);
        ret = (uint16_t)(RecorderDataPtr->SymbolTable.nextFreeSymbolIndex - (unsigned int)(uint8_t)((signed int)len + 5));
      }
      return ret;
    }
}

// prvTraceError
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2537
void prvTraceError(const char *msg)
{
  vTraceStop();
  if(traceErrorMessage == ((const char *)NULL))
  {
    traceErrorMessage = (char *)(intptr_t) msg;
    if(!(RecorderDataPtr == ((RecorderDataType *)NULL)))
    {
      prvStrncpy(RecorderDataPtr->systemInfo, traceErrorMessage, 80u);
      RecorderDataPtr->internalErrorOccured = 1u;
    }

  }

}

// prvTraceFreeObjectHandle
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2380
void prvTraceFreeObjectHandle(traceObjectClass objectclass, traceHandle handle)
{
  signed int indexOfHandle;
  if((signed int)objectclass >= 7)
    prvTraceError("TRACE_ASSERT: prvTraceFreeObjectHandle: Invalid value for objectclass");

  else
  {
    _Bool tmp_if_expr;
    if((signed int)handle >= 1)
      tmp_if_expr = (signed int)handle <= (signed int)RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[(signed long long int)objectclass] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr = (_Bool)0;
    if(!tmp_if_expr)
      prvTraceError("TRACE_ASSERT: prvTraceFreeObjectHandle: Invalid value for handle");

    else
      if(!(-1 + (signed int)objectHandleStacks.indexOfNextAvailableHandle[(signed long long int)objectclass] >= (signed int)objectHandleStacks.lowestIndexOfClass[(signed long long int)objectclass]))
        prvTraceError("Attempt to free more handles than allocated!");

      else
      {
        objectHandleStacks.indexOfNextAvailableHandle[(signed long long int)objectclass] = objectHandleStacks.indexOfNextAvailableHandle[(signed long long int)objectclass] - 1;
        indexOfHandle = (signed int)objectHandleStacks.indexOfNextAvailableHandle[(signed long long int)objectclass];
        objectHandleStacks.objectHandles[(signed long long int)indexOfHandle] = handle;
      }
  }
}

// prvTraceGetChecksum
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2873
static void prvTraceGetChecksum(const char *pname, uint8_t *pcrc, uint8_t *plength)
{
  unsigned char c;
  signed int length=1;
  signed int crc=0;
  const char *tmp_post;
  if(pname == ((const char *)NULL))
    prvTraceError("TRACE_ASSERT: prvTraceGetChecksum: pname == NULL");

  else
    if(pcrc == ((uint8_t *)NULL))
      prvTraceError("TRACE_ASSERT: prvTraceGetChecksum: pcrc == NULL");

    else
      if(plength == ((uint8_t *)NULL))
        prvTraceError("TRACE_ASSERT: prvTraceGetChecksum: plength == NULL");

      else
      {
        if(!(pname == ((const char *)NULL)))
          do
          {
            tmp_post = pname;
            pname = pname + 1ll;
            c = (unsigned char)*tmp_post;
            if((signed int)c == 0)
              break;

            crc = crc + (signed int)c;
            length = length + 1;
          }
          while((_Bool)1);

        *pcrc = (uint8_t)(crc & 0x3F);
        *plength = (uint8_t)length;
      }
}

// prvTraceGetCurrentTaskHandle
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcKernelPort.c line 452
void * prvTraceGetCurrentTaskHandle(void)
{
  TaskHandle_t return_value_xTaskGetCurrentTaskHandle=xTaskGetCurrentTaskHandle();
  return return_value_xTaskGetCurrentTaskHandle;
}

// prvTraceGetDTS
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2651
static uint16_t prvTraceGetDTS(uint16_t param_maxDTS)
{
  XTSEvent *xts=((XTSEvent *)NULL);
  uint32_t dts=0u;
  uint32_t timestamp=0u;
  unsigned long int return_value_ulGetRunTimeCounterValue;
  if(!((signed int)param_maxDTS == 0xFF) && !((signed int)param_maxDTS == 0xFFFF))
  {
    prvTraceError("TRACE_ASSERT: prvTraceGetDTS: Invalid value for param_maxDTS");
    return 0;
  }

  else
  {
    if(RecorderDataPtr->frequency == 0u)
    {
      if(!(timestampFrequency == 0u))
        RecorderDataPtr->frequency = timestampFrequency / 1u;

      else
      {
        return_value_ulGetRunTimeCounterValue=ulGetRunTimeCounterValue();
        if(!(init_hwtc_count == return_value_ulGetRunTimeCounterValue))
          RecorderDataPtr->frequency = (uint32_t)(100000 / 1);

      }
    }

    prvTracePortGetTimeStamp(&timestamp);
    static uint32_t old_timestamp=0u;
    dts = timestamp - old_timestamp;
    old_timestamp = timestamp;
    if(RecorderDataPtr->frequency >= 1u)
    {
      if(!(RecorderDataPtr->frequency >= dts))
      {
        RecorderDataPtr->absTimeLastEventSecond = RecorderDataPtr->absTimeLastEventSecond + dts / RecorderDataPtr->frequency;
        RecorderDataPtr->absTimeLastEvent = RecorderDataPtr->absTimeLastEvent + dts % RecorderDataPtr->frequency;
      }

      else
        RecorderDataPtr->absTimeLastEvent = RecorderDataPtr->absTimeLastEvent + dts;
      if(RecorderDataPtr->absTimeLastEvent >= RecorderDataPtr->frequency)
      {
        RecorderDataPtr->absTimeLastEventSecond = RecorderDataPtr->absTimeLastEventSecond + 1u;
        RecorderDataPtr->absTimeLastEvent = RecorderDataPtr->absTimeLastEvent - RecorderDataPtr->frequency;
      }

    }

    else
      RecorderDataPtr->absTimeLastEvent = timestamp;
    if(!((unsigned int)param_maxDTS >= dts))
    {
      void *return_value_prvTraceNextFreeEventBufferSlot=prvTraceNextFreeEventBufferSlot();
      xts = (XTSEvent *)return_value_prvTraceNextFreeEventBufferSlot;
      if(!(xts == ((XTSEvent *)NULL)))
      {
        if((signed int)param_maxDTS == 0xFFFF)
        {
          xts->type = (uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 1ul);
          xts->xts_16 = (uint16_t)(dts / 65536u & 65535u);
          xts->xts_8 = 0;
        }

        else
          if((signed int)param_maxDTS == 0xFF)
          {
            xts->type = (uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 0ul);
            xts->xts_16 = (uint16_t)(dts / 256u & 65535u);
            xts->xts_8 = (uint8_t)(dts / 16777216u & 255u);
          }

          else
            prvTraceError("Bad param_maxDTS in prvTraceGetDTS");
        prvTraceUpdateCounters();
      }

    }

    return (uint16_t)((signed int)(uint16_t)dts & (signed int)param_maxDTS);
  }
}

// prvTraceGetObjectHandle
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2334
traceHandle prvTraceGetObjectHandle(traceObjectClass objectclass)
{
  traceHandle handle;
  if((signed int)objectclass >= 7)
  {
    prvTraceError("TRACE_ASSERT: prvTraceGetObjectHandle: Invalid value for objectclass");
    return 0;
  }

  else
  {
    static signed int indexOfHandle;
    indexOfHandle = (signed int)objectHandleStacks.indexOfNextAvailableHandle[(signed long long int)objectclass];
    if((signed int)objectHandleStacks.objectHandles[(signed long long int)indexOfHandle] == 0)
      objectHandleStacks.objectHandles[(signed long long int)indexOfHandle] = (traceHandle)((1 + indexOfHandle) - (signed int)objectHandleStacks.lowestIndexOfClass[(signed long long int)objectclass]);

    handle = objectHandleStacks.objectHandles[(signed long long int)indexOfHandle];
    if(!((signed int)objectHandleStacks.highestIndexOfClass[(signed long long int)objectclass] >= (signed int)objectHandleStacks.indexOfNextAvailableHandle[(signed long long int)objectclass]))
    {
      const char *return_value_pszTraceGetErrorNotEnoughHandles=pszTraceGetErrorNotEnoughHandles(objectclass);
      prvTraceError(return_value_pszTraceGetErrorNotEnoughHandles);
      handle = 0;
    }

    else
    {
      signed int hndCount;
      objectHandleStacks.indexOfNextAvailableHandle[(signed long long int)objectclass] = objectHandleStacks.indexOfNextAvailableHandle[(signed long long int)objectclass] + 1;
      hndCount = (signed int)objectHandleStacks.indexOfNextAvailableHandle[(signed long long int)objectclass] - (signed int)objectHandleStacks.lowestIndexOfClass[(signed long long int)objectclass];
      if(!((signed int)objectHandleStacks.handleCountWaterMarksOfClass[(signed long long int)objectclass] >= hndCount))
        objectHandleStacks.handleCountWaterMarksOfClass[(signed long long int)objectclass] = (uint16_t)(traceHandle)hndCount;

      switch((signed int)objectclass)
      {
        case 0:
        {
          trcExcludedObjects[(signed long long int)((signed int)handle >> 3)] = trcExcludedObjects[(signed long long int)((signed int)handle >> 3)] & (uint8_t)~(1 << ((signed int)handle & 7));
          break;
        }
        case 1:
        {
          trcExcludedObjects[(signed long long int)(90 + 1 + (signed int)handle >> 3)] = trcExcludedObjects[(signed long long int)(90 + 1 + (signed int)handle >> 3)] & (uint8_t)~(1 << (90 + 1 + (signed int)handle & 7));
          break;
        }
        case 2:
        {
          trcExcludedObjects[(signed long long int)(90 + 1 + 90 + 1 + (signed int)handle >> 3)] = trcExcludedObjects[(signed long long int)(90 + 1 + 90 + 1 + (signed int)handle >> 3)] & (uint8_t)~(1 << (90 + 1 + 90 + 1 + (signed int)handle & 7));
          break;
        }
        case 3:
        {
          trcExcludedObjects[(signed long long int)(90 + 1 + 90 + 1 + 90 + 1 + (signed int)handle >> 3)] = trcExcludedObjects[(signed long long int)(90 + 1 + 90 + 1 + 90 + 1 + (signed int)handle >> 3)] & (uint8_t)~(1 << (90 + 1 + 90 + 1 + 90 + 1 + (signed int)handle & 7));
          break;
        }
        case 5:
        {
          trcExcludedObjects[(signed long long int)(90 + 1 + 90 + 1 + 90 + 1 + 150 + 1 + (signed int)handle >> 3)] = trcExcludedObjects[(signed long long int)(90 + 1 + 90 + 1 + 90 + 1 + 150 + 1 + (signed int)handle >> 3)] & (uint8_t)~(1 << (90 + 1 + 90 + 1 + 90 + 1 + 150 + 1 + (signed int)handle & 7));
          break;
        }
        case 6:
          trcExcludedObjects[(signed long long int)(90 + 1 + 90 + 1 + 90 + 1 + 150 + 1 + 250 + 1 + (signed int)handle >> 3)] = trcExcludedObjects[(signed long long int)(90 + 1 + 90 + 1 + 90 + 1 + 150 + 1 + 250 + 1 + (signed int)handle >> 3)] & (uint8_t)~(1 << (90 + 1 + 90 + 1 + 90 + 1 + 150 + 1 + 250 + 1 + (signed int)handle & 7));
      }
    }
    return handle;
  }
}

// prvTraceGetObjectNumber
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcKernelPort.c line 463
traceHandle prvTraceGetObjectNumber(void *handle)
{
  UBaseType_t return_value_uxQueueGetQueueNumber=uxQueueGetQueueNumber(handle);
  return (traceHandle)return_value_uxQueueGetQueueNumber;
}

// prvTraceGetObjectState
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2121
static uint8_t prvTraceGetObjectState(uint8_t objectclass, traceHandle id)
{
  if((signed int)objectclass >= 7)
  {
    prvTraceError("TRACE_ASSERT: prvTraceGetObjectState: objectclass >= TRACE_NCLASSES");
    return 0;
  }

  else
    if(!((signed int)RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[(signed long long int)objectclass] >= (signed int)id))
    {
      prvTraceError("TRACE_ASSERT: prvTraceGetObjectState: Invalid value for id");
      return 0;
    }

    else
    {
      uint16_t return_value_uiIndexOfObject=uiIndexOfObject(id, objectclass);
      return RecorderDataPtr->ObjectPropertyTable.objbytes[(signed long long int)((signed int)return_value_uiIndexOfObject + (signed int)RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[(signed long long int)objectclass])];
    }
}

// prvTraceGetObjectType
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcKernelPort.c line 469
uint8_t prvTraceGetObjectType(void *handle)
{
  uint8_t return_value_ucQueueGetQueueType=ucQueueGetQueueType(handle);
  return return_value_ucQueueGetQueueType;
}

// prvTraceGetParam
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 1854
static uint32_t prvTraceGetParam(uint32_t param_max, uint32_t param)
{
  XPSEvent *xps;
  if(!(param_max == 255u) && !(param_max == 65535u))
  {
    prvTraceError("TRACE_ASSERT: prvTraceGetParam: Invalid value for param_max");
    return param;
  }

  else
    if(param_max >= param)
      return param;

    else
    {
      void *return_value_prvTraceNextFreeEventBufferSlot=prvTraceNextFreeEventBufferSlot();
      xps = (XPSEvent *)return_value_prvTraceNextFreeEventBufferSlot;
      if(!(xps == ((XPSEvent *)NULL)))
      {
        xps->type = (uint8_t)(0x0ul + 1ul + 0ul);
        xps->xps_8 = (uint8_t)((param & 65280u & ~param_max) >> 8);
        xps->xps_16 = (uint16_t)((param & 0xFFFF0000u & ~param_max) >> 16);
        prvTraceUpdateCounters();
      }

      return param & param_max;
    }
}

// prvTraceGetPriorityProperty
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2101
uint8_t prvTraceGetPriorityProperty(uint8_t objectclass, traceHandle id)
{
  if((signed int)objectclass >= 7)
  {
    prvTraceError("TRACE_ASSERT: prvTraceGetPriorityProperty: objectclass >= TRACE_NCLASSES");
    return 0;
  }

  else
    if(!((signed int)RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[(signed long long int)objectclass] >= (signed int)id))
    {
      prvTraceError("TRACE_ASSERT: prvTraceGetPriorityProperty: Invalid value for id");
      return 0;
    }

    else
    {
      uint16_t return_value_uiIndexOfObject=uiIndexOfObject(id, objectclass);
      return RecorderDataPtr->ObjectPropertyTable.objbytes[(signed long long int)((signed int)return_value_uiIndexOfObject + (signed int)RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[(signed long long int)objectclass] + 1)];
    }
}

// prvTraceGetTaskNumber
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcKernelPort.c line 474
traceHandle prvTraceGetTaskNumber(void *handle)
{
  UBaseType_t return_value_uxTaskGetTaskNumber=uxTaskGetTaskNumber(handle);
  return (traceHandle)return_value_uxTaskGetTaskNumber;
}

// prvTraceInitTraceData
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2186
static void prvTraceInitTraceData(void)
{
  if(RecorderDataPtr == ((RecorderDataType *)NULL))
    RecorderDataPtr = &RecorderData;

  else
    if((signed int)RecorderDataPtr->startmarker0 == 1)
      goto __CPROVER_DUMP_L3;

  init_hwtc_count=ulGetRunTimeCounterValue();
  memset((void *)RecorderDataPtr, 0, sizeof(RecorderDataType) /*79804ull*/ );
  RecorderDataPtr->version = 6817;
  RecorderDataPtr->minor_version = 5;
  RecorderDataPtr->irq_priority_order = 1;
  RecorderDataPtr->filesize = (uint32_t)sizeof(RecorderDataType) /*79804u*/ ;
  RecorderDataPtr->maxEvents = 15000u;
  RecorderDataPtr->debugMarker0 = -252645136;
  RecorderDataPtr->isUsing16bitHandles = 0u;
  RecorderDataPtr->isrTailchainingThreshold = 0u;
  vTraceInitObjectPropertyTable();
  RecorderDataPtr->debugMarker1 = -235802127;
  RecorderDataPtr->SymbolTable.symTableSize = 5000u;
  RecorderDataPtr->SymbolTable.nextFreeSymbolIndex = 1u;
  RecorderDataPtr->debugMarker2 = -218959118;
  prvStrncpy(RecorderDataPtr->systemInfo, "Trace Recorder Demo", 80u);
  RecorderDataPtr->debugMarker3 = -202116109;
  RecorderDataPtr->endmarker0 = 10;
  RecorderDataPtr->endmarker1 = 11;
  RecorderDataPtr->endmarker2 = 12;
  RecorderDataPtr->endmarker3 = 13;
  RecorderDataPtr->endmarker4 = 113;
  RecorderDataPtr->endmarker5 = 114;
  RecorderDataPtr->endmarker6 = 115;
  RecorderDataPtr->endmarker7 = 116;
  RecorderDataPtr->endmarker8 = 241;
  RecorderDataPtr->endmarker9 = 242;
  RecorderDataPtr->endmarker10 = 243;
  RecorderDataPtr->endmarker11 = 244;
  vTraceInitObjectHandleStack();
  RecorderDataPtr->startmarker11 = 244;
  RecorderDataPtr->startmarker10 = 243;
  RecorderDataPtr->startmarker9 = 242;
  RecorderDataPtr->startmarker8 = 241;
  RecorderDataPtr->startmarker7 = 116;
  RecorderDataPtr->startmarker6 = 115;
  RecorderDataPtr->startmarker5 = 114;
  RecorderDataPtr->startmarker4 = 113;
  RecorderDataPtr->startmarker3 = 4;
  RecorderDataPtr->startmarker2 = 3;
  RecorderDataPtr->startmarker1 = 2;
  RecorderDataPtr->startmarker0 = 1;

__CPROVER_DUMP_L3:
  ;
}

// prvTraceIsSchedulerSuspended
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcKernelPort.c line 593
unsigned char prvTraceIsSchedulerSuspended(void)
{
  BaseType_t return_value_xTaskGetSchedulerState=xTaskGetSchedulerState();
  return (unsigned char)(return_value_xTaskGetSchedulerState == 0);
}

// prvTraceLookupSymbolTableEntry
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2769
static traceString prvTraceLookupSymbolTableEntry(const char *name, uint8_t crc6, uint8_t len, traceString chn)
{
  uint16_t i=RecorderDataPtr->SymbolTable.latestEntryOfChecksum[(signed long long int)crc6];
  if(name == ((const char *)NULL))
  {
    prvTraceError("TRACE_ASSERT: prvTraceLookupSymbolTableEntry: name == NULL");
    return 0;
  }

  else
    if((signed int)len == 0)
    {
      prvTraceError("TRACE_ASSERT: prvTraceLookupSymbolTableEntry: len == 0");
      return 0;
    }

    else
    {
      for( ; !((signed int)i == 0); i = (uint16_t)((signed int)RecorderDataPtr->SymbolTable.symbytes[(signed long long int)i] + (signed int)RecorderDataPtr->SymbolTable.symbytes[(signed long long int)((signed int)i + 1)] * 0x100))
        if((signed int)RecorderDataPtr->SymbolTable.symbytes[(signed long long int)(2 + (signed int)i)] == (0xFF & (signed int)chn))
        {
          if((signed int)RecorderDataPtr->SymbolTable.symbytes[(signed long long int)(3 + (signed int)i)] == (signed int)chn / 0x100)
          {
            if((signed int)RecorderDataPtr->SymbolTable.symbytes[(signed long long int)(4 + (signed int)i + (signed int)len)] == 0)
            {
              signed int return_value_strncmp=strncmp((char *)&RecorderDataPtr->SymbolTable.symbytes[(signed long long int)((signed int)i + 4)], name, (size_t)len);
              if(return_value_strncmp == 0)
                break;

            }

          }

        }

      return i;
    }
}

// prvTraceNextFreeEventBufferSlot
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2299
static void * prvTraceNextFreeEventBufferSlot(void)
{
  if(RecorderDataPtr->recorderActive == 0u)
    return NULL;

  else
    if(RecorderDataPtr->nextFreeIndex >= 15000u)
    {
      prvTraceError("Attempt to index outside event buffer!");
      return NULL;
    }

    else
      return (void *)&RecorderDataPtr->eventData[(signed long long int)(RecorderDataPtr->nextFreeIndex * 4u)];
}

// prvTraceOpenSymbol
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2477
static traceString prvTraceOpenSymbol(const char *name, traceString userEventChannel)
{
  uint16_t result;
  uint8_t len;
  uint8_t crc;
  len = 0;
  crc = 0;
  if(name == ((const char *)NULL))
  {
    prvTraceError("TRACE_ASSERT: prvTraceOpenSymbol: name == NULL");
    return 0;
  }

  else
  {
    prvTraceGetChecksum(name, &crc, &len);
    vPortEnterCritical();
    recorder_busy = recorder_busy + 1;
    result=prvTraceLookupSymbolTableEntry(name, crc, len, userEventChannel);
    if(result == 0)
      result=prvTraceCreateSymbolTableEntry(name, crc, len, userEventChannel);

    recorder_busy = recorder_busy - 1;
    vPortExitCritical();
    return result;
  }
}

// prvTracePortGetTimeStamp
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 3010
void prvTracePortGetTimeStamp(uint32_t *pTimestamp)
{
  uint32_t hwtc_count=0u;
  uint32_t diff=0u;
  uint32_t diff_scaled=0u;
  if(trace_disable_timestamp == 1u)
  {
    if(!(pTimestamp == ((uint32_t *)NULL)))
      *pTimestamp = last_timestamp;

  }

  else
  {
    hwtc_count=ulGetRunTimeCounterValue();
    static uint32_t last_hwtc_count=0u;
    if(!(hwtc_count >= last_hwtc_count))
      hwtc_count = last_hwtc_count;

    static uint32_t last_hwtc_rest=0u;
    diff = (hwtc_count - last_hwtc_count) + last_hwtc_rest;
    diff_scaled = diff / 1u;
    last_hwtc_rest = diff % 1u;
    last_timestamp = last_timestamp + diff_scaled;
    if(!(pTimestamp == ((uint32_t *)NULL)))
      *pTimestamp = last_timestamp;

    last_hwtc_count = hwtc_count;
  }
}

// prvTraceSetObjectName
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2439
void prvTraceSetObjectName(traceObjectClass objectclass, traceHandle handle, const char *name)
{
  if(name == ((const char *)NULL))
    prvTraceError("TRACE_ASSERT: prvTraceSetObjectName: name == NULL");

  else
    if((signed int)objectclass >= 7)
      prvTraceError("Illegal object class in prvTraceSetObjectName");

    else
      if((signed int)handle == 0)
        prvTraceError("Illegal handle (0) in prvTraceSetObjectName.");

      else
        if(!((signed int)RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[(signed long long int)objectclass] >= (signed int)handle))
        {
          const char *return_value_pszTraceGetErrorNotEnoughHandles=pszTraceGetErrorNotEnoughHandles(objectclass);
          prvTraceError(return_value_pszTraceGetErrorNotEnoughHandles);
        }

        else
        {
          static uint16_t idx;
          idx=uiIndexOfObject(handle, objectclass);
          if(traceErrorMessage == ((const char *)NULL))
            prvStrncpy((char *)&RecorderDataPtr->ObjectPropertyTable.objbytes[(signed long long int)idx], name, (uint32_t)RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[(signed long long int)objectclass]);

        }
}

// prvTraceSetObjectState
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2111
void prvTraceSetObjectState(uint8_t objectclass, traceHandle id, uint8_t value)
{
  if((signed int)objectclass >= 7)
    prvTraceError("TRACE_ASSERT: prvTraceSetObjectState: objectclass >= TRACE_NCLASSES");

  else
    if(!((signed int)RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[(signed long long int)objectclass] >= (signed int)id))
      prvTraceError("TRACE_ASSERT: prvTraceSetObjectState: Invalid value for id");

    else
    {
      uint16_t return_value_uiIndexOfObject=uiIndexOfObject(id, objectclass);
      RecorderDataPtr->ObjectPropertyTable.objbytes[(signed long long int)((signed int)return_value_uiIndexOfObject + (signed int)RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[(signed long long int)objectclass])] = value;
    }
}

// prvTraceSetPriorityProperty
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2091
void prvTraceSetPriorityProperty(uint8_t objectclass, traceHandle id, uint8_t value)
{
  if((signed int)objectclass >= 7)
    prvTraceError("TRACE_ASSERT: prvTraceSetPriorityProperty: objectclass >= TRACE_NCLASSES");

  else
    if(!((signed int)RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[(signed long long int)objectclass] >= (signed int)id))
      prvTraceError("TRACE_ASSERT: prvTraceSetPriorityProperty: Invalid value for id");

    else
    {
      uint16_t return_value_uiIndexOfObject=uiIndexOfObject(id, objectclass);
      RecorderDataPtr->ObjectPropertyTable.objbytes[(signed long long int)((signed int)return_value_uiIndexOfObject + (signed int)RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[(signed long long int)objectclass] + 1)] = value;
    }
}

// prvTraceSetReadyEventsEnabled
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 1515
void prvTraceSetReadyEventsEnabled(signed int status)
{
  readyEventsEnabled = status;
}

// prvTraceSetTaskInstanceFinished
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2131
void prvTraceSetTaskInstanceFinished(traceHandle handle)
{
  if(!((signed int)RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[3ll] >= (signed int)handle))
    prvTraceError("TRACE_ASSERT: prvTraceSetTaskInstanceFinished: Invalid value for handle");

  else
  {
    uint16_t return_value_uiIndexOfObject=uiIndexOfObject(handle, 3);
    RecorderDataPtr->ObjectPropertyTable.objbytes[(signed long long int)((signed int)return_value_uiIndexOfObject + (signed int)RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[3ll])] = 0;
  }
}

// prvTraceStoreKernelCall
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 1723
void prvTraceStoreKernelCall(uint32_t ecode, traceObjectClass objectClass, uint32_t objectNumber)
{
  KernelCall *kse;
  uint16_t dts1;
  uint8_t hnd8;
  if(ecode >= 255u)
    prvTraceError("TRACE_ASSERT: prvTraceStoreKernelCall: ecode >= 0xFF");

  else
    if((signed int)objectClass >= 7)
      prvTraceError("TRACE_ASSERT: prvTraceStoreKernelCall: objectClass >= TRACE_NCLASSES");

    else
      if(!((unsigned int)RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[(signed long long int)objectClass] >= objectNumber))
        prvTraceError("TRACE_ASSERT: prvTraceStoreKernelCall: Invalid value for objectNumber");

      else
        if(!(recorder_busy == 0))
          prvTraceError("Recorder busy - high priority ISR using syscall? (2)");

        else
          if(!((signed int)handle_of_last_logged_task == 0))
          {
            vPortEnterCritical();
            recorder_busy = recorder_busy + 1;
            if(!(RecorderDataPtr->recorderActive == 0u))
            {
              if(inExcludedTask == 0 || !(nISRactive == 0))
              {
                uint8_t return_value_uiTraceIsObjectExcluded=uiTraceIsObjectExcluded(objectClass, (traceHandle)objectNumber);
                if(return_value_uiTraceIsObjectExcluded == 0)
                {
                  if((1 << (7u & ecode) & (signed int)trcExcludedEventCodes[(signed long long int)(ecode >> 3)]) == 0)
                  {
                    uint16_t return_value_prvTraceGetDTS=prvTraceGetDTS(65535);
                    dts1 = (uint16_t)return_value_prvTraceGetDTS;
                    hnd8 = (traceHandle)objectNumber;
                    void *return_value_prvTraceNextFreeEventBufferSlot=prvTraceNextFreeEventBufferSlot();
                    kse = (KernelCall *)return_value_prvTraceNextFreeEventBufferSlot;
                    if(!(kse == ((KernelCall *)NULL)))
                    {
                      kse->dts = dts1;
                      kse->type = (uint8_t)ecode;
                      kse->objHandle = hnd8;
                      prvTraceUpdateCounters();
                    }

                  }

                }

              }

            }

            recorder_busy = recorder_busy - 1;
            vPortExitCritical();
          }

}

// prvTraceStoreKernelCallWithNumericParamOnly
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 1888
void prvTraceStoreKernelCallWithNumericParamOnly(uint32_t evtcode, uint32_t param)
{
  KernelCallWithParam16 *kse;
  uint8_t dts6;
  uint16_t restParam;
  restParam = 0;
  if(evtcode >= 255u)
    prvTraceError("TRACE_ASSERT: prvTraceStoreKernelCallWithNumericParamOnly: Invalid value for evtcode");

  else
    if(!(recorder_busy == 0))
      prvTraceError("Recorder busy - high priority ISR using syscall? (4)");

    else
    {
      vPortEnterCritical();
      recorder_busy = recorder_busy + 1;
      if(!(RecorderDataPtr->recorderActive == 0u))
      {
        if(!(handle_of_last_logged_task == 0))
        {
          if(inExcludedTask == 0 || !(nISRactive == 0))
          {
            if((1 << (7u & evtcode) & (signed int)trcExcludedEventCodes[(signed long long int)(evtcode >> 3)]) == 0)
            {
              uint16_t return_value_prvTraceGetDTS=prvTraceGetDTS(255);
              dts6 = (uint8_t)return_value_prvTraceGetDTS;
              uint32_t return_value_prvTraceGetParam=prvTraceGetParam(65535u, param);
              restParam = (uint16_t)return_value_prvTraceGetParam;
              void *return_value_prvTraceNextFreeEventBufferSlot=prvTraceNextFreeEventBufferSlot();
              kse = (KernelCallWithParam16 *)return_value_prvTraceNextFreeEventBufferSlot;
              if(!(kse == ((KernelCallWithParam16 *)NULL)))
              {
                kse->dts = dts6;
                kse->type = (uint8_t)evtcode;
                kse->param = restParam;
                prvTraceUpdateCounters();
              }

            }

          }

        }

      }

      recorder_busy = recorder_busy - 1;
      vPortExitCritical();
    }
}

// prvTraceStoreKernelCallWithParam
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 1789
void prvTraceStoreKernelCallWithParam(uint32_t evtcode, traceObjectClass objectClass, uint32_t objectNumber, uint32_t param)
{
  KernelCallWithParamAndHandle *kse;
  uint8_t dts2;
  uint8_t hnd8;
  uint8_t p8;
  if(evtcode >= 255u)
    prvTraceError("TRACE_ASSERT: prvTraceStoreKernelCallWithParam: evtcode >= 0xFF");

  else
    if((signed int)objectClass >= 7)
      prvTraceError("TRACE_ASSERT: prvTraceStoreKernelCallWithParam: objectClass >= TRACE_NCLASSES");

    else
      if(!((unsigned int)RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[(signed long long int)objectClass] >= objectNumber))
        prvTraceError("TRACE_ASSERT: prvTraceStoreKernelCallWithParam: Invalid value for objectNumber");

      else
        if(!(recorder_busy == 0))
          prvTraceError("Recorder busy - high priority ISR using syscall? (3)");

        else
        {
          vPortEnterCritical();
          recorder_busy = recorder_busy + 1;
          if(!(RecorderDataPtr->recorderActive == 0u))
          {
            if(!(handle_of_last_logged_task == 0))
            {
              if(inExcludedTask == 0 || !(nISRactive == 0))
              {
                uint8_t return_value_uiTraceIsObjectExcluded=uiTraceIsObjectExcluded(objectClass, (traceHandle)objectNumber);
                if(return_value_uiTraceIsObjectExcluded == 0)
                {
                  if((1 << (7u & evtcode) & (signed int)trcExcludedEventCodes[(signed long long int)(evtcode >> 3)]) == 0)
                  {
                    uint16_t return_value_prvTraceGetDTS=prvTraceGetDTS(255);
                    dts2 = (uint8_t)return_value_prvTraceGetDTS;
                    uint32_t return_value_prvTraceGetParam=prvTraceGetParam(255u, param);
                    p8 = (uint8_t)return_value_prvTraceGetParam;
                    hnd8 = (traceHandle)objectNumber;
                    void *return_value_prvTraceNextFreeEventBufferSlot=prvTraceNextFreeEventBufferSlot();
                    kse = (KernelCallWithParamAndHandle *)return_value_prvTraceNextFreeEventBufferSlot;
                    if(!(kse == ((KernelCallWithParamAndHandle *)NULL)))
                    {
                      kse->dts = dts2;
                      kse->type = (uint8_t)evtcode;
                      kse->objHandle = hnd8;
                      kse->param = p8;
                      prvTraceUpdateCounters();
                    }

                  }

                }

              }

            }

          }

          recorder_busy = recorder_busy - 1;
          vPortExitCritical();
        }
}

// prvTraceStoreLowPower
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 1592
void prvTraceStoreLowPower(uint32_t flag)
{
  uint16_t dts;
  LPEvent *lp;
  if(flag >= 2u)
    prvTraceError("TRACE_ASSERT: prvTraceStoreLowPower: Invalid flag value");

  else
    if(!(recorder_busy == 0))
      prvTraceError("Recorder busy - high priority ISR using syscall? (1)");

    else
    {
      vPortEnterCritical();
      recorder_busy = recorder_busy + 1;
      if(!(RecorderDataPtr->recorderActive == 0u))
      {
        uint16_t return_value_prvTraceGetDTS=prvTraceGetDTS(65535);
        dts = (uint16_t)return_value_prvTraceGetDTS;
        void *return_value_prvTraceNextFreeEventBufferSlot=prvTraceNextFreeEventBufferSlot();
        lp = (LPEvent *)return_value_prvTraceNextFreeEventBufferSlot;
        if(!(lp == ((LPEvent *)NULL)))
        {
          lp->type = (uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 4ul + (unsigned int)(uint8_t)flag);
          lp->dts = dts;
          prvTraceUpdateCounters();
        }

      }

      recorder_busy = recorder_busy - 1;
      vPortExitCritical();
    }
}

// prvTraceStoreObjectNameOnCloseEvent
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2030
void prvTraceStoreObjectNameOnCloseEvent(traceHandle handle, traceObjectClass objectclass)
{
  ObjCloseNameEvent *ce;
  const char *name;
  traceString idx;
  if((signed int)objectclass >= 7)
    prvTraceError("TRACE_ASSERT: prvTraceStoreObjectNameOnCloseEvent: objectclass >= TRACE_NCLASSES");

  else
    if(!((signed int)RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[(signed long long int)objectclass] >= (signed int)handle))
      prvTraceError("TRACE_ASSERT: prvTraceStoreObjectNameOnCloseEvent: Invalid value for handle");

    else
      if(!(RecorderDataPtr->recorderActive == 0u))
      {
        uint8_t hnd8=(uint8_t)handle;
        uint16_t return_value_uiIndexOfObject=uiIndexOfObject(handle, objectclass);
        name = (const char *)&RecorderDataPtr->ObjectPropertyTable.objbytes[(signed long long int)return_value_uiIndexOfObject];
        idx=prvTraceOpenSymbol(name, 0);
        void *return_value_prvTraceNextFreeEventBufferSlot=prvTraceNextFreeEventBufferSlot();
        ce = (ObjCloseNameEvent *)return_value_prvTraceNextFreeEventBufferSlot;
        if(!(ce == ((ObjCloseNameEvent *)NULL)))
        {
          ce->type = (uint8_t)(0x0ul + 1ul + 3ul + 4ul + (unsigned int)objectclass);
          ce->objHandle = hnd8;
          ce->symbolIndex = idx;
          prvTraceUpdateCounters();
        }

      }

}

// prvTraceStoreObjectPropertiesOnCloseEvent
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2060
void prvTraceStoreObjectPropertiesOnCloseEvent(traceHandle handle, traceObjectClass objectclass)
{
  ObjClosePropEvent *pe;
  if((signed int)objectclass >= 7)
    prvTraceError("TRACE_ASSERT: prvTraceStoreObjectPropertiesOnCloseEvent: objectclass >= TRACE_NCLASSES");

  else
    if(!((signed int)RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[(signed long long int)objectclass] >= (signed int)handle))
      prvTraceError("TRACE_ASSERT: prvTraceStoreObjectPropertiesOnCloseEvent: Invalid value for handle");

    else
      if(!(RecorderDataPtr->recorderActive == 0u))
      {
        void *return_value_prvTraceNextFreeEventBufferSlot=prvTraceNextFreeEventBufferSlot();
        pe = (ObjClosePropEvent *)return_value_prvTraceNextFreeEventBufferSlot;
        if(!(pe == ((ObjClosePropEvent *)NULL)))
        {
          if(objectclass == 3)
          {
            uint16_t return_value_uiIndexOfObject=uiIndexOfObject(handle, objectclass);
            pe->arg1 = RecorderDataPtr->ObjectPropertyTable.objbytes[(signed long long int)((signed int)return_value_uiIndexOfObject + (signed int)RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[(signed long long int)objectclass] + 1)];
          }

          else
          {
            uint16_t return_value_uiIndexOfObject$0=uiIndexOfObject(handle, objectclass);
            pe->arg1 = RecorderDataPtr->ObjectPropertyTable.objbytes[(signed long long int)((signed int)return_value_uiIndexOfObject$0 + (signed int)RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[(signed long long int)objectclass])];
          }
          pe->type = (uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + (unsigned int)objectclass);
          prvTraceUpdateCounters();
        }

      }

}

// prvTraceStoreTaskReady
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 1525
void prvTraceStoreTaskReady(traceHandle handle)
{
  uint16_t dts3;
  TREvent *tr;
  uint8_t hnd8;
  if(!((signed int)handle == 0))
  {
    if(!(readyEventsEnabled == 0))
    {
      if((signed int)handle >= 151)
        prvTraceError("TRACE_ASSERT: prvTraceStoreTaskReady: Invalid value for handle");

      else
        if(!(recorder_busy == 0))
          prvTraceError("Recorder busy - high priority ISR using syscall? (1)");

        else
        {
          vPortEnterCritical();
          recorder_busy = recorder_busy + 1;
          if(!(RecorderDataPtr->recorderActive == 0u))
          {
            if((1 << (273 + (signed int)handle & 7) & (signed int)trcExcludedObjects[(signed long long int)(273 + (signed int)handle >> 3)]) == 0)
            {
              uint16_t return_value_prvTraceGetDTS=prvTraceGetDTS(65535);
              dts3 = (uint16_t)return_value_prvTraceGetDTS;
              hnd8 = (uint8_t)handle;
              void *return_value_prvTraceNextFreeEventBufferSlot=prvTraceNextFreeEventBufferSlot();
              tr = (TREvent *)return_value_prvTraceNextFreeEventBufferSlot;
              if(!(tr == ((TREvent *)NULL)))
              {
                tr->type = (uint8_t)(0x0ul + 1ul + 1ul);
                tr->dts = dts3;
                tr->objHandle = hnd8;
                prvTraceUpdateCounters();
              }

            }

          }

          recorder_busy = recorder_busy - 1;
          vPortExitCritical();
        }
    }

  }

}

// prvTraceStoreTaskswitch
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 1943
void prvTraceStoreTaskswitch(traceHandle task_handle)
{
  uint16_t dts3;
  TSEvent *ts;
  int8_t skipEvent;
  uint8_t hnd8;
  skipEvent = 0;
  if((signed int)task_handle >= 151)
    prvTraceError("TRACE_ASSERT: prvTraceStoreTaskswitch: Invalid value for task_handle");

  else
  {
    if(!((1 << (273 + (signed int)task_handle & 7) & (signed int)trcExcludedObjects[(signed long long int)(273 + (signed int)task_handle >> 3)]) == 0))
    {
      skipEvent = 1;
      inExcludedTask = 1;
    }

    else
      inExcludedTask = 0;
    recorder_busy = recorder_busy + 1;
    if(task_handle == handle_of_last_logged_task)
      skipEvent = 1;

    if(RecorderDataPtr->recorderActive == 0u)
      skipEvent = 1;

    if((signed int)skipEvent == 0)
    {
      isPendingContextSwitch = 0;
      uint16_t return_value_prvTraceGetDTS=prvTraceGetDTS(65535);
      dts3 = (uint16_t)return_value_prvTraceGetDTS;
      handle_of_last_logged_task = task_handle;
      hnd8 = (uint8_t)handle_of_last_logged_task;
      void *return_value_prvTraceNextFreeEventBufferSlot=prvTraceNextFreeEventBufferSlot();
      ts = (TSEvent *)return_value_prvTraceNextFreeEventBufferSlot;
      if(!(ts == ((TSEvent *)NULL)))
      {
        uint8_t return_value_prvTraceGetObjectState=prvTraceGetObjectState(3, handle_of_last_logged_task);
        if((signed int)return_value_prvTraceGetObjectState == 1)
          ts->type = (uint8_t)(0x0ul + 1ul + 3ul + 3ul);

        else
          ts->type = (uint8_t)(0x0ul + 1ul + 3ul + 2ul);
        ts->dts = dts3;
        ts->objHandle = hnd8;
        prvTraceSetObjectState(3, handle_of_last_logged_task, 1);
        prvTraceUpdateCounters();
      }

    }

    recorder_busy = recorder_busy - 1;
  }
}

// prvTraceTaskInstanceFinish
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 438
static void prvTraceTaskInstanceFinish(int8_t direct)
{
  TaskInstanceStatusEvent *tis;
  uint8_t dts45;
  vPortEnterCritical();
  recorder_busy = recorder_busy + 1;
  if(!(RecorderDataPtr->recorderActive == 0u))
  {
    if(inExcludedTask == 0 || !(nISRactive == 0))
    {
      if(!(handle_of_last_logged_task == 0))
      {
        uint16_t return_value_prvTraceGetDTS=prvTraceGetDTS(255);
        dts45 = (uint8_t)return_value_prvTraceGetDTS;
        void *return_value_prvTraceNextFreeEventBufferSlot=prvTraceNextFreeEventBufferSlot();
        tis = (TaskInstanceStatusEvent *)return_value_prvTraceNextFreeEventBufferSlot;
        if(!(tis == ((TaskInstanceStatusEvent *)NULL)))
        {
          if((signed int)direct == 0)
            tis->type = (uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + 18ul + 14ul);

          else
            tis->type = (uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + 18ul + 15ul);
          tis->dts = dts45;
          prvTraceUpdateCounters();
        }

      }

    }

  }

  recorder_busy = recorder_busy - 1;
  vPortExitCritical();
}

// prvTraceUpdateCounters
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2615
static void prvTraceUpdateCounters(void)
{
  if(!(RecorderDataPtr->recorderActive == 0u))
  {
    RecorderDataPtr->numEvents = RecorderDataPtr->numEvents + 1u;
    RecorderDataPtr->nextFreeIndex = RecorderDataPtr->nextFreeIndex + 1u;
    if(RecorderDataPtr->nextFreeIndex >= 15000u)
    {
      RecorderDataPtr->bufferIsFull = 1u;
      RecorderDataPtr->nextFreeIndex = 0u;
    }

    prvCheckDataToBeOverwrittenForMultiEntryEvents(1);
  }

}

// prvTraceUserEventFormat
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 897
static uint8_t prvTraceUserEventFormat(const char *formatStr, va_list vl, uint8_t *buffer, uint8_t byteOffset)
{
  uint16_t formatStrIndex=0;
  uint8_t argCounter=0;
  uint8_t i=byteOffset;
  traceString return_value_xTraceRegisterString;
  while(!((signed int)formatStr[(signed long long int)formatStrIndex] == 0))
  {
    if((signed int)formatStr[(signed long long int)formatStrIndex] == 37)
    {
      argCounter = argCounter + 1;
      if((signed int)argCounter >= 16)
      {
        prvTraceError("vTracePrintF - Too many arguments, max 15 allowed!");
        return 0;
      }

      formatStrIndex = formatStrIndex + 1;
      for( ; (_Bool)1; formatStrIndex = formatStrIndex + 1)
      {
        if((signed int)formatStr[(signed long long int)formatStrIndex] >= 48)
        {
          if(!((signed int)formatStr[(signed long long int)formatStrIndex] >= 58))
            goto __CPROVER_DUMP_L5;

        }

        if(!((signed int)formatStr[(signed long long int)formatStrIndex] == 35))
        {
          if(!((signed int)formatStr[(signed long long int)formatStrIndex] == 46))
            break;

        }


      __CPROVER_DUMP_L5:
        ;
      }
      if(!((signed int)formatStr[(signed long long int)formatStrIndex] == 0))
        switch((signed int)formatStr[(signed long long int)formatStrIndex])
        {
          case 100:
          {
            vl = vl + (signed long long int)((sizeof(uint32_t) /*4ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull));
            i=writeInt32((void *)buffer, i, (uint32_t)*((uint32_t *)(vl - (signed long long int)((sizeof(uint32_t) /*4ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull)))));
            break;
          }
          case 120:

          case 88:

          case 117:
          {
            vl = vl + (signed long long int)((sizeof(uint32_t) /*4ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull));
            i=writeInt32((void *)buffer, i, (uint32_t)*((uint32_t *)(vl - (signed long long int)((sizeof(uint32_t) /*4ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull)))));
            break;
          }
          case 115:
          {
            vl = vl + (signed long long int)((sizeof(char *) /*8ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull));
            return_value_xTraceRegisterString=xTraceRegisterString((char *)*((char **)(vl - (signed long long int)((sizeof(char *) /*8ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull)))));
            i=writeInt16((void *)buffer, i, return_value_xTraceRegisterString);
            break;
          }
          case 102:
          {
            vl = vl + (signed long long int)((sizeof(double) /*8ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull));
            i=writeInt32((void *)buffer, i, (uint32_t)*((double *)(vl - (signed long long int)((sizeof(double) /*8ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull)))));
            break;
          }
          case 108:
          {
            formatStrIndex = formatStrIndex + 1;
            if((signed int)formatStr[(signed long long int)formatStrIndex] == 102)
            {
              vl = vl + (signed long long int)((sizeof(double) /*8ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull));
              i=writeInt32((void *)buffer, i, (uint32_t)*((double *)(vl - (signed long long int)((sizeof(double) /*8ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull)))));
              vl = vl + (signed long long int)((sizeof(double) /*8ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull));
              i=writeInt32((void *)buffer, i, (uint32_t)*((double *)(vl - (signed long long int)((sizeof(double) /*8ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull)))));
            }

            break;
          }
          case 104:
          {
            formatStrIndex = formatStrIndex + 1;
            switch((signed int)formatStr[(signed long long int)formatStrIndex])
            {
              case 100:
              {
                vl = vl + (signed long long int)((sizeof(uint32_t) /*4ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull));
                i=writeInt16((void *)buffer, i, (uint16_t)*((uint32_t *)(vl - (signed long long int)((sizeof(uint32_t) /*4ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull)))));
                break;
              }
              case 117:
              {
                vl = vl + (signed long long int)((sizeof(uint32_t) /*4ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull));
                i=writeInt16((void *)buffer, i, (uint16_t)*((uint32_t *)(vl - (signed long long int)((sizeof(uint32_t) /*4ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull)))));
              }
            }
            break;
          }
          case 98:
          {
            formatStrIndex = formatStrIndex + 1;
            switch((signed int)formatStr[(signed long long int)formatStrIndex])
            {
              case 100:
              {
                vl = vl + (signed long long int)((sizeof(uint32_t) /*4ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull));
                i=writeInt8((void *)buffer, i, (uint8_t)*((uint32_t *)(vl - (signed long long int)((sizeof(uint32_t) /*4ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull)))));
                break;
              }
              case 117:
              {
                vl = vl + (signed long long int)((sizeof(uint32_t) /*4ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull));
                i=writeInt8((void *)buffer, i, (uint8_t)*((uint32_t *)(vl - (signed long long int)((sizeof(uint32_t) /*4ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull)))));
              }
            }
          }
        }

      else
        break;
    }

    formatStrIndex = formatStrIndex + 1;
    if((signed int)i == 255)
    {
      prvTraceError("vTracePrintF - Too large arguments, max 32 byte allowed!");
      return 0;
    }

  }
  return (uint8_t)((signed int)(uint8_t)((signed int)i + 3) / 4);
}

// prvUint32PublishSubscribe
// file ..\..\..\common\mqtt\aws_subscribe_publish_loop.c line 328
static BaseType_t prvUint32PublishSubscribe(MQTTAgentConnectParams_t *pxConnectParams, MQTTQoS_t xQOS, MQTTAgentHandle_t prvUint32PublishSubscribe$$xMQTTClientHandle, SubpubUserData_t *pxUserData)
{
  MQTTAgentSubscribeParams_t xSubscribeParams;
  MQTTAgentPublishParams_t xPublishParams;
  MQTTAgentUnsubscribeParams_t xUnsubscribeParams;
  BaseType_t xResult;
  uint32_t ulData;
  uint32_t ulPasses=0ul;
  const uint32_t ulMaxMessages=10ul;
  TickType_t prvUint32PublishSubscribe$$1$$xTickCount=xTaskGetTickCount();
  vLoggingPrintf("%s initiated connection to broker at time %u ticks.\r\n", (const void *)"prvUint32PublishSubscribe", prvUint32PublishSubscribe$$1$$xTickCount);
  char *return_value_pcTaskGetName=pcTaskGetName(NULL);
  strncpy((char *)pxUserData->cTopic, (char *)return_value_pcTaskGetName, 10ull);
  strncat((char *)pxUserData->cTopic, (char *)"/uint/", sizeof(char [9ll]) /*9ull*/ );
  MQTTAgentReturnCode_t return_value_MQTT_AGENT_Connect=MQTT_AGENT_Connect(prvUint32PublishSubscribe$$xMQTTClientHandle, pxConnectParams, xMaxCommandTime$link1);
  if((signed int)return_value_MQTT_AGENT_Connect == 0)
  {
    TickType_t return_value_xTaskGetTickCount=xTaskGetTickCount();
    vLoggingPrintf("%s connection to broker took %u ticks.\r\n", (const void *)"prvUint32PublishSubscribe", return_value_xTaskGetTickCount - prvUint32PublishSubscribe$$1$$xTickCount);
    xSubscribeParams.pucTopic = (const uint8_t *)pxUserData->cTopic;
    size_t return_value_strlen=strlen(pxUserData->cTopic);
    xSubscribeParams.usTopicLength = (uint16_t)return_value_strlen;
    xSubscribeParams.xQoS = xQOS;
    xSubscribeParams.pvPublishCallbackContext = (void *)pxUserData;
    xSubscribeParams.pxPublishCallback = prvMQTTUint32PublishCallback;
    MQTTAgentReturnCode_t return_value_MQTT_AGENT_Subscribe=MQTT_AGENT_Subscribe(prvUint32PublishSubscribe$$xMQTTClientHandle, &xSubscribeParams, xMaxCommandTime$link1);
    if((signed int)return_value_MQTT_AGENT_Subscribe == 0)
    {
      vLoggingPrintf("%s subscribed to topic %s.\r\n", (const void *)"prvUint32PublishSubscribe", xSubscribeParams.pucTopic);
      xPublishParams.xQoS = xQOS;
      xPublishParams.pucTopic = (const uint8_t *)pxUserData->cTopic;
      size_t return_value_strlen$0=strlen(pxUserData->cTopic);
      xPublishParams.usTopicLength = (uint16_t)return_value_strlen$0;
      xPublishParams.ulDataLength = (uint32_t)sizeof(uint32_t) /*4u*/ ;
      ulData = 0u;
      for( ; !(ulData >= ulMaxMessages); ulData = ulData + 1u)
      {
        xPublishParams.pvData = (const void *)&ulData;
        pxUserData->ulExpectedUint32 = ulData;
        pxUserData->xCallbackStatus = 0;
        MQTTAgentReturnCode_t return_value_MQTT_AGENT_Publish=MQTT_AGENT_Publish(prvUint32PublishSubscribe$$xMQTTClientHandle, &xPublishParams, xMaxCommandTime$link1);
        if((signed int)return_value_MQTT_AGENT_Publish == 0)
        {
          vLoggingPrintf("%s published to topic %s\r\n", (const void *)"prvUint32PublishSubscribe", xPublishParams.pucTopic);
          BaseType_t return_value_xQueueSemaphoreTake=xQueueSemaphoreTake(pxUserData->xWakeUpSemaphore, xMaxCommandTime$link1);
          if(return_value_xQueueSemaphoreTake == 1)
          {
            if(pxUserData->xCallbackStatus == 1)
              ulPasses = ulPasses + 1u;

          }

        }

        else
          vLoggingPrintf("ERROR %s did not published to topic %s\r\n", (const void *)"prvUint32PublishSubscribe", xPublishParams.pucTopic);
      }
      xUnsubscribeParams.pucTopic = (const uint8_t *)pxUserData->cTopic;
      size_t return_value_strlen$1=strlen(pxUserData->cTopic);
      xUnsubscribeParams.usTopicLength = (uint16_t)return_value_strlen$1;
      MQTTAgentReturnCode_t return_value_MQTT_AGENT_Unsubscribe=MQTT_AGENT_Unsubscribe(prvUint32PublishSubscribe$$xMQTTClientHandle, &xUnsubscribeParams, xMaxCommandTime$link1);
      if((signed int)return_value_MQTT_AGENT_Unsubscribe == 0)
        vLoggingPrintf("%s unsubscribed from topic %s\r\n", (const void *)"prvUint32PublishSubscribe", xUnsubscribeParams.pucTopic);

      else
      {
        vLoggingPrintf("ERROR:  %s did not unsubscribed from topic %s\r\n", (const void *)"prvUint32PublishSubscribe", xUnsubscribeParams.pucTopic);
        ulPasses = 0u;
      }
    }

    else
      vLoggingPrintf("ERROR %s did not subscribe to topic %s.\r\n", (const void *)"prvUint32PublishSubscribe", xSubscribeParams.pucTopic);
    vLoggingPrintf("Disconnecting from broker.\r\n");
    MQTTAgentReturnCode_t return_value_MQTT_AGENT_Disconnect=MQTT_AGENT_Disconnect(prvUint32PublishSubscribe$$xMQTTClientHandle, xMaxCommandTime$link1);
    if((signed int)return_value_MQTT_AGENT_Disconnect == 0)
      vLoggingPrintf("Disconnected from the broker.\r\n");

    else
    {
      vLoggingPrintf("ERROR:  Did not disconnected from the broker.\r\n");
      ulPasses = 0u;
    }
  }

  if(ulPasses == ulMaxMessages)
    xResult = 1;

  else
    xResult = 0;
  if(!(xResult == 1))
    vAssertCalled("..\\..\\..\\common\\mqtt\\aws_subscribe_publish_loop.c", 452u);

  return xResult;
}

// prvUnSubscribeFromDataStream
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1866
static uint8_t prvUnSubscribeFromDataStream(OTA_FileContext_t *C)
{
  MQTTAgentUnsubscribeParams_t stUnSub;
  uint8_t bResult=0;
  char acOTA_RxStreamTopic[256ll];
  if(!(C == ((OTA_FileContext_t *)NULL)))
  {
    uint32_t return_value_prvBuildDataStreamTopicName=prvBuildDataStreamTopicName(acOTA_RxStreamTopic, 256u, C);
    stUnSub.usTopicLength = (uint16_t)return_value_prvBuildDataStreamTopicName;
    if((signed int)stUnSub.usTopicLength >= 1)
    {
      stUnSub.pucTopic = (const uint8_t *)acOTA_RxStreamTopic;
      MQTTAgentReturnCode_t return_value_MQTT_AGENT_Unsubscribe=MQTT_AGENT_Unsubscribe(pvPubSubClient, &stUnSub, (TickType_t)((1000ul * 1000u) / 1000u));
      if(!((signed int)return_value_MQTT_AGENT_Unsubscribe == 0))
      {
        vLoggingPrintf("[OTA] Error when un-subscribing from topic: %s\n\r", (const void *)acOTA_RxStreamTopic);
        MQTT_AGENT_Disconnect(pvPubSubClient, 0u);
      }

      else
      {
        vLoggingPrintf("[OTA] Un-subscribed from topic: %s\n\r", (const void *)acOTA_RxStreamTopic);
        bResult = 1;
      }
    }

  }

  return bResult;
}

// prvUnSubscribeFromJobNotificationTopic
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 1899
static uint8_t prvUnSubscribeFromJobNotificationTopic(void)
{
  MQTTAgentUnsubscribeParams_t stUnSub;
  uint8_t bResult=0;
  stUnSub.pucTopic = stJobsNotificationSubscription.pucTopic;
  stUnSub.usTopicLength = stJobsNotificationSubscription.usTopicLength;
  MQTTAgentReturnCode_t return_value_MQTT_AGENT_Unsubscribe=MQTT_AGENT_Unsubscribe(pvPubSubClient, &stUnSub, (TickType_t)((1000ul * 1000u) / 1000u));
  if(!((signed int)return_value_MQTT_AGENT_Unsubscribe == 0))
  {
    vLoggingPrintf("[OTA] Error when un-subscribing from topic: %s\n\r", stJobsNotificationSubscription.pucTopic);
    MQTT_AGENT_Disconnect(pvPubSubClient, 0u);
  }

  else
  {
    vLoggingPrintf("[OTA] Un-subscribed from topic: %s\n\r", stJobsNotificationSubscription.pucTopic);
    bResult = 1;
  }
  return bResult;
}

// prvUnlockQueue
// file ..\..\..\..\lib\FreeRTOS\queue.c line 2138
static void prvUnlockQueue(Queue_t * const pxQueue)
{
  vPortEnterCritical();
  int8_t cTxLock=pxQueue->cTxLock;
  for( ; (signed int)cTxLock >= 1; cTxLock = cTxLock - 1)
    if(!(pxQueue->xTasksWaitingToReceive.uxNumberOfItems == 0ul))
    {
      BaseType_t return_value_xTaskRemoveFromEventList=xTaskRemoveFromEventList(&pxQueue->xTasksWaitingToReceive);
      if(!(return_value_xTaskRemoveFromEventList == 0))
        vTaskMissedYield();

    }

    else
      break;
  pxQueue->cTxLock = (int8_t)-1;
  vPortExitCritical();
  vPortEnterCritical();
  int8_t cRxLock=pxQueue->cRxLock;
  while((signed int)cRxLock >= 1)
    if(!(pxQueue->xTasksWaitingToSend.uxNumberOfItems == 0ul))
    {
      BaseType_t return_value_xTaskRemoveFromEventList$0=xTaskRemoveFromEventList(&pxQueue->xTasksWaitingToSend);
      if(!(return_value_xTaskRemoveFromEventList$0 == 0))
        vTaskMissedYield();

      cRxLock = cRxLock - 1;
    }

    else
      break;
  pxQueue->cRxLock = (int8_t)-1;
  vPortExitCritical();
}

// prvUpdateJobStatus
// file ..\..\..\..\lib\ota\aws_ota_agent.c line 620
static void prvUpdateJobStatus(OTA_FileContext_t *C, char *pcOTA_DynamicTopic, OTA_JobStatus_t eStatus, int32_t lReason)
{
  uint32_t ulRequestTopicLen;
  uint32_t iNumBlocks;
  uint32_t iReceived;
  uint32_t iMsgSize;
  MQTTAgentReturnCode_t eResult;
  MQTTQoS_t eQOS;
  char acMsg[128ll];
  eQOS = /*enum*/eMQTTQoS1;
  if((signed int)eStatus == 0)
  {
    if(lReason == 0)
    {
      if(!(C == ((OTA_FileContext_t *)NULL)))
      {
        iNumBlocks = C->iFileSize + (unsigned int)(1024 - 1) >> 8 * (signed int)(1024 > 255) + ((8 - 90 / ((1024 >> 8 * (signed int)(1024 > 255)) / 4 + 14 | 1)) - 2 / ((1024 >> 8 * (signed int)(1024 > 255)) / 2 + 1));
        iReceived = iNumBlocks - C->iBlocksRemaining;
        if(iReceived % 64u == 0u)
        {
          eQOS = /*enum*/eMQTTQoS0;
          iMsgSize=rsprintf(acMsg, acOTA_JobStatus_StatusTemplate, acOTA_JobStatus_Strings[(signed long long int)eStatus]);
          uint32_t return_value_rsprintf=rsprintf(&acMsg[(signed long long int)iMsgSize], acOTA_JobStatus_ReceiveDetailsTemplate, (const void *)acOTA_String_Receive, iReceived, iNumBlocks);
          iMsgSize = iMsgSize + return_value_rsprintf;
        }

        else
          goto __CPROVER_DUMP_L17;
      }

      else
        goto __CPROVER_DUMP_L17;
    }

    else
    {
      iMsgSize=rsprintf(acMsg, acOTA_JobStatus_StatusTemplate, acOTA_JobStatus_Strings[(signed long long int)eStatus]);
      uint32_t return_value_rsprintf$0=rsprintf(&acMsg[(signed long long int)iMsgSize], acOTA_JobStatus_SelfTestDetailsTemplate, (const void *)acOTA_String_SelfTest, acOTA_JobReason_Strings[(signed long long int)lReason], xAppFirmwareVersion.u.ulVersion32);
      iMsgSize = iMsgSize + return_value_rsprintf$0;
    }
  }

  else
    if(!((signed int)eStatus >= 5))
    {
      iMsgSize=rsprintf(acMsg, acOTA_JobStatus_StatusTemplate, acOTA_JobStatus_Strings[(signed long long int)eStatus]);
      if((signed int)eStatus == 4)
      {
        uint32_t return_value_rsprintf$1=rsprintf(&acMsg[(signed long long int)iMsgSize], acOTA_JobStatus_ReasonValTemplate, lReason);
        iMsgSize = iMsgSize + return_value_rsprintf$1;
      }

      else
      {
        uint32_t return_value_rsprintf$2=rsprintf(&acMsg[(signed long long int)iMsgSize], acOTA_JobStatus_ReasonStrTemplate, acOTA_JobReason_Strings[(signed long long int)lReason]);
        iMsgSize = iMsgSize + return_value_rsprintf$2;
      }
    }

    else
      goto __CPROVER_DUMP_L17;
  ulRequestTopicLen=prvBuildJobStatusTopicName(pcOTA_DynamicTopic, 256u, (char *)pacOTA_Singleton_ActiveJobName);
  if(ulRequestTopicLen >= 1u)
  {
    eResult=prvPublishMessage(pvPubSubClient, pcOTA_DynamicTopic, (uint16_t)ulRequestTopicLen, acMsg, iMsgSize, eQOS);
    if(!((signed int)eResult == 0))
      vLoggingPrintf("[OTA] MQTT failed to publish job status message.\r\n");

    else
      vLoggingPrintf("[OTA] Published '%s' status to %s\r\n", acOTA_JobStatus_Strings[(signed long long int)eStatus], pcOTA_DynamicTopic);
  }

  else
    vLoggingPrintf("[OTA] Failed to publish job status message. Invalid topic name.\r\n");

__CPROVER_DUMP_L17:
  ;
}

// prvUpdateQueueTask
// file ..\..\..\common\shadow\aws_shadow_lightbulb_on_off.c line 289
static void prvUpdateQueueTask(void *pvParameters)
{
  ShadowReturnCode_t xReturn;
  ShadowOperationParams_t xUpdateParams;
  ShadowQueueData_t xShadowQueueData;
  (void)pvParameters;
  xUpdateParams.pcThingName = "Paste AWS IoT Thing name here.";
  xUpdateParams.xQoS = /*enum*/eMQTTQoS0;
  xUpdateParams.pcData = xShadowQueueData.pcUpdateBuffer;
  xUpdateParams.ucKeepSubscriptions = 1;
  while((_Bool)1)
  {
    BaseType_t return_value_xQueueReceive=xQueueReceive(xUpdateQueue, (void *)&xShadowQueueData, 500u);
    if(return_value_xQueueReceive == 1)
    {
      vLoggingPrintf("Performing Thing Shadow update.\r\n");
      xUpdateParams.ulDataLength = xShadowQueueData.ulDataLength;
      xReturn=SHADOW_Update(xClientHandle, &xUpdateParams, (TickType_t)((30000ul * 1000u) / 1000u));
      if((signed int)xReturn == 0)
        vLoggingPrintf("Successfully performed update.\r\n");

      else
        vLoggingPrintf("Update failed, returned %d.\r\n", xReturn);
      if(!(xShadowQueueData.xTaskToNotify == NULL))
        xTaskGenericNotify(xShadowQueueData.xTaskToNotify, 0u, /*enum*/eIncrement, ((uint32_t *)NULL));

    }

  }
}

// prvValidSocket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 168
static BaseType_t prvValidSocket(FreeRTOS_Socket_t *pxSocket, BaseType_t xProtocol, BaseType_t xIsBound)
{
  BaseType_t xReturn=1;
  _Bool tmp_if_expr;
  if(pxSocket == ((FreeRTOS_Socket_t *)NULL) || pxSocket == (FreeRTOS_Socket_t *)4294967295u)
    xReturn = 0;

  else
  {
    if(!(xIsBound == 0))
      tmp_if_expr = (signed int)((&pxSocket->xBoundSocketListItem)->pvContainer != NULL) == 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr = (_Bool)0;
    if(tmp_if_expr)
      xReturn = 0;

    else
      if(!(pxSocket->ucProtocol == (uint8_t)xProtocol))
        xReturn = 0;

  }
  return xReturn;
}

// prvVerifySignature
// file ..\..\..\..\lib\crypto\aws_crypto.c line 78
static BaseType_t prvVerifySignature(char *pcSignerCertificate, size_t xSignerCertificateLength, BaseType_t xHashAlgorithm, uint8_t *pucHash, size_t xHashLength, uint8_t *pucSignature, size_t xSignatureLength)
{
  BaseType_t xResult=1;
  mbedtls_x509_crt xCertCtx;
  mbedtls_md_type_t xMbedHashAlg=/*enum*/MBEDTLS_MD_SHA256;
  memset((void *)&xCertCtx, 0, sizeof(mbedtls_x509_crt) /*552ull*/ );
  if(xHashAlgorithm == 1)
    xMbedHashAlg = /*enum*/MBEDTLS_MD_SHA1;

  mbedtls_x509_crt_init(&xCertCtx);
  signed int return_value_mbedtls_x509_crt_parse=mbedtls_x509_crt_parse(&xCertCtx, (const unsigned char *)pcSignerCertificate, xSignerCertificateLength);
  if(!(return_value_mbedtls_x509_crt_parse == 0))
    xResult = 0;

  if(xResult == 1)
  {
    signed int return_value_mbedtls_pk_verify=mbedtls_pk_verify(&xCertCtx.pk, xMbedHashAlg, pucHash, xHashLength, pucSignature, xSignatureLength);
    if(!(return_value_mbedtls_pk_verify == 0))
      xResult = 0;

  }

  mbedtls_x509_crt_free(&xCertCtx);
  return xResult;
}

// prvWin32LoggingThread
// file ..\common\application_code\aws_demo_logging.c line 520
static DWORD prvWin32LoggingThread(void *pvParameter)
{
  const DWORD xMaxWait=1000ul;
  volatile uint8_t ucDummy=0;
  (void)pvParameter;
  xDirectPrint = 0;
  while((signed int)ucDummy == 0)
  {
    WaitForSingleObject(pvLoggingThreadEvent, xMaxWait);
    prvLoggingFlushBuffer();
  }
  return 0ul;
}

// prvWinPcapRecvThread
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 453
DWORD prvWinPcapRecvThread(void *pvParam)
{
  (void)pvParam;
  while((_Bool)1)
    pcap_dispatch(pxOpenedInterfaceHandle, 1, pcap_callback, (u_char *)"mydata");
}

// prvWinPcapSendThread
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 467
DWORD prvWinPcapSendThread(void *pvParam)
{
  size_t xLength;
  uint8_t ucBuffer[1214ll];
  const DWORD xMaxMSToWait=1000ul;
  (void)pvParam;
  size_t return_value_uxStreamBufferGetSize;
  while((_Bool)1)
  {
    WaitForSingleObject(pvSendEvent, xMaxMSToWait);
    do
    {
      return_value_uxStreamBufferGetSize=uxStreamBufferGetSize$link2(xSendBuffer);
      if(!(return_value_uxStreamBufferGetSize >= 9ull))
        break;

      uxStreamBufferGet(xSendBuffer, 0ull, (uint8_t *)&xLength, sizeof(size_t) /*8ull*/ , 0);
      uxStreamBufferGet(xSendBuffer, 0ull, (uint8_t *)ucBuffer, xLength, 0);
      signed int return_value_pcap_sendpacket=pcap_sendpacket(pxOpenedInterfaceHandle, ucBuffer, (signed int)xLength);
      if(!(return_value_pcap_sendpacket == 0))
        ulWinPCAPSendFailures = ulWinPCAPSendFailures + 1u;

    }
    while((_Bool)1);
  }
}

// prvWinScaleFactor
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 1325
static uint8_t prvWinScaleFactor(FreeRTOS_Socket_t *pxSocket)
{
  size_t uxWinSize;
  uint8_t ucFactor;
  uxWinSize = pxSocket->u.xTCP.uxRxWinSize * (size_t)pxSocket->u.xTCP.usInitMSS;
  ucFactor = 0;
  for( ; uxWinSize >= 65536ull; ucFactor = ucFactor + 1)
    uxWinSize = uxWinSize >> 1;
  while((_Bool)0)
    ;
  return ucFactor;
}

// prvWriteBlock
// file ..\..\..\..\lib\ota\portable\pc\windows\aws_ota_pal.c line 236
static int16_t prvWriteBlock(OTA_FileContext_t * const C, int32_t iOffset, uint8_t * const pacData, uint32_t iBlockSize)
{
  fseek(C->$anon0.pstFile, iOffset, 0);
  size_t return_value_fwrite=fwrite((const void *)pacData, 1ull, (size_t)iBlockSize, C->$anon0.pstFile);
  return (int16_t)return_value_fwrite;
}

// prvWriteBytesToBuffer
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 1020
static size_t prvWriteBytesToBuffer(StreamBuffer_t1 * const pxStreamBuffer, const uint8_t *pucData, size_t xCount)
{
  size_t xNextHead;
  size_t xFirstLength;
  if(!(xCount >= 1ull))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 1024u);

  xNextHead = pxStreamBuffer->xHead;
  size_t tmp_if_expr;
  if(!(pxStreamBuffer->xLength + -xNextHead >= xCount))
    tmp_if_expr = pxStreamBuffer->xLength - xNextHead;

  else
    tmp_if_expr = xCount;
  xFirstLength = tmp_if_expr;
  if(!(pxStreamBuffer->xLength >= xFirstLength + xNextHead))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 1034u);

  memcpy((void *)&pxStreamBuffer->pucBuffer[(signed long long int)xNextHead], (const void *)pucData, xFirstLength);
  if(!(xFirstLength >= xCount))
  {
    if(!(pxStreamBuffer->xLength >= xCount + -xFirstLength))
      vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 1042u);

    memcpy((void *)pxStreamBuffer->pucBuffer, (const void *)&pucData[(signed long long int)xFirstLength], xCount - xFirstLength);
  }

  xNextHead = xNextHead + xCount;
  if(xNextHead >= pxStreamBuffer->xLength)
    xNextHead = xNextHead - pxStreamBuffer->xLength;

  pxStreamBuffer->xHead = xNextHead;
  return xCount;
}

// prvWriteMessageToBuffer
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 639
static size_t prvWriteMessageToBuffer(StreamBuffer_t1 * const pxStreamBuffer, const void *pvTxData, size_t xDataLengthBytes, size_t xSpace, size_t xRequiredSpace)
{
  BaseType_t xShouldWrite;
  size_t xReturn;
  if(xSpace == 0ull)
    xShouldWrite = 0;

  else
    if((1 & (signed int)pxStreamBuffer->ucFlags) == 0)
    {
      xShouldWrite = 1;
      xDataLengthBytes = xDataLengthBytes < xSpace ? xDataLengthBytes : xSpace;
    }

    else
      if(xSpace >= xRequiredSpace)
      {
        xShouldWrite = 1;
        prvWriteBytesToBuffer(pxStreamBuffer, (const uint8_t *)&xDataLengthBytes, sizeof(size_t) /*8ull*/ );
      }

      else
        xShouldWrite = 0;
  if(!(xShouldWrite == 0))
    xReturn=prvWriteBytesToBuffer(pxStreamBuffer, (const uint8_t *)pvTxData, xDataLengthBytes);

  else
    xReturn = 0ull;
  return xReturn;
}

// prvWriteNameToBuffer
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 4204
static char * prvWriteNameToBuffer(char *pcBuffer, const char *pcTaskName)
{
  size_t x;
  strcpy(pcBuffer, pcTaskName);
  x=strlen(pcBuffer);
  for( ; !(x >= 14ull); x = x + 1ull)
    pcBuffer[(signed long long int)x] = ' ';
  pcBuffer[(signed long long int)x] = 0;
  return &pcBuffer[(signed long long int)x];
}

// prvWriteString
// file ..\..\..\..\lib\mqtt\aws_mqtt_lib.c line 1815
static uint8_t * prvWriteString(uint8_t *pucDestination, const uint8_t * const pucLastByteInBuffer, const uint8_t * const pucString, uint16_t usStringLength)
{
  uint8_t *pucEndAddress=&pucDestination[(signed long long int)(((signed int)usStringLength + 2) - 1)];
  if(pucLastByteInBuffer >= pucEndAddress)
  {
    *pucDestination = (uint8_t)((signed int)usStringLength >> 8);
    pucDestination = pucDestination + 1ll;
    *pucDestination = (uint8_t)usStringLength;
    pucDestination = pucDestination + 1ll;
    memcpy((void *)pucDestination, (const void *)pucString, (size_t)usStringLength);
  }

  else
    usStringLength = 0;
  return &pucDestination[(signed long long int)usStringLength];
}

// pszTraceGetErrorNotEnoughHandles
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcKernelPort.c line 535
const char * pszTraceGetErrorNotEnoughHandles(traceObjectClass objectclass)
{
  switch((signed int)objectclass)
  {
    case 3:
      return "Not enough TASK handles - increase TRC_CFG_NTASK in trcSnapshotConfig.h";
    case 4:
      return "Not enough ISR handles - increase TRC_CFG_NISR in trcSnapshotConfig.h";
    case 1:
      return "Not enough SEMAPHORE handles - increase TRC_CFG_NSEMAPHORE in trcSnapshotConfig.h";
    case 2:
      return "Not enough MUTEX handles - increase TRC_CFG_NMUTEX in trcSnapshotConfig.h";
    case 0:
      return "Not enough QUEUE handles - increase TRC_CFG_NQUEUE in trcSnapshotConfig.h";
    case 5:
      return "Not enough TIMER handles - increase TRC_CFG_NTIMER in trcSnapshotConfig.h";
    case 6:
      return "Not enough EVENTGROUP handles - increase TRC_CFG_NEVENTGROUP in trcSnapshotConfig.h";
    default:
      return "pszTraceGetErrorHandles: Invalid objectclass!";
  }
}

// pucGetNetworkBuffer
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\BufferManagement\BufferAllocation_2.c line 157
uint8_t * pucGetNetworkBuffer(size_t *pxRequestedSizeBytes)
{
  uint8_t *pucEthernetBuffer;
  size_t xSize=*pxRequestedSizeBytes;
  if(!(xSize >= sizeof(TCPPacket_t) /*70ull*/ ))
    xSize = sizeof(TCPPacket_t) /*70ull*/ ;

  if(!((7ull & xSize) == 0ull))
    xSize = (xSize | sizeof(size_t) /*8ull*/  - 1ull) + 1ull;

  *pxRequestedSizeBytes = xSize;
  void *return_value_pvPortMalloc=pvPortMalloc(xSize + (unsigned long long int)(8u + 2u));
  pucEthernetBuffer = (uint8_t *)return_value_pvPortMalloc;
  if(pucEthernetBuffer == ((uint8_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS-Plus-TCP\\source\\portable\\BufferManagement\\BufferAllocation_2.c", 181u);

  if(!(pucEthernetBuffer == ((uint8_t *)NULL)))
    pucEthernetBuffer = pucEthernetBuffer + (signed long long int)(8u + 2u);

  return pucEthernetBuffer;
}

// put16
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 210
static inline void put16(void *where, uint16_t v)
{
  v=_byteswap_ushort(v);
  memcpy(where, (const void *)&v, sizeof(uint16_t) /*2ull*/ );
}

// put32
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 227
static inline void put32(void *where, uint32_t v)
{
  v=_byteswap_ulong(v);
  memcpy(where, (const void *)&v, sizeof(uint32_t) /*4ull*/ );
}

// put64
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 233
static inline void put64(void *where, uint64_t v)
{
  v=_byteswap_uint64(v);
  memcpy(where, (const void *)&v, sizeof(uint64_t) /*8ull*/ );
}

// pvPortMalloc
// file ..\..\..\..\lib\FreeRTOS\portable\MemMang\heap_4.c line 113
void * pvPortMalloc(size_t xWantedSize)
{
  BlockLink_t *pxBlock;
  BlockLink_t *pxPreviousBlock;
  BlockLink_t *pxNewBlockLink;
  void *pvReturn=NULL;
  vTaskSuspendAll();
  if(pxEnd == ((BlockLink_t *)NULL))
    prvHeapInit();

  if((xWantedSize & xBlockAllocatedBit) == 0ull)
  {
    if(xWantedSize >= 1ull)
    {
      xWantedSize = xWantedSize + xHeapStructSize;
      if(!((7ull & xWantedSize) == 0ull))
      {
        xWantedSize = xWantedSize + (8ull - (xWantedSize & 7ull));
        if(!((7ull & xWantedSize) == 0ull))
          vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\portable\\MemMang\\heap_4.c", 149u);

      }

    }

    if(xWantedSize >= 1ull && xFreeBytesRemaining >= xWantedSize)
    {
      pxPreviousBlock = &xStart;
      pxBlock = xStart.pxNextFreeBlock;
      for( ; !(pxBlock->xBlockSize >= xWantedSize); pxBlock = pxBlock->pxNextFreeBlock)
      {
        if(pxBlock->pxNextFreeBlock == ((struct A_BLOCK_LINK *)NULL))
          break;

        pxPreviousBlock = pxBlock;
      }
      if(!(pxBlock == pxEnd))
      {
        pvReturn = (void *)((uint8_t *)pxPreviousBlock->pxNextFreeBlock + (signed long long int)xHeapStructSize);
        pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
        if(!(xHeapStructSize << 1 >= pxBlock->xBlockSize + -xWantedSize))
        {
          pxNewBlockLink = (BlockLink_t *)(void *)((uint8_t *)pxBlock + (signed long long int)xWantedSize);
          if(!((7ull & (size_t)pxNewBlockLink) == 0ull))
            vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\portable\\MemMang\\heap_4.c", 194u);

          pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
          pxBlock->xBlockSize = xWantedSize;
          prvInsertBlockIntoFreeList(pxNewBlockLink);
        }

        xFreeBytesRemaining = xFreeBytesRemaining - pxBlock->xBlockSize;
        if(!(xFreeBytesRemaining >= xMinimumEverFreeBytesRemaining))
          xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;

        pxBlock->xBlockSize = pxBlock->xBlockSize | xBlockAllocatedBit;
        pxBlock->pxNextFreeBlock = ((struct A_BLOCK_LINK *)NULL);
      }

    }

  }

  if(!(pvReturn == NULL))
    vTraceStoreMemMangEvent(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 4ul, (uint32_t)pvReturn, (int32_t)xWantedSize);

  xTaskResumeAll();
  if(pvReturn == NULL)
    vApplicationMallocFailedHook();

  if(!((7ull & (size_t)pvReturn) == 0ull))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\portable\\MemMang\\heap_4.c", 258u);

  return pvReturn;
}

// pvTaskGetThreadLocalStoragePointer
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3470
void * pvTaskGetThreadLocalStoragePointer(TaskHandle_t xTaskToQuery, BaseType_t xIndex)
{
  void *pvReturn=NULL;
  TCB_t *pxTCB;
  if(!(xIndex >= 3))
  {
    pxTCB = xTaskToQuery == NULL ? (TCB_t *)pxCurrentTCB : (TCB_t *)xTaskToQuery;
    pvReturn = pxTCB->pvThreadLocalStoragePointers[(signed long long int)xIndex];
  }

  else
    pvReturn = NULL;
  return pvReturn;
}

// pvTaskIncrementMutexHeldCount
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 4469
void * pvTaskIncrementMutexHeldCount(void)
{
  if(!(pxCurrentTCB == ((TCB_t *)NULL)))
    pxCurrentTCB->uxMutexesHeld = pxCurrentTCB->uxMutexesHeld + 1ul;

  return (void *)pxCurrentTCB;
}

// pvTimerGetTimerID
// file ..\..\..\..\lib\FreeRTOS\timers.c line 966
void * pvTimerGetTimerID(const TimerHandle_t xTimer)
{
  Timer_t * const pxTimer=(Timer_t *)xTimer;
  void *pvReturn;
  if(xTimer == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\timers.c", 971u);

  vPortEnterCritical();
  pvReturn = pxTimer->pvTimerID;
  vPortExitCritical();
  return pvReturn;
}

// pxDuplicateNetworkBufferWithDescriptor
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 822
NetworkBufferDescriptor_t * pxDuplicateNetworkBufferWithDescriptor(NetworkBufferDescriptor_t * const pxNetworkBuffer, BaseType_t xNewLength)
{
  NetworkBufferDescriptor_t *pxNewBuffer=pxGetNetworkBufferWithDescriptor((size_t)xNewLength, 0u);
  if(!(pxNewBuffer == ((NetworkBufferDescriptor_t *)NULL)))
  {
    pxNewBuffer->xDataLength = (size_t)xNewLength;
    pxNewBuffer->ulIPAddress = pxNetworkBuffer->ulIPAddress;
    pxNewBuffer->usPort = pxNetworkBuffer->usPort;
    pxNewBuffer->usBoundPort = pxNetworkBuffer->usBoundPort;
    memcpy((void *)pxNewBuffer->pucEthernetBuffer, (const void *)pxNetworkBuffer->pucEthernetBuffer, pxNetworkBuffer->xDataLength);
  }

  return pxNewBuffer;
}

// pxGetNetworkBufferWithDescriptor
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\BufferManagement\BufferAllocation_2.c line 208
NetworkBufferDescriptor_t * pxGetNetworkBufferWithDescriptor(size_t xRequestedSizeBytes, TickType_t xBlockTimeTicks)
{
  NetworkBufferDescriptor_t *pxReturn=((NetworkBufferDescriptor_t *)NULL);
  size_t uxCount;
  if(!(xRequestedSizeBytes == 0ull) && !(xRequestedSizeBytes >= sizeof(TCPPacket_t) /*70ull*/ ))
    xRequestedSizeBytes = sizeof(TCPPacket_t) /*70ull*/ ;

  xRequestedSizeBytes = xRequestedSizeBytes + 2ull;
  if(!((7ull & xRequestedSizeBytes) == 0ull))
    xRequestedSizeBytes = (xRequestedSizeBytes | sizeof(size_t) /*8ull*/  - 1ull) + 1ull;

  BaseType_t return_value_xQueueSemaphoreTake=xQueueSemaphoreTake(xNetworkBufferSemaphore, xBlockTimeTicks);
  if(return_value_xQueueSemaphoreTake == 1)
  {
    vPortEnterCritical();
    pxReturn = (NetworkBufferDescriptor_t *)(&(&xFreeBuffersList)->xListEnd)->pxNext->pvOwner;
    uxListRemove(&pxReturn->xBufferListItem);
    vPortExitCritical();
    uxCount = (size_t)(&xFreeBuffersList)->uxNumberOfItems;
    if(!(uxCount >= uxMinimumFreeNetworkBuffers))
      uxMinimumFreeNetworkBuffers = uxCount;

    if(!(pxReturn->pucEthernetBuffer == ((uint8_t *)NULL)))
      vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS-Plus-TCP\\source\\portable\\BufferManagement\\BufferAllocation_2.c", 248u);

    if(xRequestedSizeBytes >= 1ull)
    {
      void *return_value_pvPortMalloc=pvPortMalloc(xRequestedSizeBytes + (unsigned long long int)(8u + 2u));
      pxReturn->pucEthernetBuffer = (uint8_t *)return_value_pvPortMalloc;
      if(pxReturn->pucEthernetBuffer == ((uint8_t *)NULL))
      {
        vReleaseNetworkBufferAndDescriptor(pxReturn);
        pxReturn = ((NetworkBufferDescriptor_t *)NULL);
      }

      else
      {
        *((NetworkBufferDescriptor_t **)pxReturn->pucEthernetBuffer) = pxReturn;
        pxReturn->pucEthernetBuffer = pxReturn->pucEthernetBuffer + (signed long long int)(8u + 2u);
        pxReturn->xDataLength = xRequestedSizeBytes;
      }
    }

  }

  return pxReturn;
}

// pxListFindListItemWithValue
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 1686
static const ListItem_t * pxListFindListItemWithValue(const List_t *pxList, TickType_t xWantedItemValue)
{
  const ListItem_t *pxResult=((const ListItem_t *)NULL);
  BaseType_t return_value_xIPIsNetworkTaskReady=xIPIsNetworkTaskReady();
  if(!(return_value_xIPIsNetworkTaskReady == 0))
  {
    if(!(pxList == ((const List_t *)NULL)))
    {
      const ListItem_t *pxIterator;
      const MiniListItem_t *pxListFindListItemWithValue$$1$$1$$pxEnd=(const MiniListItem_t *)(const ListItem_t *)&pxList->xListEnd;
      pxIterator = (const ListItem_t *)pxListFindListItemWithValue$$1$$1$$pxEnd->pxNext;
      for( ; !(pxIterator == (const ListItem_t *)pxListFindListItemWithValue$$1$$1$$pxEnd); pxIterator = (const ListItem_t *)pxIterator->pxNext)
        if(pxIterator->xItemValue == xWantedItemValue)
        {
          pxResult = pxIterator;
          break;
        }

    }

  }

  return pxResult;
}

// pxPortInitialiseStack
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 210
StackType_t * pxPortInitialiseStack(StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters)
{
  xThreadState *pxThreadState=((xThreadState *)NULL);
  int8_t *pcTopOfStack=(int8_t *)pxTopOfStack;
  const SIZE_T xStackSize=1024ull;
  pxThreadState = (xThreadState *)(pcTopOfStack - (signed long long int)sizeof(xThreadState) /*8ll*/ );
  pxThreadState->pvThread=CreateThread(((LPSECURITY_ATTRIBUTES)NULL), xStackSize, (LPTHREAD_START_ROUTINE)pxCode, pvParameters, (DWORD)(0x4 | 0x10000), ((LPDWORD)NULL));
  if(pxThreadState->pvThread == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\portable\\MSVC-MingW\\port.c", 226u);

  SetThreadAffinityMask(pxThreadState->pvThread, 1ull);
  SetThreadPriorityBoost(pxThreadState->pvThread, 1);
  SetThreadPriority(pxThreadState->pvThread, 2 - 1);
  return (StackType_t *)pxThreadState;
}

// pxResizeNetworkBufferWithDescriptor
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\BufferManagement\BufferAllocation_2.c line 360
NetworkBufferDescriptor_t * pxResizeNetworkBufferWithDescriptor(NetworkBufferDescriptor_t *pxNetworkBuffer, size_t xNewSizeBytes)
{
  size_t xOriginalLength;
  uint8_t *pucBuffer;
  xOriginalLength = pxNetworkBuffer->xDataLength + (unsigned long long int)(8u + 2u);
  xNewSizeBytes = xNewSizeBytes + (unsigned long long int)(8u + 2u);
  pucBuffer=pucGetNetworkBuffer(&xNewSizeBytes);
  if(pucBuffer == ((uint8_t *)NULL))
    pxNetworkBuffer = ((NetworkBufferDescriptor_t *)NULL);

  else
  {
    pxNetworkBuffer->xDataLength = xNewSizeBytes;
    if(!(xOriginalLength >= xNewSizeBytes))
      xNewSizeBytes = xOriginalLength;

    memcpy((void *)(pucBuffer - (signed long long int)(8u + 2u)), (const void *)(pxNetworkBuffer->pucEthernetBuffer - (signed long long int)(8u + 2u)), xNewSizeBytes);
    vReleaseNetworkBuffer(pxNetworkBuffer->pucEthernetBuffer);
    pxNetworkBuffer->pucEthernetBuffer = pucBuffer;
  }
  return pxNetworkBuffer;
}

// pxTCPSocketLookup
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 2820
FreeRTOS_Socket_t * pxTCPSocketLookup(uint32_t ulLocalIP, UBaseType_t uxLocalPort, uint32_t ulRemoteIP, UBaseType_t uxRemotePort)
{
  ListItem_t *pxIterator;
  FreeRTOS_Socket_t *pxResult=((FreeRTOS_Socket_t *)NULL);
  FreeRTOS_Socket_t *pxListenSocket=((FreeRTOS_Socket_t *)NULL);
  MiniListItem_t *pxTCPSocketLookup$$1$$pxEnd=(MiniListItem_t *)(const ListItem_t *)&(&xBoundTCPSocketsList)->xListEnd;
  (void)ulLocalIP;
  pxIterator = (ListItem_t *)pxTCPSocketLookup$$1$$pxEnd->pxNext;
  for( ; !(pxIterator == (ListItem_t *)pxTCPSocketLookup$$1$$pxEnd); pxIterator = (ListItem_t *)pxIterator->pxNext)
  {
    FreeRTOS_Socket_t *pxSocket=(FreeRTOS_Socket_t *)pxIterator->pvOwner;
    if(pxSocket->usLocalPort == (uint16_t)uxLocalPort)
    {
      if((signed int)pxSocket->u.xTCP.ucTCPState == 1)
        pxListenSocket = pxSocket;

      else
        if(pxSocket->u.xTCP.usRemotePort == (uint16_t)uxRemotePort)
        {
          if(pxSocket->u.xTCP.ulRemoteIP == ulRemoteIP)
          {
            pxResult = pxSocket;
            break;
          }

        }

    }

  }
  if(pxResult == ((FreeRTOS_Socket_t *)NULL))
    pxResult = pxListenSocket;

  return pxResult;
}

// pxUDPPayloadBuffer_to_NetworkBuffer
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 887
NetworkBufferDescriptor_t * pxUDPPayloadBuffer_to_NetworkBuffer(void *pvBuffer)
{
  uint8_t *pucBuffer;
  NetworkBufferDescriptor_t *pxResult;
  if(pvBuffer == NULL)
    pxResult = ((NetworkBufferDescriptor_t *)NULL);

  else
  {
    pucBuffer = (uint8_t *)pvBuffer;
    pucBuffer = pucBuffer - (signed long long int)(sizeof(UDPPacket_t) /*42ull*/  + (unsigned long long int)(8u + 2u));
    if((7ull & (unsigned long long int)(uint32_t)pucBuffer) == 0ull)
      pxResult = *((NetworkBufferDescriptor_t **)pucBuffer);

    else
      pxResult = ((NetworkBufferDescriptor_t *)NULL);
  }
  return pxResult;
}

// pxUDPSocketLookup
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 1712
FreeRTOS_Socket_t * pxUDPSocketLookup(UBaseType_t uxLocalPort)
{
  const ListItem_t *pxListItem;
  FreeRTOS_Socket_t *pxSocket=((FreeRTOS_Socket_t *)NULL);
  pxListItem=pxListFindListItemWithValue(&xBoundUDPSocketsList, (TickType_t)uxLocalPort);
  if(!(pxListItem == ((const ListItem_t *)NULL)))
  {
    pxSocket = (FreeRTOS_Socket_t *)pxListItem->pvOwner;
    if(pxSocket == ((FreeRTOS_Socket_t *)NULL))
      vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS-Plus-TCP\\source\\FreeRTOS_Sockets.c", 1727u);

  }

  return pxSocket;
}

// rsa_alloc_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 160
static void * rsa_alloc_wrap(void)
{
  void *ctx=mbedtls_calloc(1ull, sizeof(mbedtls_rsa_context) /*336ull*/ );
  if(!(ctx == NULL))
    mbedtls_rsa_init((mbedtls_rsa_context *)ctx, 0, 0);

  return ctx;
}

// rsa_alt_alloc_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 489
static void * rsa_alt_alloc_wrap(void)
{
  void *ctx=mbedtls_calloc(1ull, sizeof(mbedtls_rsa_alt_context) /*32ull*/ );
  if(!(ctx == NULL))
    memset(ctx, 0, sizeof(mbedtls_rsa_alt_context) /*32ull*/ );

  return ctx;
}

// rsa_alt_can_do
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 412
static signed int rsa_alt_can_do(mbedtls_pk_type_t type)
{
  return (signed int)((signed int)type == 1);
}

// rsa_alt_check_pair
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 460
static signed int rsa_alt_check_pair(const void *pub, const void *prv)
{
  unsigned char sig[1024ll];
  unsigned char hash[32ll];
  size_t sig_len=0ull;
  signed int ret;
  size_t return_value_rsa_alt_get_bitlen=rsa_alt_get_bitlen(prv);
  size_t return_value_rsa_get_bitlen=rsa_get_bitlen(pub);
  if(!(return_value_rsa_alt_get_bitlen == return_value_rsa_get_bitlen))
    return -0x4200;

  else
  {
    memset((void *)hash, 0x2A, sizeof(unsigned char [32ll]) /*32ull*/ );
    ret=rsa_alt_sign_wrap((void *)prv, /*enum*/MBEDTLS_MD_NONE, hash, sizeof(unsigned char [32ll]) /*32ull*/ , sig, &sig_len, ((signed int (*)(void *, unsigned char *, size_t))NULL), NULL);
    if(!(ret == 0))
      return ret;

    else
    {
      signed int return_value_rsa_verify_wrap=rsa_verify_wrap((void *)pub, /*enum*/MBEDTLS_MD_NONE, hash, sizeof(unsigned char [32ll]) /*32ull*/ , sig, sig_len);
      if(!(return_value_rsa_verify_wrap == 0))
        return -0x4200;

      else
        return 0;
    }
  }
}

// rsa_alt_decrypt_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 442
static signed int rsa_alt_decrypt_wrap(void *ctx, const unsigned char *input, size_t ilen, unsigned char *output, size_t *olen, size_t osize, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
  mbedtls_rsa_alt_context *rsa_alt=(mbedtls_rsa_alt_context *)ctx;
  (void)f_rng;
  (void)p_rng;
  size_t return_value=rsa_alt->key_len_func(rsa_alt->key);
  if(!(ilen == return_value))
    return -0x4080;

  else
  {
    signed int return_value$0=rsa_alt->decrypt_func(rsa_alt->key, 1, olen, input, output, osize);
    return return_value$0;
  }
}

// rsa_alt_free_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 499
static void rsa_alt_free_wrap(void *ctx)
{
  mbedtls_zeroize$link12(ctx, sizeof(mbedtls_rsa_alt_context) /*32ull*/ );
  mbedtls_free(ctx);
}

// rsa_alt_get_bitlen
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 417
static size_t rsa_alt_get_bitlen(const void *ctx)
{
  const mbedtls_rsa_alt_context *rsa_alt=(const mbedtls_rsa_alt_context *)ctx;
  size_t return_value=rsa_alt->key_len_func(rsa_alt->key);
  return 8ull * return_value;
}

// rsa_alt_sign_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 424
static signed int rsa_alt_sign_wrap(void *ctx, mbedtls_md_type_t md_alg, const unsigned char *hash, size_t hash_len, unsigned char *sig, size_t *sig_len, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
  mbedtls_rsa_alt_context *rsa_alt=(mbedtls_rsa_alt_context *)ctx;
  if(hash_len >= 4294967296ull)
    return -0x3E80;

  else
  {
    *sig_len=rsa_alt->key_len_func(rsa_alt->key);
    signed int return_value=rsa_alt->sign_func(rsa_alt->key, f_rng, p_rng, 1, md_alg, (unsigned int)hash_len, hash, sig);
    return return_value;
  }
}

// rsa_can_do
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 63
static signed int rsa_can_do(mbedtls_pk_type_t type)
{
  return (signed int)((signed int)type == 1 || (signed int)type == 6);
}

// rsa_check_context
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 156
static signed int rsa_check_context(const mbedtls_rsa_context *ctx, signed int is_priv, signed int blinding_needed)
{
  (void)blinding_needed;
  size_t return_value_mbedtls_mpi_size=mbedtls_mpi_size(&ctx->N);
  _Bool tmp_if_expr;
  if(!(ctx->len == return_value_mbedtls_mpi_size))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ctx->len > 1024ull ? (_Bool)1 : (_Bool)0;
  signed int return_value_mbedtls_mpi_get_bit;
  signed int return_value_mbedtls_mpi_cmp_int$0;
  _Bool tmp_if_expr$1;
  signed int return_value_mbedtls_mpi_get_bit$0;
  _Bool tmp_if_expr$2;
  signed int return_value_mbedtls_mpi_cmp_int$1;
  _Bool tmp_if_expr$3;
  signed int return_value_mbedtls_mpi_get_bit$1;
  signed int return_value_mbedtls_mpi_cmp_int$3;
  _Bool tmp_if_expr$4;
  signed int return_value_mbedtls_mpi_cmp_int$4;
  signed int return_value_mbedtls_mpi_cmp_int$5;
  if(tmp_if_expr)
    return -0x4080;

  else
  {
    signed int return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(&ctx->N, 0ll);
    _Bool tmp_if_expr$0;
    if(!(return_value_mbedtls_mpi_cmp_int >= 1))
      tmp_if_expr$0 = (_Bool)1;

    else
    {
      return_value_mbedtls_mpi_get_bit=mbedtls_mpi_get_bit(&ctx->N, 0ull);
      tmp_if_expr$0 = return_value_mbedtls_mpi_get_bit == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$0)
      return -0x4080;

    else
    {
      if(!(is_priv == 0))
      {
        return_value_mbedtls_mpi_cmp_int$0=mbedtls_mpi_cmp_int(&ctx->P, 0ll);
        if(!(return_value_mbedtls_mpi_cmp_int$0 >= 1))
          tmp_if_expr$1 = (_Bool)1;

        else
        {
          return_value_mbedtls_mpi_get_bit$0=mbedtls_mpi_get_bit(&ctx->P, 0ull);
          tmp_if_expr$1 = return_value_mbedtls_mpi_get_bit$0 == 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$1)
          tmp_if_expr$2 = (_Bool)1;

        else
        {
          return_value_mbedtls_mpi_cmp_int$1=mbedtls_mpi_cmp_int(&ctx->Q, 0ll);
          tmp_if_expr$2 = return_value_mbedtls_mpi_cmp_int$1 <= 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$2)
          tmp_if_expr$3 = (_Bool)1;

        else
        {
          return_value_mbedtls_mpi_get_bit$1=mbedtls_mpi_get_bit(&ctx->Q, 0ull);
          tmp_if_expr$3 = return_value_mbedtls_mpi_get_bit$1 == 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$3)
          return -0x4080;

      }

      signed int return_value_mbedtls_mpi_cmp_int$2=mbedtls_mpi_cmp_int(&ctx->E, 0ll);
      if(!(return_value_mbedtls_mpi_cmp_int$2 >= 1))
        return -0x4080;

      else
      {
        if(!(is_priv == 0))
        {
          return_value_mbedtls_mpi_cmp_int$3=mbedtls_mpi_cmp_int(&ctx->DP, 0ll);
          if(!(return_value_mbedtls_mpi_cmp_int$3 >= 1))
            tmp_if_expr$4 = (_Bool)1;

          else
          {
            return_value_mbedtls_mpi_cmp_int$4=mbedtls_mpi_cmp_int(&ctx->DQ, 0ll);
            tmp_if_expr$4 = return_value_mbedtls_mpi_cmp_int$4 <= 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$4)
            return -0x4080;

        }

        if(!(is_priv == 0))
        {
          return_value_mbedtls_mpi_cmp_int$5=mbedtls_mpi_cmp_int(&ctx->QP, 0ll);
          if(!(return_value_mbedtls_mpi_cmp_int$5 >= 1))
            return -0x4080;

        }

        return 0;
      }
    }
  }
}

// rsa_check_pair_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 154
static signed int rsa_check_pair_wrap(const void *pub, const void *prv)
{
  signed int return_value_mbedtls_rsa_check_pub_priv=mbedtls_rsa_check_pub_priv((const mbedtls_rsa_context *)pub, (const mbedtls_rsa_context *)prv);
  return return_value_mbedtls_rsa_check_pub_priv;
}

// rsa_debug
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 176
static void rsa_debug(const void *ctx, mbedtls_pk_debug_item *items)
{
  items->type = /*enum*/MBEDTLS_PK_DEBUG_MPI;
  items->name = "rsa.N";
  items->value = (void *)&((mbedtls_rsa_context *)ctx)->N;
  items = items + 1ll;
  items->type = /*enum*/MBEDTLS_PK_DEBUG_MPI;
  items->name = "rsa.E";
  items->value = (void *)&((mbedtls_rsa_context *)ctx)->E;
}

// rsa_decrypt_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 125
static signed int rsa_decrypt_wrap(void *ctx, const unsigned char *input, size_t ilen, unsigned char *output, size_t *olen, size_t osize, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
  mbedtls_rsa_context *rsa=(mbedtls_rsa_context *)ctx;
  size_t return_value_mbedtls_rsa_get_len=mbedtls_rsa_get_len(rsa);
  if(!(ilen == return_value_mbedtls_rsa_get_len))
    return -0x4080;

  else
  {
    signed int return_value_mbedtls_rsa_pkcs1_decrypt=mbedtls_rsa_pkcs1_decrypt(rsa, f_rng, p_rng, 1, olen, input, output, osize);
    return return_value_mbedtls_rsa_pkcs1_decrypt;
  }
}

// rsa_encrypt_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 139
static signed int rsa_encrypt_wrap(void *ctx, const unsigned char *input, size_t ilen, unsigned char *output, size_t *olen, size_t osize, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
  mbedtls_rsa_context *rsa=(mbedtls_rsa_context *)ctx;
  *olen=mbedtls_rsa_get_len(rsa);
  if(!(osize >= *olen))
    return -0x4400;

  else
  {
    signed int return_value_mbedtls_rsa_pkcs1_encrypt=mbedtls_rsa_pkcs1_encrypt(rsa, f_rng, p_rng, 0, ilen, input, output);
    return return_value_mbedtls_rsa_pkcs1_encrypt;
  }
}

// rsa_free_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 170
static void rsa_free_wrap(void *ctx)
{
  mbedtls_rsa_free((mbedtls_rsa_context *)ctx);
  mbedtls_free(ctx);
}

// rsa_get_bitlen
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 69
static size_t rsa_get_bitlen(const void *ctx)
{
  const mbedtls_rsa_context *rsa=(const mbedtls_rsa_context *)ctx;
  size_t return_value_mbedtls_rsa_get_len=mbedtls_rsa_get_len(rsa);
  return 8ull * return_value_mbedtls_rsa_get_len;
}

// rsa_prepare_blinding
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 712
static signed int rsa_prepare_blinding(mbedtls_rsa_context *ctx, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
  signed int ret;
  signed int count=0;
  signed int return_value_mbedtls_mpi_cmp_int;
  if(!(ctx->Vf.p == ((mbedtls_mpi_uint *)NULL)))
  {
    do
    {
      ret=mbedtls_mpi_mul_mpi(&ctx->Vi, &ctx->Vi, &ctx->Vi);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_mod_mpi(&ctx->Vi, &ctx->Vi, &ctx->N);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_mul_mpi(&ctx->Vf, &ctx->Vf, &ctx->Vf);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_mod_mpi(&ctx->Vf, &ctx->Vf, &ctx->N);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
  }

  else
  {
    do
    {
      signed int tmp_post=count;
      count = count + 1;
      if(tmp_post >= 11)
        return -0x4480;

      do
      {
        ret=mbedtls_mpi_fill_random(&ctx->Vf, ctx->len - 1ull, f_rng, p_rng);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      do
      {
        ret=mbedtls_mpi_gcd(&ctx->Vi, &ctx->Vf, &ctx->N);
        if(!(ret == 0))
          goto cleanup;

      }
      while((_Bool)0);
      return_value_mbedtls_mpi_cmp_int=mbedtls_mpi_cmp_int(&ctx->Vi, 1ll);
    }
    while(!(return_value_mbedtls_mpi_cmp_int == 0));
    do
    {
      ret=mbedtls_mpi_inv_mod(&ctx->Vi, &ctx->Vf, &ctx->N);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
    do
    {
      ret=mbedtls_mpi_exp_mod(&ctx->Vi, &ctx->Vi, &ctx->E, &ctx->N, &ctx->RN);
      if(!(ret == 0))
        goto cleanup;

    }
    while((_Bool)0);
  }

cleanup:
  ;
  return ret;
}

// rsa_rsassa_pkcs1_v15_encode
// file ..\..\..\..\lib\third_party\mbedtls\library\rsa.c line 1625
static signed int rsa_rsassa_pkcs1_v15_encode(mbedtls_md_type_t md_alg, unsigned int hashlen, const unsigned char *hash, size_t dst_len, unsigned char *dst)
{
  size_t oid_size=0ull;
  size_t nb_pad=dst_len;
  unsigned char *p=dst;
  const char *oid=((const char *)NULL);
  if(!((signed int)md_alg == 0))
  {
    const mbedtls_md_info_t *md_info=mbedtls_md_info_from_type(md_alg);
    if(md_info == ((const mbedtls_md_info_t *)NULL))
      return -0x4080;

    signed int return_value_mbedtls_oid_get_oid_by_md=mbedtls_oid_get_oid_by_md(md_alg, &oid, &oid_size);
    if(!(return_value_mbedtls_oid_get_oid_by_md == 0))
      return -0x4080;

    unsigned char return_value_mbedtls_md_get_size=mbedtls_md_get_size(md_info);
    hashlen = (unsigned int)return_value_mbedtls_md_get_size;
    if(oid_size + (unsigned long long int)(8u + hashlen) >= 128ull || !(10u + hashlen >= hashlen) || !(oid_size + (unsigned long long int)(10u + hashlen) >= (unsigned long long int)(10u + hashlen)))
      return -0x4080;

    if(!(nb_pad >= oid_size + (unsigned long long int)(10u + hashlen)))
      return -0x4080;

    nb_pad = nb_pad - ((unsigned long long int)(10u + hashlen) + oid_size);
  }

  else
  {
    if(!(nb_pad >= (unsigned long long int)hashlen))
      return -0x4080;

    nb_pad = nb_pad - (size_t)hashlen;
  }
  if(!(nb_pad >= 11ull))
    return -0x4080;

  else
  {
    nb_pad = nb_pad - 3ull;
    unsigned char *tmp_post=p;
    p = p + 1ll;
    *tmp_post = 0;
    unsigned char *tmp_post$0=p;
    p = p + 1ll;
    *tmp_post$0 = 1;
    memset((void *)p, 0xFF, nb_pad);
    p = p + (signed long long int)nb_pad;
    unsigned char *tmp_post$1=p;
    p = p + 1ll;
    *tmp_post$1 = 0;
    if((signed int)md_alg == 0)
    {
      memcpy((void *)p, (const void *)hash, (size_t)hashlen);
      return 0;
    }

    else
    {
      unsigned char *tmp_post$2=p;
      p = p + 1ll;
      *tmp_post$2 = (unsigned char)(0x10 | 0x20);
      unsigned char *tmp_post$3=p;
      p = p + 1ll;
      *tmp_post$3 = (unsigned char)(8ull + oid_size + (unsigned long long int)hashlen);
      unsigned char *tmp_post$4=p;
      p = p + 1ll;
      *tmp_post$4 = (unsigned char)(0x10 | 0x20);
      unsigned char *tmp_post$5=p;
      p = p + 1ll;
      *tmp_post$5 = (unsigned char)(4ull + oid_size);
      unsigned char *tmp_post$6=p;
      p = p + 1ll;
      *tmp_post$6 = 6;
      unsigned char *tmp_post$7=p;
      p = p + 1ll;
      *tmp_post$7 = (unsigned char)oid_size;
      memcpy((void *)p, (const void *)oid, oid_size);
      p = p + (signed long long int)oid_size;
      unsigned char *tmp_post$8=p;
      p = p + 1ll;
      *tmp_post$8 = 5;
      unsigned char *tmp_post$9=p;
      p = p + 1ll;
      *tmp_post$9 = 0;
      unsigned char *tmp_post$10=p;
      p = p + 1ll;
      *tmp_post$10 = 4;
      unsigned char *tmp_post$11=p;
      p = p + 1ll;
      *tmp_post$11 = (unsigned char)hashlen;
      memcpy((void *)p, (const void *)hash, (size_t)hashlen);
      p = p + (signed long long int)hashlen;
      if(!(p == dst + (signed long long int)dst_len))
      {
        mbedtls_zeroize$link13((void *)dst, dst_len);
        return -0x4080;
      }

      else
        return 0;
    }
  }
}

// rsa_sign_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 107
static signed int rsa_sign_wrap(void *ctx, mbedtls_md_type_t md_alg, const unsigned char *hash, size_t hash_len, unsigned char *sig, size_t *sig_len, signed int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
{
  mbedtls_rsa_context *rsa=(mbedtls_rsa_context *)ctx;
  if((signed int)md_alg == 0 && hash_len >= 4294967296ull)
    return -0x3E80;

  else
  {
    *sig_len=mbedtls_rsa_get_len(rsa);
    signed int return_value_mbedtls_rsa_pkcs1_sign=mbedtls_rsa_pkcs1_sign(rsa, f_rng, p_rng, 1, md_alg, (unsigned int)hash_len, hash, sig);
    return return_value_mbedtls_rsa_pkcs1_sign;
  }
}

// rsa_verify_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\pk_wrap.c line 75
static signed int rsa_verify_wrap(void *ctx, mbedtls_md_type_t md_alg, const unsigned char *hash, size_t hash_len, const unsigned char *sig, size_t sig_len)
{
  signed int ret;
  mbedtls_rsa_context *rsa=(mbedtls_rsa_context *)ctx;
  size_t rsa_len=mbedtls_rsa_get_len(rsa);
  if((signed int)md_alg == 0 && hash_len >= 4294967296ull)
    return -0x3E80;

  else
    if(!(sig_len >= rsa_len))
      return -0x4380;

    else
    {
      ret=mbedtls_rsa_pkcs1_verify(rsa, ((signed int (*)(void *, unsigned char *, size_t))NULL), NULL, 0, md_alg, (unsigned int)hash_len, hash, sig);
      if(!(ret == 0))
        return ret;

      else
        if(!(rsa_len >= sig_len))
          return -0x3900;

        else
          return 0;
    }
}

// rsprintf
// file ..\..\..\..\lib\ota\aws_rsprintf.c line 303
uint32_t rsprintf(char *dest, const char *fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	uint32_t iLen = rvsprintf(dest, fmt, args);
	va_end(args);
	return iLen;
// va_list args=(va_list)&fmt + (signed long long int)((sizeof(const char *) [>8ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull<]  - 1ull));
  /*uint32_t iLen=rvsprintf(dest, fmt, args);*/
  /*args = ((va_list)NULL);*/
  /*return iLen;*/
}

// rvsprintf
// file ..\..\..\..\lib\ota\aws_rsprintf.c line 313
uint32_t rvsprintf(char *dest, const char *fmt, va_list va)
{
  char c;
  uint32_t iWidth=0u;
  char acSmallBuf[12ll];
  uint8_t bConsoleOut=0;
  BaseType_t xResult;
  char *dptr;
  if(dest == ((char *)NULL))
    return 0u;

  else
    dptr = dest;
  const char *tmp_post;
  const char *tmp_post$0;
  uint8_t *p;
  uint32_t tmp_post$5;
  uint8_t *rvsprintf$$1$$3$$1$$1$$4$$8$$p;
  char *tmp_post$7;
  char *tmp_post$8;
  do
  {
    tmp_post = fmt;
    fmt = fmt + 1ll;
    c = *tmp_post;
    if((signed int)c == 0)
      break;

    if((signed int)c == 37)
    {
      tmp_post$0 = fmt;
      fmt = fmt + 1ll;
      c = *tmp_post$0;
      if((signed int)c == 46 || (signed int)c == 76 || (signed int)c == 108)
      {
        const char *tmp_post$1=fmt;
        fmt = fmt + 1ll;
        c = *tmp_post$1;
      }

      if((signed int)c == 42)
      {
        va = va + (signed long long int)((sizeof(uint32_t) /*4ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull));
        iWidth = *((uint32_t *)(va - (signed long long int)((sizeof(uint32_t) /*4ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull))));
        const char *tmp_post$2=fmt;
        fmt = fmt + 1ll;
        c = *tmp_post$2;
      }

      else
        if((signed int)c >= 48 && !((signed int)c >= 58))
        {
          iWidth=strtoul(fmt - 1ll, (char **)&fmt, 10);
          const char *tmp_post$3=fmt;
          fmt = fmt + 1ll;
          c = *tmp_post$3;
        }

        else
          iWidth = 0u;
      switch((signed int)c)
      {
        case 126:
        {
          va = va + (signed long long int)((sizeof(uint32_t) /*4ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull));
          *((uint32_t *)(va - (signed long long int)((sizeof(uint32_t) /*4ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull))));
          break;
        }
        case 100:

        case 68:
        {
          int32_t rvsprintf$$1$$3$$1$$1$$4$$2$$v;
          va = va + (signed long long int)((sizeof(int32_t) /*4ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull));
          rvsprintf$$1$$3$$1$$1$$4$$2$$v = *((int32_t *)(va - (signed long long int)((sizeof(int32_t) /*4ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull))));
          dptr=szS32(dptr, rvsprintf$$1$$3$$1$$1$$4$$2$$v, (uint8_t)iWidth);
          break;
        }
        case 117:

        case 85:
        {
          uint32_t rvsprintf$$1$$3$$1$$1$$4$$3$$v;
          va = va + (signed long long int)((sizeof(uint32_t) /*4ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull));
          rvsprintf$$1$$3$$1$$1$$4$$3$$v = *((uint32_t *)(va - (signed long long int)((sizeof(uint32_t) /*4ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull))));
          dptr=szU32(dptr, rvsprintf$$1$$3$$1$$1$$4$$3$$v, (uint8_t)iWidth);
          break;
        }
        case 120:

        case 88:
        {
          uint32_t v;
          va = va + (signed long long int)((sizeof(uint32_t) /*4ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull));
          v = *((uint32_t *)(va - (signed long long int)((sizeof(uint32_t) /*4ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull))));
          dptr=szH32(dptr, v, (uint8_t)iWidth);
          break;
        }
        case 67:

        case 99:
        {
          char c2;
          va = va + (signed long long int)((sizeof(signed int) /*4ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull));
          c2 = (char)*((signed int *)(va - (signed long long int)((sizeof(signed int) /*4ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull))));
          char *tmp_post$4=dptr;
          dptr = dptr + 1ll;
          *tmp_post$4 = c2;
          break;
        }
        case 115:
        {
          char *rvsprintf$$1$$3$$1$$1$$4$$6$$p;
          va = va + (signed long long int)((sizeof(char *) /*8ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull));
          rvsprintf$$1$$3$$1$$1$$4$$6$$p = *((char **)(va - (signed long long int)((sizeof(char *) /*8ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull))));
          static const char acNullMsg[7ll]={ '{', 'N', 'U', 'L', 'L', '}', 0 };
          if(!(rvsprintf$$1$$3$$1$$1$$4$$6$$p == ((char *)NULL)))
          {
            if(!(iWidth == 0u))
            {
              dptr=prvMemPrint((uint8_t *)rvsprintf$$1$$3$$1$$1$$4$$6$$p, iWidth, 0, bConsoleOut, acSmallBuf, dptr);
              break;
            }

            else
              dptr=stpcpy(dptr, rvsprintf$$1$$3$$1$$1$$4$$6$$p);
          }

          else
            dptr=stpcpy(dptr, acNullMsg);
          break;
        }
        case 72:
        {
          va = va + (signed long long int)((sizeof(uint32_t) /*4ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull));
          iWidth = *((uint32_t *)(va - (signed long long int)((sizeof(uint32_t) /*4ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull))));
          va = va + (signed long long int)((sizeof(uint8_t *) /*8ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull));
          p = *((uint8_t **)(va - (signed long long int)((sizeof(uint8_t *) /*8ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull))));
          xResult = 1;
          while(xResult == 1)
          {
            tmp_post$5 = iWidth;
            iWidth = iWidth - 1u;
            if(tmp_post$5 == 0u)
              break;

            uint8_t *tmp_post$6=p;
            p = p + 1ll;
            dptr=szH32(dptr, (uint32_t)*tmp_post$6, 2);
          }
          break;
        }
        case 94:
        {
          va = va + (signed long long int)((sizeof(uint32_t) /*4ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull));
          iWidth = *((uint32_t *)(va - (signed long long int)((sizeof(uint32_t) /*4ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull))));
          va = va + (signed long long int)((sizeof(uint8_t *) /*8ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull));
          rvsprintf$$1$$3$$1$$1$$4$$8$$p = *((uint8_t **)(va - (signed long long int)((sizeof(uint8_t *) /*8ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull))));
          dptr=prvMemPrint(rvsprintf$$1$$3$$1$$1$$4$$8$$p, iWidth, 1, bConsoleOut, acSmallBuf, dptr);
          break;
        }
        default:
        {
          tmp_post$7 = dptr;
          dptr = dptr + 1ll;
          *tmp_post$7 = c;
        }
      }
    }

    else
    {
      tmp_post$8 = dptr;
      dptr = dptr + 1ll;
      *tmp_post$8 = c;
    }
  }
  while((_Bool)1);
  *dptr = 0;
  return (uint32_t)(dptr - dest);
}

// scanf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1307

// setipv4sourcefilter
// file C:\Program Files (x86)\Windows Kits\8.1\Include\um\ws2tcpip.h line 681
inline signed int setipv4sourcefilter(SOCKET Socket, IN_ADDR Interface, IN_ADDR Group, MULTICAST_MODE_TYPE FilterMode, ULONG SourceCount, const IN_ADDR *SourceList)
{
  signed int Error;
  DWORD Size;
  DWORD Returned;
  PIP_MSFILTER Filter;
  if((unsigned long long int)SourceCount >= 1073741819ull)
  {
    WSASetLastError(10055l);
    return -1;
  }

  else
  {
    Size = (DWORD)((sizeof(IP_MSFILTER) /*20ull*/  - sizeof(IN_ADDR) /*4ull*/ ) + (unsigned long long int)SourceCount * sizeof(IN_ADDR) /*4ull*/ );
    HANDLE return_value_GetProcessHeap=GetProcessHeap();
    LPVOID return_value_HeapAlloc=HeapAlloc(return_value_GetProcessHeap, 0ul, (SIZE_T)Size);
    Filter = (PIP_MSFILTER)return_value_HeapAlloc;
    if(Filter == ((PIP_MSFILTER)NULL))
    {
      WSASetLastError(10055l);
      return -1;
    }

    else
    {
      Filter->imsf_multiaddr = Group;
      Filter->imsf_interface = Interface;
      Filter->imsf_fmode = FilterMode;
      Filter->imsf_numsrc = SourceCount;
      if(SourceCount >= 1u)
        memcpy((void *)Filter->imsf_slist, (const void *)SourceList, (unsigned long long int)SourceCount * sizeof(const IN_ADDR) /*4ull*/ );

      Error=WSAIoctl(Socket, 0x80000000u | (unsigned int)(((signed long int)sizeof(ULONG) /*4l*/  & 0x7F) << 16) | (unsigned int)(116 << 8) | 125u, (LPVOID)Filter, Size, NULL, 0ul, &Returned, ((LPWSAOVERLAPPED)NULL), ((LPWSAOVERLAPPED_COMPLETION_ROUTINE)NULL));
      HANDLE return_value_GetProcessHeap$0=GetProcessHeap();
      HeapFree(return_value_GetProcessHeap$0, 0ul, (LPVOID)Filter);
      return Error;
    }
  }
}

// sha1_clone_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 354
static void sha1_clone_wrap(void *dst, const void *src)
{
  mbedtls_sha1_clone((mbedtls_sha1_context *)dst, (const mbedtls_sha1_context *)src);
}

// sha1_ctx_alloc
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 344
static void * sha1_ctx_alloc(void)
{
  void *ctx=mbedtls_calloc(1ull, sizeof(mbedtls_sha1_context) /*92ull*/ );
  if(!(ctx == NULL))
    mbedtls_sha1_init((mbedtls_sha1_context *)ctx);

  return ctx;
}

// sha1_ctx_free
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 360
static void sha1_ctx_free(void *ctx)
{
  mbedtls_sha1_free((mbedtls_sha1_context *)ctx);
  mbedtls_free(ctx);
}

// sha1_finish_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 339
static signed int sha1_finish_wrap(void *ctx, unsigned char *output)
{
  signed int return_value_mbedtls_sha1_finish_ret=mbedtls_sha1_finish_ret((mbedtls_sha1_context *)ctx, output);
  return return_value_mbedtls_sha1_finish_ret;
}

// sha1_process_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 366
static signed int sha1_process_wrap(void *ctx, const unsigned char *data)
{
  signed int return_value_mbedtls_internal_sha1_process=mbedtls_internal_sha1_process((mbedtls_sha1_context *)ctx, data);
  return return_value_mbedtls_internal_sha1_process;
}

// sha1_starts_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 327
static signed int sha1_starts_wrap(void *ctx)
{
  signed int return_value_mbedtls_sha1_starts_ret=mbedtls_sha1_starts_ret((mbedtls_sha1_context *)ctx);
  return return_value_mbedtls_sha1_starts_ret;
}

// sha1_update_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 332
static signed int sha1_update_wrap(void *ctx, const unsigned char *input, size_t ilen)
{
  signed int return_value_mbedtls_sha1_update_ret=mbedtls_sha1_update_ret((mbedtls_sha1_context *)ctx, input, ilen);
  return return_value_mbedtls_sha1_update_ret;
}

// sha224_clone_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 434
static void sha224_clone_wrap(void *dst, const void *src)
{
  mbedtls_sha256_clone((mbedtls_sha256_context *)dst, (const mbedtls_sha256_context *)src);
}

// sha224_ctx_alloc
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 418
static void * sha224_ctx_alloc(void)
{
  void *ctx=mbedtls_calloc(1ull, sizeof(mbedtls_sha256_context) /*108ull*/ );
  if(!(ctx == NULL))
    mbedtls_sha256_init((mbedtls_sha256_context *)ctx);

  return ctx;
}

// sha224_ctx_free
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 428
static void sha224_ctx_free(void *ctx)
{
  mbedtls_sha256_free((mbedtls_sha256_context *)ctx);
  mbedtls_free(ctx);
}

// sha224_finish_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 406
static signed int sha224_finish_wrap(void *ctx, unsigned char *output)
{
  signed int return_value_mbedtls_sha256_finish_ret=mbedtls_sha256_finish_ret((mbedtls_sha256_context *)ctx, output);
  return return_value_mbedtls_sha256_finish_ret;
}

// sha224_process_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 440
static signed int sha224_process_wrap(void *ctx, const unsigned char *data)
{
  signed int return_value_mbedtls_internal_sha256_process=mbedtls_internal_sha256_process((mbedtls_sha256_context *)ctx, data);
  return return_value_mbedtls_internal_sha256_process;
}

// sha224_starts_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 394
static signed int sha224_starts_wrap(void *ctx)
{
  signed int return_value_mbedtls_sha256_starts_ret=mbedtls_sha256_starts_ret((mbedtls_sha256_context *)ctx, 1);
  return return_value_mbedtls_sha256_starts_ret;
}

// sha224_update_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 399
static signed int sha224_update_wrap(void *ctx, const unsigned char *input, size_t ilen)
{
  signed int return_value_mbedtls_sha256_update_ret=mbedtls_sha256_update_ret((mbedtls_sha256_context *)ctx, input, ilen);
  return return_value_mbedtls_sha256_update_ret;
}

// sha224_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 412
static signed int sha224_wrap(const unsigned char *input, size_t ilen, unsigned char *output)
{
  signed int return_value_mbedtls_sha256_ret=mbedtls_sha256_ret(input, ilen, output, 1);
  return return_value_mbedtls_sha256_ret;
}

// sha256_starts_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 461
static signed int sha256_starts_wrap(void *ctx)
{
  signed int return_value_mbedtls_sha256_starts_ret=mbedtls_sha256_starts_ret((mbedtls_sha256_context *)ctx, 0);
  return return_value_mbedtls_sha256_starts_ret;
}

// sha256_wrap
// file ..\..\..\..\lib\third_party\mbedtls\library\md_wrap.c line 466
static signed int sha256_wrap(const unsigned char *input, size_t ilen, unsigned char *output)
{
  signed int return_value_mbedtls_sha256_ret=mbedtls_sha256_ret(input, ilen, output, 0);
  return return_value_mbedtls_sha256_ret;
}

// sinhl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 915
/*inline double sinhl(double _X)*/
/*{*/
  /*double return_value_sinh=sinh((double)_X);*/
  /*return return_value_sinh;*/
/*}*/

// sinl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 920
/*inline double sinl(double _X)*/
/*{*/
  /*double return_value_sin=sin((double)_X);*/
  /*return return_value_sin;*/
/*}*/

// sprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1826
inline signed int sprintf_s(char * const _Buffer, const size_t _BufferCount, const char * const _Format, ...)
{
  signed int _Result;
  va_list _ArgList;
	va_start(_ArgList, _Format);
//  va_list _ArgList=(va_list)&_Format + (signed long long int)((sizeof(const char *) /*8ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull));
  _Result=_vsprintf_s_l(_Buffer, _BufferCount, _Format, ((const _locale_t)NULL), _ArgList);
	va_end(_ArgList);
  return _Result;
}

// sqrtl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 925
/*inline double sqrtl(double _X)*/
/*{*/
  /*double return_value_sqrt=sqrt((double)_X);*/
  /*return return_value_sqrt;*/
/*}*/

// sscanf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 2293
/*inline signed int sscanf_s(const char * const _Buffer, const char * const _Format, ...)*/
/*{*/
  /*signed int _Result;*/
 // va_list _ArgList=(va_list)&_Format + (signed long long int)((sizeof(const char *) [>8ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull<]  - 1ull));
  /*_Result=vsscanf_s(_Buffer, _Format, _ArgList);*/
  /*_ArgList = ((va_list)NULL);*/
  /*return _Result;*/
/*}*/

// ssl_append_key_cert
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5993
static signed int ssl_append_key_cert(mbedtls_ssl_key_cert **head, mbedtls_x509_crt *cert, mbedtls_pk_context *ssl_append_key_cert$$key)
{
  mbedtls_ssl_key_cert *new;
  void *return_value=mbedtls_calloc(1ull, sizeof(mbedtls_ssl_key_cert) /*24ull*/ );
  new = (mbedtls_ssl_key_cert *)return_value;
  if(new == ((mbedtls_ssl_key_cert *)NULL))
    return -0x7F00;

  else
  {
    new->cert = cert;
    new->key = ssl_append_key_cert$$key;
    new->next = ((mbedtls_ssl_key_cert *)NULL);
    if(*head == ((mbedtls_ssl_key_cert *)NULL))
      *head = new;

    else
    {
      mbedtls_ssl_key_cert *cur=*head;
      if(!(cur->next == ((mbedtls_ssl_key_cert *)NULL)))
        cur = cur->next;

      cur->next = new;
    }
    return 0;
  }
}

// ssl_calc_finished_tls_sha256
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5099
static void ssl_calc_finished_tls_sha256(mbedtls_ssl_context *ssl, unsigned char *buf, signed int from)
{
  signed int len=12;
  const char *sender;
  mbedtls_sha256_context sha256;
  unsigned char padbuf[32ll];
  mbedtls_ssl_session *session=ssl->session_negotiate;
  if(session == ((mbedtls_ssl_session *)NULL))
    session = ssl->session;

  mbedtls_sha256_init(&sha256);
  while((_Bool)0)
    ;
  mbedtls_sha256_clone(&sha256, &ssl->handshake->fin_sha256);
  while((_Bool)0)
    ;
  sender = from == 0 ? "client finished" : "server finished";
  mbedtls_sha256_finish_ret(&sha256, padbuf);
  ssl->handshake->tls_prf(session->master, 48ull, sender, padbuf, 32ull, buf, (size_t)len);
  mbedtls_sha256_free(&sha256);
  mbedtls_zeroize$link16((void *)padbuf, sizeof(unsigned char [32ll]) /*32ull*/ );
}

// ssl_calc_verify_tls_sha256
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 1068
static void ssl_calc_verify_tls_sha256(mbedtls_ssl_context *ssl, unsigned char *hash)
{
  mbedtls_sha256_context sha256;
  mbedtls_sha256_init(&sha256);
  while((_Bool)0)
    ;
  mbedtls_sha256_clone(&sha256, &ssl->handshake->fin_sha256);
  mbedtls_sha256_finish_ret(&sha256, hash);
  while((_Bool)0)
    ;
  while((_Bool)0)
    ;
  mbedtls_sha256_free(&sha256);
}

// ssl_check_server_ecdh_params
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 1976
static signed int ssl_check_server_ecdh_params(const mbedtls_ssl_context *ssl)
{
  const mbedtls_ecp_curve_info *curve_info=mbedtls_ecp_curve_info_from_grp_id(ssl->handshake->ecdh_ctx.grp.id);
  if(curve_info == ((const mbedtls_ecp_curve_info *)NULL))
  {
    while((_Bool)0)
      ;
    return -0x6C00;
  }

  else
  {
    while((_Bool)0)
      ;
    signed int return_value_mbedtls_ssl_check_curve=mbedtls_ssl_check_curve(ssl, ssl->handshake->ecdh_ctx.grp.id);
    if(!(return_value_mbedtls_ssl_check_curve == 0))
      return -1;

    else
    {
      while((_Bool)0)
        ;
      return 0;
    }
  }
}

// ssl_check_timer
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 89
static signed int ssl_check_timer(mbedtls_ssl_context *ssl)
{
  if(ssl->f_get_timer == ((mbedtls_ssl_get_timer_t (*))NULL))
    return 0;

  else
  {
    signed int return_value=ssl->f_get_timer(ssl->p_timer);
    if(return_value == 2)
      return -1;

    else
      return 0;
  }
}

// ssl_decrypt_buf
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 1612
static signed int ssl_decrypt_buf(mbedtls_ssl_context *ssl)
{
  size_t i;
  mbedtls_cipher_mode_t mode;
  signed int auth_done=0;
  size_t padlen=0ull;
  size_t correct=1ull;
  while((_Bool)0)
    ;
  _Bool tmp_if_expr;
  if(ssl->session_in == ((mbedtls_ssl_session *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ssl->transform_in == ((mbedtls_ssl_transform *)NULL) ? (_Bool)1 : (_Bool)0;
  size_t return_value_ssl_ep_len;
  if(tmp_if_expr)
  {
    while((_Bool)0)
      ;
    return -0x6C00;
  }

  else
  {
    mode=mbedtls_cipher_get_cipher_mode(&ssl->transform_in->cipher_ctx_dec);
    if(!(ssl->in_msglen >= ssl->transform_in->minlen))
    {
      while((_Bool)0)
        ;
      return -0x7180;
    }

    else
    {
      if((signed int)mode == 6 || (signed int)mode == 8)
      {
        signed int ret;
        size_t dec_msglen;
        size_t ssl_decrypt_buf$$1$$4$$olen;
        unsigned char *dec_msg;
        unsigned char *ssl_decrypt_buf$$1$$4$$dec_msg_result;
        unsigned char add_data[13ll];
        unsigned char taglen=(unsigned char)(((signed int)ssl->transform_in->ciphersuite_info->flags & 0x2) != 0 ? 8 : 16);
        size_t explicit_iv_len=ssl->transform_in->ivlen - ssl->transform_in->fixed_ivlen;
        if(!(ssl->in_msglen >= explicit_iv_len + (unsigned long long int)taglen))
        {
          while((_Bool)0)
            ;
          return -0x7180;
        }

        dec_msglen = (ssl->in_msglen - explicit_iv_len) - (unsigned long long int)taglen;
        dec_msg = ssl->in_msg;
        ssl_decrypt_buf$$1$$4$$dec_msg_result = ssl->in_msg;
        ssl->in_msglen = dec_msglen;
        memcpy((void *)add_data, (const void *)ssl->in_ctr, 8ull);
        add_data[8ll] = (unsigned char)ssl->in_msgtype;
        mbedtls_ssl_write_version(ssl->major_ver, ssl->minor_ver, (signed int)ssl->conf->transport, add_data + 9ll);
        add_data[11ll] = (unsigned char)(ssl->in_msglen >> 8 & 255ull);
        add_data[12ll] = (unsigned char)(ssl->in_msglen & 255ull);
        while((_Bool)0)
          ;
        memcpy((void *)(ssl->transform_in->iv_dec + (signed long long int)ssl->transform_in->fixed_ivlen), (const void *)ssl->in_iv, ssl->transform_in->ivlen - ssl->transform_in->fixed_ivlen);
        while((_Bool)0)
          ;
        while((_Bool)0)
          ;
        ret=mbedtls_cipher_auth_decrypt(&ssl->transform_in->cipher_ctx_dec, ssl->transform_in->iv_dec, ssl->transform_in->ivlen, add_data, 13ull, dec_msg, dec_msglen, ssl_decrypt_buf$$1$$4$$dec_msg_result, &ssl_decrypt_buf$$1$$4$$olen, dec_msg + (signed long long int)dec_msglen, (size_t)taglen);
        if(!(ret == 0))
        {
          while((_Bool)0)
            ;
          if(ret == -25344)
            return -0x7180;

          return ret;
        }

        auth_done = auth_done + 1;
        if(!(ssl_decrypt_buf$$1$$4$$olen == dec_msglen))
        {
          while((_Bool)0)
            ;
          return -0x6C00;
        }

      }

      else
        if((signed int)mode == 2)
        {
          signed int ssl_decrypt_buf$$1$$5$$ret;
          unsigned char *ssl_decrypt_buf$$1$$5$$dec_msg;
          unsigned char *dec_msg_result;
          size_t ssl_decrypt_buf$$1$$5$$dec_msglen;
          size_t minlen=0ull;
          size_t olen=0ull;
          if(ssl->minor_ver >= 2)
            minlen = minlen + ssl->transform_in->ivlen;

          _Bool tmp_if_expr$0;
          if(!(ssl->in_msglen >= ssl->transform_in->ivlen + minlen))
            tmp_if_expr$0 = (_Bool)1;

          else
            tmp_if_expr$0 = ssl->in_msglen < minlen + ssl->transform_in->maclen + 1ull ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$0)
          {
            while((_Bool)0)
              ;
            return -0x7180;
          }

          ssl_decrypt_buf$$1$$5$$dec_msglen = ssl->in_msglen;
          ssl_decrypt_buf$$1$$5$$dec_msg = ssl->in_msg;
          dec_msg_result = ssl->in_msg;
          if(ssl->session_in->encrypt_then_mac == 1)
          {
            unsigned char mac_expect[32ll];
            unsigned char pseudo_hdr[13ll];
            while((_Bool)0)
              ;
            ssl_decrypt_buf$$1$$5$$dec_msglen = ssl_decrypt_buf$$1$$5$$dec_msglen - ssl->transform_in->maclen;
            ssl->in_msglen = ssl->in_msglen - ssl->transform_in->maclen;
            memcpy((void *)(pseudo_hdr + 0ll), (const void *)ssl->in_ctr, 8ull);
            memcpy((void *)(pseudo_hdr + 8ll), (const void *)ssl->in_hdr, 3ull);
            pseudo_hdr[11ll] = (unsigned char)(ssl->in_msglen >> 8 & 255ull);
            pseudo_hdr[12ll] = (unsigned char)(ssl->in_msglen & 255ull);
            while((_Bool)0)
              ;
            mbedtls_md_hmac_update(&ssl->transform_in->md_ctx_dec, pseudo_hdr, 13ull);
            mbedtls_md_hmac_update(&ssl->transform_in->md_ctx_dec, ssl->in_iv, ssl->in_msglen);
            mbedtls_md_hmac_finish(&ssl->transform_in->md_ctx_dec, mac_expect);
            mbedtls_md_hmac_reset(&ssl->transform_in->md_ctx_dec);
            while((_Bool)0)
              ;
            while((_Bool)0)
              ;
            signed int return_value_mbedtls_ssl_safer_memcmp=mbedtls_ssl_safer_memcmp((const void *)(ssl->in_iv + (signed long long int)ssl->in_msglen), (const void *)mac_expect, ssl->transform_in->maclen);
            if(!(return_value_mbedtls_ssl_safer_memcmp == 0))
            {
              while((_Bool)0)
                ;
              return -0x7180;
            }

            auth_done = auth_done + 1;
          }

          if(!(ssl->in_msglen % ssl->transform_in->ivlen == 0ull))
          {
            while((_Bool)0)
              ;
            return -0x7180;
          }

          if(ssl->minor_ver >= 2)
          {
            ssl_decrypt_buf$$1$$5$$dec_msglen = ssl_decrypt_buf$$1$$5$$dec_msglen - ssl->transform_in->ivlen;
            ssl->in_msglen = ssl->in_msglen - ssl->transform_in->ivlen;
            i = 0ull;
            for( ; !(i >= ssl->transform_in->ivlen); i = i + 1ull)
              ssl->transform_in->iv_dec[(signed long long int)i] = ssl->in_iv[(signed long long int)i];
          }

          ssl_decrypt_buf$$1$$5$$ret=mbedtls_cipher_crypt(&ssl->transform_in->cipher_ctx_dec, ssl->transform_in->iv_dec, ssl->transform_in->ivlen, ssl_decrypt_buf$$1$$5$$dec_msg, ssl_decrypt_buf$$1$$5$$dec_msglen, dec_msg_result, &olen);
          if(!(ssl_decrypt_buf$$1$$5$$ret == 0))
          {
            while((_Bool)0)
              ;
            return ssl_decrypt_buf$$1$$5$$ret;
          }

          if(!(ssl_decrypt_buf$$1$$5$$dec_msglen == olen))
          {
            while((_Bool)0)
              ;
            return -0x6C00;
          }

          padlen = (size_t)(1 + (signed int)ssl->in_msg[(signed long long int)(ssl->in_msglen - 1ull)]);
          if(!(ssl->in_msglen >= ssl->transform_in->maclen + padlen))
          {
            if(auth_done == 0)
            {
              padlen = 0ull;
              correct = 0ull;
            }

          }

          if(ssl->minor_ver >= 1)
          {
            size_t pad_count=0ull;
            size_t real_count=1ull;
            size_t padding_idx=(ssl->in_msglen - padlen) - 1ull;
            correct = correct & (size_t)(ssl->in_msglen >= padlen + 1ull);
            correct = correct & (size_t)(padding_idx < 8192ull + ssl->transform_in->maclen);
            padding_idx = padding_idx * correct;
            i = 1ull;
            for( ; !(i >= 257ull); i = i + 1ull)
            {
              real_count = real_count & (size_t)(i <= padlen);
              pad_count = pad_count + real_count * (unsigned long long int)((unsigned long long int)ssl->in_msg[(signed long long int)(padding_idx + i)] == padlen - 1ull);
            }
            correct = correct & (size_t)(pad_count == padlen);
            padlen = padlen & correct * 511ull;
          }

          else
          {
            while((_Bool)0)
              ;
            return -0x6C00;
          }
          ssl->in_msglen = ssl->in_msglen - padlen;
        }

        else
        {
          while((_Bool)0)
            ;
          return -0x6C00;
        }
      while((_Bool)0)
        ;
      if(auth_done == 0)
      {
        unsigned char ssl_decrypt_buf$$1$$8$$mac_expect[32ll];
        ssl->in_msglen = ssl->in_msglen - ssl->transform_in->maclen;
        ssl->in_len[0ll] = (unsigned char)(ssl->in_msglen >> 8);
        ssl->in_len[1ll] = (unsigned char)ssl->in_msglen;
        if(ssl->minor_ver >= 1)
        {
          size_t j;
          size_t extra_run=0ull;
          extra_run = (13ull + ssl->in_msglen + padlen + 8ull) / 64ull - (13ull + ssl->in_msglen + 8ull) / 64ull;
          extra_run = extra_run & correct * 255ull;
          mbedtls_md_hmac_update(&ssl->transform_in->md_ctx_dec, ssl->in_ctr, 8ull);
          mbedtls_md_hmac_update(&ssl->transform_in->md_ctx_dec, ssl->in_hdr, 3ull);
          mbedtls_md_hmac_update(&ssl->transform_in->md_ctx_dec, ssl->in_len, 2ull);
          mbedtls_md_hmac_update(&ssl->transform_in->md_ctx_dec, ssl->in_msg, ssl->in_msglen);
          mbedtls_md_hmac_finish(&ssl->transform_in->md_ctx_dec, ssl_decrypt_buf$$1$$8$$mac_expect);
          j = 0ull;
          for( ; !(j >= 1ull + extra_run); j = j + 1ull)
            mbedtls_md_process(&ssl->transform_in->md_ctx_dec, ssl->in_msg);
          mbedtls_md_hmac_reset(&ssl->transform_in->md_ctx_dec);
        }

        else
        {
          while((_Bool)0)
            ;
          return -0x6C00;
        }
        while((_Bool)0)
          ;
        while((_Bool)0)
          ;
        signed int return_value_mbedtls_ssl_safer_memcmp$0=mbedtls_ssl_safer_memcmp((const void *)(ssl->in_msg + (signed long long int)ssl->in_msglen), (const void *)ssl_decrypt_buf$$1$$8$$mac_expect, ssl->transform_in->maclen);
        if(!(return_value_mbedtls_ssl_safer_memcmp$0 == 0))
          correct = 0ull;

        auth_done = auth_done + 1;
        if(correct == 0ull)
          return -0x7180;

      }

      if(!(auth_done == 1))
      {
        while((_Bool)0)
          ;
        return -0x6C00;
      }

      else
      {
        if(ssl->in_msglen == 0ull)
        {
          ssl->nb_zero = ssl->nb_zero + 1;
          if(ssl->nb_zero >= 4)
          {
            while((_Bool)0)
              ;
            return -0x7180;
          }

        }

        else
          ssl->nb_zero = 0;
        i = 8ull;
        do
        {
          return_value_ssl_ep_len=ssl_ep_len(ssl);
          if(return_value_ssl_ep_len >= i)
            break;

          ssl->in_ctr[(signed long long int)(i - 1ull)] = ssl->in_ctr[(signed long long int)(i - 1ull)] + 1;
          if(!((signed int)ssl->in_ctr[-1ll + (signed long long int)i] == 0))
            break;

          i = i - 1ull;
        }
        while((_Bool)1);
        size_t return_value_ssl_ep_len$0=ssl_ep_len(ssl);
        if(i == return_value_ssl_ep_len$0)
        {
          while((_Bool)0)
            ;
          return -0x6B80;
        }

        else
        {
          while((_Bool)0)
            ;
          return 0;
        }
      }
    }
  }
}

// ssl_encrypt_buf
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 1284
static signed int ssl_encrypt_buf(mbedtls_ssl_context *ssl)
{
  mbedtls_cipher_mode_t mode;
  signed int auth_done=0;
  while((_Bool)0)
    ;
  _Bool tmp_if_expr;
  if(ssl->session_out == ((mbedtls_ssl_session *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ssl->transform_out == ((mbedtls_ssl_transform *)NULL) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$0;
  if(tmp_if_expr)
  {
    while((_Bool)0)
      ;
    return -0x6C00;
  }

  else
  {
    mode=mbedtls_cipher_get_cipher_mode(&ssl->transform_out->cipher_ctx_enc);
    while((_Bool)0)
      ;
    if(ssl->out_msglen >= 8193ull)
    {
      while((_Bool)0)
        ;
      return -0x7100;
    }

    else
    {
      _Bool tmp_if_expr$1;
      if((signed int)mode == 7)
        tmp_if_expr$1 = (_Bool)1;

      else
      {
        if((signed int)mode == 2)
          tmp_if_expr$0 = ssl->session_out->encrypt_then_mac == 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$0 = (_Bool)0;
        tmp_if_expr$1 = tmp_if_expr$0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$1)
      {
        if(ssl->minor_ver >= 1)
        {
          unsigned char mac[32ll];
          mbedtls_md_hmac_update(&ssl->transform_out->md_ctx_enc, ssl->out_ctr, 8ull);
          mbedtls_md_hmac_update(&ssl->transform_out->md_ctx_enc, ssl->out_hdr, 3ull);
          mbedtls_md_hmac_update(&ssl->transform_out->md_ctx_enc, ssl->out_len, 2ull);
          mbedtls_md_hmac_update(&ssl->transform_out->md_ctx_enc, ssl->out_msg, ssl->out_msglen);
          mbedtls_md_hmac_finish(&ssl->transform_out->md_ctx_enc, mac);
          mbedtls_md_hmac_reset(&ssl->transform_out->md_ctx_enc);
          memcpy((void *)(ssl->out_msg + (signed long long int)ssl->out_msglen), (const void *)mac, ssl->transform_out->maclen);
        }

        else
        {
          while((_Bool)0)
            ;
          return -0x6C00;
        }
        while((_Bool)0)
          ;
        ssl->out_msglen = ssl->out_msglen + ssl->transform_out->maclen;
        auth_done = auth_done + 1;
      }

      if((signed int)mode == 6 || (signed int)mode == 8)
      {
        signed int ret;
        size_t enc_msglen;
        size_t olen;
        unsigned char *enc_msg;
        unsigned char add_data[13ll];
        unsigned char taglen=(unsigned char)(((signed int)ssl->transform_out->ciphersuite_info->flags & 0x2) != 0 ? 8 : 16);
        memcpy((void *)add_data, (const void *)ssl->out_ctr, 8ull);
        add_data[8ll] = (unsigned char)ssl->out_msgtype;
        mbedtls_ssl_write_version(ssl->major_ver, ssl->minor_ver, (signed int)ssl->conf->transport, add_data + 9ll);
        add_data[11ll] = (unsigned char)(ssl->out_msglen >> 8 & 255ull);
        add_data[12ll] = (unsigned char)(ssl->out_msglen & 255ull);
        while((_Bool)0)
          ;
        if(!(ssl->transform_out->ivlen + -ssl->transform_out->fixed_ivlen == 8ull))
        {
          while((_Bool)0)
            ;
          return -0x6C00;
        }

        memcpy((void *)(ssl->transform_out->iv_enc + (signed long long int)ssl->transform_out->fixed_ivlen), (const void *)ssl->out_ctr, 8ull);
        memcpy((void *)ssl->out_iv, (const void *)ssl->out_ctr, 8ull);
        while((_Bool)0)
          ;
        enc_msg = ssl->out_msg;
        enc_msglen = ssl->out_msglen;
        ssl->out_msglen = ssl->out_msglen + (ssl->transform_out->ivlen - ssl->transform_out->fixed_ivlen);
        while((_Bool)0)
          ;
        ret=mbedtls_cipher_auth_encrypt(&ssl->transform_out->cipher_ctx_enc, ssl->transform_out->iv_enc, ssl->transform_out->ivlen, add_data, 13ull, enc_msg, enc_msglen, enc_msg, &olen, enc_msg + (signed long long int)enc_msglen, (size_t)taglen);
        if(!(ret == 0))
        {
          while((_Bool)0)
            ;
          return ret;
        }

        if(!(olen == enc_msglen))
        {
          while((_Bool)0)
            ;
          return -0x6C00;
        }

        ssl->out_msglen = ssl->out_msglen + (size_t)taglen;
        auth_done = auth_done + 1;
        while((_Bool)0)
          ;
      }

      else
        if((signed int)mode == 2)
        {
          signed int ssl_encrypt_buf$$1$$7$$ret;
          unsigned char *ssl_encrypt_buf$$1$$7$$enc_msg;
          size_t ssl_encrypt_buf$$1$$7$$enc_msglen;
          size_t padlen;
          size_t ssl_encrypt_buf$$1$$7$$olen=0ull;
          size_t i;
          padlen = ssl->transform_out->ivlen - (ssl->out_msglen + 1ull) % ssl->transform_out->ivlen;
          if(padlen == ssl->transform_out->ivlen)
            padlen = 0ull;

          i = 0ull;
          for( ; padlen >= i; i = i + 1ull)
            ssl->out_msg[(signed long long int)(ssl->out_msglen + i)] = (unsigned char)padlen;
          ssl->out_msglen = ssl->out_msglen + padlen + 1ull;
          ssl_encrypt_buf$$1$$7$$enc_msglen = ssl->out_msglen;
          ssl_encrypt_buf$$1$$7$$enc_msg = ssl->out_msg;
          if(ssl->minor_ver >= 2)
          {
            ssl_encrypt_buf$$1$$7$$ret=ssl->conf->f_rng(ssl->conf->p_rng, ssl->transform_out->iv_enc, ssl->transform_out->ivlen);
            if(!(ssl_encrypt_buf$$1$$7$$ret == 0))
              return ssl_encrypt_buf$$1$$7$$ret;

            memcpy((void *)ssl->out_iv, (const void *)ssl->transform_out->iv_enc, ssl->transform_out->ivlen);
            ssl_encrypt_buf$$1$$7$$enc_msg = ssl->out_msg;
            ssl_encrypt_buf$$1$$7$$enc_msglen = ssl->out_msglen;
            ssl->out_msglen = ssl->out_msglen + ssl->transform_out->ivlen;
          }

          while((_Bool)0)
            ;
          ssl_encrypt_buf$$1$$7$$ret=mbedtls_cipher_crypt(&ssl->transform_out->cipher_ctx_enc, ssl->transform_out->iv_enc, ssl->transform_out->ivlen, ssl_encrypt_buf$$1$$7$$enc_msg, ssl_encrypt_buf$$1$$7$$enc_msglen, ssl_encrypt_buf$$1$$7$$enc_msg, &ssl_encrypt_buf$$1$$7$$olen);
          if(!(ssl_encrypt_buf$$1$$7$$ret == 0))
          {
            while((_Bool)0)
              ;
            return ssl_encrypt_buf$$1$$7$$ret;
          }

          if(!(ssl_encrypt_buf$$1$$7$$enc_msglen == ssl_encrypt_buf$$1$$7$$olen))
          {
            while((_Bool)0)
              ;
            return -0x6C00;
          }

          if(auth_done == 0)
          {
            unsigned char pseudo_hdr[13ll];
            while((_Bool)0)
              ;
            memcpy((void *)(pseudo_hdr + 0ll), (const void *)ssl->out_ctr, 8ull);
            memcpy((void *)(pseudo_hdr + 8ll), (const void *)ssl->out_hdr, 3ull);
            pseudo_hdr[11ll] = (unsigned char)(ssl->out_msglen >> 8 & 255ull);
            pseudo_hdr[12ll] = (unsigned char)(ssl->out_msglen & 255ull);
            while((_Bool)0)
              ;
            mbedtls_md_hmac_update(&ssl->transform_out->md_ctx_enc, pseudo_hdr, 13ull);
            mbedtls_md_hmac_update(&ssl->transform_out->md_ctx_enc, ssl->out_iv, ssl->out_msglen);
            mbedtls_md_hmac_finish(&ssl->transform_out->md_ctx_enc, ssl->out_iv + (signed long long int)ssl->out_msglen);
            mbedtls_md_hmac_reset(&ssl->transform_out->md_ctx_enc);
            ssl->out_msglen = ssl->out_msglen + ssl->transform_out->maclen;
            auth_done = auth_done + 1;
          }

        }

        else
        {
          while((_Bool)0)
            ;
          return -0x6C00;
        }
      if(!(auth_done == 1))
      {
        while((_Bool)0)
          ;
        return -0x6C00;
      }

      else
      {
        while((_Bool)0)
          ;
        return 0;
      }
    }
  }
}

// ssl_ep_len
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 62
static inline size_t ssl_ep_len(const mbedtls_ssl_context *ssl)
{
  (void)ssl;
  return 0ull;
}

// ssl_generate_random
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 680
static signed int ssl_generate_random(mbedtls_ssl_context *ssl)
{
  signed int ret;
  unsigned char *p=ssl->handshake->randbytes;
  ret=ssl->conf->f_rng(ssl->conf->p_rng, p, 4ull);
  if(!(ret == 0))
    return ret;

  else
  {
    p = p + 4ll;
    ret=ssl->conf->f_rng(ssl->conf->p_rng, p, 28ull);
    if(!(ret == 0))
      return ret;

    else
      return 0;
  }
}

// ssl_handshake_init
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5551
static signed int ssl_handshake_init(mbedtls_ssl_context *ssl)
{
  if(!(ssl->transform_negotiate == ((mbedtls_ssl_transform *)NULL)))
    mbedtls_ssl_transform_free(ssl->transform_negotiate);

  if(!(ssl->session_negotiate == ((mbedtls_ssl_session *)NULL)))
    mbedtls_ssl_session_free(ssl->session_negotiate);

  if(!(ssl->handshake == ((mbedtls_ssl_handshake_params *)NULL)))
    mbedtls_ssl_handshake_free(ssl->handshake);

  if(ssl->transform_negotiate == ((mbedtls_ssl_transform *)NULL))
  {
    void *return_value=mbedtls_calloc(1ull, sizeof(mbedtls_ssl_transform) /*304ull*/ );
    ssl->transform_negotiate = (mbedtls_ssl_transform *)return_value;
  }

  if(ssl->session_negotiate == ((mbedtls_ssl_session *)NULL))
  {
    void *return_value$0=mbedtls_calloc(1ull, sizeof(mbedtls_ssl_session) /*120ull*/ );
    ssl->session_negotiate = (mbedtls_ssl_session *)return_value$0;
  }

  if(ssl->handshake == ((mbedtls_ssl_handshake_params *)NULL))
  {
    void *return_value$1=mbedtls_calloc(1ull, sizeof(mbedtls_ssl_handshake_params) /*976ull*/ );
    ssl->handshake = (mbedtls_ssl_handshake_params *)return_value$1;
  }

  _Bool tmp_if_expr;
  if(ssl->handshake == ((mbedtls_ssl_handshake_params *)NULL))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ssl->transform_negotiate == ((mbedtls_ssl_transform *)NULL) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$0;
  if(tmp_if_expr)
    tmp_if_expr$0 = (_Bool)1;

  else
    tmp_if_expr$0 = ssl->session_negotiate == ((mbedtls_ssl_session *)NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$0)
  {
    while((_Bool)0)
      ;
    mbedtls_free((void *)ssl->handshake);
    mbedtls_free((void *)ssl->transform_negotiate);
    mbedtls_free((void *)ssl->session_negotiate);
    ssl->handshake = ((mbedtls_ssl_handshake_params *)NULL);
    ssl->transform_negotiate = ((mbedtls_ssl_transform *)NULL);
    ssl->session_negotiate = ((mbedtls_ssl_session *)NULL);
    return -0x7F00;
  }

  else
  {
    mbedtls_ssl_session_init(ssl->session_negotiate);
    ssl_transform_init(ssl->transform_negotiate);
    ssl_handshake_params_init(ssl->handshake);
    return 0;
  }
}

// ssl_handshake_params_init
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5487
static void ssl_handshake_params_init(mbedtls_ssl_handshake_params *handshake)
{
  memset((void *)handshake, 0, sizeof(mbedtls_ssl_handshake_params) /*976ull*/ );
  mbedtls_sha256_init(&handshake->fin_sha256);
  mbedtls_sha256_starts_ret(&handshake->fin_sha256, 0);
  handshake->update_checksum = ssl_update_checksum_start;
  mbedtls_ssl_sig_hash_set_init(&handshake->hash_algs);
  mbedtls_ecdh_init(&handshake->ecdh_ctx);
  handshake->sni_authmode = 3;
}

// ssl_handshake_wrapup_free_hs_transform
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5197
static void ssl_handshake_wrapup_free_hs_transform(mbedtls_ssl_context *ssl)
{
  while((_Bool)0)
    ;
  mbedtls_ssl_handshake_free(ssl->handshake);
  mbedtls_free((void *)ssl->handshake);
  ssl->handshake = ((mbedtls_ssl_handshake_params *)NULL);
  if(!(ssl->transform == ((mbedtls_ssl_transform *)NULL)))
  {
    mbedtls_ssl_transform_free(ssl->transform);
    mbedtls_free((void *)ssl->transform);
  }

  ssl->transform = ssl->transform_negotiate;
  ssl->transform_negotiate = ((mbedtls_ssl_transform *)NULL);
}

// ssl_key_cert_free
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7399
static void ssl_key_cert_free(mbedtls_ssl_key_cert *key_cert)
{
  mbedtls_ssl_key_cert *cur=key_cert;
  mbedtls_ssl_key_cert *next;
  if(!(cur == ((mbedtls_ssl_key_cert *)NULL)))
  {
    next = cur->next;
    mbedtls_free((void *)cur);
    cur = next;
  }

}

// ssl_parse_alpn_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 1300
static signed int ssl_parse_alpn_ext(mbedtls_ssl_context *ssl, const unsigned char *buf, size_t len)
{
  size_t list_len;
  size_t name_len;
  const char **p;
  signed int return_value_memcmp;
  if(ssl->conf->alpn_list == ((const char **)NULL))
  {
    while((_Bool)0)
      ;
    mbedtls_ssl_send_alert_message(ssl, 2, 40);
    return -0x7980;
  }

  else
    if(!(len >= 4ull))
    {
      mbedtls_ssl_send_alert_message(ssl, 2, 50);
      return -0x7980;
    }

    else
    {
      list_len = (size_t)((signed int)buf[0ll] << 8 | (signed int)buf[1ll]);
      if(!(list_len == 18446744073709551614ull + len))
      {
        mbedtls_ssl_send_alert_message(ssl, 2, 50);
        return -0x7980;
      }

      else
      {
        name_len = (size_t)buf[2ll];
        if(!(name_len == 18446744073709551615ull + list_len))
        {
          mbedtls_ssl_send_alert_message(ssl, 2, 50);
          return -0x7980;
        }

        else
        {
          p = ssl->conf->alpn_list;
          for( ; !(*p == ((const char *)NULL)); p = p + 1ll)
          {
            size_t return_value_strlen=strlen(*p);
            if(name_len == return_value_strlen)
            {
              return_value_memcmp=memcmp((const void *)(buf + 3ll), (const void *)*p, name_len);
              if(return_value_memcmp == 0)
              {
                ssl->alpn_chosen = *p;
                return 0;
              }

            }

          }
          while((_Bool)0)
            ;
          mbedtls_ssl_send_alert_message(ssl, 2, 40);
          return -0x7980;
        }
      }
    }
}

// ssl_parse_certificate_request
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 2604
static signed int ssl_parse_certificate_request(mbedtls_ssl_context *ssl)
{
  signed int ret;
  unsigned char *buf;
  size_t n=0ull;
  size_t cert_type_len=0ull;
  size_t dn_len=0ull;
  const mbedtls_ssl_ciphersuite_t *ciphersuite_info=ssl->transform_negotiate->ciphersuite_info;
  while((_Bool)0)
    ;
  signed int return_value_mbedtls_ssl_ciphersuite_cert_req_allowed=mbedtls_ssl_ciphersuite_cert_req_allowed(ciphersuite_info);
  size_t return_value_mbedtls_ssl_hs_hdr_len;
  size_t return_value_mbedtls_ssl_hs_hdr_len$0;
  size_t return_value_mbedtls_ssl_hs_hdr_len$4;
  size_t return_value_mbedtls_ssl_hs_hdr_len$5;
  size_t return_value_mbedtls_ssl_hs_hdr_len$6;
  if(return_value_mbedtls_ssl_ciphersuite_cert_req_allowed == 0)
  {
    while((_Bool)0)
      ;
    ssl->state = ssl->state + 1;
    return 0;
  }

  else
  {
    ret=mbedtls_ssl_read_record(ssl);
    if(!(ret == 0))
    {
      while((_Bool)0)
        ;
      return ret;
    }

    else
      if(!(ssl->in_msgtype == 22))
      {
        while((_Bool)0)
          ;
        mbedtls_ssl_send_alert_message(ssl, 2, 10);
        return -0x7700;
      }

      else
      {
        ssl->state = ssl->state + 1;
        ssl->client_auth = (signed int)((signed int)ssl->in_msg[0ll] == 13);
        while((_Bool)0)
          ;
        if(ssl->client_auth == 0)
          ssl->keep_current_message = 1;

        else
        {
          buf = ssl->in_msg;
          return_value_mbedtls_ssl_hs_hdr_len=mbedtls_ssl_hs_hdr_len(ssl);
          cert_type_len = (size_t)buf[(signed long long int)return_value_mbedtls_ssl_hs_hdr_len];
          n = cert_type_len;
          return_value_mbedtls_ssl_hs_hdr_len$0=mbedtls_ssl_hs_hdr_len(ssl);
          if(!(ssl->in_hslen >= 2ull + return_value_mbedtls_ssl_hs_hdr_len$0 + n))
          {
            while((_Bool)0)
              ;
            mbedtls_ssl_send_alert_message(ssl, 2, 50);
            return -0x7A80;
          }

          if(ssl->minor_ver == 3)
          {
            size_t sig_alg_len;
            size_t return_value_mbedtls_ssl_hs_hdr_len$1=mbedtls_ssl_hs_hdr_len(ssl);
            size_t return_value_mbedtls_ssl_hs_hdr_len$2=mbedtls_ssl_hs_hdr_len(ssl);
            sig_alg_len = (size_t)((signed int)buf[(signed long long int)(return_value_mbedtls_ssl_hs_hdr_len$1 + 1ull + n)] << 8 | (signed int)buf[(signed long long int)(return_value_mbedtls_ssl_hs_hdr_len$2 + 2ull + n)]);
            n = n + 2ull + sig_alg_len;
            size_t return_value_mbedtls_ssl_hs_hdr_len$3=mbedtls_ssl_hs_hdr_len(ssl);
            if(!(ssl->in_hslen >= 2ull + return_value_mbedtls_ssl_hs_hdr_len$3 + n))
            {
              while((_Bool)0)
                ;
              mbedtls_ssl_send_alert_message(ssl, 2, 50);
              return -0x7A80;
            }

          }

          return_value_mbedtls_ssl_hs_hdr_len$4=mbedtls_ssl_hs_hdr_len(ssl);
          return_value_mbedtls_ssl_hs_hdr_len$5=mbedtls_ssl_hs_hdr_len(ssl);
          dn_len = (size_t)((signed int)buf[(signed long long int)(return_value_mbedtls_ssl_hs_hdr_len$4 + 1ull + n)] << 8 | (signed int)buf[(signed long long int)(return_value_mbedtls_ssl_hs_hdr_len$5 + 2ull + n)]);
          n = n + dn_len;
          return_value_mbedtls_ssl_hs_hdr_len$6=mbedtls_ssl_hs_hdr_len(ssl);
          if(!(ssl->in_hslen == 3ull + return_value_mbedtls_ssl_hs_hdr_len$6 + n))
          {
            while((_Bool)0)
              ;
            mbedtls_ssl_send_alert_message(ssl, 2, 50);
            return -0x7A80;
          }

        }
        do

          exit:
            ;
        while((_Bool)0);
        return 0;
      }
  }
}

// ssl_parse_encrypt_then_mac_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 1154
static signed int ssl_parse_encrypt_then_mac_ext(mbedtls_ssl_context *ssl, const unsigned char *buf, size_t len)
{
  _Bool tmp_if_expr;
  if((signed int)ssl->conf->encrypt_then_mac == 0)
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ssl->minor_ver == 0 ? (_Bool)1 : (_Bool)0;
  if(!(len == 0ull) || tmp_if_expr)
  {
    while((_Bool)0)
      ;
    mbedtls_ssl_send_alert_message(ssl, 2, 40);
    return -0x7980;
  }

  else
  {
    (void)buf;
    ssl->session_negotiate->encrypt_then_mac = 1;
    return 0;
  }
}

// ssl_parse_extended_ms_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 1177
static signed int ssl_parse_extended_ms_ext(mbedtls_ssl_context *ssl, const unsigned char *buf, size_t len)
{
  _Bool tmp_if_expr;
  if((signed int)ssl->conf->extended_ms == 0)
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = ssl->minor_ver == 0 ? (_Bool)1 : (_Bool)0;
  if(!(len == 0ull) || tmp_if_expr)
  {
    while((_Bool)0)
      ;
    mbedtls_ssl_send_alert_message(ssl, 2, 40);
    return -0x7980;
  }

  else
  {
    (void)buf;
    ssl->handshake->extended_ms = 1;
    return 0;
  }
}

// ssl_parse_max_fragment_length_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 1109
static signed int ssl_parse_max_fragment_length_ext(mbedtls_ssl_context *ssl, const unsigned char *buf, size_t len)
{
  _Bool tmp_if_expr;
  if((signed int)ssl->conf->mfl_code == 0 || !(len == 1ull))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = (signed int)buf[0ll] != (signed int)ssl->conf->mfl_code ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
  {
    while((_Bool)0)
      ;
    mbedtls_ssl_send_alert_message(ssl, 2, 40);
    return -0x7980;
  }

  else
    return 0;
}

// ssl_parse_record_header
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 3547
static signed int ssl_parse_record_header(mbedtls_ssl_context *ssl)
{
  signed int major_ver;
  signed int minor_ver;
  while((_Bool)0)
    ;
  ssl->in_msgtype = (signed int)ssl->in_hdr[0ll];
  ssl->in_msglen = (size_t)((signed int)ssl->in_len[0ll] << 8 | (signed int)ssl->in_len[1ll]);
  mbedtls_ssl_read_version(&major_ver, &minor_ver, (signed int)ssl->conf->transport, ssl->in_hdr + 1ll);
  while((_Bool)0)
    ;
  if(!(ssl->in_msgtype == 22))
  {
    if(!(ssl->in_msgtype == 21))
    {
      if(!(ssl->in_msgtype == 20))
      {
        if(!(ssl->in_msgtype == 23))
        {
          while((_Bool)0)
            ;
          mbedtls_ssl_send_alert_message(ssl, 2, 10);
          return -0x7200;
        }

      }

    }

  }

  if(!(major_ver == ssl->major_ver))
  {
    while((_Bool)0)
      ;
    return -0x7200;
  }

  else
    if(!((signed int)ssl->conf->max_minor_ver >= minor_ver))
    {
      while((_Bool)0)
        ;
      return -0x7200;
    }

    else
      if(!(8509ull + -((size_t)(ssl->in_msg - ssl->in_buf)) >= ssl->in_msglen))
      {
        while((_Bool)0)
          ;
        return -0x7200;
      }

      else
      {
        if(ssl->transform_in == ((mbedtls_ssl_transform *)NULL))
        {
          _Bool tmp_if_expr;
          if(!(ssl->in_msglen >= 1ull))
            tmp_if_expr = (_Bool)1;

          else
            tmp_if_expr = ssl->in_msglen > 8192ull ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr)
          {
            while((_Bool)0)
              ;
            return -0x7200;
          }

        }

        else
        {
          if(!(ssl->in_msglen >= ssl->transform_in->minlen))
          {
            while((_Bool)0)
              ;
            return -0x7200;
          }

          if(ssl->minor_ver >= 1)
          {
            if(!(8448ull + ssl->transform_in->minlen >= ssl->in_msglen))
            {
              while((_Bool)0)
                ;
              return -0x7200;
            }

          }

        }
        return 0;
      }
}

// ssl_parse_renegotiation_info
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 1070
static signed int ssl_parse_renegotiation_info(mbedtls_ssl_context *ssl, const unsigned char *buf, size_t len)
{
  _Bool tmp_if_expr;
  if(!(len == 1ull))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = (signed int)buf[0ll] != 0x0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr)
  {
    while((_Bool)0)
      ;
    mbedtls_ssl_send_alert_message(ssl, 2, 40);
    return -0x7980;
  }

  else
  {
    ssl->secure_renegotiation = 1;
    return 0;
  }
}

// ssl_parse_server_ecdh_params
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 2012
static signed int ssl_parse_server_ecdh_params(mbedtls_ssl_context *ssl, unsigned char **p, unsigned char *end)
{
  signed int ret=-0x7080;
  ret=mbedtls_ecdh_read_params(&ssl->handshake->ecdh_ctx, (const unsigned char **)p, end);
  if(!(ret == 0))
  {
    while((_Bool)0)
      ;
    return ret;
  }

  else
  {
    signed int return_value_ssl_check_server_ecdh_params=ssl_check_server_ecdh_params(ssl);
    if(!(return_value_ssl_check_server_ecdh_params == 0))
    {
      while((_Bool)0)
        ;
      return -0x7B00;
    }

    else
      return ret;
  }
}

// ssl_parse_server_hello
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 1442
static signed int ssl_parse_server_hello(mbedtls_ssl_context *ssl)
{
  signed int ret;
  signed int i;
  size_t n;
  size_t ext_len;
  unsigned char *buf;
  unsigned char *ext;
  unsigned char comp;
  signed int handshake_failure=0;
  const mbedtls_ssl_ciphersuite_t *suite_info;
  while((_Bool)0)
    ;
  buf = ssl->in_msg;
  ret=mbedtls_ssl_read_record(ssl);
  size_t return_value_mbedtls_ssl_hs_hdr_len$1;
  size_t return_value_mbedtls_ssl_hs_hdr_len$2;
  signed int return_value_memcmp;
  if(!(ret == 0))
  {
    while((_Bool)0)
      ;
    return ret;
  }

  else
    if(!(ssl->in_msgtype == 22))
    {
      while((_Bool)0)
        ;
      mbedtls_ssl_send_alert_message(ssl, 2, 10);
      return -0x7700;
    }

    else
    {
      size_t return_value_mbedtls_ssl_hs_hdr_len=mbedtls_ssl_hs_hdr_len(ssl);
      _Bool tmp_if_expr;
      if(!(ssl->in_hslen >= 38ull + return_value_mbedtls_ssl_hs_hdr_len))
        tmp_if_expr = (_Bool)1;

      else
        tmp_if_expr = (signed int)buf[0ll] != 2 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr)
      {
        while((_Bool)0)
          ;
        mbedtls_ssl_send_alert_message(ssl, 2, 50);
        return -0x7980;
      }

      else
      {
        size_t return_value_mbedtls_ssl_hs_hdr_len$0=mbedtls_ssl_hs_hdr_len(ssl);
        buf = buf + (signed long long int)return_value_mbedtls_ssl_hs_hdr_len$0;
        while((_Bool)0)
          ;
        mbedtls_ssl_read_version(&ssl->major_ver, &ssl->minor_ver, (signed int)ssl->conf->transport, buf + 0ll);
        _Bool tmp_if_expr$0;
        if(!(ssl->major_ver >= (signed int)ssl->conf->min_major_ver))
          tmp_if_expr$0 = (_Bool)1;

        else
          tmp_if_expr$0 = ssl->minor_ver < (signed int)ssl->conf->min_minor_ver ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr$1;
        if(tmp_if_expr$0)
          tmp_if_expr$1 = (_Bool)1;

        else
          tmp_if_expr$1 = ssl->major_ver > (signed int)ssl->conf->max_major_ver ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr$2;
        if(tmp_if_expr$1)
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = ssl->minor_ver > (signed int)ssl->conf->max_minor_ver ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$2)
        {
          while((_Bool)0)
            ;
          mbedtls_ssl_send_alert_message(ssl, 2, 70);
          return -0x6E80;
        }

        else
        {
          while((_Bool)0)
            ;
          memcpy((void *)(ssl->handshake->randbytes + 32ll), (const void *)(buf + 2ll), 32ull);
          n = (size_t)buf[34ll];
          while((_Bool)0)
            ;
          if(n >= 33ull)
          {
            while((_Bool)0)
              ;
            mbedtls_ssl_send_alert_message(ssl, 2, 50);
            return -0x7980;
          }

          else
          {
            size_t return_value_mbedtls_ssl_hs_hdr_len$3=mbedtls_ssl_hs_hdr_len(ssl);
            if(!(39ull + return_value_mbedtls_ssl_hs_hdr_len$3 + n >= ssl->in_hslen))
            {
              ext_len = (size_t)((signed int)buf[(signed long long int)(38ull + n)] << 8 | (signed int)buf[(signed long long int)(39ull + n)]);
              _Bool tmp_if_expr$3;
              if(ext_len >= 1ull && !(ext_len >= 4ull))
                tmp_if_expr$3 = (_Bool)1;

              else
              {
                return_value_mbedtls_ssl_hs_hdr_len$1=mbedtls_ssl_hs_hdr_len(ssl);
                tmp_if_expr$3 = ssl->in_hslen != return_value_mbedtls_ssl_hs_hdr_len$1 + 40ull + n + ext_len ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$3)
              {
                while((_Bool)0)
                  ;
                mbedtls_ssl_send_alert_message(ssl, 2, 50);
                return -0x7980;
              }

            }

            else
            {
              return_value_mbedtls_ssl_hs_hdr_len$2=mbedtls_ssl_hs_hdr_len(ssl);
              if(ssl->in_hslen == 38ull + return_value_mbedtls_ssl_hs_hdr_len$2 + n)
                ext_len = 0ull;

              else
              {
                while((_Bool)0)
                  ;
                mbedtls_ssl_send_alert_message(ssl, 2, 50);
                return -0x7980;
              }
            }
            i = (signed int)buf[(signed long long int)(35ull + n)] << 8 | (signed int)buf[(signed long long int)(36ull + n)];
            comp = buf[(signed long long int)(37ull + n)];
            if(!((signed int)comp == 0))
            {
              while((_Bool)0)
                ;
              mbedtls_ssl_send_alert_message(ssl, 2, 47);
              return -0x7080;
            }

            else
            {
              ssl->transform_negotiate->ciphersuite_info=mbedtls_ssl_ciphersuite_from_id(i);
              if(ssl->transform_negotiate->ciphersuite_info == ((const mbedtls_ssl_ciphersuite_t *)NULL))
              {
                while((_Bool)0)
                  ;
                mbedtls_ssl_send_alert_message(ssl, 2, 80);
                return -0x7100;
              }

              else
              {
                mbedtls_ssl_optimize_checksum(ssl, ssl->transform_negotiate->ciphersuite_info);
                while((_Bool)0)
                  ;
                while((_Bool)0)
                  ;
                _Bool tmp_if_expr$4;
                if(ssl->handshake->resume == 0 || n == 0ull)
                  tmp_if_expr$4 = (_Bool)1;

                else
                  tmp_if_expr$4 = ssl->session_negotiate->ciphersuite != i ? (_Bool)1 : (_Bool)0;
                _Bool tmp_if_expr$5;
                if(tmp_if_expr$4)
                  tmp_if_expr$5 = (_Bool)1;

                else
                  tmp_if_expr$5 = ssl->session_negotiate->compression != (signed int)comp ? (_Bool)1 : (_Bool)0;
                _Bool tmp_if_expr$6;
                if(tmp_if_expr$5)
                  tmp_if_expr$6 = (_Bool)1;

                else
                  tmp_if_expr$6 = ssl->session_negotiate->id_len != n ? (_Bool)1 : (_Bool)0;
                _Bool tmp_if_expr$7;
                if(tmp_if_expr$6)
                  tmp_if_expr$7 = (_Bool)1;

                else
                {
                  return_value_memcmp=memcmp((const void *)ssl->session_negotiate->id, (const void *)(buf + 35ll), n);
                  tmp_if_expr$7 = return_value_memcmp != 0 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$7)
                {
                  ssl->state = ssl->state + 1;
                  ssl->handshake->resume = 0;
                  ssl->session_negotiate->ciphersuite = i;
                  ssl->session_negotiate->compression = (signed int)comp;
                  ssl->session_negotiate->id_len = n;
                  memcpy((void *)ssl->session_negotiate->id, (const void *)(buf + 35ll), n);
                }

                else
                {
                  ssl->state = 12;
                  ret=mbedtls_ssl_derive_keys(ssl);
                  if(!(ret == 0))
                  {
                    while((_Bool)0)
                      ;
                    mbedtls_ssl_send_alert_message(ssl, 2, 80);
                    return ret;
                  }

                }
                while((_Bool)0)
                  ;
                while((_Bool)0)
                  ;
                while((_Bool)0)
                  ;
                suite_info=mbedtls_ssl_ciphersuite_from_id(ssl->session_negotiate->ciphersuite);
                if(suite_info == ((const mbedtls_ssl_ciphersuite_t *)NULL))
                {
                  while((_Bool)0)
                    ;
                  mbedtls_ssl_send_alert_message(ssl, 2, 47);
                  return -0x7980;
                }

                else
                {
                  while((_Bool)0)
                    ;
                  i = 0;
                  while((_Bool)1)
                  {
                    if(ssl->conf->ciphersuite_list[(signed long long int)ssl->minor_ver][(signed long long int)i] == 0)
                    {
                      while((_Bool)0)
                        ;
                      mbedtls_ssl_send_alert_message(ssl, 2, 47);
                      return -0x7980;
                    }

                    signed int tmp_post=i;
                    i = i + 1;
                    if(ssl->conf->ciphersuite_list[(signed long long int)ssl->minor_ver][(signed long long int)tmp_post] == ssl->session_negotiate->ciphersuite)
                      break;

                  }
                  if(!((signed int)comp == 0))
                  {
                    while((_Bool)0)
                      ;
                    mbedtls_ssl_send_alert_message(ssl, 2, 47);
                    return -0x7980;
                  }

                  else
                  {
                    ssl->session_negotiate->compression = (signed int)comp;
                    ext = buf + 40ll + (signed long long int)n;
                    while((_Bool)0)
                      ;
                    while(!(ext_len == 0ull))
                    {
                      unsigned int ext_id=(unsigned int)((signed int)ext[0ll] << 8 | (signed int)ext[1ll]);
                      unsigned int ext_size=(unsigned int)((signed int)ext[2ll] << 8 | (signed int)ext[3ll]);
                      if(!(ext_len >= (unsigned long long int)(4u + ext_size)))
                      {
                        while((_Bool)0)
                          ;
                        mbedtls_ssl_send_alert_message(ssl, 2, 50);
                        return -0x7980;
                      }

                      switch(ext_id)
                      {
                        case 65281u:
                        {
                          while((_Bool)0)
                            ;
                          ret=ssl_parse_renegotiation_info(ssl, ext + 4ll, (size_t)ext_size);
                          if(!(ret == 0))
                            return ret;

                          break;
                        }
                        case 1u:
                        {
                          while((_Bool)0)
                            ;
                          ret=ssl_parse_max_fragment_length_ext(ssl, ext + 4ll, (size_t)ext_size);
                          if(!(ret == 0))
                            return ret;

                          break;
                        }
                        case 22u:
                        {
                          while((_Bool)0)
                            ;
                          ret=ssl_parse_encrypt_then_mac_ext(ssl, ext + 4ll, (size_t)ext_size);
                          if(!(ret == 0))
                            return ret;

                          break;
                        }
                        case 23u:
                        {
                          while((_Bool)0)
                            ;
                          ret=ssl_parse_extended_ms_ext(ssl, ext + 4ll, (size_t)ext_size);
                          if(!(ret == 0))
                            return ret;

                          break;
                        }
                        case 11u:
                        {
                          while((_Bool)0)
                            ;
                          ret=ssl_parse_supported_point_formats_ext(ssl, ext + 4ll, (size_t)ext_size);
                          if(!(ret == 0))
                            return ret;

                          break;
                        }
                        case 16u:
                        {
                          while((_Bool)0)
                            ;
                          ret=ssl_parse_alpn_ext(ssl, ext + 4ll, (size_t)ext_size);
                          if(!(ret == 0))
                            return ret;

                          break;
                        }
                        default:
                          while((_Bool)0)
                            ;
                      }
                      ext_len = ext_len - (size_t)(4u + ext_size);
                      ext = ext + (signed long long int)(4u + ext_size);
                      if(ext_len >= 1ull && !(ext_len >= 4ull))
                      {
                        while((_Bool)0)
                          ;
                        return -0x7980;
                      }

                    }
                    if(ssl->secure_renegotiation == 0)
                    {
                      if((signed int)ssl->conf->allow_legacy_renegotiation == 2)
                      {
                        while((_Bool)0)
                          ;
                        handshake_failure = 1;
                      }

                    }

                    if(handshake_failure == 1)
                    {
                      mbedtls_ssl_send_alert_message(ssl, 2, 40);
                      return -0x7980;
                    }

                    else
                    {
                      while((_Bool)0)
                        ;
                      return 0;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
}

// ssl_parse_server_hello_done
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 2736
static signed int ssl_parse_server_hello_done(mbedtls_ssl_context *ssl)
{
  signed int ret;
  while((_Bool)0)
    ;
  ret=mbedtls_ssl_read_record(ssl);
  if(!(ret == 0))
  {
    while((_Bool)0)
      ;
    return ret;
  }

  else
    if(!(ssl->in_msgtype == 22))
    {
      while((_Bool)0)
        ;
      return -0x7700;
    }

    else
    {
      size_t return_value_mbedtls_ssl_hs_hdr_len=mbedtls_ssl_hs_hdr_len(ssl);
      _Bool tmp_if_expr;
      if(!(ssl->in_hslen == return_value_mbedtls_ssl_hs_hdr_len))
        tmp_if_expr = (_Bool)1;

      else
        tmp_if_expr = (signed int)ssl->in_msg[0ll] != 14 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr)
      {
        while((_Bool)0)
          ;
        mbedtls_ssl_send_alert_message(ssl, 2, 50);
        return -0x7B80;
      }

      else
      {
        ssl->state = ssl->state + 1;
        while((_Bool)0)
          ;
        return 0;
      }
    }
}

// ssl_parse_server_key_exchange
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 2271
static signed int ssl_parse_server_key_exchange(mbedtls_ssl_context *ssl)
{
  signed int ret;
  const mbedtls_ssl_ciphersuite_t *ciphersuite_info=ssl->transform_negotiate->ciphersuite_info;
  unsigned char *p=((unsigned char *)NULL);
  unsigned char *end=((unsigned char *)NULL);
  while((_Bool)0)
    ;
  ret=mbedtls_ssl_read_record(ssl);
  if(!(ret == 0))
  {
    while((_Bool)0)
      ;
    return ret;
  }

  else
    if(!(ssl->in_msgtype == 22))
    {
      while((_Bool)0)
        ;
      mbedtls_ssl_send_alert_message(ssl, 2, 10);
      return -0x7700;
    }

    else
      if(!((signed int)*ssl->in_msg == 12))
      {
        _Bool tmp_if_expr;
        if((signed int)ciphersuite_info->key_exchange == 5)
          tmp_if_expr = (_Bool)1;

        else
          tmp_if_expr = (signed int)ciphersuite_info->key_exchange == 7 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr)
        {
          ssl->keep_current_message = 1;
          goto exit;
        }

        while((_Bool)0)
          ;
        mbedtls_ssl_send_alert_message(ssl, 2, 10);
        return -0x7700;
      }

      else
      {
        size_t return_value_mbedtls_ssl_hs_hdr_len=mbedtls_ssl_hs_hdr_len(ssl);
        p = ssl->in_msg + (signed long long int)return_value_mbedtls_ssl_hs_hdr_len;
        end = ssl->in_msg + (signed long long int)ssl->in_hslen;
        while((_Bool)0)
          ;
        _Bool tmp_if_expr$0;
        if((signed int)ciphersuite_info->key_exchange == 3)
          tmp_if_expr$0 = (_Bool)1;

        else
          tmp_if_expr$0 = (signed int)ciphersuite_info->key_exchange == 8 ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr$1;
        if(tmp_if_expr$0)
          tmp_if_expr$1 = (_Bool)1;

        else
          tmp_if_expr$1 = (signed int)ciphersuite_info->key_exchange == 4 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$1)
        {
          signed int return_value_ssl_parse_server_ecdh_params=ssl_parse_server_ecdh_params(ssl, &p, end);
          if(!(return_value_ssl_parse_server_ecdh_params == 0))
          {
            while((_Bool)0)
              ;
            mbedtls_ssl_send_alert_message(ssl, 2, 47);
            return -0x7B00;
          }

        }

        else
        {
          while((_Bool)0)
            ;
          return -0x6C00;
        }
        signed int return_value_mbedtls_ssl_ciphersuite_uses_server_signature=mbedtls_ssl_ciphersuite_uses_server_signature(ciphersuite_info);
        if(!(return_value_mbedtls_ssl_ciphersuite_uses_server_signature == 0))
        {
          size_t sig_len;
          size_t hashlen;
          unsigned char hash[64ll];
          mbedtls_md_type_t md_alg=/*enum*/MBEDTLS_MD_NONE;
          mbedtls_pk_type_t pk_alg=/*enum*/MBEDTLS_PK_NONE;
          unsigned char *params;
          size_t return_value_mbedtls_ssl_hs_hdr_len$0=mbedtls_ssl_hs_hdr_len(ssl);
          params = ssl->in_msg + (signed long long int)return_value_mbedtls_ssl_hs_hdr_len$0;
          size_t params_len=(size_t)(p - params);
          if(ssl->minor_ver == 3)
          {
            signed int return_value_ssl_parse_signature_algorithm=ssl_parse_signature_algorithm(ssl, &p, end, &md_alg, &pk_alg);
            if(!(return_value_ssl_parse_signature_algorithm == 0))
            {
              while((_Bool)0)
                ;
              mbedtls_ssl_send_alert_message(ssl, 2, 47);
              return -0x7B00;
            }

            mbedtls_pk_type_t return_value_mbedtls_ssl_get_ciphersuite_sig_pk_alg=mbedtls_ssl_get_ciphersuite_sig_pk_alg(ciphersuite_info);
            if(!(pk_alg == return_value_mbedtls_ssl_get_ciphersuite_sig_pk_alg))
            {
              while((_Bool)0)
                ;
              mbedtls_ssl_send_alert_message(ssl, 2, 47);
              return -0x7B00;
            }

          }

          else
          {
            while((_Bool)0)
              ;
            return -0x6C00;
          }
          if(!(end + -2ll >= p))
          {
            while((_Bool)0)
              ;
            mbedtls_ssl_send_alert_message(ssl, 2, 50);
            return -0x7B00;
          }

          sig_len = (size_t)((signed int)p[0ll] << 8 | (signed int)p[1ll]);
          p = p + 2ll;
          if(!(p == end + -((signed long long int)sig_len)))
          {
            while((_Bool)0)
              ;
            mbedtls_ssl_send_alert_message(ssl, 2, 50);
            return -0x7B00;
          }

          while((_Bool)0)
            ;
          if(!((signed int)md_alg == 0))
          {
            hashlen = 0ull;
            ret=mbedtls_ssl_get_key_exchange_md_tls1_2(ssl, hash, params, params_len, md_alg);
            if(!(ret == 0))
              return ret;

          }

          else
          {
            while((_Bool)0)
              ;
            return -0x6C00;
          }
          while((_Bool)0)
            ;
          if(ssl->session_negotiate->peer_cert == ((mbedtls_x509_crt *)NULL))
          {
            while((_Bool)0)
              ;
            mbedtls_ssl_send_alert_message(ssl, 2, 40);
            return -0x7700;
          }

          signed int return_value_mbedtls_pk_can_do=mbedtls_pk_can_do(&ssl->session_negotiate->peer_cert->pk, pk_alg);
          if(return_value_mbedtls_pk_can_do == 0)
          {
            while((_Bool)0)
              ;
            mbedtls_ssl_send_alert_message(ssl, 2, 40);
            return -0x6D00;
          }

          ret=mbedtls_pk_verify(&ssl->session_negotiate->peer_cert->pk, md_alg, hash, hashlen, p, sig_len);
          if(!(ret == 0))
          {
            mbedtls_ssl_send_alert_message(ssl, 2, 51);
            while((_Bool)0)
              ;
            return ret;
          }

        }


      exit:
        ;
        ssl->state = ssl->state + 1;
        while((_Bool)0)
          ;
        return 0;
      }
}

// ssl_parse_signature_algorithm
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 2169
static signed int ssl_parse_signature_algorithm(mbedtls_ssl_context *ssl, unsigned char **p, unsigned char *end, mbedtls_md_type_t *md_alg, mbedtls_pk_type_t *pk_alg)
{
  (void)ssl;
  *md_alg = /*enum*/MBEDTLS_MD_NONE;
  *pk_alg = /*enum*/MBEDTLS_PK_NONE;
  if(!(ssl->minor_ver == 3))
    return 0;

  else
    if(!(end >= *p + 2ll))
      return -0x7B00;

    else
    {
      *md_alg=mbedtls_ssl_md_alg_from_hash((*p)[0ll]);
      if((signed int)*md_alg == 0)
      {
        while((_Bool)0)
          ;
        return -0x7B00;
      }

      else
      {
        *pk_alg=mbedtls_ssl_pk_alg_from_sig((*p)[1ll]);
        if((signed int)*pk_alg == 0)
        {
          while((_Bool)0)
            ;
          return -0x7B00;
        }

        else
        {
          signed int return_value_mbedtls_ssl_check_sig_hash=mbedtls_ssl_check_sig_hash(ssl, *md_alg);
          if(!(return_value_mbedtls_ssl_check_sig_hash == 0))
          {
            while((_Bool)0)
              ;
            return -0x7B00;
          }

          else
          {
            while((_Bool)0)
              ;
            while((_Bool)0)
              ;
            *p = *p + 2ll;
            return 0;
          }
        }
      }
    }
}

// ssl_parse_supported_point_formats_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 1222
static signed int ssl_parse_supported_point_formats_ext(mbedtls_ssl_context *ssl, const unsigned char *buf, size_t len)
{
  size_t list_size;
  const unsigned char *p;
  list_size = (size_t)buf[0ll];
  if(!(1ull + list_size == len))
  {
    while((_Bool)0)
      ;
    mbedtls_ssl_send_alert_message(ssl, 2, 50);
    return -0x7980;
  }

  else
  {
    p = buf + 1ll;
    while(list_size >= 1ull)
    {
      _Bool tmp_if_expr;
      if((signed int)*p == 0)
        tmp_if_expr = (_Bool)1;

      else
        tmp_if_expr = (signed int)p[0ll] == 1 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr)
      {
        ssl->handshake->ecdh_ctx.point_format = (signed int)p[0ll];
        while((_Bool)0)
          ;
        return 0;
      }

      list_size = list_size - 1ull;
      p = p + 1ll;
    }
    while((_Bool)0)
      ;
    mbedtls_ssl_send_alert_message(ssl, 2, 40);
    return -0x7980;
  }
}

// ssl_prepare_record_content
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 3732
static signed int ssl_prepare_record_content(mbedtls_ssl_context *ssl)
{
  signed int ret;
  signed int done=0;
  while((_Bool)0)
    ;
  if(done == 0)
  {
    if(!(ssl->transform_in == ((mbedtls_ssl_transform *)NULL)))
    {
      ret=ssl_decrypt_buf(ssl);
      if(!(ret == 0))
      {
        while((_Bool)0)
          ;
        return ret;
      }

      while((_Bool)0)
        ;
      if(ssl->in_msglen >= 8193ull)
      {
        while((_Bool)0)
          ;
        return -0x7200;
      }

    }

  }

  return 0;
}

// ssl_session_copy
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 159
static signed int ssl_session_copy(mbedtls_ssl_session *dst, const mbedtls_ssl_session *src)
{
  mbedtls_ssl_session_free(dst);
  memcpy((void *)dst, (const void *)src, sizeof(mbedtls_ssl_session) /*120ull*/ );
  if(!(src->peer_cert == ((mbedtls_x509_crt *)NULL)))
  {
    signed int ret;
    void *return_value=mbedtls_calloc(1ull, sizeof(mbedtls_x509_crt) /*552ull*/ );
    dst->peer_cert = (mbedtls_x509_crt *)return_value;
    if(dst->peer_cert == ((mbedtls_x509_crt *)NULL))
      return -0x7F00;

    mbedtls_x509_crt_init(dst->peer_cert);
    ret=mbedtls_x509_crt_parse_der(dst->peer_cert, src->peer_cert->raw.p, src->peer_cert->raw.len);
    if(!(ret == 0))
    {
      mbedtls_free((void *)dst->peer_cert);
      dst->peer_cert = ((mbedtls_x509_crt *)NULL);
      return ret;
    }

  }

  return 0;
}

// ssl_session_reset_int
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5724
static signed int ssl_session_reset_int(mbedtls_ssl_context *ssl, signed int partial)
{
  signed int ret;
  ssl->state = 0;
  ssl_set_timer(ssl, 0u);
  ssl->secure_renegotiation = 0;
  ssl->in_offt = ((unsigned char *)NULL);
  ssl->in_msg = ssl->in_buf + 13ll;
  ssl->in_msgtype = 0;
  ssl->in_msglen = 0ull;
  if(partial == 0)
    ssl->in_left = 0ull;

  ssl->in_hslen = 0ull;
  ssl->nb_zero = 0;
  ssl->keep_current_message = 0;
  ssl->out_msg = ssl->out_buf + 13ll;
  ssl->out_msgtype = 0;
  ssl->out_msglen = 0ull;
  ssl->out_left = 0ull;
  ssl->transform_in = ((mbedtls_ssl_transform *)NULL);
  ssl->transform_out = ((mbedtls_ssl_transform *)NULL);
  memset((void *)ssl->out_buf, 0, (size_t)(13 + 8192 + 0 + 16 + 32 + 256));
  if(partial == 0)
    memset((void *)ssl->in_buf, 0, (size_t)(13 + 8192 + 0 + 16 + 32 + 256));

  if(!(ssl->transform == ((mbedtls_ssl_transform *)NULL)))
  {
    mbedtls_ssl_transform_free(ssl->transform);
    mbedtls_free((void *)ssl->transform);
    ssl->transform = ((mbedtls_ssl_transform *)NULL);
  }

  if(!(ssl->session == ((mbedtls_ssl_session *)NULL)))
  {
    mbedtls_ssl_session_free(ssl->session);
    mbedtls_free((void *)ssl->session);
    ssl->session = ((mbedtls_ssl_session *)NULL);
  }

  ssl->alpn_chosen = ((const char *)NULL);
  ret=ssl_handshake_init(ssl);
  if(!(ret == 0))
    return ret;

  else
    return 0;
}

// ssl_set_timer
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 77
static void ssl_set_timer(mbedtls_ssl_context *ssl, uint32_t millisecs)
{
  if(!(ssl->f_set_timer == ((mbedtls_ssl_set_timer_t (*))NULL)))
  {
    while((_Bool)0)
      ;
    ssl->f_set_timer(ssl->p_timer, millisecs / 4u, millisecs);
  }

}

// ssl_transform_init
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 5535
static void ssl_transform_init(mbedtls_ssl_transform *transform)
{
  memset((void *)transform, 0, sizeof(mbedtls_ssl_transform) /*304ull*/ );
  mbedtls_cipher_init(&transform->cipher_ctx_enc);
  mbedtls_cipher_init(&transform->cipher_ctx_dec);
  mbedtls_md_init(&transform->md_ctx_enc);
  mbedtls_md_init(&transform->md_ctx_dec);
}

// ssl_update_checksum_sha256
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 4937
static void ssl_update_checksum_sha256(mbedtls_ssl_context *ssl, const unsigned char *buf, size_t len)
{
  mbedtls_sha256_update_ret(&ssl->handshake->fin_sha256, buf, len);
}

// ssl_update_checksum_start
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 4907
static void ssl_update_checksum_start(mbedtls_ssl_context *ssl, const unsigned char *buf, size_t len)
{
  mbedtls_sha256_update_ret(&ssl->handshake->fin_sha256, buf, len);
}

// ssl_write_alpn_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 618
static void ssl_write_alpn_ext(mbedtls_ssl_context *ssl, unsigned char *buf, size_t *olen)
{
  unsigned char *p=buf;
  const unsigned char *end=ssl->out_msg + 8192ll;
  size_t alpnlen=0ull;
  const char **cur;
  *olen = 0ull;
  size_t return_value_strlen;
  if(!(ssl->conf->alpn_list == ((const char **)NULL)))
  {
    while((_Bool)0)
      ;
    cur = ssl->conf->alpn_list;
    for( ; !(*cur == ((const char *)NULL)); cur = cur + 1ll)
    {
      return_value_strlen=strlen(*cur);
      alpnlen = alpnlen + (size_t)((signed int)(unsigned char)(return_value_strlen & 255ull) + 1);
    }
    if(!(end >= p) || !((size_t)(end - p) >= 6ull + alpnlen))
      while((_Bool)0)
        ;

    else
    {
      unsigned char *tmp_post=p;
      p = p + 1ll;
      *tmp_post = (unsigned char)(16 >> 8 & 0xFF);
      unsigned char *tmp_post$0=p;
      p = p + 1ll;
      *tmp_post$0 = (unsigned char)(16 & 0xFF);
      p = p + 4ll;
      cur = ssl->conf->alpn_list;
      for( ; !(*cur == ((const char *)NULL)); cur = cur + 1ll)
      {
        size_t return_value_strlen$0=strlen(*cur);
        *p = (unsigned char)(return_value_strlen$0 & 255ull);
        memcpy((void *)(p + 1ll), (const void *)*cur, (size_t)*p);
        p = p + (signed long long int)(1 + (signed int)*p);
      }
      *olen = (size_t)(p - buf);
      buf[4ll] = (unsigned char)(*olen - 6ull >> 8 & 255ull);
      buf[5ll] = (unsigned char)(*olen - 6ull & 255ull);
      buf[2ll] = (unsigned char)(*olen - 4ull >> 8 & 255ull);
      buf[3ll] = (unsigned char)(*olen - 4ull & 255ull);
    }
  }

}

// ssl_write_certificate_verify
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 3064
static signed int ssl_write_certificate_verify(mbedtls_ssl_context *ssl)
{
  signed int ret=-0x7080;
  const mbedtls_ssl_ciphersuite_t *ciphersuite_info=ssl->transform_negotiate->ciphersuite_info;
  size_t n=0ull;
  size_t offset=0ull;
  unsigned char hash[48ll];
  unsigned char *hash_start=hash;
  mbedtls_md_type_t md_alg=/*enum*/MBEDTLS_MD_NONE;
  unsigned int hashlen;
  while((_Bool)0)
    ;
  ret=mbedtls_ssl_derive_keys(ssl);
  mbedtls_x509_crt *return_value_mbedtls_ssl_own_cert;
  if(!(ret == 0))
  {
    while((_Bool)0)
      ;
    return ret;
  }

  else
  {
    _Bool tmp_if_expr;
    if((signed int)ciphersuite_info->key_exchange == 5)
      tmp_if_expr = (_Bool)1;

    else
      tmp_if_expr = (signed int)ciphersuite_info->key_exchange == 7 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$0;
    if(tmp_if_expr)
      tmp_if_expr$0 = (_Bool)1;

    else
      tmp_if_expr$0 = (signed int)ciphersuite_info->key_exchange == 8 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$1;
    if(tmp_if_expr$0)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)ciphersuite_info->key_exchange == 6 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$2;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)ciphersuite_info->key_exchange == 11 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      while((_Bool)0)
        ;
      ssl->state = ssl->state + 1;
      return 0;
    }

    else
    {
      _Bool tmp_if_expr$3;
      if(ssl->client_auth == 0)
        tmp_if_expr$3 = (_Bool)1;

      else
      {
        return_value_mbedtls_ssl_own_cert=mbedtls_ssl_own_cert(ssl);
        tmp_if_expr$3 = return_value_mbedtls_ssl_own_cert == ((mbedtls_x509_crt *)NULL) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$3)
      {
        while((_Bool)0)
          ;
        ssl->state = ssl->state + 1;
        return 0;
      }

      else
      {
        mbedtls_pk_context *return_value_mbedtls_ssl_own_key=mbedtls_ssl_own_key(ssl);
        if(return_value_mbedtls_ssl_own_key == ((mbedtls_pk_context *)NULL))
        {
          while((_Bool)0)
            ;
          return -0x7600;
        }

        else
        {
          ssl->handshake->calc_verify(ssl, hash);
          if(ssl->minor_ver == 3)
          {
            if((signed int)ssl->transform_negotiate->ciphersuite_info->mac == 7)
            {
              md_alg = /*enum*/MBEDTLS_MD_SHA384;
              ssl->out_msg[4ll] = 5;
            }

            else
            {
              md_alg = /*enum*/MBEDTLS_MD_SHA256;
              ssl->out_msg[4ll] = 4;
            }
            mbedtls_pk_context *return_value_mbedtls_ssl_own_key$0=mbedtls_ssl_own_key(ssl);
            ssl->out_msg[5ll]=mbedtls_ssl_sig_from_pk(return_value_mbedtls_ssl_own_key$0);
            hashlen = 0u;
            offset = 2ull;
          }

          else
            return -0x6C00;
          mbedtls_pk_context *return_value_mbedtls_ssl_own_key$1=mbedtls_ssl_own_key(ssl);
          ret=mbedtls_pk_sign(return_value_mbedtls_ssl_own_key$1, md_alg, hash_start, (size_t)hashlen, ssl->out_msg + 6ll + (signed long long int)offset, &n, ssl->conf->f_rng, ssl->conf->p_rng);
          if(!(ret == 0))
            return ret;

          else
          {
            ssl->out_msg[(signed long long int)(4ull + offset)] = (unsigned char)(n >> 8);
            ssl->out_msg[(signed long long int)(5ull + offset)] = (unsigned char)n;
            ssl->out_msglen = 6ull + n + offset;
            ssl->out_msgtype = 22;
            ssl->out_msg[0ll] = 15;
            ssl->state = ssl->state + 1;
            ret=mbedtls_ssl_write_record(ssl);
            if(!(ret == 0))
              return ret;

            else
              return ret;
          }
        }
      }
    }
  }
}

// ssl_write_client_hello
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 720
static signed int ssl_write_client_hello(mbedtls_ssl_context *ssl)
{
  signed int ret;
  size_t i;
  size_t n;
  size_t olen;
  size_t ext_len=0ull;
  unsigned char *buf;
  unsigned char *p;
  unsigned char *q;
  unsigned char offer_compress;
  const signed int *ciphersuites;
  const mbedtls_ssl_ciphersuite_t *ciphersuite_info;
  while((_Bool)0)
    ;
  unsigned char *tmp_post$0;
  if(ssl->conf->f_rng == ((signed int (*)(void *, unsigned char *, size_t))NULL))
  {
    while((_Bool)0)
      ;
    return -0x7400;
  }

  else
  {
    ssl->major_ver = (signed int)ssl->conf->min_major_ver;
    ssl->minor_ver = (signed int)ssl->conf->min_minor_ver;
    if((signed int)ssl->conf->max_major_ver == 0)
    {
      while((_Bool)0)
        ;
      return -0x7100;
    }

    else
    {
      buf = ssl->out_msg;
      p = buf + 4ll;
      mbedtls_ssl_write_version((signed int)ssl->conf->max_major_ver, (signed int)ssl->conf->max_minor_ver, (signed int)ssl->conf->transport, p);
      p = p + 2ll;
      while((_Bool)0)
        ;
      ret=ssl_generate_random(ssl);
      if(!(ret == 0))
      {
        while((_Bool)0)
          ;
        return ret;
      }

      else
      {
        memcpy((void *)p, (const void *)ssl->handshake->randbytes, 32ull);
        while((_Bool)0)
          ;
        p = p + 32ll;
        n = ssl->session_negotiate->id_len;
        _Bool tmp_if_expr;
        if(n >= 33ull || !(n >= 16ull))
          tmp_if_expr = (_Bool)1;

        else
          tmp_if_expr = ssl->handshake->resume == 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr)
          n = 0ull;

        unsigned char *tmp_post=p;
        p = p + 1ll;
        *tmp_post = (unsigned char)n;
        i = 0ull;
        for( ; !(i >= n); i = i + 1ull)
        {
          tmp_post$0 = p;
          p = p + 1ll;
          *tmp_post$0 = ssl->session_negotiate->id[(signed long long int)i];
        }
        while((_Bool)0)
          ;
        while((_Bool)0)
          ;
        ciphersuites = ssl->conf->ciphersuite_list[(signed long long int)ssl->minor_ver];
        n = 0ull;
        q = p;
        p = p + 2ll;
        i = 0ull;
        for( ; !(ciphersuites[(signed long long int)i] == 0); i = i + 1ull)
        {
          ciphersuite_info=mbedtls_ssl_ciphersuite_from_id(ciphersuites[(signed long long int)i]);
          if(!(ciphersuite_info == ((const mbedtls_ssl_ciphersuite_t *)NULL)))
          {
            _Bool tmp_if_expr$0;
            if(!((signed int)ssl->conf->max_minor_ver >= ciphersuite_info->min_minor_ver))
              tmp_if_expr$0 = (_Bool)1;

            else
              tmp_if_expr$0 = ciphersuite_info->max_minor_ver < (signed int)ssl->conf->min_minor_ver ? (_Bool)1 : (_Bool)0;
            if(!tmp_if_expr$0)
            {
              while((_Bool)0)
                ;
              n = n + 1ull;
              unsigned char *tmp_post$1=p;
              p = p + 1ll;
              *tmp_post$1 = (unsigned char)(ciphersuites[(signed long long int)i] >> 8);
              unsigned char *tmp_post$2=p;
              p = p + 1ll;
              *tmp_post$2 = (unsigned char)ciphersuites[(signed long long int)i];
            }

          }

        }
        while((_Bool)0)
          ;
        while((_Bool)0)
          ;
        unsigned char *tmp_post$3=p;
        p = p + 1ll;
        *tmp_post$3 = (unsigned char)(0xFF >> 8);
        unsigned char *tmp_post$4=p;
        p = p + 1ll;
        *tmp_post$4 = 255;
        n = n + 1ull;
        unsigned char *tmp_post$5=q;
        q = q + 1ll;
        *tmp_post$5 = (unsigned char)(n >> 7);
        unsigned char *tmp_post$6=q;
        q = q + 1ll;
        *tmp_post$6 = (unsigned char)(n << 1);
        offer_compress = 0;
        if(!(offer_compress == 0))
        {
          while((_Bool)0)
            ;
          while((_Bool)0)
            ;
          unsigned char *tmp_post$7=p;
          p = p + 1ll;
          *tmp_post$7 = 2;
          unsigned char *tmp_post$8=p;
          p = p + 1ll;
          *tmp_post$8 = 1;
          unsigned char *tmp_post$9=p;
          p = p + 1ll;
          *tmp_post$9 = 0;
        }

        else
        {
          while((_Bool)0)
            ;
          while((_Bool)0)
            ;
          unsigned char *tmp_post$10=p;
          p = p + 1ll;
          *tmp_post$10 = 1;
          unsigned char *tmp_post$11=p;
          p = p + 1ll;
          *tmp_post$11 = 0;
        }
        ssl_write_hostname_ext(ssl, p + 2ll + (signed long long int)ext_len, &olen);
        ext_len = ext_len + olen;
        ssl_write_signature_algorithms_ext(ssl, p + 2ll + (signed long long int)ext_len, &olen);
        ext_len = ext_len + olen;
        ssl_write_supported_elliptic_curves_ext(ssl, p + 2ll + (signed long long int)ext_len, &olen);
        ext_len = ext_len + olen;
        ssl_write_supported_point_formats_ext(ssl, p + 2ll + (signed long long int)ext_len, &olen);
        ext_len = ext_len + olen;
        ssl_write_max_fragment_length_ext(ssl, p + 2ll + (signed long long int)ext_len, &olen);
        ext_len = ext_len + olen;
        ssl_write_encrypt_then_mac_ext(ssl, p + 2ll + (signed long long int)ext_len, &olen);
        ext_len = ext_len + olen;
        ssl_write_extended_ms_ext(ssl, p + 2ll + (signed long long int)ext_len, &olen);
        ext_len = ext_len + olen;
        ssl_write_alpn_ext(ssl, p + 2ll + (signed long long int)ext_len, &olen);
        ext_len = ext_len + olen;
        (void)olen;
        while((_Bool)0)
          ;
        if(ext_len >= 1ull)
        {
          unsigned char *tmp_post$12=p;
          p = p + 1ll;
          *tmp_post$12 = (unsigned char)(ext_len >> 8 & 255ull);
          unsigned char *tmp_post$13=p;
          p = p + 1ll;
          *tmp_post$13 = (unsigned char)(ext_len & 255ull);
          p = p + (signed long long int)ext_len;
        }

        ssl->out_msglen = (size_t)(p - buf);
        ssl->out_msgtype = 22;
        ssl->out_msg[0ll] = 1;
        ssl->state = ssl->state + 1;
        ret=mbedtls_ssl_write_record(ssl);
        if(!(ret == 0))
        {
          while((_Bool)0)
            ;
          return ret;
        }

        else
        {
          while((_Bool)0)
            ;
          return 0;
        }
      }
    }
  }
}

// ssl_write_client_key_exchange
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 2775
static signed int ssl_write_client_key_exchange(mbedtls_ssl_context *ssl)
{
  signed int ret;
  size_t i;
  size_t n;
  const mbedtls_ssl_ciphersuite_t *ciphersuite_info=ssl->transform_negotiate->ciphersuite_info;
  while((_Bool)0)
    ;
  _Bool tmp_if_expr;
  if((signed int)ciphersuite_info->key_exchange == 3)
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = (signed int)ciphersuite_info->key_exchange == 4 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$0;
  if(tmp_if_expr)
    tmp_if_expr$0 = (_Bool)1;

  else
    tmp_if_expr$0 = (signed int)ciphersuite_info->key_exchange == 9 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$1;
  if(tmp_if_expr$0)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)ciphersuite_info->key_exchange == 10 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    i = 4ull;
    ret=mbedtls_ecdh_make_public(&ssl->handshake->ecdh_ctx, &n, &ssl->out_msg[(signed long long int)i], 1000ull, ssl->conf->f_rng, ssl->conf->p_rng);
    if(!(ret == 0))
    {
      while((_Bool)0)
        ;
      return ret;
    }

    while((_Bool)0)
      ;
    ret=mbedtls_ecdh_calc_secret(&ssl->handshake->ecdh_ctx, &ssl->handshake->pmslen, ssl->handshake->premaster, 1024ull, ssl->conf->f_rng, ssl->conf->p_rng);
    if(!(ret == 0))
    {
      while((_Bool)0)
        ;
      return ret;
    }

    while((_Bool)0)
      ;
  }

  else
  {
    (void)ciphersuite_info;
    while((_Bool)0)
      ;
    return -0x6C00;
  }
  ssl->out_msglen = i + n;
  ssl->out_msgtype = 22;
  ssl->out_msg[0ll] = 16;
  ssl->state = ssl->state + 1;
  ret=mbedtls_ssl_write_record(ssl);
  if(!(ret == 0))
  {
    while((_Bool)0)
      ;
    return ret;
  }

  else
  {
    while((_Bool)0)
      ;
    return 0;
  }
}

// ssl_write_encrypt_then_mac_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 506
static void ssl_write_encrypt_then_mac_ext(mbedtls_ssl_context *ssl, unsigned char *buf, size_t *olen)
{
  unsigned char *p=buf;
  const unsigned char *end=ssl->out_msg + 8192ll;
  *olen = 0ull;
  _Bool tmp_if_expr;
  if((signed int)ssl->conf->encrypt_then_mac == 0)
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = (signed int)ssl->conf->max_minor_ver == 0 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr)
  {
    while((_Bool)0)
      ;
    if(!(end >= p) || !((size_t)(end - p) >= 4ull))
      while((_Bool)0)
        ;

    else
    {
      unsigned char *tmp_post=p;
      p = p + 1ll;
      *tmp_post = (unsigned char)(22 >> 8 & 0xFF);
      unsigned char *tmp_post$0=p;
      p = p + 1ll;
      *tmp_post$0 = (unsigned char)(22 & 0xFF);
      unsigned char *tmp_post$1=p;
      p = p + 1ll;
      *tmp_post$1 = 0;
      unsigned char *tmp_post$2=p;
      p = p + 1ll;
      *tmp_post$2 = 0;
      *olen = 4ull;
    }
  }

}

// ssl_write_extended_ms_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 540
static void ssl_write_extended_ms_ext(mbedtls_ssl_context *ssl, unsigned char *buf, size_t *olen)
{
  unsigned char *p=buf;
  const unsigned char *end=ssl->out_msg + 8192ll;
  *olen = 0ull;
  _Bool tmp_if_expr;
  if((signed int)ssl->conf->extended_ms == 0)
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = (signed int)ssl->conf->max_minor_ver == 0 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr)
  {
    while((_Bool)0)
      ;
    if(!(end >= p) || !((size_t)(end - p) >= 4ull))
      while((_Bool)0)
        ;

    else
    {
      unsigned char *tmp_post=p;
      p = p + 1ll;
      *tmp_post = (unsigned char)(0x17 >> 8 & 0xFF);
      unsigned char *tmp_post$0=p;
      p = p + 1ll;
      *tmp_post$0 = (unsigned char)(0x17 & 0xFF);
      unsigned char *tmp_post$1=p;
      p = p + 1ll;
      *tmp_post$1 = 0;
      unsigned char *tmp_post$2=p;
      p = p + 1ll;
      *tmp_post$2 = 0;
      *olen = 4ull;
    }
  }

}

// ssl_write_hostname_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 58
static void ssl_write_hostname_ext(mbedtls_ssl_context *ssl, unsigned char *buf, size_t *olen)
{
  unsigned char *p=buf;
  const unsigned char *end=ssl->out_msg + 8192ll;
  size_t hostname_len;
  *olen = 0ull;
  if(!(ssl->hostname == ((char *)NULL)))
  {
    while((_Bool)0)
      ;
    hostname_len=strlen(ssl->hostname);
    if(!(end >= p) || !((size_t)(end - p) >= 9ull + hostname_len))
      while((_Bool)0)
        ;

    else
    {
      unsigned char *tmp_post=p;
      p = p + 1ll;
      *tmp_post = (unsigned char)(0 >> 8 & 0xFF);
      unsigned char *tmp_post$0=p;
      p = p + 1ll;
      *tmp_post$0 = (unsigned char)(0 & 0xFF);
      unsigned char *tmp_post$1=p;
      p = p + 1ll;
      *tmp_post$1 = (unsigned char)(hostname_len + 5ull >> 8 & 255ull);
      unsigned char *tmp_post$2=p;
      p = p + 1ll;
      *tmp_post$2 = (unsigned char)(hostname_len + 5ull & 255ull);
      unsigned char *tmp_post$3=p;
      p = p + 1ll;
      *tmp_post$3 = (unsigned char)(hostname_len + 3ull >> 8 & 255ull);
      unsigned char *tmp_post$4=p;
      p = p + 1ll;
      *tmp_post$4 = (unsigned char)(hostname_len + 3ull & 255ull);
      unsigned char *tmp_post$5=p;
      p = p + 1ll;
      *tmp_post$5 = (unsigned char)(0 & 0xFF);
      unsigned char *tmp_post$6=p;
      p = p + 1ll;
      *tmp_post$6 = (unsigned char)(hostname_len >> 8 & 255ull);
      unsigned char *tmp_post$7=p;
      p = p + 1ll;
      *tmp_post$7 = (unsigned char)(hostname_len & 255ull);
      memcpy((void *)p, (const void *)ssl->hostname, hostname_len);
      *olen = hostname_len + 9ull;
    }
  }

}

// ssl_write_max_fragment_length_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 440
static void ssl_write_max_fragment_length_ext(mbedtls_ssl_context *ssl, unsigned char *buf, size_t *olen)
{
  unsigned char *p=buf;
  const unsigned char *end=ssl->out_msg + 8192ll;
  *olen = 0ull;
  if(!((signed int)ssl->conf->mfl_code == 0))
  {
    while((_Bool)0)
      ;
    if(!(end >= p) || !((size_t)(end - p) >= 5ull))
      while((_Bool)0)
        ;

    else
    {
      unsigned char *tmp_post=p;
      p = p + 1ll;
      *tmp_post = (unsigned char)(1 >> 8 & 0xFF);
      unsigned char *tmp_post$0=p;
      p = p + 1ll;
      *tmp_post$0 = (unsigned char)(1 & 0xFF);
      unsigned char *tmp_post$1=p;
      p = p + 1ll;
      *tmp_post$1 = 0;
      unsigned char *tmp_post$2=p;
      p = p + 1ll;
      *tmp_post$2 = 1;
      unsigned char *tmp_post$3=p;
      p = p + 1ll;
      *tmp_post$3 = (unsigned char)ssl->conf->mfl_code;
      *olen = 5ull;
    }
  }

}

// ssl_write_real
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 7222
static signed int ssl_write_real(mbedtls_ssl_context *ssl, const unsigned char *buf, size_t len)
{
  signed int ret;
  size_t max_len=mbedtls_ssl_get_max_frag_len(ssl);
  if(!(max_len >= len))
    len = max_len;

  if(!(ssl->out_left == 0ull))
  {
    ret=mbedtls_ssl_flush_output(ssl);
    if(!(ret == 0))
    {
      while((_Bool)0)
        ;
      return ret;
    }

  }

  else
  {
    ssl->out_msglen = len;
    ssl->out_msgtype = 23;
    memcpy((void *)ssl->out_msg, (const void *)buf, len);
    ret=mbedtls_ssl_write_record(ssl);
    if(!(ret == 0))
    {
      while((_Bool)0)
        ;
      return ret;
    }

  }
  return (signed int)len;
}

// ssl_write_signature_algorithms_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 171
static void ssl_write_signature_algorithms_ext(mbedtls_ssl_context *ssl, unsigned char *buf, size_t *olen)
{
  unsigned char *p=buf;
  const unsigned char *end=ssl->out_msg + 8192ll;
  size_t sig_alg_len=0ull;
  const signed int *md;
  unsigned char *sig_alg_list=buf + 6ll;
  *olen = 0ull;
  if((signed int)ssl->conf->max_minor_ver == 3)
  {
    while((_Bool)0)
      ;
    md = ssl->conf->sig_hashes;
    for( ; !(*md == 0); md = md + 1ll)
    {
      sig_alg_len = sig_alg_len + 2ull;
      sig_alg_len = sig_alg_len + 2ull;
    }
    if(!(end >= p) || !((size_t)(end - p) >= 6ull + sig_alg_len))
      while((_Bool)0)
        ;

    else
    {
      sig_alg_len = 0ull;
      md = ssl->conf->sig_hashes;
      for( ; !(*md == 0); md = md + 1ll)
      {
        size_t tmp_post=sig_alg_len;
        sig_alg_len = sig_alg_len + 1ull;
        sig_alg_list[(signed long long int)tmp_post]=mbedtls_ssl_hash_from_md_alg(*md);
        size_t tmp_post$0=sig_alg_len;
        sig_alg_len = sig_alg_len + 1ull;
        sig_alg_list[(signed long long int)tmp_post$0] = 3;
        size_t tmp_post$1=sig_alg_len;
        sig_alg_len = sig_alg_len + 1ull;
        sig_alg_list[(signed long long int)tmp_post$1]=mbedtls_ssl_hash_from_md_alg(*md);
        size_t tmp_post$2=sig_alg_len;
        sig_alg_len = sig_alg_len + 1ull;
        sig_alg_list[(signed long long int)tmp_post$2] = 1;
      }
      unsigned char *tmp_post$3=p;
      p = p + 1ll;
      *tmp_post$3 = (unsigned char)(13 >> 8 & 0xFF);
      unsigned char *tmp_post$4=p;
      p = p + 1ll;
      *tmp_post$4 = (unsigned char)(13 & 0xFF);
      unsigned char *tmp_post$5=p;
      p = p + 1ll;
      *tmp_post$5 = (unsigned char)(sig_alg_len + 2ull >> 8 & 255ull);
      unsigned char *tmp_post$6=p;
      p = p + 1ll;
      *tmp_post$6 = (unsigned char)(sig_alg_len + 2ull & 255ull);
      unsigned char *tmp_post$7=p;
      p = p + 1ll;
      *tmp_post$7 = (unsigned char)(sig_alg_len >> 8 & 255ull);
      unsigned char *tmp_post$8=p;
      p = p + 1ll;
      *tmp_post$8 = (unsigned char)(sig_alg_len & 255ull);
      *olen = 6ull + sig_alg_len;
    }
  }

}

// ssl_write_supported_elliptic_curves_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 256
static void ssl_write_supported_elliptic_curves_ext(mbedtls_ssl_context *ssl, unsigned char *buf, size_t *olen)
{
  unsigned char *p=buf;
  const unsigned char *end=ssl->out_msg + 8192ll;
  unsigned char *elliptic_curve_list=p + 6ll;
  size_t elliptic_curve_len=0ull;
  const mbedtls_ecp_curve_info *info;
  const mbedtls_ecp_group_id *grp_id;
  *olen = 0ull;
  while((_Bool)0)
    ;
  grp_id = ssl->conf->curve_list;
  for( ; !((signed int)*grp_id == 0); grp_id = grp_id + 1ll)
  {
    info=mbedtls_ecp_curve_info_from_grp_id(*grp_id);
    if(info == ((const mbedtls_ecp_curve_info *)NULL))
    {
      while((_Bool)0)
        ;
      goto __CPROVER_DUMP_L11;
    }

    elliptic_curve_len = elliptic_curve_len + 2ull;
  }
  if(!(end >= p) || !((size_t)(end - p) >= 6ull + elliptic_curve_len))
    while((_Bool)0)
      ;

  else
  {
    elliptic_curve_len = 0ull;
    grp_id = ssl->conf->curve_list;
    for( ; !((signed int)*grp_id == 0); grp_id = grp_id + 1ll)
    {
      info=mbedtls_ecp_curve_info_from_grp_id(*grp_id);
      size_t tmp_post=elliptic_curve_len;
      elliptic_curve_len = elliptic_curve_len + 1ull;
      elliptic_curve_list[(signed long long int)tmp_post] = (unsigned char)((signed int)info->tls_id >> 8);
      size_t tmp_post$0=elliptic_curve_len;
      elliptic_curve_len = elliptic_curve_len + 1ull;
      elliptic_curve_list[(signed long long int)tmp_post$0] = (unsigned char)((signed int)info->tls_id & 0xFF);
    }
    if(!(elliptic_curve_len == 0ull))
    {
      unsigned char *tmp_post$1=p;
      p = p + 1ll;
      *tmp_post$1 = (unsigned char)(10 >> 8 & 0xFF);
      unsigned char *tmp_post$2=p;
      p = p + 1ll;
      *tmp_post$2 = (unsigned char)(10 & 0xFF);
      unsigned char *tmp_post$3=p;
      p = p + 1ll;
      *tmp_post$3 = (unsigned char)(elliptic_curve_len + 2ull >> 8 & 255ull);
      unsigned char *tmp_post$4=p;
      p = p + 1ll;
      *tmp_post$4 = (unsigned char)(elliptic_curve_len + 2ull & 255ull);
      unsigned char *tmp_post$5=p;
      p = p + 1ll;
      *tmp_post$5 = (unsigned char)(elliptic_curve_len >> 8 & 255ull);
      unsigned char *tmp_post$6=p;
      p = p + 1ll;
      *tmp_post$6 = (unsigned char)(elliptic_curve_len & 255ull);
      *olen = 6ull + elliptic_curve_len;
    }

  }

__CPROVER_DUMP_L11:
  ;
}

// ssl_write_supported_point_formats_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_cli.c line 330
static void ssl_write_supported_point_formats_ext(mbedtls_ssl_context *ssl, unsigned char *buf, size_t *olen)
{
  unsigned char *p=buf;
  const unsigned char *end=ssl->out_msg + 8192ll;
  *olen = 0ull;
  while((_Bool)0)
    ;
  if(!(end >= p) || !((size_t)(end - p) >= 6ull))
    while((_Bool)0)
      ;

  else
  {
    unsigned char *tmp_post=p;
    p = p + 1ll;
    *tmp_post = (unsigned char)(11 >> 8 & 0xFF);
    unsigned char *tmp_post$0=p;
    p = p + 1ll;
    *tmp_post$0 = (unsigned char)(11 & 0xFF);
    unsigned char *tmp_post$1=p;
    p = p + 1ll;
    *tmp_post$1 = 0;
    unsigned char *tmp_post$2=p;
    p = p + 1ll;
    *tmp_post$2 = 2;
    unsigned char *tmp_post$3=p;
    p = p + 1ll;
    *tmp_post$3 = 1;
    unsigned char *tmp_post$4=p;
    p = p + 1ll;
    *tmp_post$4 = 0;
    *olen = 6ull;
  }
}

// stpcpy
// file ..\..\..\..\lib\ota\aws_rsprintf.c line 86
char * stpcpy(char *dest, const char *src)
{
  char *d=dest;
  const char *s=src;
  char *tmp_post;
  const char *tmp_post$0;
  do
  {
    tmp_post = d;
    d = d + 1ll;
    tmp_post$0 = s;
    s = s + 1ll;
    *tmp_post = *tmp_post$0;
    if(*tmp_post == 0)
      break;

  }
  while((_Bool)1);
  return d - 1ll;
}

// sub32
// file ..\..\..\..\lib\third_party\mbedtls\library\ecp_curves.c line 971
static inline void sub32(uint32_t *dst, uint32_t src, signed char *carry)
{
  *carry = *carry - (signed char)(*dst < src);
  *dst = *dst - src;
}

// swprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1528
/*inline signed int swprintf_s(wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, ...)*/
/*{*/
  /*signed int _Result;*/
//  va_list _ArgList=(va_list)&_Format + (signed long long int)((sizeof(const wchar_t *) [>8ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull<]  - 1ull));
  /*_Result=_vswprintf_s_l(_Buffer, _BufferCount, _Format, ((const _locale_t)NULL), _ArgList);*/
  /*_ArgList = ((va_list)NULL);*/
  /*return _Result;*/
/*}*/

// swscanf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 2037
/*inline signed int swscanf(const wchar_t * const _Buffer, const wchar_t * const _Format, ...)*/
/*{*/
  /*signed int _Result;*/
//  va_list _ArgList=(va_list)&_Format + (signed long long int)((sizeof(const wchar_t *) [>8ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull<]  - 1ull));
  /*_Result=_vswscanf_l(_Buffer, _Format, ((const _locale_t)NULL), _ArgList);*/
  /*_ArgList = ((va_list)NULL);*/
  /*return _Result;*/
/*}*/

// swscanf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 2078
/*inline signed int swscanf_s(const wchar_t * const _Buffer, const wchar_t * const _Format, ...)*/
/*{*/
  /*signed int _Result;*/
//  va_list _ArgList=(va_list)&_Format + (signed long long int)((sizeof(const wchar_t *) [>8ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull<]  - 1ull));
  /*_Result=_vswscanf_s_l(_Buffer, _Format, ((const _locale_t)NULL), _ArgList);*/
  /*_ArgList = ((va_list)NULL);*/
  /*return _Result;*/
/*}*/

// szH32
// file ..\..\..\..\lib\ota\aws_rsprintf.c line 235
char * szH32(char *dest, uint32_t val, uint8_t iFieldWidth)
{
  char buf[8ll];
  char *dptr;
  uint32_t d;
  uint32_t n;
  if((signed int)iFieldWidth >= 9)
    iFieldWidth = 8;

  dptr = buf;
  d = 268435456u;
  for( ; d >= 1u; d = d >> 4)
  {
    n = val / d;
    if(n >= 10u)
    {
      char *tmp_post=dptr;
      dptr = dptr + 1ll;
      *tmp_post = (char)((unsigned int)(97 - 10) + n);
    }

    else
    {
      char *tmp_post$0=dptr;
      dptr = dptr + 1ll;
      *tmp_post$0 = (char)(48u + n);
    }
    val = val - n * d;
  }
  if((signed int)iFieldWidth == 0)
  {
    d = 0u;
    for( ; !(d >= 7u); d = d + 1u)
      if(!((signed int)buf[(signed long long int)d] == 48))
        break;

  }

  else
    d = (uint32_t)(8 - (signed int)iFieldWidth);
  uint32_t tmp_post$1;
  do
  {
    char *tmp_post$2=dest;
    dest = dest + 1ll;
    *tmp_post$2 = buf[(signed long long int)d];
    tmp_post$1 = d;
    d = d + 1u;
  }
  while(!(tmp_post$1 >= 7u));
  *dest = 0;
  return dest;
}

// szS32
// file ..\..\..\..\lib\ota\aws_rsprintf.c line 165
char * szS32(char *dest, int32_t val, uint8_t iFieldWidth)
{
  if(!(val >= 0))
  {
    char *tmp_post=dest;
    dest = dest + 1ll;
    *tmp_post = '-';
    val = -val;
  }

  char *return_value_szU32=szU32(dest, (uint32_t)val, iFieldWidth);
  return return_value_szU32;
}

// szU32
// file ..\..\..\..\lib\ota\aws_rsprintf.c line 109
char * szU32(char *dest, uint32_t val, uint8_t iFieldWidth)
{
  char buf[10ll];
  char *dptr;
  uint32_t d;
  uint32_t n;
  if((signed int)iFieldWidth >= 11)
    iFieldWidth = 10;

  dptr = buf;
  d = 1000000000u;
  for( ; d >= 2u; d = d / 10u)
  {
    n = val / d;
    char *tmp_post=dptr;
    dptr = dptr + 1ll;
    *tmp_post = (char)(48u + n);
    val = val - n * d;
  }
  char *tmp_post$0=dptr;
  dptr = dptr + 1ll;
  *tmp_post$0 = (char)(48u + val);
  if((signed int)iFieldWidth == 0)
  {
    d = 0u;
    for( ; !(d >= 9u); d = d + 1u)
      if(!((signed int)buf[(signed long long int)d] == 48))
        break;

  }

  else
    d = (uint32_t)(10 - (signed int)iFieldWidth);
  uint32_t tmp_post$1;
  do
  {
    char *tmp_post$2=dest;
    dest = dest + 1ll;
    *tmp_post$2 = buf[(signed long long int)d];
    tmp_post$1 = d;
    d = d + 1u;
  }
  while(!(tmp_post$1 >= 9u));
  *dest = 0;
  return dest;
}

// tanhl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 930
/*inline double tanhl(double _X)*/
/*{*/
  /*double return_value_tanh=tanh((double)_X);*/
  /*return return_value_tanh;*/
/*}*/

// tanl
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\math.h line 935
/*inline double tanl(double _X)*/
/*{*/
  /*double return_value_tan=tan((double)_X);*/
  /*return return_value_tan;*/
/*}*/

// tls_prf_generic
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 378
static signed int tls_prf_generic(mbedtls_md_type_t md_type, const unsigned char *secret, size_t slen, const char *label, const unsigned char *random, size_t rlen, unsigned char *dstbuf, size_t dlen)
{
  size_t nb;
  size_t i;
  size_t j;
  size_t k;
  size_t md_len;
  unsigned char tmp[128ll];
  unsigned char h_i[32ll];
  const mbedtls_md_info_t *md_info;
  mbedtls_md_context_t md_ctx;
  signed int ret;
  mbedtls_md_init(&md_ctx);
  md_info=mbedtls_md_info_from_type(md_type);
  if(md_info == ((const mbedtls_md_info_t *)NULL))
    return -0x6C00;

  else
  {
    unsigned char return_value_mbedtls_md_get_size=mbedtls_md_get_size(md_info);
    md_len = (size_t)return_value_mbedtls_md_get_size;
    size_t return_value_strlen=strlen(label);
    if(return_value_strlen + md_len + rlen >= 129ull)
      return -0x7100;

    else
    {
      nb=strlen(label);
      memcpy((void *)(tmp + (signed long long int)md_len), (const void *)label, nb);
      memcpy((void *)(tmp + (signed long long int)md_len + (signed long long int)nb), (const void *)random, rlen);
      nb = nb + rlen;
      ret=mbedtls_md_setup(&md_ctx, md_info, 1);
      if(!(ret == 0))
        return ret;

      else
      {
        mbedtls_md_hmac_starts(&md_ctx, secret, slen);
        mbedtls_md_hmac_update(&md_ctx, tmp + (signed long long int)md_len, nb);
        mbedtls_md_hmac_finish(&md_ctx, tmp);
        i = 0ull;
        for( ; !(i >= dlen); i = i + md_len)
        {
          mbedtls_md_hmac_reset(&md_ctx);
          mbedtls_md_hmac_update(&md_ctx, tmp, md_len + nb);
          mbedtls_md_hmac_finish(&md_ctx, h_i);
          mbedtls_md_hmac_reset(&md_ctx);
          mbedtls_md_hmac_update(&md_ctx, tmp, md_len);
          mbedtls_md_hmac_finish(&md_ctx, tmp);
          k = i + md_len > dlen ? dlen % md_len : md_len;
          j = 0ull;
          for( ; !(j >= k); j = j + 1ull)
            dstbuf[(signed long long int)(i + j)] = h_i[(signed long long int)j];
        }
        mbedtls_md_free(&md_ctx);
        mbedtls_zeroize$link16((void *)tmp, sizeof(unsigned char [128ll]) /*128ull*/ );
        mbedtls_zeroize$link16((void *)h_i, sizeof(unsigned char [32ll]) /*32ull*/ );
        return 0;
      }
    }
  }
}

// tls_prf_sha256
// file ..\..\..\..\lib\third_party\mbedtls\library\ssl_tls.c line 442
static signed int tls_prf_sha256(const unsigned char *secret, size_t slen, const char *label, const unsigned char *random, size_t rlen, unsigned char *dstbuf, size_t dlen)
{
  signed int return_value_tls_prf_generic=tls_prf_generic(/*enum*/MBEDTLS_MD_SHA256, secret, slen, label, random, rlen, dstbuf, dlen);
  return return_value_tls_prf_generic;
}

// ucQueueGetQueueType
// file ..\..\..\..\lib\FreeRTOS\queue.c line 2006
uint8_t ucQueueGetQueueType(QueueHandle_t xQueue)
{
  return ((Queue_t *)xQueue)->ucQueueType;
}

// ucStreamBufferGetStreamBufferType
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 1193
uint8_t ucStreamBufferGetStreamBufferType(StreamBufferHandle_t xStreamBuffer)
{
  return (uint8_t)((signed int)((StreamBuffer_t1 *)xStreamBuffer)->ucFlags | 1);
}

// uiIndexOfObject
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2316
uint16_t uiIndexOfObject(traceHandle objecthandle, uint8_t objectclass)
{
  if((signed int)objectclass >= 7)
  {
    prvTraceError("TRACE_ASSERT: uiIndexOfObject: Invalid value for objectclass");
    return 0;
  }

  else
  {
    _Bool tmp_if_expr;
    if((signed int)objecthandle >= 1)
      tmp_if_expr = (signed int)objecthandle <= (signed int)RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[(signed long long int)objectclass] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr = (_Bool)0;
    if(!tmp_if_expr)
    {
      prvTraceError("TRACE_ASSERT: uiIndexOfObject: Invalid value for objecthandle");
      return 0;
    }

    else
    {
      if((signed int)objecthandle >= 1 && !((signed int)objectclass >= 7))
      {
        if((signed int)RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[(signed long long int)objectclass] >= (signed int)objecthandle)
          return (uint16_t)((signed int)RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[(signed long long int)objectclass] + (signed int)RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[(signed long long int)objectclass] * ((signed int)objecthandle - 1));

      }

      prvTraceError("Object table lookup with invalid object handle or object class!");
      return 0;
    }
  }
}

// uiTraceGetTraceBufferSize
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 427
uint32_t uiTraceGetTraceBufferSize(void)
{
  return (uint32_t)sizeof(RecorderDataType) /*79804u*/ ;
}

// uiTraceIsObjectExcluded
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcKernelPort.c line 559
uint8_t uiTraceIsObjectExcluded(traceObjectClass objectclass, traceHandle handle)
{
  if((signed int)objectclass >= 7)
  {
    prvTraceError("TRACE_ASSERT: prvIsObjectExcluded: objectclass >= TRACE_NCLASSES");
    return 1;
  }

  else
    if(!((signed int)RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[(signed long long int)objectclass] >= (signed int)handle))
    {
      prvTraceError("TRACE_ASSERT: prvIsObjectExcluded: Invalid value for handle");
      return 1;
    }

    else
      switch((signed int)objectclass)
      {
        case 3:
          return (uint8_t)((signed int)trcExcludedObjects[(signed long long int)(90 + 1 + 90 + 1 + 90 + 1 + (signed int)handle >> 3)] & 1 << (90 + 1 + 90 + 1 + 90 + 1 + (signed int)handle & 7));
        case 1:
          return (uint8_t)((signed int)trcExcludedObjects[(signed long long int)(90 + 1 + (signed int)handle >> 3)] & 1 << (90 + 1 + (signed int)handle & 7));
        case 2:
          return (uint8_t)((signed int)trcExcludedObjects[(signed long long int)(90 + 1 + 90 + 1 + (signed int)handle >> 3)] & 1 << (90 + 1 + 90 + 1 + (signed int)handle & 7));
        case 0:
          return (uint8_t)((signed int)trcExcludedObjects[(signed long long int)((signed int)handle >> 3)] & 1 << ((signed int)handle & 7));
        case 5:
          return (uint8_t)((signed int)trcExcludedObjects[(signed long long int)(90 + 1 + 90 + 1 + 90 + 1 + 150 + 1 + (signed int)handle >> 3)] & 1 << (90 + 1 + 90 + 1 + 90 + 1 + 150 + 1 + (signed int)handle & 7));
        case 6:
          return (uint8_t)((signed int)trcExcludedObjects[(signed long long int)(90 + 1 + 90 + 1 + 90 + 1 + 150 + 1 + 250 + 1 + (signed int)handle >> 3)] & 1 << (90 + 1 + 90 + 1 + 90 + 1 + 150 + 1 + 250 + 1 + (signed int)handle & 7));
        default:
        {
          prvTraceError("Invalid object class ID in prvIsObjectExcluded!");
          return 1;
        }
      }
}

// uiTraceStart
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 308
uint32_t uiTraceStart(void)
{
  traceHandle handle;
  handle = 0;
  if(RecorderDataPtr == ((RecorderDataType *)NULL))
  {
    prvTraceError("RecorderDataPtr is NULL. Call vTraceInitTraceData() before starting trace.");
    return 0u;
  }

  else
    if(RecorderDataPtr->recorderActive == 1u)
      return 1u;

    else
    {
      if(traceErrorMessage == ((const char *)NULL))
      {
        vPortEnterCritical();
        recorder_busy = recorder_busy + 1;
        RecorderDataPtr->recorderActive = 1u;
        void *return_value_prvTraceGetCurrentTaskHandle=prvTraceGetCurrentTaskHandle();
        handle=prvTraceGetTaskNumber(return_value_prvTraceGetCurrentTaskHandle);
        if((signed int)handle == 0)
        {
          handle=prvTraceGetObjectHandle(3);
          prvTraceSetObjectName(3, handle, "(startup)");
          prvTraceSetPriorityProperty(3, handle, 0);
        }

        prvTraceStoreTaskswitch(handle);
        recorder_busy = recorder_busy - 1;
        vPortExitCritical();
      }

      return RecorderDataPtr->recorderActive;
    }
}

// ulChar2u32
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP_Private.h line 713
static inline uint32_t ulChar2u32(const uint8_t *apChr)
{
  return (uint32_t)apChr[0ll] << 24 | (uint32_t)apChr[1ll] << 16 | (uint32_t)apChr[2ll] << 8 | (uint32_t)apChr[3ll];
}

// ulDNSHandlePacket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DNS.c line 810
uint32_t ulDNSHandlePacket(NetworkBufferDescriptor_t *pxNetworkBuffer)
{
  uint8_t *pucUDPPayloadBuffer;
  size_t xPlayloadBufferLength;
  DNSMessage_t *pxDNSMessageHeader;
  xPlayloadBufferLength = pxNetworkBuffer->xDataLength - sizeof(UDPPacket_t) /*42ull*/ ;
  if(!(xPlayloadBufferLength >= sizeof(DNSMessage_t) /*12ull*/ ))
    return 0u;

  else
  {
    pucUDPPayloadBuffer = pxNetworkBuffer->pucEthernetBuffer + (signed long long int)sizeof(UDPPacket_t) /*42ll*/ ;
    pxDNSMessageHeader = (DNSMessage_t *)pucUDPPayloadBuffer;
    if(pxNetworkBuffer->xDataLength >= 43ull)
      prvParseDNSReply(pucUDPPayloadBuffer, xPlayloadBufferLength, (uint32_t)pxDNSMessageHeader->usIdentifier);

    return 0u;
  }
}

// ulGetNextSequenceNumber
// file ..\..\..\..\lib\secure_sockets\portable\freertos_plus_tcp\aws_secure_sockets.c line 621
uint32_t ulGetNextSequenceNumber(uint32_t ulSourceAddress, uint16_t usSourcePort, uint32_t ulDestinationAddress, uint16_t usDestinationPort)
{
  CK_RV xResult=0ul;
  CK_SESSION_HANDLE xPkcs11Session=0ul;
  CK_FUNCTION_LIST_PTR pxPkcs11FunctionList=((CK_FUNCTION_LIST_PTR)NULL);
  CK_MECHANISM xMechSha256={ .mechanism=0ul, .pParameter=NULL, .ulParameterLen=0ul };
  uint8_t ucSha256Result[32ll];
  CK_ULONG ulLength=(CK_ULONG)sizeof(uint8_t [32ll]) /*32ul*/ ;
  uint32_t ulNextSequenceNumber=0u;
  xResult=prvSocketsGetCryptoSession(&xPkcs11Session, &pxPkcs11FunctionList);
  static uint64_t ullKey=0ull;
  if(xResult == 0u)
  {
    vPortEnterCritical();
    if(ullKey == 0ull)
      xResult=pxPkcs11FunctionList->C_GenerateRandom(xPkcs11Session, (CK_BYTE_PTR)&ullKey, (CK_ULONG)sizeof(uint64_t) /*8ul*/ );

    vPortExitCritical();
  }

  vPortEnterCritical();
  if(xResult == 0u)
  {
    xMechSha256.mechanism = 0x250ul;
    xResult=pxPkcs11FunctionList->C_DigestInit(xPkcs11Session, &xMechSha256);
  }

  if(xResult == 0u)
    xResult=pxPkcs11FunctionList->C_DigestUpdate(xPkcs11Session, (CK_BYTE_PTR)&ullKey, (CK_ULONG)sizeof(uint64_t) /*8ul*/ );

  if(xResult == 0u)
    xResult=pxPkcs11FunctionList->C_DigestUpdate(xPkcs11Session, (CK_BYTE_PTR)&ulSourceAddress, (CK_ULONG)sizeof(uint32_t) /*4ul*/ );

  if(xResult == 0u)
    xResult=pxPkcs11FunctionList->C_DigestUpdate(xPkcs11Session, (CK_BYTE_PTR)&usSourcePort, (CK_ULONG)sizeof(uint16_t) /*2ul*/ );

  if(xResult == 0u)
    xResult=pxPkcs11FunctionList->C_DigestUpdate(xPkcs11Session, (CK_BYTE_PTR)&ulDestinationAddress, (CK_ULONG)sizeof(uint32_t) /*4ul*/ );

  if(xResult == 0u)
    xResult=pxPkcs11FunctionList->C_DigestUpdate(xPkcs11Session, (CK_BYTE_PTR)&usDestinationPort, (CK_ULONG)sizeof(uint16_t) /*2ul*/ );

  if(xResult == 0u)
    xResult=pxPkcs11FunctionList->C_DigestFinal(xPkcs11Session, ucSha256Result, &ulLength);

  vPortExitCritical();
  if(xResult == 0u)
  {
    memcpy((void *)&ulNextSequenceNumber, (const void *)ucSha256Result, sizeof(uint32_t) /*4ull*/ );
    TickType_t return_value_xTaskGetTickCount=xTaskGetTickCount();
    ulNextSequenceNumber = ulNextSequenceNumber + return_value_xTaskGetTickCount / 4u;
  }

  return ulNextSequenceNumber;
}

// ulGetRunTimeCounterValue
// file ..\common\application_code\aws_run-time-stats-utils.c line 74
unsigned long int ulGetRunTimeCounterValue(void)
{
  LARGE_INTEGER liCurrentCount;
  unsigned long int ulReturn;
  QueryPerformanceCounter(&liCurrentCount);
  if(llTicksPerHundedthMillisecond == 0ll)
    ulReturn = 0ul;

  else
    ulReturn = (unsigned long int)((liCurrentCount.QuadPart - llInitialRunTimeCounterValue) / llTicksPerHundedthMillisecond);
  return ulReturn;
}

// ulRand
// file ..\..\..\..\lib\secure_sockets\portable\freertos_plus_tcp\aws_secure_sockets.c line 584
extern uint32_t ulRand(void)
{
  CK_RV xResult=0ul;
  CK_SESSION_HANDLE xPkcs11Session=0ul;
  CK_FUNCTION_LIST_PTR pxPkcs11FunctionList=((CK_FUNCTION_LIST_PTR)NULL);
  uint32_t ulRandomValue=0u;
  xResult=prvSocketsGetCryptoSession(&xPkcs11Session, &pxPkcs11FunctionList);
  if(xResult == 0u)
  {
    vPortEnterCritical();
    xResult=pxPkcs11FunctionList->C_GenerateRandom(xPkcs11Session, (CK_BYTE_PTR)&ulRandomValue, (CK_ULONG)sizeof(uint32_t) /*4ul*/ );
    vPortExitCritical();
  }

  if(!(xResult == 0u))
    ulRandomValue = 0u;

  return ulRandomValue;
}

// ulTCPWindowTxAck
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 1636
uint32_t ulTCPWindowTxAck(TCPWindow_t *pxWindow, uint32_t ulSequenceNumber)
{
  uint32_t ulFirstSequence;
  uint32_t ulReturn;
  ulFirstSequence = pxWindow->tx.ulCurrentSequenceNumber;
  BaseType_t return_value_xSequenceLessThanOrEqual=xSequenceLessThanOrEqual(ulSequenceNumber, ulFirstSequence);
  if(!(return_value_xSequenceLessThanOrEqual == 0))
    ulReturn = 0ul;

  else
    ulReturn=prvTCPWindowTxCheckAck(pxWindow, ulFirstSequence, ulSequenceNumber);
  return ulReturn;
}

// ulTCPWindowTxGet
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 1259
uint32_t ulTCPWindowTxGet(TCPWindow_t *pxWindow, uint32_t ulWindowSize, int32_t *plPosition)
{
  TCPSegment_t *pxSegment;
  uint32_t ulMaxTime;
  uint32_t ulReturn=~0ul;
  pxSegment=xTCPWindowGetHead(&pxWindow->xPriorityQueue);
  pxWindow->ulOurSequenceNumber = pxWindow->tx.ulHighestSequenceNumber;
  _Bool tmp_if_expr;
  BaseType_t return_value_prvTCPWindowTxHasSpace;
  if(pxSegment == ((TCPSegment_t *)NULL))
  {
    pxSegment=xTCPWindowPeekHead(&pxWindow->xWaitQueue);
    if(!(pxSegment == ((TCPSegment_t *)NULL)))
    {
      ulMaxTime = (1u << (signed int)pxSegment->u.bits.ucTransmitCount) * (uint32_t)pxWindow->lSRTT;
      uint32_t return_value_ulTimerGetAge=ulTimerGetAge(&pxSegment->xTransmitTimer);
      if(!(ulMaxTime >= return_value_ulTimerGetAge))
      {
        pxSegment=xTCPWindowGetHead(&pxWindow->xWaitQueue);
        pxSegment->u.bits.ucDupAckCount = 0u;
        if(!(xTCPWindowLoggingLevel == 0))
        {
          if(!((unsigned int)pxWindow->usOurPortNumber == 23u))
          {
            while((_Bool)0)
              ;
            while((_Bool)0)
              ;
          }

        }

      }

      else
        pxSegment = ((TCPSegment_t *)NULL);
    }

    if(pxSegment == ((TCPSegment_t *)NULL))
    {
      pxSegment=xTCPWindowPeekHead(&pxWindow->xTxQueue);
      if(pxSegment == ((TCPSegment_t *)NULL))
        ulReturn = 0ul;

      else
      {
        if(!((unsigned int)pxWindow->u.bits.bSendFullSize == 0u))
          tmp_if_expr = pxSegment->lDataLength < pxSegment->lMaxLength ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr = (_Bool)0;
        if(tmp_if_expr)
          ulReturn = 0u;

        else
        {
          return_value_prvTCPWindowTxHasSpace=prvTCPWindowTxHasSpace(pxWindow, ulWindowSize);
          if(return_value_prvTCPWindowTxHasSpace == 0)
            ulReturn = 0u;

          else
          {
            pxSegment=xTCPWindowGetHead(&pxWindow->xTxQueue);
            if(pxWindow->pxHeadSegment == pxSegment)
              pxWindow->pxHeadSegment = ((TCPSegment_t *)NULL);

            pxWindow->tx.ulHighestSequenceNumber = pxSegment->ulSequenceNumber + (uint32_t)pxSegment->lDataLength;
            if(xTCPWindowLoggingLevel >= 2)
            {
              if(!((unsigned int)pxWindow->usOurPortNumber == 23u))
              {
                while((_Bool)0)
                  ;
                while((_Bool)0)
                  ;
              }

            }

          }
        }
      }
    }

  }

  else
    if(!(xTCPWindowLoggingLevel == 0))
    {
      while((_Bool)0)
        ;
      while((_Bool)0)
        ;
    }

  if(!(ulReturn == 0ul))
  {
    if(!(pxSegment->xQueueItem.pvContainer == NULL))
      vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS-Plus-TCP\\source\\FreeRTOS_TCP_WIN.c", 1381u);

    vListInsertFifo(&pxWindow->xWaitQueue, &pxSegment->xQueueItem);
    pxSegment->u.bits.bOutstanding = 1u;
    pxSegment->u.bits.ucTransmitCount = (uint32_t)pxSegment->u.bits.ucTransmitCount + 1u;
    if((unsigned int)pxSegment->u.bits.ucTransmitCount == 4u)
    {
      if(!(2u * (unsigned int)pxWindow->usMSS >= pxWindow->xSize.ulTxWindowLength))
      {
        while((_Bool)0)
          ;
        pxWindow->xSize.ulTxWindowLength = 2ul * (unsigned int)pxWindow->usMSS;
      }

    }

    vTCPTimerSet(&pxSegment->xTransmitTimer);
    pxWindow->ulOurSequenceNumber = pxSegment->ulSequenceNumber;
    *plPosition = pxSegment->lStreamPos;
    ulReturn = (uint32_t)pxSegment->lDataLength;
  }

  return ulReturn;
}

// ulTCPWindowTxSack
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 1661
uint32_t ulTCPWindowTxSack(TCPWindow_t *pxWindow, uint32_t ulFirst, uint32_t ulLast)
{
  uint32_t ulAckCount=0ul;
  uint32_t ulCurrentSequenceNumber=pxWindow->tx.ulCurrentSequenceNumber;
  ulAckCount=prvTCPWindowTxCheckAck(pxWindow, ulFirst, ulLast);
  prvTCPWindowFastRetransmit(pxWindow, ulFirst);
  BaseType_t return_value_xSequenceGreaterThan;
  if(xTCPWindowLoggingLevel >= 1)
  {
    return_value_xSequenceGreaterThan=xSequenceGreaterThan(ulFirst, ulCurrentSequenceNumber);
    if(!(return_value_xSequenceGreaterThan == 0))
    {
      while((_Bool)0)
        ;
      while((_Bool)0)
        ;
    }

  }

  return ulAckCount;
}

// ulTaskNotifyTake
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 4486
uint32_t ulTaskNotifyTake(BaseType_t xClearCountOnExit, TickType_t xTicksToWait)
{
  uint32_t ulReturn;
  vPortEnterCritical();
  if(pxCurrentTCB->ulNotifiedValue == 0ul)
  {
    pxCurrentTCB->ucNotifyState = 1;
    if(xTicksToWait >= 1u)
    {
      prvAddCurrentTaskToDelayedList(xTicksToWait, 1);
      UBaseType_t return_value_uxTaskGetTaskNumber=uxTaskGetTaskNumber((TaskHandle_t)pxCurrentTCB);
      prvTraceStoreKernelCallWithParam(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + 18ul + 16ul + 2ul, 3, return_value_uxTaskGetTaskNumber, xTicksToWait);
      void *return_value_prvTraceGetCurrentTaskHandle=prvTraceGetCurrentTaskHandle();
      traceHandle return_value_prvTraceGetTaskNumber=prvTraceGetTaskNumber(return_value_prvTraceGetCurrentTaskHandle);
      prvTraceSetTaskInstanceFinished(return_value_prvTraceGetTaskNumber);
      vPortGenerateSimulatedInterrupt(0ul);
    }

  }

  vPortExitCritical();
  vPortEnterCritical();
  if(pxCurrentTCB->ucNotifyState == 2)
  {
    UBaseType_t return_value_uxTaskGetTaskNumber$0=uxTaskGetTaskNumber((TaskHandle_t)pxCurrentTCB);
    prvTraceStoreKernelCallWithParam(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + 18ul + 16ul + 1ul, 3, return_value_uxTaskGetTaskNumber$0, xTicksToWait);
  }

  else
  {
    UBaseType_t return_value_uxTaskGetTaskNumber$1=uxTaskGetTaskNumber((TaskHandle_t)pxCurrentTCB);
    prvTraceStoreKernelCallWithParam(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + 18ul + 16ul + 3ul, 3, return_value_uxTaskGetTaskNumber$1, xTicksToWait);
  }
  ulReturn = pxCurrentTCB->ulNotifiedValue;
  if(!(ulReturn == 0ul))
  {
    if(!(xClearCountOnExit == 0))
      pxCurrentTCB->ulNotifiedValue = 0ul;

    else
      pxCurrentTCB->ulNotifiedValue = ulReturn - 1u;
  }

  pxCurrentTCB->ucNotifyState = 0;
  vPortExitCritical();
  return ulReturn;
}

// ulTimerGetAge
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 273
static inline uint32_t ulTimerGetAge(TCPTimer_t *pxTimer)
{
  TickType_t return_value_xTaskGetTickCount=xTaskGetTickCount();
  return (return_value_xTaskGetTickCount - pxTimer->ulBorn) * (1000u / 1000u);
}

// usChar2u16
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP_Private.h line 722
static inline uint16_t usChar2u16(const uint8_t *apChr)
{
  return (uint16_t)((uint32_t)apChr[0ll] << 8 | (uint32_t)apChr[1ll]);
}

// usChar2u16$link1
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_IP_Private.h line 722
static inline uint16_t usChar2u16$link1(const uint8_t *apChr$link1)
{
  return (uint16_t)((uint32_t)apChr$link1[0ll] << 8 | (uint32_t)apChr$link1[1ll]);
}

// usGenerateChecksum
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 2031
uint16_t usGenerateChecksum(uint32_t ulSum, const uint8_t *pucNextData, size_t uxDataLengthBytes)
{
  xUnion32 xSum2;
  xUnion32 xSum;
  xUnion32 xTerm;
  xUnionPtr xSource;
  xUnionPtr xLastSource;
  uint32_t ulAlignBits;
  uint32_t ulCarry=0ul;
  xSum.u32 = (uint32_t)(uint16_t)(ulSum << 8u | ulSum >> 8u);
  xTerm.u32 = 0ul;
  xSource.u8ptr = (uint8_t *)pucNextData;
  ulAlignBits = (uint32_t)pucNextData & 0x3u;
  if(uxDataLengthBytes >= 1ull && !((1ul & ulAlignBits) == 0ul))
  {
    xTerm.u8[1ll] = *xSource.u8ptr;
    xSource.u8ptr = xSource.u8ptr + 1ll;
    uxDataLengthBytes = uxDataLengthBytes - 1ull;
  }

  if(uxDataLengthBytes >= 2ull && (ulAlignBits == 1u || ulAlignBits == 2u))
  {
    xSum.u32 = xSum.u32 + (uint32_t)*xSource.u16ptr;
    xSource.u16ptr = xSource.u16ptr + 1ll;
    uxDataLengthBytes = uxDataLengthBytes - 2ull;
  }

  xLastSource.u32ptr = (xSource.u32ptr + (signed long long int)(uxDataLengthBytes / 4ull)) - 3ll;
  for( ; !(xSource.u32ptr >= xLastSource.u32ptr); xSource.u32ptr = xSource.u32ptr + 4ll)
  {
    xSum2.u32 = xSum.u32 + xSource.u32ptr[0ll];
    if(!(xSum2.u32 >= xSum.u32))
      ulCarry = ulCarry + 1u;

    xSum.u32 = xSum2.u32 + xSource.u32ptr[1ll];
    if(!(xSum.u32 >= xSum2.u32))
      ulCarry = ulCarry + 1u;

    xSum2.u32 = xSum.u32 + xSource.u32ptr[2ll];
    if(!(xSum2.u32 >= xSum.u32))
      ulCarry = ulCarry + 1u;

    xSum.u32 = xSum2.u32 + xSource.u32ptr[3ll];
    if(!(xSum.u32 >= xSum2.u32))
      ulCarry = ulCarry + 1u;

  }
  xSum.u32 = (uint32_t)xSum.u16[0ll] + (unsigned int)xSum.u16[1ll] + ulCarry;
  uxDataLengthBytes = uxDataLengthBytes % 16ull;
  xLastSource.u8ptr = (uint8_t *)(xSource.u8ptr + (signed long long int)(uxDataLengthBytes & ~1ull));
  for( ; !(xSource.u16ptr >= xLastSource.u16ptr); xSource.u16ptr = xSource.u16ptr + 1ll)
    xSum.u32 = xSum.u32 + (uint32_t)xSource.u16ptr[0ll];
  if(!((1ull & uxDataLengthBytes) == 0ull))
    xTerm.u8[0ll] = xSource.u8ptr[0ll];

  xSum.u32 = xSum.u32 + xTerm.u32;
  xSum.u32 = (uint32_t)xSum.u16[0ll] + (unsigned int)xSum.u16[1ll];
  xSum.u32 = (uint32_t)xSum.u16[0ll] + (unsigned int)xSum.u16[1ll];
  if(!((1u & ulAlignBits) == 0u))
    xSum.u32 = (xSum.u32 & 0xFFu) << 8 | (xSum.u32 & 0xFF00u) >> 8;

  return (uint16_t)((signed int)(uint16_t)xSum.u32 << 8u | (signed int)(uint16_t)xSum.u32 >> 8u);
}

// usGenerateProtocolChecksum
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 1794
uint16_t usGenerateProtocolChecksum(const uint8_t * const pucEthernetBuffer, size_t uxBufferLength, BaseType_t xOutgoingPacket)
{
  uint32_t ulLength;
  uint16_t usChecksum;
  uint16_t *pusChecksum;
  const IPPacket_t *pxIPPacket;
  UBaseType_t uxIPHeaderLength;
  ProtocolPacket_t *pxProtPack;
  uint8_t ucProtocol;
  if(!(uxBufferLength >= sizeof(IPPacket_t) /*34ull*/ ))
    return 4660;

  else
  {
    pxIPPacket = (const IPPacket_t *)pucEthernetBuffer;
    uxIPHeaderLength = (UBaseType_t)(sizeof(uint32_t) /*4ull*/  * (unsigned long long int)((unsigned int)pxIPPacket->xIPHeader.ucVersionHeaderLength & 0xFu));
    if(!(uxBufferLength >= 14ull + (unsigned long long int)uxIPHeaderLength))
      return 4660;

    else
      if(!(uxBufferLength >= (unsigned long long int)((uint16_t)((signed int)pxIPPacket->xIPHeader.usLength >> 8u) | (uint16_t)((signed int)pxIPPacket->xIPHeader.usLength << 8u))))
        return 4660;

      else
      {
        ucProtocol = pxIPPacket->xIPHeader.ucProtocol;
        pxProtPack = (ProtocolPacket_t *)(pucEthernetBuffer + (signed long long int)(uxIPHeaderLength - 20u));
        if(ucProtocol == 17)
        {
          if(!(uxBufferLength >= (unsigned long long int)(22u + uxIPHeaderLength)))
            return 4660;

          pusChecksum = (uint16_t *)&pxProtPack->xUDPPacket.xUDPHeader.usChecksum;
        }

        else
          if(ucProtocol == 6)
          {
            if(!(uxBufferLength >= (unsigned long long int)(34u + uxIPHeaderLength)))
              return 4660;

            pusChecksum = (uint16_t *)&pxProtPack->xTCPPacket.xTCPHeader.usChecksum;
          }

          else
            if(ucProtocol == 1 || ucProtocol == 2)
            {
              if(!(uxBufferLength >= (unsigned long long int)(22u + uxIPHeaderLength)))
                return 4660;

              pusChecksum = (uint16_t *)&pxProtPack->xICMPPacket.xICMPHeader.usChecksum;
            }

            else
              return 17185;
        if(!(xOutgoingPacket == 0))
          *pusChecksum = 0;

        else
          if((unsigned int)*pusChecksum == 0u)
          {
            if(ucProtocol == 17)
              return 65535;

          }

        ulLength = (uint32_t)((signed int)(uint16_t)((signed int)pxIPPacket->xIPHeader.usLength << 8u | (signed int)pxIPPacket->xIPHeader.usLength >> 8u) - (signed int)(uint16_t)uxIPHeaderLength);
        if(!(1200u + -uxIPHeaderLength >= ulLength) || !((unsigned long long int)ulLength >= sizeof(UDPHeader_t) /*8ull*/ ))
          return 4660;

        else
        {
          if(!((signed int)ucProtocol >= 3))
          {
            uint16_t return_value_usGenerateChecksum=usGenerateChecksum(0ul, (uint8_t *)&pxProtPack->xTCPPacket.xTCPHeader, (size_t)ulLength);
            usChecksum = (uint16_t)~((signed int)return_value_usGenerateChecksum);
          }

          else
          {
            usChecksum = (uint16_t)(ulLength + (unsigned int)(uint16_t)ucProtocol);
            uint16_t return_value_usGenerateChecksum$0=usGenerateChecksum((uint32_t)usChecksum, (uint8_t *)&pxIPPacket->xIPHeader.ulSourceIPAddress, 2ull * sizeof(uint32_t) /*4ull*/  + (unsigned long long int)ulLength);
            usChecksum = (uint16_t)~((signed int)return_value_usGenerateChecksum$0);
          }
          if(xOutgoingPacket == 0)
          {
            if((unsigned int)usChecksum == 0u)
              usChecksum = 65535;

          }

          else
            if(ucProtocol == 17 && (unsigned int)usChecksum == 0u)
              usChecksum = 65535;

          usChecksum = (uint16_t)((signed int)usChecksum << 8u | (signed int)usChecksum >> 8u);
          if(!(xOutgoingPacket == 0))
            *pusChecksum = usChecksum;

          return usChecksum;
        }
      }
  }
}

// utf8EscapedDump
// file ..\..\..\..\lib\third_party\tinycbor\cborpretty.c line 125
static signed int utf8EscapedDump(FILE *out, const char *buffer, size_t n)
{
  uint32_t uc;
  size_t tmp_post;
  do
  {
    tmp_post = n;
    n = n - 1ull;
    if(tmp_post == 0ull)
      break;

    const char *tmp_post$0=buffer;
    buffer = buffer + 1ll;
    uc = (uint32_t)(uint8_t)*tmp_post$0;
    if(!(uc >= 128u))
    {
      if(uc >= 32u && !(uc == 34u) && !(uc == 92u) && !(uc >= 127u))
      {
        signed int return_value_fprintf=fprintf(out, "%c", (char)uc);
        if(!(return_value_fprintf >= 0))
          return 4;

        continue;
      }

      char escaped=(char)uc;
      switch(uc)
      {
        case 34u:

        case 92u:
          break;
        case 8u:
        {
          escaped = 'b';
          break;
        }
        case 12u:
        {
          escaped = 'f';
          break;
        }
        case 10u:
        {
          escaped = 'n';
          break;
        }
        case 13u:
        {
          escaped = 'r';
          break;
        }
        case 9u:
        {
          escaped = 't';
          break;
        }
        default:
          goto print_utf16;
      }
      signed int return_value_fprintf$0=fprintf(out, "\\%c", escaped);
      if(!(return_value_fprintf$0 >= 0))
        return 4;

    }

    else
    {
      unsigned int charsNeeded;
      uint32_t min_uc;
      if(!(uc >= 194u))
        return 516;

      if(!(uc >= 224u))
      {
        charsNeeded = 2u;
        min_uc = 128u;
        uc = uc & 31u;
      }

      else
        if(!(uc >= 240u))
        {
          charsNeeded = 3u;
          min_uc = 2048u;
          uc = uc & 15u;
        }

        else
          if(!(uc >= 245u))
          {
            charsNeeded = 4u;
            min_uc = 65536u;
            uc = uc & 7u;
          }

          else
            return 516;
      if(!(n >= (unsigned long long int)(4294967295u + charsNeeded)))
        return 516;

      n = n - (size_t)(charsNeeded - 1u);
      uint8_t b;
      const char *tmp_post$1=buffer;
      buffer = buffer + 1ll;
      b = (uint8_t)*tmp_post$1;
      if(!((0xC0 & (signed int)b) == 0x80))
        return 516;

      uc = uc << 6;
      uc = uc | (uint32_t)((signed int)b & 0x3F);
      if(charsNeeded >= 3u)
      {
        const char *tmp_post$2=buffer;
        buffer = buffer + 1ll;
        b = (uint8_t)*tmp_post$2;
        if(!((0xC0 & (signed int)b) == 0x80))
          return 516;

        uc = uc << 6;
        uc = uc | (uint32_t)((signed int)b & 0x3F);
        if(charsNeeded >= 4u)
        {
          const char *tmp_post$3=buffer;
          buffer = buffer + 1ll;
          b = (uint8_t)*tmp_post$3;
          if(!((0xC0 & (signed int)b) == 0x80))
            return 516;

          uc = uc << 6;
          uc = uc | (uint32_t)((signed int)b & 0x3F);
        }

      }

      if(uc >= 1114112u || !(4294912000u + uc >= 2048u) || !(uc >= min_uc))
        return 516;

      if(charsNeeded >= 4u)
      {
        signed int return_value_fprintf$1=fprintf(out, "\\u%04X\\u%04X", (uc >> 10) + 55232u, uc % 1024u + 56320u);
        if(!(return_value_fprintf$1 >= 0))
          return 4;

      }

      else
      {

      print_utf16:
        ;
        signed int return_value_fprintf$2=fprintf(out, "\\u%04X", uc);
        if(!(return_value_fprintf$2 >= 0))
          return 4;

      }
    }
  }
  while((_Bool)1);
  return 0;
}

// uxEventGroupGetNumber
// file ..\..\..\..\lib\FreeRTOS\event_groups.c line 708
UBaseType_t uxEventGroupGetNumber(void *xEventGroup)
{
  UBaseType_t xReturn;
  EventGroup_t *pxEventBits=(EventGroup_t *)xEventGroup;
  if(xEventGroup == NULL)
    xReturn = 0ul;

  else
    xReturn = pxEventBits->uxEventGroupNumber;
  return xReturn;
}

// uxGetMinimumFreeNetworkBuffers
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\BufferManagement\BufferAllocation_2.c line 354
UBaseType_t uxGetMinimumFreeNetworkBuffers(void)
{
  return (UBaseType_t)uxMinimumFreeNetworkBuffers;
}

// uxGetNumberOfFreeNetworkBuffers
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\BufferManagement\BufferAllocation_2.c line 348
UBaseType_t uxGetNumberOfFreeNetworkBuffers(void)
{
  return (&xFreeBuffersList)->uxNumberOfItems;
}

// uxListRemove
// file ..\..\..\..\lib\FreeRTOS\list.c line 170
UBaseType_t uxListRemove(ListItem_t * const pxItemToRemove)
{
  List_t * const pxList=(List_t *)pxItemToRemove->pvContainer;
  pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
  pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  if(pxList->pxIndex == pxItemToRemove)
    pxList->pxIndex = pxItemToRemove->pxPrevious;

  pxItemToRemove->pvContainer = NULL;
  pxList->uxNumberOfItems = pxList->uxNumberOfItems - 1ul;
  return pxList->uxNumberOfItems;
}

// uxQueueGetQueueNumber
// file ..\..\..\..\lib\FreeRTOS\queue.c line 1986
UBaseType_t uxQueueGetQueueNumber(QueueHandle_t xQueue)
{
  return ((Queue_t *)xQueue)->uxQueueNumber;
}

// uxQueueMessagesWaiting
// file ..\..\..\..\lib\FreeRTOS\queue.c line 1896
UBaseType_t uxQueueMessagesWaiting(const QueueHandle_t xQueue)
{
  UBaseType_t uxReturn;
  if(xQueue == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 1900u);

  vPortEnterCritical();
  uxReturn = ((Queue_t *)xQueue)->uxMessagesWaiting;
  vPortExitCritical();
  return uxReturn;
}

// uxQueueMessagesWaitingFromISR
// file ..\..\..\..\lib\FreeRTOS\queue.c line 1930
UBaseType_t uxQueueMessagesWaitingFromISR(const QueueHandle_t xQueue)
{
  UBaseType_t uxReturn;
  if(xQueue == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 1934u);

  uxReturn = ((Queue_t *)xQueue)->uxMessagesWaiting;
  return uxReturn;
}

// uxQueueSpacesAvailable
// file ..\..\..\..\lib\FreeRTOS\queue.c line 1912
UBaseType_t uxQueueSpacesAvailable(const QueueHandle_t xQueue)
{
  UBaseType_t uxReturn;
  Queue_t *pxQueue=(Queue_t *)xQueue;
  if(pxQueue == ((Queue_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 1918u);

  vPortEnterCritical();
  uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
  vPortExitCritical();
  return uxReturn;
}

// uxStreamBufferAdd
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Stream_Buffer.c line 47
size_t uxStreamBufferAdd(StreamBuffer_t *pxBuffer, size_t uxOffset, const uint8_t *pucData, size_t uxCount)
{
  size_t uxSpace;
  size_t uxNextHead;
  size_t uxFirst;
  uxSpace=uxStreamBufferGetSpace$link1(pxBuffer);
  if(!(uxOffset >= uxSpace))
    uxSpace = uxSpace - uxOffset;

  else
    uxSpace = 0ull;
  uint32_t return_value_FreeRTOS_min_uint32=FreeRTOS_min_uint32$link1((uint32_t)uxSpace, (uint32_t)uxCount);
  uxCount = (size_t)return_value_FreeRTOS_min_uint32;
  if(!(uxCount == 0ull))
  {
    uxNextHead = pxBuffer->uxHead;
    if(!(uxOffset == 0ull))
    {
      uxNextHead = uxNextHead + uxOffset;
      if(uxNextHead >= pxBuffer->LENGTH)
        uxNextHead = uxNextHead - pxBuffer->LENGTH;

    }

    if(!(pucData == ((const uint8_t *)NULL)))
    {
      uint32_t return_value_FreeRTOS_min_uint32$0=FreeRTOS_min_uint32$link1((uint32_t)(pxBuffer->LENGTH - uxNextHead), (uint32_t)uxCount);
      uxFirst = (size_t)return_value_FreeRTOS_min_uint32$0;
      memcpy((void *)(pxBuffer->ucArray + (signed long long int)uxNextHead), (const void *)pucData, uxFirst);
      if(!(uxFirst >= uxCount))
        memcpy((void *)pxBuffer->ucArray, (const void *)(pucData + (signed long long int)uxFirst), uxCount - uxFirst);

    }

    if(uxOffset == 0ull)
    {
      uxNextHead = uxNextHead + uxCount;
      if(uxNextHead >= pxBuffer->LENGTH)
        uxNextHead = uxNextHead - pxBuffer->LENGTH;

      pxBuffer->uxHead = uxNextHead;
    }

    BaseType_t return_value_xStreamBufferLessThenEqual=xStreamBufferLessThenEqual(pxBuffer, pxBuffer->uxFront, uxNextHead);
    if(!(return_value_xStreamBufferLessThenEqual == 0))
      pxBuffer->uxFront = uxNextHead;

  }

  return uxCount;
}

// uxStreamBufferDistance
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 114
static inline size_t uxStreamBufferDistance(const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper)
{
  size_t uxCount=(pxBuffer->LENGTH + uxUpper) - uxLower;
  if(uxCount >= pxBuffer->LENGTH)
    uxCount = uxCount - pxBuffer->LENGTH;

  return uxCount;
}

// uxStreamBufferDistance$link1
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 114
static inline size_t uxStreamBufferDistance$link1(const StreamBuffer_t *pxBuffer$link1, const size_t uxLower$link1, const size_t uxUpper$link1)
{
  size_t uxCount$link1=(pxBuffer$link1->LENGTH + uxUpper$link1) - uxLower$link1;
  if(uxCount$link1 >= pxBuffer$link1->LENGTH)
    uxCount$link1 = uxCount$link1 - pxBuffer$link1->LENGTH;

  return uxCount$link1;
}

// uxStreamBufferDistance$link2
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 114
static inline size_t uxStreamBufferDistance$link2(const StreamBuffer_t *pxBuffer$link2, const size_t uxLower$link2, const size_t uxUpper$link2)
{
  size_t uxCount$link2=(pxBuffer$link2->LENGTH + uxUpper$link2) - uxLower$link2;
  if(uxCount$link2 >= pxBuffer$link2->LENGTH)
    uxCount$link2 = uxCount$link2 - pxBuffer$link2->LENGTH;

  return uxCount$link2;
}

// uxStreamBufferDistance$link3
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 114
static inline size_t uxStreamBufferDistance$link3(const StreamBuffer_t *pxBuffer$link3, const size_t uxLower$link3, const size_t uxUpper$link3)
{
  size_t uxCount$link3=(pxBuffer$link3->LENGTH + uxUpper$link3) - uxLower$link3;
  if(uxCount$link3 >= pxBuffer$link3->LENGTH)
    uxCount$link3 = uxCount$link3 - pxBuffer$link3->LENGTH;

  return uxCount$link3;
}

// uxStreamBufferDistance$link4
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_Stream_Buffer.h line 114
static inline size_t uxStreamBufferDistance$link4(const StreamBuffer_t *pxBuffer$link4, const size_t uxLower$link4, const size_t uxUpper$link4)
{
  size_t uxCount$link4=(pxBuffer$link4->LENGTH + uxUpper$link4) - uxLower$link4;
  if(uxCount$link4 >= pxBuffer$link4->LENGTH)
    uxCount$link4 = uxCount$link4 - pxBuffer$link4->LENGTH;

  return uxCount$link4;
}

// uxStreamBufferFrontSpace
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 146
static inline size_t uxStreamBufferFrontSpace(const StreamBuffer_t *pxBuffer)
{
  size_t uxFront=pxBuffer->uxFront;
  size_t uxTail=pxBuffer->uxTail;
  size_t return_value_uxStreamBufferSpace=uxStreamBufferSpace(pxBuffer, uxFront, uxTail);
  return return_value_uxStreamBufferSpace;
}

// uxStreamBufferFrontSpace$link1
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 146
static inline size_t uxStreamBufferFrontSpace$link1(const StreamBuffer_t *pxBuffer$link1)
{
  size_t uxFront$link1=pxBuffer$link1->uxFront;
  size_t uxTail$link1=pxBuffer$link1->uxTail;
  size_t return_value_uxStreamBufferSpace$link1=uxStreamBufferSpace$link2(pxBuffer$link1, uxFront$link1, uxTail$link1);
  return return_value_uxStreamBufferSpace$link1;
}

// uxStreamBufferGet
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Stream_Buffer.c line 130
size_t uxStreamBufferGet( StreamBuffer_t *pxBuffer, size_t uxOffset, uint8_t *pucData, size_t uxMaxCount, BaseType_t xPeek)
{
  size_t uxSize;
  size_t uxCount;
  size_t uxFirst;
  size_t uxNextTail;
  uxSize=uxStreamBufferGetSize$link1(pxBuffer);
  if(!(uxOffset >= uxSize))
    uxSize = uxSize - uxOffset;

  else
    uxSize = 0ull;
  uint32_t return_value_FreeRTOS_min_uint32=FreeRTOS_min_uint32$link1((uint32_t)uxSize, (uint32_t)uxMaxCount);
  uxCount = (size_t)return_value_FreeRTOS_min_uint32;
  if(uxCount >= 1ull)
  {
    uxNextTail = pxBuffer->uxTail;
    if(!(uxOffset == 0ull))
    {
      uxNextTail = uxNextTail + uxOffset;
      if(uxNextTail >= pxBuffer->LENGTH)
        uxNextTail = uxNextTail - pxBuffer->LENGTH;

    }

    if(!(pucData == ((uint8_t *)NULL)))
    {
      uint32_t return_value_FreeRTOS_min_uint32$0=FreeRTOS_min_uint32$link1((uint32_t)(pxBuffer->LENGTH - uxNextTail), (uint32_t)uxCount);
      uxFirst = (size_t)return_value_FreeRTOS_min_uint32$0;
      memcpy((void *)pucData, (const void *)(pxBuffer->ucArray + (signed long long int)uxNextTail), uxFirst);
      if(!(uxFirst >= uxCount))
        memcpy((void *)(pucData + (signed long long int)uxFirst), (const void *)pxBuffer->ucArray, uxCount - uxFirst);

    }

    if(xPeek == 0 && uxOffset == 0ull)
    {
      uxNextTail = uxNextTail + uxCount;
      if(uxNextTail >= pxBuffer->LENGTH)
        uxNextTail = uxNextTail - pxBuffer->LENGTH;

      pxBuffer->uxTail = uxNextTail;
    }

  }

  return uxCount;
}

// uxStreamBufferGetPtr
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 283
static inline size_t uxStreamBufferGetPtr(const StreamBuffer_t *pxBuffer, uint8_t **ppucData)
{
  size_t uxNextTail=pxBuffer->uxTail;
  size_t uxSize=uxStreamBufferGetSize(pxBuffer);
  *ppucData = pxBuffer->ucArray + (signed long long int)uxNextTail;
  uint32_t return_value_FreeRTOS_min_uint32=FreeRTOS_min_uint32((uint32_t)uxSize, (uint32_t)(pxBuffer->LENGTH - uxNextTail));
  return (size_t)return_value_FreeRTOS_min_uint32;
}

// uxStreamBufferGetSize
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 162
static inline size_t uxStreamBufferGetSize(const StreamBuffer_t *pxBuffer)
{
  size_t uxHead=pxBuffer->uxHead;
  size_t uxTail=pxBuffer->uxTail;
  size_t return_value_uxStreamBufferDistance=uxStreamBufferDistance(pxBuffer, uxTail, uxHead);
  return return_value_uxStreamBufferDistance;
}

// uxStreamBufferGetSize$link1
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 162
static inline size_t uxStreamBufferGetSize$link1(const StreamBuffer_t *pxBuffer$link1)
{
  size_t uxHead$link1=pxBuffer$link1->uxHead;
  size_t uxTail$link1=pxBuffer$link1->uxTail;
  size_t return_value_uxStreamBufferDistance$link1=uxStreamBufferDistance$link1(pxBuffer$link1, uxTail$link1, uxHead$link1);
  return return_value_uxStreamBufferDistance$link1;
}

// uxStreamBufferGetSize$link2
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 162
static inline size_t uxStreamBufferGetSize$link2(const StreamBuffer_t *pxBuffer$link2)
{
  size_t uxHead$link2=pxBuffer$link2->uxHead;
  size_t uxTail$link2=pxBuffer$link2->uxTail;
  size_t return_value_uxStreamBufferDistance$link2=uxStreamBufferDistance$link3(pxBuffer$link2, uxTail$link2, uxHead$link2);
  return return_value_uxStreamBufferDistance$link2;
}

// uxStreamBufferGetSize$link3
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_Stream_Buffer.h line 162
static inline size_t uxStreamBufferGetSize$link3(const StreamBuffer_t *pxBuffer$link3)
{
  size_t uxHead$link3=pxBuffer$link3->uxHead;
  size_t uxTail$link3=pxBuffer$link3->uxTail;
  size_t return_value_uxStreamBufferDistance$link3=uxStreamBufferDistance$link4(pxBuffer$link3, uxTail$link3, uxHead$link3);
  return return_value_uxStreamBufferDistance$link3;
}

// uxStreamBufferGetSpace
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 132
static inline size_t uxStreamBufferGetSpace(const StreamBuffer_t *pxBuffer)
{
  size_t uxHead=pxBuffer->uxHead;
  size_t uxTail=pxBuffer->uxTail;
  size_t return_value_uxStreamBufferSpace=uxStreamBufferSpace(pxBuffer, uxHead, uxTail);
  return return_value_uxStreamBufferSpace;
}

// uxStreamBufferGetSpace$link1
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 132
static inline size_t uxStreamBufferGetSpace$link1(const StreamBuffer_t *pxBuffer$link1)
{
  size_t uxHead$link1=pxBuffer$link1->uxHead;
  size_t uxTail$link1=pxBuffer$link1->uxTail;
  size_t return_value_uxStreamBufferSpace$link1=uxStreamBufferSpace$link1(pxBuffer$link1, uxHead$link1, uxTail$link1);
  return return_value_uxStreamBufferSpace$link1;
}

// uxStreamBufferGetSpace$link2
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 132
static inline size_t uxStreamBufferGetSpace$link2(const StreamBuffer_t *pxBuffer$link2)
{
  size_t uxHead$link2=pxBuffer$link2->uxHead;
  size_t uxTail$link2=pxBuffer$link2->uxTail;
  size_t return_value_uxStreamBufferSpace$link2=uxStreamBufferSpace$link2(pxBuffer$link2, uxHead$link2, uxTail$link2);
  return return_value_uxStreamBufferSpace$link2;
}

// uxStreamBufferGetSpace$link3
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 132
static inline size_t uxStreamBufferGetSpace$link3(const StreamBuffer_t *pxBuffer$link3)
{
  size_t uxHead$link3=pxBuffer$link3->uxHead;
  size_t uxTail$link3=pxBuffer$link3->uxTail;
  size_t return_value_uxStreamBufferSpace$link3=uxStreamBufferSpace$link3(pxBuffer$link3, uxHead$link3, uxTail$link3);
  return return_value_uxStreamBufferSpace$link3;
}

// uxStreamBufferGetSpace$link4
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_Stream_Buffer.h line 132
static inline size_t uxStreamBufferGetSpace$link4(const StreamBuffer_t *pxBuffer$link4)
{
  size_t uxHead$link4=pxBuffer$link4->uxHead;
  size_t uxTail$link4=pxBuffer$link4->uxTail;
  size_t return_value_uxStreamBufferSpace$link4=uxStreamBufferSpace$link4(pxBuffer$link4, uxHead$link4, uxTail$link4);
  return return_value_uxStreamBufferSpace$link4;
}

// uxStreamBufferGetStreamBufferNumber
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 1173
UBaseType_t uxStreamBufferGetStreamBufferNumber(StreamBufferHandle_t xStreamBuffer)
{
  return ((StreamBuffer_t1 *)xStreamBuffer)->uxStreamBufferNumber;
}

// uxStreamBufferMidSpace
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 177
static inline size_t uxStreamBufferMidSpace(const StreamBuffer_t *pxBuffer)
{
  size_t uxHead=pxBuffer->uxHead;
  size_t uxMid=pxBuffer->uxMid;
  size_t return_value_uxStreamBufferDistance=uxStreamBufferDistance$link2(pxBuffer, uxMid, uxHead);
  return return_value_uxStreamBufferDistance;
}

// uxStreamBufferSpace
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 95
static inline size_t uxStreamBufferSpace(const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper)
{
  size_t uxCount=((pxBuffer->LENGTH + uxUpper) - uxLower) - 1ull;
  if(uxCount >= pxBuffer->LENGTH)
    uxCount = uxCount - pxBuffer->LENGTH;

  return uxCount;
}

// uxStreamBufferSpace$link1
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 95
static inline size_t uxStreamBufferSpace$link1(const StreamBuffer_t *pxBuffer$link1, const size_t uxLower$link1, const size_t uxUpper$link1)
{
  size_t uxCount$link1=((pxBuffer$link1->LENGTH + uxUpper$link1) - uxLower$link1) - 1ull;
  if(uxCount$link1 >= pxBuffer$link1->LENGTH)
    uxCount$link1 = uxCount$link1 - pxBuffer$link1->LENGTH;

  return uxCount$link1;
}

// uxStreamBufferSpace$link2
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 95
static inline size_t uxStreamBufferSpace$link2(const StreamBuffer_t *pxBuffer$link2, const size_t uxLower$link2, const size_t uxUpper$link2)
{
  size_t uxCount$link2=((pxBuffer$link2->LENGTH + uxUpper$link2) - uxLower$link2) - 1ull;
  if(uxCount$link2 >= pxBuffer$link2->LENGTH)
    uxCount$link2 = uxCount$link2 - pxBuffer$link2->LENGTH;

  return uxCount$link2;
}

// uxStreamBufferSpace$link3
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 95
static inline size_t uxStreamBufferSpace$link3(const StreamBuffer_t *pxBuffer$link3, const size_t uxLower$link3, const size_t uxUpper$link3)
{
  size_t uxCount$link3=((pxBuffer$link3->LENGTH + uxUpper$link3) - uxLower$link3) - 1ull;
  if(uxCount$link3 >= pxBuffer$link3->LENGTH)
    uxCount$link3 = uxCount$link3 - pxBuffer$link3->LENGTH;

  return uxCount$link3;
}

// uxStreamBufferSpace$link4
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\include\FreeRTOS_Stream_Buffer.h line 95
static inline size_t uxStreamBufferSpace$link4(const StreamBuffer_t *pxBuffer$link4, const size_t uxLower$link4, const size_t uxUpper$link4)
{
  size_t uxCount$link4=((pxBuffer$link4->LENGTH + uxUpper$link4) - uxLower$link4) - 1ull;
  if(uxCount$link4 >= pxBuffer$link4->LENGTH)
    uxCount$link4 = uxCount$link4 - pxBuffer$link4->LENGTH;

  return uxCount$link4;
}

// uxTaskGetNumberOfTasks
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 2318
UBaseType_t uxTaskGetNumberOfTasks(void)
{
  return uxCurrentNumberOfTasks;
}

// uxTaskGetStackHighWaterMark
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3719
UBaseType_t uxTaskGetStackHighWaterMark(TaskHandle_t xTask)
{
  TCB_t *pxTCB;
  uint8_t *pucEndOfStack;
  UBaseType_t uxReturn;
  pxTCB = xTask == NULL ? (TCB_t *)pxCurrentTCB : (TCB_t *)xTask;
  pucEndOfStack = (uint8_t *)pxTCB->pxStack;
  uint16_t return_value_prvTaskCheckFreeStackSpace=prvTaskCheckFreeStackSpace(pucEndOfStack);
  uxReturn = (UBaseType_t)return_value_prvTaskCheckFreeStackSpace;
  return uxReturn;
}

// uxTaskGetSystemState
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 2466
UBaseType_t uxTaskGetSystemState(TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime)
{
  UBaseType_t uxTask=0ul;
  UBaseType_t uxQueue=7ul;
  vTaskSuspendAll();
  if(uxArraySize >= uxCurrentNumberOfTasks)
  {
    do
    {
      uxQueue = uxQueue - 1ul;
      UBaseType_t return_value_prvListTasksWithinSingleList=prvListTasksWithinSingleList(&pxTaskStatusArray[(signed long long int)uxTask], &pxReadyTasksLists[(signed long long int)uxQueue], /*enum*/eReady);
      uxTask = uxTask + return_value_prvListTasksWithinSingleList;
    }
    while(uxQueue >= 1u);
    UBaseType_t return_value_prvListTasksWithinSingleList$0=prvListTasksWithinSingleList(&pxTaskStatusArray[(signed long long int)uxTask], (List_t *)pxDelayedTaskList, /*enum*/eBlocked);
    uxTask = uxTask + return_value_prvListTasksWithinSingleList$0;
    UBaseType_t return_value_prvListTasksWithinSingleList$1=prvListTasksWithinSingleList(&pxTaskStatusArray[(signed long long int)uxTask], (List_t *)pxOverflowDelayedTaskList, /*enum*/eBlocked);
    uxTask = uxTask + return_value_prvListTasksWithinSingleList$1;
    UBaseType_t return_value_prvListTasksWithinSingleList$2=prvListTasksWithinSingleList(&pxTaskStatusArray[(signed long long int)uxTask], &xTasksWaitingTermination, /*enum*/eDeleted);
    uxTask = uxTask + return_value_prvListTasksWithinSingleList$2;
    UBaseType_t return_value_prvListTasksWithinSingleList$3=prvListTasksWithinSingleList(&pxTaskStatusArray[(signed long long int)uxTask], &xSuspendedTaskList, /*enum*/eSuspended);
    uxTask = uxTask + return_value_prvListTasksWithinSingleList$3;
    if(!(pulTotalRunTime == ((uint32_t *)NULL)))
      *pulTotalRunTime=ulGetRunTimeCounterValue();

  }

  xTaskResumeAll();
  return uxTask;
}

// uxTaskGetTaskNumber
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3248
UBaseType_t uxTaskGetTaskNumber(TaskHandle_t xTask)
{
  UBaseType_t uxReturn;
  TCB_t *pxTCB;
  if(!(xTask == NULL))
  {
    pxTCB = (TCB_t *)xTask;
    uxReturn = pxTCB->uxTaskNumber;
  }

  else
    uxReturn = 0u;
  return uxReturn;
}

// uxTaskPriorityGet
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 1415
UBaseType_t uxTaskPriorityGet(TaskHandle_t xTask)
{
  TCB_t *pxTCB;
  UBaseType_t uxReturn;
  vPortEnterCritical();
  pxTCB = xTask == NULL ? (TCB_t *)pxCurrentTCB : (TCB_t *)xTask;
  uxReturn = pxTCB->uxPriority;
  vPortExitCritical();
  return uxReturn;
}

// uxTaskPriorityGetFromISR
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 1437
UBaseType_t uxTaskPriorityGetFromISR(TaskHandle_t xTask)
{
  TCB_t *pxTCB;
  UBaseType_t uxReturn;
  UBaseType_t uxSavedInterruptState;
  uxSavedInterruptState = 0ul;
  pxTCB = xTask == NULL ? (TCB_t *)pxCurrentTCB : (TCB_t *)xTask;
  uxReturn = pxTCB->uxPriority;
  (void)uxSavedInterruptState;
  return uxReturn;
}

// uxTaskResetEventItemValue
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 4453
TickType_t uxTaskResetEventItemValue(void)
{
  TickType_t uxReturn=(&pxCurrentTCB->xEventListItem)->xItemValue;
  (&pxCurrentTCB->xEventListItem)->xItemValue = 7u - (TickType_t)pxCurrentTCB->uxPriority;
  return uxReturn;
}

// uxTimerGetTimerNumber
// file ..\..\..\..\lib\FreeRTOS\timers.c line 1052
UBaseType_t uxTimerGetTimerNumber(TimerHandle_t xTimer)
{
  return ((Timer_t *)xTimer)->uxTimerNumber;
}

// vARPAgeCache
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_ARP.c line 493
void vARPAgeCache(void)
{
  BaseType_t x;
  TickType_t xTimeNow;
  x = 0;
  for( ; !(x >= 6); x = x + 1l)
    if((unsigned int)xARPCache[(signed long long int)x].ucAge >= 1u)
    {
      xARPCache[(signed long long int)x].ucAge = xARPCache[(signed long long int)x].ucAge - 1;
      if(xARPCache[(signed long long int)x].ucValid == 0)
        FreeRTOS_OutputARPRequest(xARPCache[(signed long long int)x].ulIPAddress);

      else
        if(!((signed int)xARPCache[(signed long long int)x].ucAge >= 4))
          FreeRTOS_OutputARPRequest(xARPCache[(signed long long int)x].ulIPAddress);

      if((unsigned int)xARPCache[(signed long long int)x].ucAge == 0u)
        xARPCache[(signed long long int)x].ulIPAddress = 0ul;

    }

  xTimeNow=xTaskGetTickCount();
  if(xLastGratuitousARPTime == 0u || xTimeNow + -xLastGratuitousARPTime >= 20001u)
  {
    FreeRTOS_OutputARPRequest(*((uint32_t *)&xDefaultPartUDPPacketHeader.ulWords[(signed long long int)(20ull / sizeof(uint32_t) /*4ull*/ )]));
    xLastGratuitousARPTime = xTimeNow;
  }

}

// vARPGenerateRequestPacket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_ARP.c line 588
void vARPGenerateRequestPacket(NetworkBufferDescriptor_t * const pxNetworkBuffer)
{
  ARPPacket_t *pxARPPacket=(ARPPacket_t *)pxNetworkBuffer->pucEthernetBuffer;
  memcpy((void *)pxARPPacket, (void *)xDefaultPartARPPacketHeader, sizeof(const uint8_t [38ll]) /*38ull*/ );
  memcpy((void *)pxARPPacket->xEthernetHeader.xSourceAddress.ucBytes, (void *)xDefaultPartUDPPacketHeader.ucBytes, 6ull);
  memcpy((void *)pxARPPacket->xARPHeader.xSenderHardwareAddress.ucBytes, (void *)xDefaultPartUDPPacketHeader.ucBytes, 6ull);
  memcpy((void *)pxARPPacket->xARPHeader.ucSenderProtocolAddress, (void *)(uint32_t *)&xDefaultPartUDPPacketHeader.ulWords[(signed long long int)(20ull / sizeof(uint32_t) /*4ull*/ )], sizeof(uint8_t [4ll]) /*4ull*/ );
  pxARPPacket->xARPHeader.ulTargetProtocolAddress = pxNetworkBuffer->ulIPAddress;
  pxNetworkBuffer->xDataLength = sizeof(ARPPacket_t) /*42ull*/ ;
}

// vARPRefreshCacheEntry
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_ARP.c line 212
void vARPRefreshCacheEntry(const MACAddress_t *pxMACAddress, const uint32_t ulIPAddress)
{
  BaseType_t x=0;
  BaseType_t xIpEntry=-1;
  BaseType_t xMacEntry=-1;
  BaseType_t xUseEntry=0;
  uint8_t ucMinAgeFound=0;
  _Bool tmp_if_expr$0;
  if((xNetworkAddressing.ulNetMask & ulIPAddress) == (xDefaultPartUDPPacketHeader.ulWords[5ll] & xNetworkAddressing.ulNetMask))
    tmp_if_expr$0 = (_Bool)1;

  else
    tmp_if_expr$0 = *((uint32_t *)&xDefaultPartUDPPacketHeader.ulWords[(signed long long int)(20ull / sizeof(uint32_t) /*4ull*/ )]) == 0ul ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr;
  signed int return_value_memcmp$0;
  if(tmp_if_expr$0)
  {
    ucMinAgeFound = ucMinAgeFound - 1;
    x = 0;
    for( ; !(x >= 6); x = x + 1l)
      if(xARPCache[(signed long long int)x].ulIPAddress == ulIPAddress)
      {
        if(pxMACAddress == ((const MACAddress_t *)NULL))
        {
          xIpEntry = x;
          break;
        }

        signed int return_value_memcmp=memcmp((const void *)xARPCache[(signed long long int)x].xMACAddress.ucBytes, (const void *)pxMACAddress->ucBytes, sizeof(uint8_t [6ll]) /*6ull*/ );
        if(return_value_memcmp == 0)
        {
          xARPCache[(signed long long int)x].ucAge = 150;
          xARPCache[(signed long long int)x].ucValid = 1;
          goto __CPROVER_DUMP_L22;
        }

        xIpEntry = x;
      }

      else
      {
        if(!(pxMACAddress == ((const MACAddress_t *)NULL)))
        {
          return_value_memcmp$0=memcmp((const void *)xARPCache[(signed long long int)x].xMACAddress.ucBytes, (const void *)pxMACAddress->ucBytes, sizeof(uint8_t [6ll]) /*6ull*/ );
          tmp_if_expr = return_value_memcmp$0 == 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr = (_Bool)0;
        if(tmp_if_expr)
          xMacEntry = x;

        else
          if(!((signed int)xARPCache[(signed long long int)x].ucAge >= (signed int)ucMinAgeFound))
          {
            ucMinAgeFound = xARPCache[(signed long long int)x].ucAge;
            xUseEntry = x;
          }

      }
    if(xMacEntry >= 0)
    {
      xUseEntry = xMacEntry;
      if(xIpEntry >= 0)
        memset((void *)&xARPCache[(signed long long int)xIpEntry], 0, sizeof(ARPCacheRow_t) /*12ull*/ );

    }

    else
      if(xIpEntry >= 0)
        xUseEntry = xIpEntry;

    xARPCache[(signed long long int)xUseEntry].ulIPAddress = ulIPAddress;
    if(!(pxMACAddress == ((const MACAddress_t *)NULL)))
    {
      memcpy((void *)xARPCache[(signed long long int)xUseEntry].xMACAddress.ucBytes, (const void *)pxMACAddress->ucBytes, sizeof(uint8_t [6ll]) /*6ull*/ );
      xARPCache[(signed long long int)xUseEntry].ucAge = 150;
      xARPCache[(signed long long int)xUseEntry].ucValid = 1;
    }

    else
      if(!(xIpEntry >= 0))
      {
        xARPCache[(signed long long int)xUseEntry].ucAge = 5;
        xARPCache[(signed long long int)xUseEntry].ucValid = 0;
      }

  }


__CPROVER_DUMP_L22:
  ;
}

// vARPSendGratuitous
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_ARP.c line 545
void vARPSendGratuitous(void)
{
  xLastGratuitousARPTime = 0u;
  xSendEventToIPTask(/*enum*/eARPTimerEvent);
}

// vAlternateKeyProvisioning
// file ..\..\..\common\devmode_key_provisioning\aws_dev_mode_key_provisioning.c line 100
void vAlternateKeyProvisioning(ProvisioningParams_t *xParams)
{
  CK_RV xResult=0ul;
  CK_FUNCTION_LIST_PTR pxFunctionList=((CK_FUNCTION_LIST_PTR)NULL);
  CK_SLOT_ID xSlotId=0ul;
  CK_SESSION_HANDLE xSession=0ul;
  CK_OBJECT_HANDLE xObject=0ul;
  CK_OBJECT_CLASS xPrivateKeyClass=0x3ul;
  CK_OBJECT_CLASS xCertificateClass=0x1ul;
  CK_OBJECT_CLASS xDeviceCertificateType=1ul;
  CK_OBJECT_CLASS xRootCertificateType=2ul;
  CK_KEY_TYPE xPrivateKeyType=(CK_KEY_TYPE)xParams->ulClientPrivateKeyType;
  CK_BBOOL xCanSign=1;
  CK_ATTRIBUTE xPrivateKeyTemplate[4ll];
  CK_ATTRIBUTE xCertificateTemplate[3ll];
  CK_ATTRIBUTE xRootCertificateTemplate[3ll];
  vLoggingPrintf("Starting key provisioning...\r\n");
  xPrivateKeyTemplate[0ll].type = 0x0ul;
  xPrivateKeyTemplate[0ll].pValue = (CK_VOID_PTR)&xPrivateKeyClass;
  xPrivateKeyTemplate[0ll].ulValueLen = (CK_ULONG)sizeof(CK_OBJECT_CLASS) /*4ul*/ ;
  xPrivateKeyTemplate[1ll].type = 0x100ul;
  xPrivateKeyTemplate[1ll].pValue = (CK_VOID_PTR)&xPrivateKeyType;
  xPrivateKeyTemplate[1ll].ulValueLen = (CK_ULONG)sizeof(CK_KEY_TYPE) /*4ul*/ ;
  xPrivateKeyTemplate[2ll].type = 0x108ul;
  xPrivateKeyTemplate[2ll].pValue = (CK_VOID_PTR)&xCanSign;
  xPrivateKeyTemplate[2ll].ulValueLen = (CK_ULONG)sizeof(CK_BBOOL) /*1ul*/ ;
  xPrivateKeyTemplate[3ll].type = 0x11ul;
  xPrivateKeyTemplate[3ll].pValue = (CK_VOID_PTR)xParams->pcClientPrivateKey;
  xPrivateKeyTemplate[3ll].ulValueLen = (CK_ULONG)xParams->ulClientPrivateKeyLength;
  xCertificateTemplate[0ll].type = 0x0ul;
  xCertificateTemplate[0ll].pValue = (CK_VOID_PTR)&xCertificateClass;
  xCertificateTemplate[0ll].ulValueLen = (CK_ULONG)sizeof(CK_OBJECT_CLASS) /*4ul*/ ;
  xCertificateTemplate[1ll].type = 0x11ul;
  xCertificateTemplate[1ll].pValue = (CK_VOID_PTR)xParams->pcClientCertificate;
  xCertificateTemplate[1ll].ulValueLen = (CK_ULONG)xParams->ulClientCertificateLength;
  xCertificateTemplate[2ll].type = 0x80ul;
  xCertificateTemplate[2ll].pValue = (CK_VOID_PTR)&xDeviceCertificateType;
  xCertificateTemplate[2ll].ulValueLen = (CK_ULONG)sizeof(CK_OBJECT_CLASS) /*4ul*/ ;
  xRootCertificateTemplate[0ll].type = 0x0ul;
  xRootCertificateTemplate[0ll].pValue = (CK_VOID_PTR)&xCertificateClass;
  xRootCertificateTemplate[0ll].ulValueLen = (CK_ULONG)sizeof(CK_OBJECT_CLASS) /*4ul*/ ;
  xRootCertificateTemplate[1ll].type = 0x11ul;
  xRootCertificateTemplate[1ll].pValue = (CK_VOID_PTR)tlsVERISIGN_ROOT_CERTIFICATE_PEM$link1;
  xRootCertificateTemplate[1ll].ulValueLen = (CK_ULONG)tlsVERISIGN_ROOT_CERTIFICATE_LENGTH$link1;
  xRootCertificateTemplate[2ll].type = 0x80ul;
  xRootCertificateTemplate[2ll].pValue = (CK_VOID_PTR)&xRootCertificateType;
  xRootCertificateTemplate[2ll].ulValueLen = (CK_ULONG)sizeof(CK_OBJECT_CLASS) /*4ul*/ ;
  xResult=prvInitialize(&pxFunctionList, &xSlotId, &xSession);
  if(xResult == 0u)
  {
    vLoggingPrintf("Write root certificate...\r\n");
    xResult=pxFunctionList->C_CreateObject(xSession, xRootCertificateTemplate, (CK_ULONG)(sizeof(CK_ATTRIBUTE [3ll]) /*72ull*/  / sizeof(CK_ATTRIBUTE) /*24ull*/ ), &xObject);
  }

  if(xResult == 0u)
  {
    xResult=pxFunctionList->C_DestroyObject(xSession, xObject);
    xObject = 0ul;
  }

  if(xResult == 0u)
  {
    vLoggingPrintf("Write device private key...\r\n");
    xResult=pxFunctionList->C_CreateObject(xSession, xPrivateKeyTemplate, (CK_ULONG)(sizeof(CK_ATTRIBUTE [4ll]) /*96ull*/  / sizeof(CK_ATTRIBUTE) /*24ull*/ ), &xObject);
  }

  if(xResult == 0u)
  {
    xResult=pxFunctionList->C_DestroyObject(xSession, xObject);
    xObject = 0ul;
  }

  if(xResult == 0u)
  {
    vLoggingPrintf("Write device certificate...\r\n");
    xResult=pxFunctionList->C_CreateObject(xSession, xCertificateTemplate, (CK_ULONG)(sizeof(CK_ATTRIBUTE [3ll]) /*72ull*/  / sizeof(CK_ATTRIBUTE) /*24ull*/ ), &xObject);
  }

  if(xResult == 0u)
  {
    xResult=pxFunctionList->C_DestroyObject(xSession, xObject);
    xObject = 0ul;
  }

  vLoggingPrintf("Key provisioning done...\r\n");
}

// vApplicationGetIdleTaskMemory
// file ..\common\application_code\main.c line 405
void vApplicationGetIdleTaskMemory(StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize)
{
  static StaticTask_t xIdleTaskTCB;
  *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
  static StackType_t uxIdleTaskStack[60ll];
  *ppxIdleTaskStackBuffer = uxIdleTaskStack;
  *pulIdleTaskStackSize = 60u;
}

// vApplicationGetTimerTaskMemory
// file ..\common\application_code\main.c line 432
void vApplicationGetTimerTaskMemory(StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize)
{
  static StaticTask_t xTimerTaskTCB;
  *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
  static StackType_t uxTimerTaskStack[120ll];
  *ppxTimerTaskStackBuffer = uxTimerTaskStack;
  *pulTimerTaskStackSize = (uint32_t)(60 * 2);
}

// vApplicationIPNetworkEventHook
// file ..\common\application_code\main.c line 199
void vApplicationIPNetworkEventHook(eIPCallbackEvent_t eNetworkEvent)
{
  uint32_t ulIPAddress;
  uint32_t ulNetMask;
  uint32_t ulGatewayAddress;
  uint32_t ulDNSServerAddress;
  char cBuffer[16ll];
  if((signed int)eNetworkEvent == 0)
  {
    static BaseType_t xTasksAlreadyCreated=0;
    if(xTasksAlreadyCreated == 0)
    {
      vDevModeKeyProvisioning();
      SYSTEM_Init();
      DEMO_RUNNER_RunDemos();
      xTasksAlreadyCreated = 1;
    }

    FreeRTOS_GetAddressConfiguration(&ulIPAddress, &ulNetMask, &ulGatewayAddress, &ulDNSServerAddress);
    sprintf((char *)cBuffer, "%u.%u.%u.%u", (unsigned int)(ulIPAddress & 0xFFul), (unsigned int)(ulIPAddress >> 8 & 0xFFul), (unsigned int)(ulIPAddress >> 16 & 0xFFul), (unsigned int)(ulIPAddress >> 24));
    vLoggingPrintf("\r\n\r\nIP Address: %s\r\n", (const void *)cBuffer);
    sprintf((char *)cBuffer, "%u.%u.%u.%u", (unsigned int)(ulNetMask & 0xFFul), (unsigned int)(ulNetMask >> 8 & 0xFFul), (unsigned int)(ulNetMask >> 16 & 0xFFul), (unsigned int)(ulNetMask >> 24));
    vLoggingPrintf("Subnet Mask: %s\r\n", (const void *)cBuffer);
    sprintf((char *)cBuffer, "%u.%u.%u.%u", (unsigned int)(ulGatewayAddress & 0xFFul), (unsigned int)(ulGatewayAddress >> 8 & 0xFFul), (unsigned int)(ulGatewayAddress >> 16 & 0xFFul), (unsigned int)(ulGatewayAddress >> 24));
    vLoggingPrintf("Gateway Address: %s\r\n", (const void *)cBuffer);
    sprintf((char *)cBuffer, "%u.%u.%u.%u", (unsigned int)(ulDNSServerAddress & 0xFFul), (unsigned int)(ulDNSServerAddress >> 8 & 0xFFul), (unsigned int)(ulDNSServerAddress >> 16 & 0xFFul), (unsigned int)(ulDNSServerAddress >> 24));
    vLoggingPrintf("DNS Server Address: %s\r\n\r\n\r\n", (const void *)cBuffer);
  }

}

// vApplicationIdleHook
// file ..\common\application_code\main.c line 330
void vApplicationIdleHook(void)
{
  const uint32_t ulMSToSleep=1u;
  const TickType_t xKitHitCheckPeriod=(TickType_t)((1000ul * 1000u) / 1000u);
  static TickType_t xTimeNow;
  xTimeNow=xTaskGetTickCount();
  static TickType_t xLastTimeCheck=0u;
  if(!(xKitHitCheckPeriod >= xTimeNow + -xLastTimeCheck))
  {
    signed int return_value__kbhit=_kbhit();
    if(!(return_value__kbhit == 0))
    {
      if(xTraceRunning == 1)
      {
        xTraceRunning = 0;
        vTraceStop();
        prvSaveTraceFile();
      }

    }

    xLastTimeCheck = xTimeNow;
  }

  Sleep(ulMSToSleep);
}

// vApplicationMallocFailedHook
// file ..\common\application_code\main.c line 258
void vApplicationMallocFailedHook()
{
  vPortEnterCritical();
  while((_Bool)1)
    ;
}

// vAssertCalled
// file ..\common\application_code\main.c line 375
extern void vAssertCalled(const char *pcFile, uint32_t ulLine)
{
  const uint32_t ulLongSleep=1000ul;
  volatile uint32_t ulBlockVariable=0ul;
  volatile char *pcFileName=(volatile char *)pcFile;
  volatile uint32_t ulLineNumber=ulLine;
  (void)pcFileName;
  (void)ulLineNumber;
  printf("vAssertCalled %s, %ld\n", pcFile, (signed long int)ulLine);
  FILE *return_value___acrt_iob_func=__acrt_iob_func(1u);
  fflush(return_value___acrt_iob_func);
  vPortEnterCritical();
  while(ulBlockVariable == 0ul)
    Sleep(ulLongSleep);
  vPortExitCritical();
}

// vConfigureTimerForRunTimeStats
// file ..\common\application_code\aws_run-time-stats-utils.c line 48
void vConfigureTimerForRunTimeStats(void)
{
  LARGE_INTEGER liPerformanceCounterFrequency;
  LARGE_INTEGER liInitialRunTimeValue;
  BOOL return_value_QueryPerformanceFrequency=QueryPerformanceFrequency(&liPerformanceCounterFrequency);
  if(return_value_QueryPerformanceFrequency == 0)
    llTicksPerHundedthMillisecond = 1ll;

  else
  {
    llTicksPerHundedthMillisecond = liPerformanceCounterFrequency.QuadPart / 100000ll;
    QueryPerformanceCounter(&liInitialRunTimeValue);
    llInitialRunTimeCounterValue = liInitialRunTimeValue.QuadPart;
  }
}

// vDHCPProcess
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DHCP.c line 263
void vDHCPProcess(BaseType_t xReset)
{
  BaseType_t xGivingUp=0;
  if(!(xReset == 0))
    xDHCPData.eDHCPState = /*enum*/eWaitingSendFirstDiscover;

  TickType_t return_value_xTaskGetTickCount;
  BaseType_t return_value_prvProcessDHCPReplies$0;
  switch((signed int)xDHCPData.eDHCPState)
  {
    case 0:
    {
      prvInitialiseDHCP();
      if(xDHCPData.xDHCPSocket == NULL)
      {
        xGivingUp = 1;
        break;
      }

      *((uint32_t *)&xDefaultPartUDPPacketHeader.ulWords[(signed long long int)(20ull / sizeof(uint32_t) /*4ull*/ )]) = 0ul;
      if(!(xDHCPData.xDHCPSocket == NULL))
      {
        xDHCPData.xDHCPTxTime=xTaskGetTickCount();
        prvSendDHCPDiscover();
        xDHCPData.eDHCPState = /*enum*/eWaitingOffer;
      }

      break;
    }
    case 1:
    {
      xGivingUp = 0;
      BaseType_t return_value_prvProcessDHCPReplies=prvProcessDHCPReplies(2);
      if(return_value_prvProcessDHCPReplies == 1)
      {
        xDHCPData.xDHCPTxTime=xTaskGetTickCount();
        xDHCPData.xDHCPTxPeriod = (TickType_t)((5000u * 1000u) / 1000u);
        prvSendDHCPRequest();
        xDHCPData.eDHCPState = /*enum*/eWaitingAcknowledge;
        break;
      }

      else
      {
        return_value_xTaskGetTickCount=xTaskGetTickCount();
        if(!(xDHCPData.xDHCPTxPeriod >= return_value_xTaskGetTickCount + -xDHCPData.xDHCPTxTime))
        {
          xDHCPData.xDHCPTxPeriod = xDHCPData.xDHCPTxPeriod << 1;
          if(!(xDHCPData.xDHCPTxPeriod >= 120001u))
          {
            xDHCPData.ulTransactionId=ulRand();
            if(!(xDHCPData.ulTransactionId == 0u))
            {
              xDHCPData.xDHCPTxTime=xTaskGetTickCount();
              xDHCPData.xUseBroadcast = (BaseType_t)!(xDHCPData.xUseBroadcast != 0l);
              prvSendDHCPDiscover();
              while((_Bool)0)
                ;
            }

            else
              while((_Bool)0)
                ;
          }

          else
          {
            while((_Bool)0)
              ;
            xGivingUp = 1;
          }
        }

      }
      break;
    }
    case 2:
    {
      return_value_prvProcessDHCPReplies$0=prvProcessDHCPReplies(5);
      if(return_value_prvProcessDHCPReplies$0 == 1)
      {
        while((_Bool)0)
          ;
        *((uint32_t *)&xDefaultPartUDPPacketHeader.ulWords[(signed long long int)(20ull / sizeof(uint32_t) /*4ull*/ )]) = xDHCPData.ulOfferedIPAddress;
        xNetworkAddressing.ulBroadcastAddress = xDHCPData.ulOfferedIPAddress & xNetworkAddressing.ulNetMask | ~xNetworkAddressing.ulNetMask;
        xDHCPData.eDHCPState = /*enum*/eLeasedAddress;
        vIPNetworkUpCalls();
        vSocketClose((FreeRTOS_Socket_t *)xDHCPData.xDHCPSocket);
        xDHCPData.xDHCPSocket = NULL;
        if(xDHCPData.ulLeaseTime == 0ul)
          xDHCPData.ulLeaseTime = 48ul * 60ul * 60ul * 1000u;

        else
          if(!(xDHCPData.ulLeaseTime >= 60000u))
            xDHCPData.ulLeaseTime = (TickType_t)((60000ul * 1000u) / 1000u);

        vARPSendGratuitous();
        vIPReloadDHCPTimer(xDHCPData.ulLeaseTime);
      }

      else
      {
        TickType_t return_value_xTaskGetTickCount$0=xTaskGetTickCount();
        if(!(xDHCPData.xDHCPTxPeriod >= return_value_xTaskGetTickCount$0 + -xDHCPData.xDHCPTxTime))
        {
          xDHCPData.xDHCPTxPeriod = xDHCPData.xDHCPTxPeriod << 1;
          if(!(xDHCPData.xDHCPTxPeriod >= 120001u))
          {
            xDHCPData.xDHCPTxTime=xTaskGetTickCount();
            prvSendDHCPRequest();
          }

          else
            xDHCPData.eDHCPState = /*enum*/eWaitingSendFirstDiscover;
        }

      }
      break;
    }
    case 3:
    {
      prvCreateDHCPSocket();
      if(!(xDHCPData.xDHCPSocket == NULL))
      {
        xDHCPData.xDHCPTxTime=xTaskGetTickCount();
        xDHCPData.xDHCPTxPeriod = (TickType_t)((5000u * 1000u) / 1000u);
        prvSendDHCPRequest();
        xDHCPData.eDHCPState = /*enum*/eWaitingAcknowledge;
        vIPReloadDHCPTimer((TickType_t)((250u * 1000u) / 1000u));
      }

      break;
    }
    case 4:
    {
      vIPSetDHCPTimerEnableState(0);
      break;
    }
    default:
      ;
  }
  if(!(xGivingUp == 0))
  {
    vPortEnterCritical();
    *((uint32_t *)&xDefaultPartUDPPacketHeader.ulWords[(signed long long int)(20ull / sizeof(uint32_t) /*4ull*/ )]) = xNetworkAddressing.ulDefaultIPAddress;
    vPortExitCritical();
    xDHCPData.eDHCPState = /*enum*/eNotUsingLeasedAddress;
    vIPSetDHCPTimerEnableState(0);
    vIPNetworkUpCalls();
    if(!(xDHCPData.xDHCPSocket == NULL))
    {
      vSocketClose((FreeRTOS_Socket_t *)xDHCPData.xDHCPSocket);
      xDHCPData.xDHCPSocket = NULL;
    }

  }

}

// vDevModeKeyProvisioning
// file ..\..\..\common\devmode_key_provisioning\aws_dev_mode_key_provisioning.c line 227
void vDevModeKeyProvisioning(void)
{
  ProvisioningParams_t xParams;
  xParams.ulClientPrivateKeyType = 0x0ul;
  xParams.pcClientPrivateKey = (uint8_t *)clientcredentialCLIENT_PRIVATE_KEY_PEM$link1;
  xParams.ulClientPrivateKeyLength = clientcredentialCLIENT_PRIVATE_KEY_LENGTH$link1;
  xParams.pcClientCertificate = (uint8_t *)clientcredentialCLIENT_CERTIFICATE_PEM$link1;
  xParams.ulClientCertificateLength = clientcredentialCLIENT_CERTIFICATE_LENGTH$link1;
  vAlternateKeyProvisioning(&xParams);
}

// vEventGroupClearBitsCallback
// file ..\..\..\..\lib\FreeRTOS\event_groups.c line 650
void vEventGroupClearBitsCallback(void *pvEventGroup, const uint32_t ulBitsToClear)
{
  xEventGroupClearBits(pvEventGroup, (EventBits_t)ulBitsToClear);
}

// vEventGroupDelete
// file ..\..\..\..\lib\FreeRTOS\event_groups.c line 598
void vEventGroupDelete(EventGroupHandle_t xEventGroup)
{
  EventGroup_t *pxEventBits=(EventGroup_t *)xEventGroup;
  const List_t *pxTasksWaitingForBits=&pxEventBits->xTasksWaitingForBits;
  vTaskSuspendAll();
  UBaseType_t return_value_uxEventGroupGetNumber=uxEventGroupGetNumber(xEventGroup);
  prvTraceStoreKernelCall(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + 18ul + 9ul, 6, (uint32_t)(traceHandle)return_value_uxEventGroupGetNumber);
  UBaseType_t return_value_uxEventGroupGetNumber$0=uxEventGroupGetNumber(xEventGroup);
  prvTraceStoreObjectNameOnCloseEvent((traceHandle)return_value_uxEventGroupGetNumber$0, 6);
  UBaseType_t return_value_uxEventGroupGetNumber$1=uxEventGroupGetNumber(xEventGroup);
  prvTraceStoreObjectPropertiesOnCloseEvent((traceHandle)return_value_uxEventGroupGetNumber$1, 6);
  UBaseType_t return_value_uxEventGroupGetNumber$2=uxEventGroupGetNumber(xEventGroup);
  prvTraceFreeObjectHandle(6, (traceHandle)return_value_uxEventGroupGetNumber$2);
  while(pxTasksWaitingForBits->uxNumberOfItems >= 1ul)
  {
    if(pxTasksWaitingForBits->xListEnd.pxNext == (const ListItem_t *)&pxTasksWaitingForBits->xListEnd)
      vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\event_groups.c", 611u);

    vTaskRemoveFromUnorderedEventList(pxTasksWaitingForBits->xListEnd.pxNext, 0x2000000ul);
  }
  if(pxEventBits->ucStaticallyAllocated == 0)
    vPortFree((void *)pxEventBits);

  xTaskResumeAll();
}

// vEventGroupSetBitsCallback
// file ..\..\..\..\lib\FreeRTOS\event_groups.c line 642
void vEventGroupSetBitsCallback(void *pvEventGroup, const uint32_t ulBitsToSet)
{
  xEventGroupSetBits(pvEventGroup, (EventBits_t)ulBitsToSet);
}

// vEventGroupSetNumber
// file ..\..\..\..\lib\FreeRTOS\event_groups.c line 730
void vEventGroupSetNumber(void *xEventGroup, UBaseType_t uxEventGroupNumber)
{
  ((EventGroup_t *)xEventGroup)->uxEventGroupNumber = uxEventGroupNumber;
}

// vIPNetworkUpCalls
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 1321
void vIPNetworkUpCalls(void)
{
  xNetworkUp = 1;
  vApplicationIPNetworkEventHook(/*enum*/eNetworkUp);
  prvIPTimerReload(&xARPTimer, (TickType_t)((500u * 1000u) / 1000u));
}

// vIPReloadDHCPTimer
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 2268
void vIPReloadDHCPTimer(uint32_t ulLeaseTime)
{
  prvIPTimerReload(&xDHCPTimer, ulLeaseTime);
}

// vIPSetDHCPTimerEnableState
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 2253
void vIPSetDHCPTimerEnableState(BaseType_t xEnableState)
{
  if(!(xEnableState == 0))
    xDHCPTimer.bActive = 1u;

  else
    xDHCPTimer.bActive = 0u;
}

// vListInitialise
// file ..\..\..\..\lib\FreeRTOS\list.c line 37
void vListInitialise(List_t * const pxList)
{
  pxList->pxIndex = (ListItem_t *)&pxList->xListEnd;
  pxList->xListEnd.xItemValue = 0xFFFFFFFFul;
  pxList->xListEnd.pxNext = (ListItem_t *)&pxList->xListEnd;
  pxList->xListEnd.pxPrevious = (ListItem_t *)&pxList->xListEnd;
  pxList->uxNumberOfItems = 0u;
}

// vListInitialiseItem
// file ..\..\..\..\lib\FreeRTOS\list.c line 62
void vListInitialiseItem(ListItem_t * const pxItem)
{
  pxItem->pvContainer = NULL;
}

// vListInsert
// file ..\..\..\..\lib\FreeRTOS\list.c line 103
void vListInsert(List_t * const pxList, ListItem_t * const pxNewListItem)
{
  ListItem_t *pxIterator;
  const TickType_t xValueOfInsertion=pxNewListItem->xItemValue;
  if(xValueOfInsertion == 0xFFFFFFFFul)
    pxIterator = pxList->xListEnd.pxPrevious;

  else
  {
    pxIterator = (ListItem_t *)&pxList->xListEnd;
    for( ; xValueOfInsertion >= pxIterator->pxNext->xItemValue; pxIterator = pxIterator->pxNext)
      ;
  }
  pxNewListItem->pxNext = pxIterator->pxNext;
  pxNewListItem->pxNext->pxPrevious = pxNewListItem;
  pxNewListItem->pxPrevious = pxIterator;
  pxIterator->pxNext = pxNewListItem;
  pxNewListItem->pvContainer = (void *)pxList;
  pxList->uxNumberOfItems = pxList->uxNumberOfItems + 1ul;
}

// vListInsertEnd
// file ..\..\..\..\lib\FreeRTOS\list.c line 74
void vListInsertEnd(List_t * const pxList, ListItem_t * const pxNewListItem)
{
  ListItem_t * const pxIndex=pxList->pxIndex;
  pxNewListItem->pxNext = pxIndex;
  pxNewListItem->pxPrevious = pxIndex->pxPrevious;
  pxIndex->pxPrevious->pxNext = pxNewListItem;
  pxIndex->pxPrevious = pxNewListItem;
  pxNewListItem->pvContainer = (void *)pxList;
  pxList->uxNumberOfItems = pxList->uxNumberOfItems + 1ul;
}

// vListInsertFifo
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 258
static inline void vListInsertFifo(List_t * const pxList, ListItem_t * const pxNewListItem)
{
  vListInsertGeneric(pxList, pxNewListItem, &pxList->xListEnd);
}

// vListInsertGeneric
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 284
extern void vListInsertGeneric(List_t * const pxList, ListItem_t * const pxNewListItem, MiniListItem_t * const pxWhere)
{
  pxNewListItem->pxNext = (struct xLIST_ITEM *)pxWhere;
  pxNewListItem->pxPrevious = pxWhere->pxPrevious;
  pxWhere->pxPrevious->pxNext = pxNewListItem;
  pxWhere->pxPrevious = pxNewListItem;
  pxNewListItem->pvContainer = (void *)pxList;
  pxList->uxNumberOfItems = pxList->uxNumberOfItems + 1ul;
}

// vLoggingInit
// file ..\common\application_code\aws_demo_logging.c line 155
void vLoggingInit(BaseType_t vLoggingInit$$xLogToStdout, BaseType_t vLoggingInit$$xLogToFile, BaseType_t vLoggingInit$$xLogToUDP, uint32_t ulRemoteIPAddress, uint16_t usRemotePort)
{
  BaseType_t return_value_xTaskGetSchedulerState=xTaskGetSchedulerState();
  if(!(return_value_xTaskGetSchedulerState == 1))
    vAssertCalled("..\\common\\application_code\\aws_demo_logging.c", 162u);

  HANDLE Win32Thread;
  xStdoutLoggingUsed = vLoggingInit$$xLogToStdout;
  xDiskFileLoggingUsed = vLoggingInit$$xLogToFile;
  xUDPLoggingUsed = vLoggingInit$$xLogToUDP;
  if(!(xDiskFileLoggingUsed == 0))
    prvFileLoggingInit();

  if(!(xUDPLoggingUsed == 0))
  {
    xPrintUDPAddress.sin_port = (uint16_t)((signed int)usRemotePort << 8u | (signed int)usRemotePort >> 8u);
    xPrintUDPAddress.sin_addr = ulRemoteIPAddress;
  }

  if(!(xDiskFileLoggingUsed == 0) || !(xStdoutLoggingUsed == 0))
  {
    void *return_value_malloc=malloc((sizeof(const StreamBuffer_t) /*48ull*/  - sizeof(uint8_t [8ll]) /*8ull*/ ) + 32768ull + 1ull);
    xLogStreamBuffer = (StreamBuffer_t *)return_value_malloc;
    if(xLogStreamBuffer == (( StreamBuffer_t *)NULL))
      vAssertCalled("..\\common\\application_code\\aws_demo_logging.c", 201u);

    memset((void *)xLogStreamBuffer, 0, sizeof(const StreamBuffer_t) /*48ull*/  - sizeof(uint8_t [8ll]) /*8ull*/ );
    xLogStreamBuffer->LENGTH = (size_t)(32768 + 1);
    pvLoggingThreadEvent=CreateEventA(((LPSECURITY_ATTRIBUTES)NULL), 0, 1, "StdoutLoggingEvent");
    Win32Thread=CreateThread(((LPSECURITY_ATTRIBUTES)NULL), 0ull, prvWin32LoggingThread, NULL, 0ul, ((LPDWORD)NULL));
    SetThreadAffinityMask(Win32Thread, (DWORD_PTR)~0x1u);
    SetThreadPriorityBoost(Win32Thread, 1);
    SetThreadPriority(Win32Thread, -15);
  }

}

// vLoggingPrint
// file ..\common\application_code\aws_demo_logging.c line 469
void vLoggingPrint(const char *pcMessage)
{
  printf("%s", pcMessage);
  FILE *return_value___acrt_iob_func=__acrt_iob_func(1u);
  fflush(return_value___acrt_iob_func);
}

// vLoggingPrintf
// file ..\common\application_code\aws_demo_logging.c line 273
extern void vLoggingPrintf(const char *pcFormat, ...)
{
  char cPrintString[255ll];
  char cOutputString[255ll];
  char *pcSource;
  char *pcTarget;
  char *pcBegin;
  size_t xLength;
  size_t xLength2;
  size_t rc;
  va_list args;
  uint32_t ulIPAddress;
  const char *pcTaskName;
  const char *pcNoTask="None";
  signed int iOriginalPriority;
  HANDLE xCurrentTask;
  signed int return_value_isxdigit;
  BaseType_t return_value_FreeRTOS_IsNetworkUp;
  if(!(xDiskFileLoggingUsed == 0) || !(xStdoutLoggingUsed == 0) || !(xUDPLoggingUsed == 0))
  {
  //  args = (va_list)&pcFormat + (signed long long int)((sizeof(const char *) /*8ull*/  + sizeof(signed int) /*4ull*/ ) - 1ull & ~(sizeof(signed int) /*4ull*/  - 1ull));
	  va_start(args, pcFormat);
    BaseType_t return_value_xTaskGetSchedulerState=xTaskGetSchedulerState();
    if(!(return_value_xTaskGetSchedulerState == 1))
      pcTaskName=pcTaskGetName(NULL);

    else
      pcTaskName = pcNoTask;
    signed int return_value_strcmp=strcmp(pcFormat, "\n");
    if(!(return_value_strcmp == 0))
    {
      static BaseType_t xMessageNumber=0;
      BaseType_t tmp_post=xMessageNumber;
      xMessageNumber = xMessageNumber + 1l;
      TickType_t return_value_xTaskGetTickCount=xTaskGetTickCount();
      signed int return_value_snprintf=snprintf(cPrintString, 255ull, "%lu %lu [%s] ", tmp_post, (unsigned long int)return_value_xTaskGetTickCount, pcTaskName);
      xLength = (size_t)return_value_snprintf;
    }

    else
    {
      xLength = 0ull;
      memset((void *)cPrintString, 0x0, 255ull);
    }
    signed int return_value_vsnprintf=vsnprintf(cPrintString + (signed long long int)xLength, 255ull - xLength, pcFormat, args);
    xLength2 = (size_t)return_value_vsnprintf;
    xLength = xLength + xLength2;
	  va_end(args);
    /*args = ((va_list)NULL);*/
    pcSource = cPrintString;
    pcTarget = cOutputString;
    while(!((signed int)*pcSource == 0))
    {
      *pcTarget = *pcSource;
      pcTarget = pcTarget + 1ll;
      pcSource = pcSource + 1ll;
      signed int return_value_isxdigit$0=isxdigit((signed int)pcSource[0ll]);
      if(!(return_value_isxdigit$0 == 0))
      {
        if((signed int)pcSource[1ll] == 105)
        {
          if((signed int)pcSource[2ll] == 112)
          {
            *pcTarget = *pcSource;
            pcTarget = pcTarget + 1ll;
            *pcTarget = 0;
            pcBegin = pcTarget - 8ll;
            for( ; !(pcBegin >= pcTarget); pcTarget = pcTarget - 1ll)
            {
              return_value_isxdigit=isxdigit((signed int)pcTarget[(signed long long int)-1]);
              if(return_value_isxdigit == 0)
                break;

            }
            sscanf(pcTarget, "%8X", &ulIPAddress);
            signed int return_value_sprintf=sprintf(pcTarget, "%lu.%lu.%lu.%lu", (unsigned long int)(ulIPAddress >> 24ul), (unsigned long int)(ulIPAddress >> 16ul & 0xFFul), (unsigned long int)(ulIPAddress >> 8ul & 0xFFul), (unsigned long int)(ulIPAddress & 0xFFul));
            rc = (size_t)return_value_sprintf;
            pcTarget = pcTarget + (signed long long int)rc;
            pcSource = pcSource + 3ll;
          }

        }

      }

    }
    xLength = (size_t)(BaseType_t)(pcTarget - cOutputString);
    if(!(xUDPLoggingUsed == 0))
    {
      if(xPrintSocket == (void *)4294967295u)
      {
        return_value_FreeRTOS_IsNetworkUp=FreeRTOS_IsNetworkUp();
        if(!(return_value_FreeRTOS_IsNetworkUp == 0))
          xTimerPendFunctionCall(prvCreatePrintSocket, NULL, 0u, 0u);

      }

      if(!(xPrintSocket == (void *)4294967295u))
      {
        FreeRTOS_sendto(xPrintSocket, (const void *)cOutputString, xLength, 0, &xPrintUDPAddress, (uint32_t)sizeof(struct freertos_sockaddr) /*8u*/ );
        FreeRTOS_sendto(xPrintSocket, (const void *)"\r", sizeof(char) /*1ull*/ , 0, &xPrintUDPAddress, (uint32_t)sizeof(struct freertos_sockaddr) /*8u*/ );
      }

    }

    if(!(xDiskFileLoggingUsed == 0) || !(xStdoutLoggingUsed == 0))
    {
      if(xLogStreamBuffer == ((const StreamBuffer_t *)NULL))
        vAssertCalled("..\\common\\application_code\\aws_demo_logging.c", 417u);

      xLength2=uxStreamBufferGetSpace$link4(xLogStreamBuffer);
      if(xLength2 >= sizeof(size_t) /*8ull*/  + xLength)
      {
        xCurrentTask=GetCurrentThread();
        iOriginalPriority=GetThreadPriority(xCurrentTask);
        HANDLE return_value_GetCurrentThread=GetCurrentThread();
        SetThreadPriority(return_value_GetCurrentThread, 15);
        uxStreamBufferAdd(xLogStreamBuffer, 0ull, ( uint8_t *)&xLength, sizeof(size_t) /*8ull*/ );
        uxStreamBufferAdd(xLogStreamBuffer, 0ull, ( uint8_t *)cOutputString, xLength);
        HANDLE return_value_GetCurrentThread$0=GetCurrentThread();
        SetThreadPriority(return_value_GetCurrentThread$0, iOriginalPriority);
      }

      if(!(xDirectPrint == 0))
        prvLoggingFlushBuffer();

      else
        if(!(pvLoggingThreadEvent == NULL))
          SetEvent(pvLoggingThreadEvent);

    }

  }

}

// vNetworkSocketsInit
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 191
BaseType_t vNetworkSocketsInit(void)
{
  vListInitialise(&xBoundUDPSocketsList);
  vListInitialise(&xBoundTCPSocketsList);
  return 1;
}

// vOTAUpdateDemoTask
// file ..\..\..\common\ota\aws_ota_update_demo.c line 67
void vOTAUpdateDemoTask(void *pvParameters)
{
  const TickType_t vOTAUpdateDemoTask$$1$$xMaxCommandTime=(TickType_t)((60000ul * 1000u) / 1000u);
  MQTTAgentConnectParams_t xConnectParams;
  MQTTAgentHandle_t vOTAUpdateDemoTask$$1$$xMQTTClientHandle;
  (void)pvParameters;
  vLoggingPrintf("OTA demo version %u.%u.%u\r\n", xAppFirmwareVersion.u.x.ucMajor, xAppFirmwareVersion.u.x.ucMinor, xAppFirmwareVersion.u.x.usBuild);
  vLoggingPrintf("Creating MQTT Client...\r\n");
  MQTTAgentReturnCode_t return_value_MQTT_AGENT_Create=MQTT_AGENT_Create(&vOTAUpdateDemoTask$$1$$xMQTTClientHandle);
  OTA_State_t return_value_OTA_GetAgentState;
  if((signed int)return_value_MQTT_AGENT_Create == 0)
    while((_Bool)1)
    {
      vLoggingPrintf("Connecting to broker...\r\n");
      memset((void *)&xConnectParams, 0, sizeof(MQTTAgentConnectParams_t) /*72ull*/ );
      xConnectParams.pucClientId = (const uint8_t *)"Paste AWS IoT Thing name here.";
      xConnectParams.usClientIdLength = (uint16_t)(sizeof(char [31ll]) /*31ull*/  - 1ull);
      xConnectParams.pcURL = clientcredentialMQTT_BROKER_ENDPOINT$link3;
      xConnectParams.usPort = 8883;
      xConnectParams.pcCertificate = ((char *)NULL);
      xConnectParams.ulCertificateSize = 0u;
      xConnectParams.pvUserData = NULL;
      xConnectParams.pxCallback = ((MQTTAgentCallback_t)NULL);
      xConnectParams.xFlags = 0x2 | 0x4;
      MQTTAgentReturnCode_t return_value_MQTT_AGENT_Connect=MQTT_AGENT_Connect(vOTAUpdateDemoTask$$1$$xMQTTClientHandle, &xConnectParams, vOTAUpdateDemoTask$$1$$xMaxCommandTime);
      if((signed int)return_value_MQTT_AGENT_Connect == 0)
      {
        vLoggingPrintf("Connected to broker.\r\n");
        OTA_AgentInit(vOTAUpdateDemoTask$$1$$xMQTTClientHandle, App_OTACompleteCallback, (TickType_t)~0);
        do
        {
          return_value_OTA_GetAgentState=OTA_GetAgentState();
          if(!((signed int)return_value_OTA_GetAgentState == 1))
            break;

          vTaskDelay(1000u);
          uint32_t return_value_OTA_GetPacketsQueued=OTA_GetPacketsQueued();
          uint32_t return_value_OTA_GetPacketsProcessed=OTA_GetPacketsProcessed();
          uint32_t return_value_OTA_GetPacketsDropped=OTA_GetPacketsDropped();
          vLoggingPrintf("[OTA] Queued: %u   Processed: %u   Dropped: %u\r\n", return_value_OTA_GetPacketsQueued, return_value_OTA_GetPacketsProcessed, return_value_OTA_GetPacketsDropped);
        }
        while((_Bool)1);
      }

      else
        vLoggingPrintf("ERROR:  MQTT_AGENT_Connect() Failed.\r\n");
    }

  else
    vLoggingPrintf("Failed to create MQTT client.\r\n");
  vTaskDelete(NULL);
}

// vPortCloseRunningThread
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 473
void vPortCloseRunningThread(void *pvTaskToDelete, volatile BaseType_t *pxPendYield)
{
  xThreadState *pxThreadState;
  void *pvThread;
  uint32_t ulErrorCode;
  (void)ulErrorCode;
  pxThreadState = (xThreadState *)*((size_t *)pvTaskToDelete);
  pvThread = pxThreadState->pvThread;
  SetThreadPriority(pvThread, 15);
  *pxPendYield = 1;
  pxThreadState->pvThread = NULL;
  BOOL return_value_CloseHandle=CloseHandle(pvThread);
  ulErrorCode = (uint32_t)return_value_CloseHandle;
  if(ulErrorCode == 0u)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\portable\\MSVC-MingW\\port.c", 502u);

  vPortExitCritical();
  ExitThread(0ul);
}

// vPortDeleteThread
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 439
void vPortDeleteThread(void *pvTaskToDelete)
{
  xThreadState *pxThreadState;
  uint32_t ulErrorCode;
  (void)ulErrorCode;
  pxThreadState = (xThreadState *)*((size_t *)pvTaskToDelete);
  if(!(pxThreadState->pvThread == NULL))
  {
    WaitForSingleObject(pvInterruptEventMutex, 0xFFFFFFFFu);
    BOOL return_value_TerminateThread=TerminateThread(pxThreadState->pvThread, 0ul);
    ulErrorCode = (uint32_t)return_value_TerminateThread;
    if(ulErrorCode == 0u)
      vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\portable\\MSVC-MingW\\port.c", 463u);

    BOOL return_value_CloseHandle=CloseHandle(pxThreadState->pvThread);
    ulErrorCode = (uint32_t)return_value_CloseHandle;
    if(ulErrorCode == 0u)
      vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\portable\\MSVC-MingW\\port.c", 466u);

    ReleaseMutex(pvInterruptEventMutex);
  }

}

// vPortEndScheduler
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 512
void vPortEndScheduler(void)
{
  HANDLE return_value_GetCurrentProcess=GetCurrentProcess();
  TerminateProcess(return_value_GetCurrentProcess, 0u);
}

// vPortEnterCritical
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 562
void vPortEnterCritical(void)
{
  if(xPortRunning == 1)
  {
    WaitForSingleObject(pvInterruptEventMutex, 0xFFFFFFFFu);
    ulCriticalNesting = ulCriticalNesting + 1u;
  }

  else
    ulCriticalNesting = ulCriticalNesting + 1u;
}

// vPortExitCritical
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 578
void vPortExitCritical(void)
{
  int32_t lMutexNeedsReleasing=1;
  if(ulCriticalNesting >= 1u)
  {
    if(ulCriticalNesting == 1u)
    {
      ulCriticalNesting = ulCriticalNesting - 1u;
      if(!(ulPendingInterrupts == 0ul))
      {
        if(xPortRunning == 0)
          vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\portable\\MSVC-MingW\\port.c", 597u);

        SetEvent(pvInterruptEvent);
        lMutexNeedsReleasing = 0;
        ReleaseMutex(pvInterruptEventMutex);
      }

    }

    else
      ulCriticalNesting = ulCriticalNesting - 1u;
  }

  if(!(pvInterruptEventMutex == NULL))
  {
    if(lMutexNeedsReleasing == 1)
    {
      if(xPortRunning == 0)
        vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\portable\\MSVC-MingW\\port.c", 618u);

      ReleaseMutex(pvInterruptEventMutex);
    }

  }

}

// vPortFree
// file ..\..\..\..\lib\FreeRTOS\portable\MemMang\heap_4.c line 263
void vPortFree(void *pv)
{
  uint8_t *puc=(uint8_t *)pv;
  BlockLink_t *pxLink;
  if(!(pv == NULL))
  {
    puc = puc - (signed long long int)xHeapStructSize;
    pxLink = (BlockLink_t *)(void *)puc;
    if((pxLink->xBlockSize & xBlockAllocatedBit) == 0ull)
      vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\portable\\MemMang\\heap_4.c", 278u);

    if(!(pxLink->pxNextFreeBlock == ((struct A_BLOCK_LINK *)NULL)))
      vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\portable\\MemMang\\heap_4.c", 279u);

    if(!((pxLink->xBlockSize & xBlockAllocatedBit) == 0ull))
    {
      if(pxLink->pxNextFreeBlock == ((struct A_BLOCK_LINK *)NULL))
      {
        pxLink->xBlockSize = pxLink->xBlockSize & ~xBlockAllocatedBit;
        vTaskSuspendAll();
        xFreeBytesRemaining = xFreeBytesRemaining + pxLink->xBlockSize;
        vTraceStoreMemMangEvent(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 6ul, (uint32_t)pv, -((int32_t)pxLink->xBlockSize));
        prvInsertBlockIntoFreeList((BlockLink_t *)pxLink);
        xTaskResumeAll();
      }

    }

  }

}

// vPortGenerateSimulatedInterrupt
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 519
void vPortGenerateSimulatedInterrupt(uint32_t ulInterruptNumber)
{
  if(xPortRunning == 0)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\portable\\MSVC-MingW\\port.c", 521u);

  if(!(pvInterruptEventMutex == NULL) && !(ulInterruptNumber >= (uint32_t)(sizeof(uint32_t) * 8ul) /*32u*/ ))
  {
    WaitForSingleObject(pvInterruptEventMutex, 0xFFFFFFFFu);
    ulPendingInterrupts = ulPendingInterrupts | (volatile uint32_t)(1 << ulInterruptNumber);
    if(ulCriticalNesting == 0u)
      SetEvent(pvInterruptEvent);

    ReleaseMutex(pvInterruptEventMutex);
  }

}

// vPortInitialiseBlocks
// file ..\..\..\..\lib\FreeRTOS\portable\MemMang\heap_4.c line 323
void vPortInitialiseBlocks(void)
{
  ;
}

// vPortSetInterruptHandler
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 544
void vPortSetInterruptHandler(uint32_t ulInterruptNumber, uint32_t (*pvHandler)(void))
{
  if(!(ulInterruptNumber >= (uint32_t)(sizeof(uint32_t) * 8ul) /*32u*/ ))
  {
    if(!(pvInterruptEventMutex == NULL))
    {
      WaitForSingleObject(pvInterruptEventMutex, 0xFFFFFFFFu);
      ulIsrHandler[(signed long long int)ulInterruptNumber] = pvHandler;
      ReleaseMutex(pvInterruptEventMutex);
    }

    else
      ulIsrHandler[(signed long long int)ulInterruptNumber] = pvHandler;
  }

}

// vProcessGeneratedUDPPacket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_UDP_IP.c line 75
void vProcessGeneratedUDPPacket(NetworkBufferDescriptor_t * const pxNetworkBuffer)
{
  UDPPacket_t *pxUDPPacket;
  IPHeader_t *pxIPHeader;
  eARPLookupResult_t eReturned;
  uint32_t ulIPAddress=pxNetworkBuffer->ulIPAddress;
  pxUDPPacket = (UDPPacket_t *)pxNetworkBuffer->pucEthernetBuffer;
  eReturned=eARPGetCacheEntry(&ulIPAddress, &pxUDPPacket->xEthernetHeader.xDestinationAddress);
  if(!((signed int)eReturned == 2))
  {
    if((signed int)eReturned == 1)
    {
      uint8_t ucSocketOptions;
      pxIPHeader = &pxUDPPacket->xIPHeader;
      UDPHeader_t *pxUDPHeader=&pxUDPPacket->xUDPHeader;
      pxUDPHeader->usDestinationPort = pxNetworkBuffer->usPort;
      pxUDPHeader->usSourcePort = pxNetworkBuffer->usBoundPort;
      pxUDPHeader->usLength = (uint16_t)(pxNetworkBuffer->xDataLength + sizeof(UDPHeader_t) /*8ull*/ );
      pxUDPHeader->usLength = (uint16_t)((signed int)pxUDPHeader->usLength << 8u | (signed int)pxUDPHeader->usLength >> 8u);
      pxUDPHeader->usChecksum = 0;
      ucSocketOptions = pxNetworkBuffer->pucEthernetBuffer[6ll];
      char *pxUdpSrcAddrOffset=(char *)pxUDPPacket + (signed long long int)sizeof(MACAddress_t) /*6ll*/ ;
      memcpy((void *)pxUdpSrcAddrOffset, (const void *)xDefaultPartUDPPacketHeader.ucBytes, sizeof(UDPPacketHeader_t) /*24ull*/ );
      pxIPHeader->usLength = (uint16_t)(pxNetworkBuffer->xDataLength + sizeof(IPHeader_t) /*20ull*/  + sizeof(UDPHeader_t) /*8ull*/ );
      pxNetworkBuffer->xDataLength = (unsigned long long int)pxIPHeader->usLength + sizeof(EthernetHeader_t) /*14ull*/ ;
      pxIPHeader->usLength = (uint16_t)((signed int)pxIPHeader->usLength << 8u | (signed int)pxIPHeader->usLength >> 8u);
      pxIPHeader->ulDestinationIPAddress = pxNetworkBuffer->ulIPAddress;
      pxIPHeader->usHeaderChecksum = 0;
      pxIPHeader->usHeaderChecksum=usGenerateChecksum(0ul, (uint8_t *)&pxIPHeader->ucVersionHeaderLength, 20ull);
      pxIPHeader->usHeaderChecksum = (uint16_t)~((signed int)(uint16_t)((signed int)pxIPHeader->usHeaderChecksum << 8u | (signed int)pxIPHeader->usHeaderChecksum >> 8u));
      if(!((2u & (unsigned int)(signed int)ucSocketOptions) == 0u))
        usGenerateProtocolChecksum((uint8_t *)pxUDPPacket, pxNetworkBuffer->xDataLength, 1);

      else
        pxUDPPacket->xUDPHeader.usChecksum = 0;
    }

    else
      if((signed int)eReturned == 0)
      {
        vARPRefreshCacheEntry(((const MACAddress_t *)NULL), ulIPAddress);
        pxNetworkBuffer->ulIPAddress = ulIPAddress;
        vARPGenerateRequestPacket(pxNetworkBuffer);
      }

      else
        eReturned = /*enum*/eCantSendPacket;
  }

  if(!((signed int)eReturned == 2))
    xNetworkInterfaceOutput(pxNetworkBuffer, 1);

  else
    vReleaseNetworkBufferAndDescriptor(pxNetworkBuffer);
}

// vQueueDelete
// file ..\..\..\..\lib\FreeRTOS\queue.c line 1942
void vQueueDelete(QueueHandle_t xQueue)
{
  Queue_t * const pxQueue=(Queue_t *)xQueue;
  if(pxQueue == ((Queue_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 1946u);

  vPortEnterCritical();
  uint8_t return_value_prvTraceGetObjectType=prvTraceGetObjectType((void *)pxQueue);
  uint8_t return_value_prvTraceGetObjectType$0=prvTraceGetObjectType((void *)pxQueue);
  traceHandle return_value_prvTraceGetObjectNumber=prvTraceGetObjectNumber((void *)pxQueue);
  prvTraceStoreKernelCall((uint32_t)(uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + (unsigned int)TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType]), TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$0], (uint32_t)return_value_prvTraceGetObjectNumber);
  traceHandle return_value_prvTraceGetObjectNumber$0=prvTraceGetObjectNumber((void *)pxQueue);
  uint8_t return_value_prvTraceGetObjectType$1=prvTraceGetObjectType((void *)pxQueue);
  prvTraceStoreObjectNameOnCloseEvent(return_value_prvTraceGetObjectNumber$0, TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$1]);
  traceHandle return_value_prvTraceGetObjectNumber$1=prvTraceGetObjectNumber((void *)pxQueue);
  uint8_t return_value_prvTraceGetObjectType$2=prvTraceGetObjectType((void *)pxQueue);
  prvTraceStoreObjectPropertiesOnCloseEvent(return_value_prvTraceGetObjectNumber$1, TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$2]);
  uint8_t return_value_prvTraceGetObjectType$3=prvTraceGetObjectType((void *)pxQueue);
  traceHandle return_value_prvTraceGetObjectNumber$2=prvTraceGetObjectNumber((void *)pxQueue);
  prvTraceFreeObjectHandle(TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$3], return_value_prvTraceGetObjectNumber$2);
  vPortExitCritical();
  if(pxQueue->ucStaticallyAllocated == 0)
    vPortFree((void *)pxQueue);

}

// vQueueSetQueueNumber
// file ..\..\..\..\lib\FreeRTOS\queue.c line 1996
void vQueueSetQueueNumber(QueueHandle_t xQueue, UBaseType_t uxQueueNumber)
{
  ((Queue_t *)xQueue)->uxQueueNumber = uxQueueNumber;
}

// vQueueWaitForMessageRestricted
// file ..\..\..\..\lib\FreeRTOS\queue.c line 2702
void vQueueWaitForMessageRestricted(QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely)
{
  Queue_t * const pxQueue=(Queue_t *)xQueue;
  vPortEnterCritical();
  if(pxQueue->cRxLock == -1)
    pxQueue->cRxLock = 0;

  if(pxQueue->cTxLock == -1)
    pxQueue->cTxLock = 0;

  vPortExitCritical();
  if(pxQueue->uxMessagesWaiting == 0u)
    vTaskPlaceOnEventListRestricted(&pxQueue->xTasksWaitingToReceive, xTicksToWait, xWaitIndefinitely);

  prvUnlockQueue(pxQueue);
}

// vReleaseNetworkBuffer
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\BufferManagement\BufferAllocation_2.c line 195
void vReleaseNetworkBuffer(uint8_t *pucEthernetBuffer)
{
  if(!(pucEthernetBuffer == ((uint8_t *)NULL)))
  {
    pucEthernetBuffer = pucEthernetBuffer - (signed long long int)(8u + 2u);
    vPortFree((void *)pucEthernetBuffer);
  }

}

// vReleaseNetworkBufferAndDescriptor
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\BufferManagement\BufferAllocation_2.c line 304
void vReleaseNetworkBufferAndDescriptor(NetworkBufferDescriptor_t * const pxNetworkBuffer)
{
  BaseType_t xListItemAlreadyInFreeList;
  vReleaseNetworkBuffer(pxNetworkBuffer->pucEthernetBuffer);
  pxNetworkBuffer->pucEthernetBuffer = ((uint8_t *)NULL);
  vPortEnterCritical();
  xListItemAlreadyInFreeList = (BaseType_t)((&pxNetworkBuffer->xBufferListItem)->pvContainer == (void *)&xFreeBuffersList);
  if(xListItemAlreadyInFreeList == 0)
    vListInsertEnd(&xFreeBuffersList, &pxNetworkBuffer->xBufferListItem);

  vPortExitCritical();
  if(xListItemAlreadyInFreeList == 0)
  {
    BaseType_t return_value_xQueueGenericSend=xQueueGenericSend((QueueHandle_t)xNetworkBufferSemaphore, NULL, 0u, 0);
  }

}

// vReturnEthernetFrame
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 2147
void vReturnEthernetFrame(NetworkBufferDescriptor_t *pxNetworkBuffer, BaseType_t xReleaseAfterSend)
{
  EthernetHeader_t *pxEthernetHeader=(EthernetHeader_t *)pxNetworkBuffer->pucEthernetBuffer;
  memcpy((void *)&pxEthernetHeader->xDestinationAddress, (void *)&pxEthernetHeader->xSourceAddress, sizeof(MACAddress_t) /*6ull*/ );
  memcpy((void *)&pxEthernetHeader->xSourceAddress, (void *)xDefaultPartUDPPacketHeader.ucBytes, 6ull);
  xNetworkInterfaceOutput(pxNetworkBuffer, xReleaseAfterSend);
}

// vSocketBind
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 969
BaseType_t vSocketBind(FreeRTOS_Socket_t *pxSocket, struct freertos_sockaddr *pxAddress, size_t uxAddressLength, BaseType_t xInternal)
{
  BaseType_t xReturn=0;
  List_t *pxSocketList;
  struct freertos_sockaddr xAddress;
  if(pxSocket->ucProtocol == 6)
    pxSocketList = &xBoundTCPSocketsList;

  else
    pxSocketList = &xBoundUDPSocketsList;
  (void)uxAddressLength;
  if(pxSocket == ((FreeRTOS_Socket_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS-Plus-TCP\\source\\FreeRTOS_Sockets.c", 992u);

  if(pxSocket == (FreeRTOS_Socket_t *)4294967295u)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS-Plus-TCP\\source\\FreeRTOS_Sockets.c", 993u);

  if(pxAddress == ((struct freertos_sockaddr *)NULL))
  {
    pxAddress = &xAddress;
    pxAddress->sin_port = 0;
  }

  if(pxAddress == ((struct freertos_sockaddr *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS-Plus-TCP\\source\\FreeRTOS_Sockets.c", 1011u);

  const ListItem_t *return_value_pxListFindListItemWithValue;
  if(!(pxAddress == ((struct freertos_sockaddr *)NULL)))
  {
    if((unsigned int)pxAddress->sin_port == 0u)
      pxAddress->sin_port=prvGetPrivatePortNumber((BaseType_t)pxSocket->ucProtocol);

    _Bool tmp_if_expr;
    if(xInternal == 0)
      tmp_if_expr = (_Bool)1;

    else
      tmp_if_expr = pxSocket->ucProtocol != 6 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$0;
    if(tmp_if_expr)
    {
      return_value_pxListFindListItemWithValue=pxListFindListItemWithValue(pxSocketList, (TickType_t)pxAddress->sin_port);
      tmp_if_expr$0 = return_value_pxListFindListItemWithValue != ((const ListItem_t *)NULL) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$0 = (_Bool)0;
    if(tmp_if_expr$0)
    {
      while((_Bool)0)
        ;
      xReturn = -112;
    }

    else
    {
      (&pxSocket->xBoundSocketListItem)->xItemValue = (TickType_t)pxAddress->sin_port;
      pxSocket->usLocalPort = (uint16_t)((signed int)pxAddress->sin_port << 8u | (signed int)pxAddress->sin_port >> 8u);
      vListInsertEnd(pxSocketList, &pxSocket->xBoundSocketListItem);
    }
  }

  else
  {
    xReturn = -125;
    while((_Bool)0)
      ;
  }
  return xReturn;
}

// vSocketClose
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 1138
void * vSocketClose(FreeRTOS_Socket_t *pxSocket)
{
  NetworkBufferDescriptor_t *pxNetworkBuffer;
  if(pxSocket->ucProtocol == 6)
  {
    if(!(pxSocket->u.xTCP.pxAckMessage == ((NetworkBufferDescriptor_t *)NULL)))
      vReleaseNetworkBufferAndDescriptor(pxSocket->u.xTCP.pxAckMessage);

    vTCPWindowDestroy(&pxSocket->u.xTCP.xTCPWindow);
    if(!(pxSocket->u.xTCP.rxStream == ((const StreamBuffer_t *)NULL)))
      vPortFree((void *)pxSocket->u.xTCP.rxStream);

    if(!(pxSocket->u.xTCP.txStream == ((const StreamBuffer_t *)NULL)))
      vPortFree((void *)pxSocket->u.xTCP.txStream);

    prvTCPSetSocketCount(pxSocket);
  }

  if(!(pxSocket->xBoundSocketListItem.pvContainer == NULL))
    uxListRemove(&pxSocket->xBoundSocketListItem);

  if(pxSocket->ucProtocol == 17)
    while(pxSocket->u.xUDP.xWaitingPacketsList.uxNumberOfItems >= 1u)
    {
      pxNetworkBuffer = (NetworkBufferDescriptor_t *)(&(&pxSocket->u.xUDP.xWaitingPacketsList)->xListEnd)->pxNext->pvOwner;
      uxListRemove(&pxNetworkBuffer->xBufferListItem);
      vReleaseNetworkBufferAndDescriptor(pxNetworkBuffer);
    }

  if(!(pxSocket->xEventGroup == NULL))
    vEventGroupDelete(pxSocket->xEventGroup);

  vPortFree((void *)pxSocket);
  return NULL;
}

// vSocketWakeUpUser
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 1840
void vSocketWakeUpUser(FreeRTOS_Socket_t *pxSocket)
{
  if(!(pxSocket->pxUserWakeCallback == ((SocketWakeupCallback_t)NULL)))
    pxSocket->pxUserWakeCallback(pxSocket);

  if(!(pxSocket->xEventGroup == NULL))
  {
    if(!(pxSocket->xEventBits == 0u))
      xEventGroupSetBits(pxSocket->xEventGroup, pxSocket->xEventBits);

  }

  pxSocket->xEventBits = 0ul;
}

// vStartGreenGrassDiscoveryTask
// file ..\..\..\common\greengrass_connectivity\aws_greengrass_discovery_demo.c line 226
extern void vStartGreenGrassDiscoveryTask(void)
{
  xTaskCreate(prvDiscoverGreenGrassCore, "IoT_GGD", (const uint16_t)(60 * 16), NULL, 0u, ((TaskHandle_t * const )NULL));
}

// vStartMQTTEchoDemo
// file ..\..\..\common\mqtt\aws_hello_world.c line 505
extern void vStartMQTTEchoDemo(void)
{
  vLoggingPrintf("Creating MQTT Echo Task...\r\n");
  StreamBufferHandle_t return_value_xStreamBufferGenericCreate=xStreamBufferGenericCreate(20ull + sizeof(size_t) /*8ull*/ , 0ull, 1);
  xEchoMessageBuffer = (MessageBufferHandle_t)return_value_xStreamBufferGenericCreate;
  if(xEchoMessageBuffer == NULL)
    vAssertCalled("..\\..\\..\\common\\mqtt\\aws_hello_world.c", 515u);

  xTaskCreate(prvMQTTConnectAndPublishTask, "MQTTEcho", (const uint16_t)(60 * 2), NULL, 0u, ((TaskHandle_t * const )NULL));
}

// vStartOTAUpdateDemoTask
// file ..\..\..\common\ota\aws_ota_update_demo.c line 164
extern void vStartOTAUpdateDemoTask(void)
{
  xTaskCreate(vOTAUpdateDemoTask, "OTA", (const uint16_t)(60 * 4), NULL, 0u, ((TaskHandle_t * const )NULL));
}

// vStartShadowDemoTasks
// file ..\..\..\common\shadow\aws_shadow_lightbulb_on_off.c line 514
extern void vStartShadowDemoTasks(void)
{
  xTaskCreate(prvShadowInitTask, "MainDemoTask", (const uint16_t)(60 * 5), NULL, 0u, ((TaskHandle_t * const )NULL));
}

// vStartSimpleTCPServerTasks
// file ..\..\..\common\tcp\aws_simple_tcp_echo_server.c line 95
extern void vStartSimpleTCPServerTasks(void)
{
  xTaskCreate(prvConnectionListeningTask, "ServerListener", (const uint16_t)(60 * 6), NULL, 0u + 1u, ((TaskHandle_t * const )NULL));
  usUsedStackSize = (uint16_t)(60 * 6);
}

// vStartSubpubDemoTasks
// file ..\..\..\common\mqtt\aws_subscribe_publish_loop.c line 724
extern void vStartSubpubDemoTasks(void)
{
  int8_t x;
  char cTaskName[10ll];
  x = 0;
  for( ; !((signed int)x >= 0); x = x + 1)
  {
    snprintf(cTaskName, 10ull, "IOT-%d", x);
    xTaskCreate(prvPublishSubscribeTask, cTaskName, (const uint16_t)(60 * 5), NULL, 0u, ((TaskHandle_t * const )NULL));
  }
  x = 0;
  for( ; !((signed int)x >= 2); x = x + 1)
  {
    snprintf(cTaskName, 10ull, "IOT-%d", x);
    xTaskCreate(prvPublishSubscribeTask, cTaskName, (const uint16_t)(60 * 5), (void *)1, 0u, ((TaskHandle_t * const )NULL));
  }
}

// vStartTCPEchoClientTasks_SeparateTasks
// file ..\..\..\common\tcp\aws_tcp_echo_client_separate_tasks.c line 113
void vStartTCPEchoClientTasks_SeparateTasks(void)
{
  xSocketPassingQueue=xQueueGenericCreate(1ul, (const UBaseType_t)sizeof(Socket_t) /*8ul*/ , 0);
  if(xSocketPassingQueue == NULL)
    vAssertCalled("..\\..\\..\\common\\tcp\\aws_tcp_echo_client_separate_tasks.c", 118u);

  xSyncEventGroup=xEventGroupCreate();
  if(xSyncEventGroup == NULL)
    vAssertCalled("..\\..\\..\\common\\tcp\\aws_tcp_echo_client_separate_tasks.c", 123u);

  xTaskCreate(prvEchoClientTxTask, "EchoMultiTx", (const uint16_t)(60 * 4), NULL, 0u, ((TaskHandle_t * const )NULL));
  xTaskCreate(prvEchoClientRxTask, "EchoMultiRx", (const uint16_t)(60 * 4), NULL, 0u, ((TaskHandle_t * const )NULL));
}

// vStartTCPEchoClientTasks_SingleTasks
// file ..\..\..\common\tcp\aws_tcp_echo_client_single_task.c line 139
void vStartTCPEchoClientTasks_SingleTasks(void)
{
  BaseType_t x;
  char cNameBuffer[8ll];
  x = 0;
  for( ; !(x >= 1); x = x + 1l)
  {
    snprintf(cNameBuffer, 8ull, "Echo%ld", x);
    xTaskCreate(prvEchoClientTask, cNameBuffer, (const uint16_t)(60 * 4), (void *)x, 0u + 1u, ((TaskHandle_t * const )NULL));
  }
}

// vStreamBufferClear
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 83
static inline void vStreamBufferClear(StreamBuffer_t *pxBuffer)
{
  pxBuffer->uxHead = 0ull;
  pxBuffer->uxTail = 0ull;
  pxBuffer->uxFront = 0ull;
  pxBuffer->uxMid = 0ull;
}

// vStreamBufferDelete
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 335
void vStreamBufferDelete(StreamBufferHandle_t xStreamBuffer)
{
  StreamBuffer_t1 *pxStreamBuffer=(StreamBuffer_t1 *)xStreamBuffer;
  if(pxStreamBuffer == ((StreamBuffer_t1 *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 339u);

  if((2 & (signed int)pxStreamBuffer->ucFlags) == 0)
    vPortFree((void *)pxStreamBuffer);

  else
    memset((void *)pxStreamBuffer, 0x0, sizeof(StreamBuffer_t) /*64ull*/ );
}

// vStreamBufferMoveMid
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 194
static inline void vStreamBufferMoveMid( StreamBuffer_t *pxBuffer, size_t uxCount)
{
  size_t uxSize=uxStreamBufferMidSpace(pxBuffer);
  if(!(uxSize >= uxCount))
    uxCount = uxSize;

  pxBuffer->uxMid = pxBuffer->uxMid + uxCount;
  if(pxBuffer->uxMid >= pxBuffer->LENGTH)
    pxBuffer->uxMid = pxBuffer->uxMid - pxBuffer->LENGTH;

}

// vStreamBufferSetStreamBufferNumber
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 1183
void vStreamBufferSetStreamBufferNumber(StreamBufferHandle_t xStreamBuffer, UBaseType_t uxStreamBufferNumber)
{
  ((StreamBuffer_t1 *)xStreamBuffer)->uxStreamBufferNumber = uxStreamBufferNumber;
}

// vTCPNetStat
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 3337
void vTCPNetStat(void)
{
  ListItem_t *pxIterator;
  BaseType_t count=0;
  if(!(xBoundTCPSocketsList.xListEnd.xItemValue == 0xFFFFFFFFul))
    vLoggingPrintf("PLUS-TCP not initialized\n");

  else
  {
    vLoggingPrintf("Prot Port IP-Remote       : Port  R/T Status       Alive  tmout Child\n");
    pxIterator = (ListItem_t *)(&xBoundTCPSocketsList)->xListEnd.pxNext;
    for( ; !(pxIterator == (const ListItem_t *)&(&xBoundTCPSocketsList)->xListEnd); pxIterator = (ListItem_t *)pxIterator->pxNext)
    {
      FreeRTOS_Socket_t *pxSocket=(FreeRTOS_Socket_t *)pxIterator->pvOwner;
      TickType_t age;
      TickType_t return_value_xTaskGetTickCount=xTaskGetTickCount();
      age = return_value_xTaskGetTickCount - pxSocket->u.xTCP.xLastAliveTime;
      void *pxHandleReceive=NULL;
      char ucChildText[16ll]={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
      if((signed int)pxSocket->u.xTCP.ucTCPState == 1)
      {
        const int32_t copied_len=snprintf(ucChildText, sizeof(char [16ll]) /*16ull*/ , " %d/%d", (signed int)pxSocket->u.xTCP.usChildCount, (signed int)pxSocket->u.xTCP.usBacklog);
        if(!(copied_len >= 0))
          vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS-Plus-TCP\\source\\FreeRTOS_Sockets.c", 3372u);

        if((unsigned long long int)copied_len >= sizeof(char [16ll]) /*16ull*/ )
          vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS-Plus-TCP\\source\\FreeRTOS_Sockets.c", 3373u);

      }

      const char *return_value_FreeRTOS_GetTCPStateName=FreeRTOS_GetTCPStateName((UBaseType_t)pxSocket->u.xTCP.ucTCPState);
      vLoggingPrintf("TCP %5d %-16lxip:%5d %d/%d %-13.13s %6lu %6u%s\n", pxSocket->usLocalPort, pxSocket->u.xTCP.ulRemoteIP, pxSocket->u.xTCP.usRemotePort, pxSocket->u.xTCP.rxStream != ((const StreamBuffer_t *)NULL), pxSocket->u.xTCP.txStream != ((const StreamBuffer_t *)NULL), return_value_FreeRTOS_GetTCPStateName, age > 999999u ? 999999u : age, pxSocket->u.xTCP.usTimeout, (const void *)ucChildText);
      (void)pxHandleReceive;
      count = count + 1l;
    }
    pxIterator = (ListItem_t *)(&xBoundUDPSocketsList)->xListEnd.pxNext;
    for( ; !(pxIterator == (const ListItem_t *)&(&xBoundUDPSocketsList)->xListEnd); pxIterator = (ListItem_t *)pxIterator->pxNext)
    {
      vLoggingPrintf("UDP Port %5u\n", (uint16_t)(pxIterator->xItemValue << 8u | pxIterator->xItemValue >> 8u));
      count = count + 1l;
    }
    UBaseType_t return_value_uxGetMinimumFreeNetworkBuffers=uxGetMinimumFreeNetworkBuffers();
    UBaseType_t return_value_uxGetNumberOfFreeNetworkBuffers=uxGetNumberOfFreeNetworkBuffers();
    vLoggingPrintf("FreeRTOS_netstat: %lu sockets %lu < %lu < %d buffers free\n", count, return_value_uxGetMinimumFreeNetworkBuffers, return_value_uxGetNumberOfFreeNetworkBuffers, 60);
  }
}

// vTCPStateChange
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 1434
void vTCPStateChange(FreeRTOS_Socket_t *pxSocket, enum eTCP_STATE eTCPState)
{
  FreeRTOS_Socket_t *xParent=((FreeRTOS_Socket_t *)NULL);
  BaseType_t bBefore;
  _Bool tmp_if_expr;
  if((signed int)pxSocket->u.xTCP.ucTCPState >= 5)
    tmp_if_expr = (signed int)pxSocket->u.xTCP.ucTCPState != 8 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr = (_Bool)0;
  bBefore = (BaseType_t)tmp_if_expr;
  BaseType_t bAfter=(BaseType_t)((signed int)eTCPState >= 5 && (signed int)eTCPState != 8);
  if(!(bBefore == bAfter))
  {
    if(!(bAfter == 0))
    {
      if(!((unsigned int)pxSocket->u.xTCP.bits.bPassQueued == 0u))
      {
        if(!((unsigned int)pxSocket->u.xTCP.bits.bReuseSocket == 0u))
          xParent = pxSocket;

        else
        {
          xParent = pxSocket->u.xTCP.pxPeerSocket;
          if(xParent == ((FreeRTOS_Socket_t *)NULL))
            vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS-Plus-TCP\\source\\FreeRTOS_TCP_IP.c", 1463u);

        }
        if(!(xParent == ((FreeRTOS_Socket_t *)NULL)))
        {
          if(xParent->u.xTCP.pxPeerSocket == ((struct XSOCKET *)NULL))
            xParent->u.xTCP.pxPeerSocket = pxSocket;

          xParent->xEventBits = xParent->xEventBits | 4u;
        }

        pxSocket->u.xTCP.pxPeerSocket = ((struct XSOCKET *)NULL);
        pxSocket->u.xTCP.bits.bPassQueued = 0u;
        pxSocket->u.xTCP.bits.bPassAccept = 1u;
      }

      else
        pxSocket->xEventBits = pxSocket->xEventBits | 8u;
    }

    else
      pxSocket->xEventBits = pxSocket->xEventBits | 32u;
    BaseType_t return_value_prvTCPSocketIsActive=prvTCPSocketIsActive((UBaseType_t)pxSocket->u.xTCP.ucTCPState);
    if(return_value_prvTCPSocketIsActive == 0)
      pxSocket->u.xTCP.usTimeout = 0;

  }

  else
    if((signed int)eTCPState == 0)
    {
      _Bool tmp_if_expr$0;
      if(!((unsigned int)pxSocket->u.xTCP.bits.bPassQueued == 0u))
        tmp_if_expr$0 = (_Bool)1;

      else
        tmp_if_expr$0 = (unsigned int)pxSocket->u.xTCP.bits.bPassAccept != 0u ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$0)
      {
        while((_Bool)0)
          ;
        if((unsigned int)pxSocket->u.xTCP.bits.bReuseSocket == 0u)
          FreeRTOS_closesocket((Socket_t)pxSocket);

      }

    }

  pxSocket->u.xTCP.ucTCPState = (uint8_t)eTCPState;
  prvTCPTouchSocket(pxSocket);
  if(!(xParent == ((FreeRTOS_Socket_t *)NULL)))
    vSocketWakeUpUser(xParent);

}

// vTCPTimerSet
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 266
static inline void vTCPTimerSet(TCPTimer_t *pxTimer)
{
  pxTimer->ulBorn=xTaskGetTickCount();
}

// vTCPWindowCreate
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 588
void vTCPWindowCreate(TCPWindow_t *pxWindow, uint32_t ulRxWindowLength, uint32_t ulTxWindowLength, uint32_t ulAckNumber, uint32_t ulSequenceNumber, uint32_t ulMSS)
{
  if(xTCPSegments == ((TCPSegment_t *)NULL))
    prvCreateSectors();

  vListInitialise(&pxWindow->xTxSegments);
  vListInitialise(&pxWindow->xRxSegments);
  vListInitialise(&pxWindow->xPriorityQueue);
  vListInitialise(&pxWindow->xTxQueue);
  vListInitialise(&pxWindow->xWaitQueue);
  if(!(xTCPWindowLoggingLevel == 0))
    while((_Bool)0)
      ;

  pxWindow->xSize.ulRxWindowLength = ulRxWindowLength;
  pxWindow->xSize.ulTxWindowLength = ulTxWindowLength;
  vTCPWindowInit(pxWindow, ulAckNumber, ulSequenceNumber, ulMSS);
}

// vTCPWindowDestroy
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 553
void vTCPWindowDestroy(TCPWindow_t *pxWindow)
{
  List_t *pxSegments;
  BaseType_t xRound;
  TCPSegment_t *pxSegment;
  xRound = 0;
  for( ; !(xRound >= 2); xRound = xRound + 1l)
  {
    if(!(xRound == 0))
      pxSegments = &pxWindow->xRxSegments;

    else
      pxSegments = &pxWindow->xTxSegments;
    if(pxSegments->xListEnd.xItemValue == 0xFFFFFFFFul)
      while(pxSegments->uxNumberOfItems >= 1u)
      {
        pxSegment = (TCPSegment_t *)(&pxSegments->xListEnd)->pxNext->pvOwner;
        vTCPWindowFree(pxSegment);
      }

  }
}

// vTCPWindowFree
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 523
static void vTCPWindowFree(TCPSegment_t *pxSegment)
{
  if(!(pxSegment->xQueueItem.pvContainer == NULL))
    uxListRemove(&pxSegment->xQueueItem);

  pxSegment->ulSequenceNumber = 0u;
  pxSegment->lDataLength = 0l;
  pxSegment->u.ulFlags = 0u;
  if(!(pxSegment->xListItem.pvContainer == NULL))
    uxListRemove(&pxSegment->xListItem);

  vListInsertFifo(&xSegmentList, &pxSegment->xListItem);
}

// vTCPWindowInit
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 622
void vTCPWindowInit(TCPWindow_t *pxWindow, uint32_t ulAckNumber, uint32_t ulSequenceNumber, uint32_t ulMSS)
{
  const int32_t l500ms=500;
  pxWindow->u.ulFlags = 0ul;
  pxWindow->u.bits.bHasInit = 1u;
  if(!(ulMSS == 0ul))
  {
    if(!((unsigned int)pxWindow->usMSSInit == 0u))
      pxWindow->usMSSInit = (uint16_t)ulMSS;

    _Bool tmp_if_expr;
    if(!(ulMSS >= (uint32_t)pxWindow->usMSS))
      tmp_if_expr = (_Bool)1;

    else
      tmp_if_expr = (unsigned int)pxWindow->usMSS == 0u ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr)
    {
      pxWindow->xSize.ulRxWindowLength = (pxWindow->xSize.ulRxWindowLength / ulMSS) * ulMSS;
      pxWindow->usMSS = (uint16_t)ulMSS;
    }

  }

  pxWindow->lSRTT = l500ms;
  pxWindow->rx.ulFirstSequenceNumber = ulAckNumber;
  pxWindow->rx.ulCurrentSequenceNumber = ulAckNumber;
  pxWindow->rx.ulHighestSequenceNumber = ulAckNumber;
  pxWindow->tx.ulFirstSequenceNumber = ulSequenceNumber;
  pxWindow->tx.ulCurrentSequenceNumber = ulSequenceNumber;
  pxWindow->ulNextTxSequenceNumber = ulSequenceNumber;
  pxWindow->tx.ulHighestSequenceNumber = ulSequenceNumber;
  pxWindow->ulOurSequenceNumber = ulSequenceNumber;
}

// vTaskDelay
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 1299
void vTaskDelay(const TickType_t xTicksToDelay)
{
  BaseType_t xAlreadyYielded=0;
  if(xTicksToDelay >= 1u)
  {
    if(!(uxSchedulerSuspended == 0u))
      vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 1306u);

    vTaskSuspendAll();
    prvTraceStoreKernelCallWithNumericParamOnly(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 1ul, xTicksToDelay);
    traceHandle return_value_prvTraceGetTaskNumber=prvTraceGetTaskNumber((void *)pxCurrentTCB);
    prvTraceSetTaskInstanceFinished((uint8_t)return_value_prvTraceGetTaskNumber);
    void *return_value_prvTraceGetCurrentTaskHandle=prvTraceGetCurrentTaskHandle();
    traceHandle return_value_prvTraceGetTaskNumber$0=prvTraceGetTaskNumber(return_value_prvTraceGetCurrentTaskHandle);
    prvTraceSetTaskInstanceFinished(return_value_prvTraceGetTaskNumber$0);
    prvAddCurrentTaskToDelayedList(xTicksToDelay, 0);
    xAlreadyYielded=xTaskResumeAll();
  }

  if(xAlreadyYielded == 0)
    vPortGenerateSimulatedInterrupt(0ul);

}

// vTaskDelayUntil
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 1215
void vTaskDelayUntil(TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement)
{
  TickType_t xTimeToWake;
  BaseType_t xAlreadyYielded;
  BaseType_t xShouldDelay=0;
  if(pxPreviousWakeTime == ((TickType_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 1220u);

  if(!(xTimeIncrement >= 1u))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 1221u);

  if(!(uxSchedulerSuspended == 0u))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 1222u);

  vTaskSuspendAll();
  const TickType_t xConstTickCount=xTickCount;
  xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
  if(!(xConstTickCount >= *pxPreviousWakeTime))
  {
    if(!(xConstTickCount >= xTimeToWake) && !(xTimeToWake >= *pxPreviousWakeTime))
      xShouldDelay = 1;

  }

  else
    if(!(xConstTickCount >= xTimeToWake) || !(xTimeToWake >= *pxPreviousWakeTime))
      xShouldDelay = 1;

  *pxPreviousWakeTime = xTimeToWake;
  if(!(xShouldDelay == 0))
  {
    prvTraceStoreKernelCallWithNumericParamOnly(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 0ul, xTimeToWake);
    traceHandle return_value_prvTraceGetTaskNumber=prvTraceGetTaskNumber((void *)pxCurrentTCB);
    prvTraceSetTaskInstanceFinished((uint8_t)return_value_prvTraceGetTaskNumber);
    void *return_value_prvTraceGetCurrentTaskHandle=prvTraceGetCurrentTaskHandle();
    traceHandle return_value_prvTraceGetTaskNumber$0=prvTraceGetTaskNumber(return_value_prvTraceGetCurrentTaskHandle);
    prvTraceSetTaskInstanceFinished(return_value_prvTraceGetTaskNumber$0);
    prvAddCurrentTaskToDelayedList(xTimeToWake - xConstTickCount, 0);
  }

  xAlreadyYielded=xTaskResumeAll();
  if(xAlreadyYielded == 0)
    vPortGenerateSimulatedInterrupt(0ul);

}

// vTaskDelete
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 1123
void vTaskDelete(TaskHandle_t xTaskToDelete)
{
  TCB_t *pxTCB;
  vPortEnterCritical();
  pxTCB = xTaskToDelete == NULL ? (TCB_t *)pxCurrentTCB : (TCB_t *)xTaskToDelete;
  UBaseType_t return_value_uxListRemove=uxListRemove(&pxTCB->xStateListItem);
  if(return_value_uxListRemove == 0ul)
  {
    if(pxReadyTasksLists[(signed long long int)pxTCB->uxPriority].uxNumberOfItems == 0ul)
      uxTopReadyPriority = uxTopReadyPriority & ~(1ul << pxTCB->uxPriority);

  }

  if(!(pxTCB->xEventListItem.pvContainer == NULL))
    uxListRemove(&pxTCB->xEventListItem);

  uxTaskNumber = uxTaskNumber + 1ul;
  if(pxTCB == pxCurrentTCB)
  {
    vListInsertEnd(&xTasksWaitingTermination, &pxTCB->xStateListItem);
    uxDeletedTasksWaitingCleanUp = uxDeletedTasksWaitingCleanUp + 1ul;
    vPortCloseRunningThread((void *)pxTCB, &xYieldPending);
  }

  else
  {
    uxCurrentNumberOfTasks = uxCurrentNumberOfTasks - 1ul;
    prvDeleteTCB(pxTCB);
    prvResetNextTaskUnblockTime();
  }
  vPortEnterCritical();
  traceHandle return_value_prvTraceGetTaskNumber=prvTraceGetTaskNumber((void *)pxTCB);
  prvTraceStoreKernelCall((uint32_t)(uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 3u), 3, (uint32_t)return_value_prvTraceGetTaskNumber);
  traceHandle return_value_prvTraceGetTaskNumber$0=prvTraceGetTaskNumber((void *)pxTCB);
  prvTraceStoreObjectNameOnCloseEvent(return_value_prvTraceGetTaskNumber$0, 3);
  traceHandle return_value_prvTraceGetTaskNumber$1=prvTraceGetTaskNumber((void *)pxTCB);
  prvTraceStoreObjectPropertiesOnCloseEvent(return_value_prvTraceGetTaskNumber$1, 3);
  traceHandle return_value_prvTraceGetTaskNumber$2=prvTraceGetTaskNumber((void *)pxTCB);
  prvTraceSetPriorityProperty(3, return_value_prvTraceGetTaskNumber$2, (uint8_t)pxTCB->uxPriority);
  traceHandle return_value_prvTraceGetTaskNumber$3=prvTraceGetTaskNumber((void *)pxTCB);
  prvTraceSetObjectState(3, return_value_prvTraceGetTaskNumber$3, 0);
  traceHandle return_value_prvTraceGetTaskNumber$4=prvTraceGetTaskNumber((void *)pxTCB);
  prvTraceFreeObjectHandle(3, return_value_prvTraceGetTaskNumber$4);
  vPortExitCritical();
  vPortExitCritical();
  if(!(xSchedulerRunning == 0))
  {
    if(pxTCB == pxCurrentTCB)
    {
      if(!(uxSchedulerSuspended == 0u))
        vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 1200u);

      vPortGenerateSimulatedInterrupt(0ul);
    }

  }

}

// vTaskEndScheduler
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 2032
void vTaskEndScheduler(void)
{
  vPortEnterCritical();
  xSchedulerRunning = 0;
  vPortEndScheduler();
}

// vTaskGetInfo
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3570
void vTaskGetInfo(TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState)
{
  TCB_t *pxTCB=xTask == NULL ? (TCB_t *)pxCurrentTCB : (TCB_t *)xTask;
  pxTaskStatus->xHandle = (TaskHandle_t)pxTCB;
  pxTaskStatus->pcTaskName = (const char *)pxTCB->pcTaskName;
  pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
  pxTaskStatus->pxStackBase = pxTCB->pxStack;
  pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
  pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
  pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
  if(!((signed int)eState == 5))
  {
    if(pxTCB == pxCurrentTCB)
      pxTaskStatus->eCurrentState = /*enum*/eRunning;

    else
    {
      pxTaskStatus->eCurrentState = eState;
      if((signed int)eState == 3)
      {
        vTaskSuspendAll();
        if(!(pxTCB->xEventListItem.pvContainer == NULL))
          pxTaskStatus->eCurrentState = /*enum*/eBlocked;

        xTaskResumeAll();
      }

    }
  }

  else
    pxTaskStatus->eCurrentState=eTaskGetState((TaskHandle_t)pxTCB);
  if(!(xGetFreeStackSpace == 0))
    pxTaskStatus->usStackHighWaterMark=prvTaskCheckFreeStackSpace((uint8_t *)pxTCB->pxStack);

  else
    pxTaskStatus->usStackHighWaterMark = 0;
}

// vTaskGetRunTimeStats
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 4328
void vTaskGetRunTimeStats(char *pcWriteBuffer)
{
  TaskStatus_t *pxTaskStatusArray;
  volatile UBaseType_t uxArraySize;
  volatile UBaseType_t x;
  uint32_t ulTotalTime;
  uint32_t ulStatsAsPercentage;
  *pcWriteBuffer = 0;
  uxArraySize = uxCurrentNumberOfTasks;
  void *return_value_pvPortMalloc=pvPortMalloc((unsigned long long int)uxCurrentNumberOfTasks * sizeof(TaskStatus_t) /*56ull*/ );
  pxTaskStatusArray = (TaskStatus_t *)return_value_pvPortMalloc;
  if(!(pxTaskStatusArray == ((TaskStatus_t *)NULL)))
  {
    uxArraySize=uxTaskGetSystemState(pxTaskStatusArray, uxArraySize, &ulTotalTime);
    ulTotalTime = ulTotalTime / 100ul;
    if(ulTotalTime >= 1u)
    {
      x = 0ul;
      for( ; !(x >= uxArraySize); x = x + 1ul)
      {
        ulStatsAsPercentage = (pxTaskStatusArray + (signed long long int)x)->ulRunTimeCounter / ulTotalTime;
        pcWriteBuffer=prvWriteNameToBuffer(pcWriteBuffer, (pxTaskStatusArray + (signed long long int)x)->pcTaskName);
        if(ulStatsAsPercentage >= 1ul)
          sprintf(pcWriteBuffer, "\t%u\t\t%u%%\r\n", (unsigned int)(pxTaskStatusArray + (signed long long int)x)->ulRunTimeCounter, (unsigned int)ulStatsAsPercentage);

        else
          sprintf(pcWriteBuffer, "\t%u\t\t<1%%\r\n", (unsigned int)(pxTaskStatusArray + (signed long long int)x)->ulRunTimeCounter);
        size_t return_value_strlen=strlen(pcWriteBuffer);
        pcWriteBuffer = pcWriteBuffer + (signed long long int)return_value_strlen;
      }
    }

    vPortFree((void *)pxTaskStatusArray);
  }

}

// vTaskInternalSetTimeOutState
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3169
void vTaskInternalSetTimeOutState(TimeOut_t * const pxTimeOut)
{
  pxTimeOut->xOverflowCount = xNumOfOverflows;
  pxTimeOut->xTimeOnEntering = xTickCount;
}

// vTaskList
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 4230
void vTaskList(char *pcWriteBuffer)
{
  TaskStatus_t *pxTaskStatusArray;
  volatile UBaseType_t uxArraySize;
  volatile UBaseType_t x;
  char cStatus;
  *pcWriteBuffer = 0;
  uxArraySize = uxCurrentNumberOfTasks;
  void *return_value_pvPortMalloc=pvPortMalloc((unsigned long long int)uxCurrentNumberOfTasks * sizeof(TaskStatus_t) /*56ull*/ );
  pxTaskStatusArray = (TaskStatus_t *)return_value_pvPortMalloc;
  if(!(pxTaskStatusArray == ((TaskStatus_t *)NULL)))
  {
    uxArraySize=uxTaskGetSystemState(pxTaskStatusArray, uxArraySize, ((uint32_t *)NULL));
    x = 0ul;
    for( ; !(x >= uxArraySize); x = x + 1ul)
    {
      switch((signed int)(pxTaskStatusArray + (signed long long int)x)->eCurrentState)
      {
        case 0:
        {
          cStatus = 'X';
          break;
        }
        case 1:
        {
          cStatus = 'R';
          break;
        }
        case 2:
        {
          cStatus = 'B';
          break;
        }
        case 3:
        {
          cStatus = 'S';
          break;
        }
        case 4:
        {
          cStatus = 'D';
          break;
        }
        default:
          cStatus = 0;
      }
      pcWriteBuffer=prvWriteNameToBuffer(pcWriteBuffer, (pxTaskStatusArray + (signed long long int)x)->pcTaskName);
      sprintf(pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, (unsigned int)(pxTaskStatusArray + (signed long long int)x)->uxCurrentPriority, (unsigned int)(pxTaskStatusArray + (signed long long int)x)->usStackHighWaterMark, (unsigned int)(pxTaskStatusArray + (signed long long int)x)->xTaskNumber);
      size_t return_value_strlen=strlen(pcWriteBuffer);
      pcWriteBuffer = pcWriteBuffer + (signed long long int)return_value_strlen;
    }
    vPortFree((void *)pxTaskStatusArray);
  }

}

// vTaskMissedYield
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3240
void vTaskMissedYield(void)
{
  xYieldPending = 1;
}

// vTaskNotifyGiveFromISR
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 4864
void vTaskNotifyGiveFromISR(TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken)
{
  TCB_t *pxTCB;
  uint8_t ucOriginalNotifyState;
  UBaseType_t uxSavedInterruptStatus;
  if(xTaskToNotify == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 4870u);

  pxTCB = (TCB_t *)xTaskToNotify;
  uxSavedInterruptStatus = 0ul;
  ucOriginalNotifyState = pxTCB->ucNotifyState;
  pxTCB->ucNotifyState = 2;
  pxTCB->ulNotifiedValue = pxTCB->ulNotifiedValue + 1u;
  UBaseType_t return_value_uxTaskGetTaskNumber=uxTaskGetTaskNumber(xTaskToNotify);
  prvTraceStoreKernelCall(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + 18ul + 16ul + 8ul, 3, return_value_uxTaskGetTaskNumber);
  if(ucOriginalNotifyState == 1)
  {
    if(!(pxTCB->xEventListItem.pvContainer == NULL))
      vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 4908u);

    if(uxSchedulerSuspended == 0ul)
    {
      uxListRemove(&pxTCB->xStateListItem);
      traceHandle return_value_prvTraceGetTaskNumber=prvTraceGetTaskNumber((void *)pxTCB);
      prvTraceStoreTaskReady(return_value_prvTraceGetTaskNumber);
      uxTopReadyPriority = uxTopReadyPriority | 1ul << pxTCB->uxPriority;
      vListInsertEnd(&pxReadyTasksLists[(signed long long int)pxTCB->uxPriority], &pxTCB->xStateListItem);
    }

    else
      vListInsertEnd(&xPendingReadyList, &pxTCB->xEventListItem);
    if(!(pxCurrentTCB->uxPriority >= pxTCB->uxPriority))
    {
      if(!(pxHigherPriorityTaskWoken == ((BaseType_t *)NULL)))
        *pxHigherPriorityTaskWoken = 1;

      else
        xYieldPending = 1;
    }

  }

  (void)uxSavedInterruptStatus;
}

// vTaskPlaceOnEventList
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 2981
void vTaskPlaceOnEventList(List_t * const pxEventList, const TickType_t xTicksToWait)
{
  if(pxEventList == ((List_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 2983u);

  vListInsert(pxEventList, &pxCurrentTCB->xEventListItem);
  prvAddCurrentTaskToDelayedList(xTicksToWait, 1);
}

// vTaskPlaceOnEventListRestricted
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3024
void vTaskPlaceOnEventListRestricted(List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely)
{
  if(pxEventList == ((List_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 3026u);

  vListInsertEnd(pxEventList, &pxCurrentTCB->xEventListItem);
  if(!(xWaitIndefinitely == 0))
    xTicksToWait = 0xFFFFFFFFul;

  prvTraceStoreKernelCallWithNumericParamOnly(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 0ul, xTickCount + xTicksToWait);
  traceHandle return_value_prvTraceGetTaskNumber=prvTraceGetTaskNumber((void *)pxCurrentTCB);
  prvTraceSetTaskInstanceFinished((uint8_t)return_value_prvTraceGetTaskNumber);
  void *return_value_prvTraceGetCurrentTaskHandle=prvTraceGetCurrentTaskHandle();
  traceHandle return_value_prvTraceGetTaskNumber$0=prvTraceGetTaskNumber(return_value_prvTraceGetCurrentTaskHandle);
  prvTraceSetTaskInstanceFinished(return_value_prvTraceGetTaskNumber$0);
  prvAddCurrentTaskToDelayedList(xTicksToWait, xWaitIndefinitely);
}

// vTaskPlaceOnUnorderedEventList
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 2998
void vTaskPlaceOnUnorderedEventList(List_t *pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait)
{
  if(pxEventList == ((List_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 3000u);

  if(uxSchedulerSuspended == 0u)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 3004u);

  (&pxCurrentTCB->xEventListItem)->xItemValue = xItemValue | 0x80000000ul;
  vListInsertEnd(pxEventList, &pxCurrentTCB->xEventListItem);
  prvAddCurrentTaskToDelayedList(xTicksToWait, 1);
}

// vTaskPriorityDisinheritAfterTimeout
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 4039
void vTaskPriorityDisinheritAfterTimeout(const TaskHandle_t pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask)
{
  TCB_t * const pxTCB=(TCB_t *)pxMutexHolder;
  UBaseType_t uxPriorityUsedOnEntry;
  UBaseType_t uxPriorityToUse;
  const UBaseType_t uxOnlyOneMutexHeld=1ul;
  if(!(pxMutexHolder == NULL))
  {
    if(pxTCB->uxMutexesHeld == 0u)
      vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 4049u);

    if(!(pxTCB->uxBasePriority >= uxHighestPriorityWaitingTask))
      uxPriorityToUse = uxHighestPriorityWaitingTask;

    else
      uxPriorityToUse = pxTCB->uxBasePriority;
    if(!(pxTCB->uxPriority == uxPriorityToUse))
    {
      if(pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld)
      {
        if(pxTCB == pxCurrentTCB)
          vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 4076u);

        traceHandle return_value_prvTraceGetTaskNumber=prvTraceGetTaskNumber((void *)pxTCB);
        traceHandle return_value_prvTraceGetTaskNumber$0=prvTraceGetTaskNumber((void *)pxTCB);
        uint8_t return_value_prvTraceGetPriorityProperty=prvTraceGetPriorityProperty(3, return_value_prvTraceGetTaskNumber$0);
        prvTraceStoreKernelCallWithParam(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 7ul, 3, (uint32_t)return_value_prvTraceGetTaskNumber, (uint32_t)return_value_prvTraceGetPriorityProperty);
        traceHandle return_value_prvTraceGetTaskNumber$1=prvTraceGetTaskNumber((void *)pxTCB);
        prvTraceSetPriorityProperty(3, return_value_prvTraceGetTaskNumber$1, (uint8_t)pxTCB->uxBasePriority);
        uxPriorityUsedOnEntry = pxTCB->uxPriority;
        pxTCB->uxPriority = uxPriorityToUse;
        if((0x80000000ul & pxTCB->xEventListItem.xItemValue) == 0ul)
          (&pxTCB->xEventListItem)->xItemValue = 7u - (TickType_t)uxPriorityToUse;

        if(pxTCB->xStateListItem.pvContainer == (void *)(pxReadyTasksLists + (signed long long int)uxPriorityUsedOnEntry))
        {
          UBaseType_t return_value_uxListRemove=uxListRemove(&pxTCB->xStateListItem);
          if(return_value_uxListRemove == 0ul)
          {
            if(pxReadyTasksLists[(signed long long int)pxTCB->uxPriority].uxNumberOfItems == 0ul)
              uxTopReadyPriority = uxTopReadyPriority & ~(1ul << pxTCB->uxPriority);

          }

          traceHandle return_value_prvTraceGetTaskNumber$2=prvTraceGetTaskNumber((void *)pxTCB);
          prvTraceStoreTaskReady(return_value_prvTraceGetTaskNumber$2);
          uxTopReadyPriority = uxTopReadyPriority | 1ul << pxTCB->uxPriority;
          vListInsertEnd(&pxReadyTasksLists[(signed long long int)pxTCB->uxPriority], &pxTCB->xStateListItem);
        }

      }

    }

  }

}

// vTaskPrioritySet
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 1477
void vTaskPrioritySet(TaskHandle_t xTask, UBaseType_t uxNewPriority)
{
  TCB_t *pxTCB;
  UBaseType_t uxCurrentBasePriority;
  UBaseType_t uxPriorityUsedOnEntry;
  BaseType_t xYieldRequired=0;
  if(uxNewPriority >= 7u)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 1483u);

  if(uxNewPriority >= 7ul)
    uxNewPriority = 7ul - 1u;

  vPortEnterCritical();
  pxTCB = xTask == NULL ? (TCB_t *)pxCurrentTCB : (TCB_t *)xTask;
  traceHandle return_value_prvTraceGetTaskNumber=prvTraceGetTaskNumber((void *)pxTCB);
  traceHandle return_value_prvTraceGetTaskNumber$0=prvTraceGetTaskNumber((void *)pxTCB);
  uint8_t return_value_prvTraceGetPriorityProperty=prvTraceGetPriorityProperty(3, return_value_prvTraceGetTaskNumber$0);
  prvTraceStoreKernelCallWithParam(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 5ul, 3, (uint32_t)return_value_prvTraceGetTaskNumber, (uint32_t)return_value_prvTraceGetPriorityProperty);
  traceHandle return_value_prvTraceGetTaskNumber$1=prvTraceGetTaskNumber((void *)pxTCB);
  prvTraceSetPriorityProperty(3, return_value_prvTraceGetTaskNumber$1, (uint8_t)uxNewPriority);
  uxCurrentBasePriority = pxTCB->uxBasePriority;
  if(!(uxCurrentBasePriority == uxNewPriority))
  {
    if(!(uxCurrentBasePriority >= uxNewPriority))
    {
      if(!(pxTCB == pxCurrentTCB))
      {
        if(uxNewPriority >= pxCurrentTCB->uxPriority)
          xYieldRequired = 1;

      }

    }

    else
      if(pxTCB == pxCurrentTCB)
        xYieldRequired = 1;

    uxPriorityUsedOnEntry = pxTCB->uxPriority;
    if(pxTCB->uxBasePriority == pxTCB->uxPriority)
      pxTCB->uxPriority = uxNewPriority;

    pxTCB->uxBasePriority = uxNewPriority;
    if((0x80000000ul & pxTCB->xEventListItem.xItemValue) == 0ul)
      (&pxTCB->xEventListItem)->xItemValue = 7u - (TickType_t)uxNewPriority;

    if(pxTCB->xStateListItem.pvContainer == (void *)(pxReadyTasksLists + (signed long long int)uxPriorityUsedOnEntry))
    {
      UBaseType_t return_value_uxListRemove=uxListRemove(&pxTCB->xStateListItem);
      if(return_value_uxListRemove == 0ul)
        uxTopReadyPriority = uxTopReadyPriority & ~(1ul << uxPriorityUsedOnEntry);

      traceHandle return_value_prvTraceGetTaskNumber$2=prvTraceGetTaskNumber((void *)pxTCB);
      prvTraceStoreTaskReady(return_value_prvTraceGetTaskNumber$2);
      uxTopReadyPriority = uxTopReadyPriority | 1ul << pxTCB->uxPriority;
      vListInsertEnd(&pxReadyTasksLists[(signed long long int)pxTCB->uxPriority], &pxTCB->xStateListItem);
    }

    if(!(xYieldRequired == 0))
      vPortGenerateSimulatedInterrupt(0ul);

    (void)uxPriorityUsedOnEntry;
  }

  vPortExitCritical();
}

// vTaskRemoveFromUnorderedEventList
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3123
void vTaskRemoveFromUnorderedEventList(ListItem_t *pxEventListItem, const TickType_t xItemValue)
{
  TCB_t *pxUnblockedTCB;
  if(uxSchedulerSuspended == 0u)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 3129u);

  pxEventListItem->xItemValue = xItemValue | 0x80000000ul;
  pxUnblockedTCB = (TCB_t *)pxEventListItem->pvOwner;
  if(pxUnblockedTCB == ((TCB_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 3137u);

  uxListRemove(pxEventListItem);
  uxListRemove(&pxUnblockedTCB->xStateListItem);
  traceHandle return_value_prvTraceGetTaskNumber=prvTraceGetTaskNumber((void *)pxUnblockedTCB);
  prvTraceStoreTaskReady(return_value_prvTraceGetTaskNumber);
  uxTopReadyPriority = uxTopReadyPriority | 1ul << pxUnblockedTCB->uxPriority;
  vListInsertEnd(&pxReadyTasksLists[(signed long long int)pxUnblockedTCB->uxPriority], &pxUnblockedTCB->xStateListItem);
  if(!(pxCurrentTCB->uxPriority >= pxUnblockedTCB->uxPriority))
    xYieldPending = 1;

}

// vTaskResume
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 1788
void vTaskResume(TaskHandle_t xTaskToResume)
{
  TCB_t * const pxTCB=(TCB_t *)xTaskToResume;
  if(xTaskToResume == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 1793u);

  if(!(pxTCB == ((TCB_t *)NULL)) && !(pxTCB == pxCurrentTCB))
  {
    vPortEnterCritical();
    BaseType_t return_value_prvTaskIsTaskSuspended=prvTaskIsTaskSuspended((const TaskHandle_t)pxTCB);
    if(!(return_value_prvTaskIsTaskSuspended == 0))
    {
      traceHandle return_value_prvTraceGetTaskNumber=prvTraceGetTaskNumber((void *)pxTCB);
      prvTraceStoreKernelCall(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 3ul, 3, (uint32_t)return_value_prvTraceGetTaskNumber);
      uxListRemove(&pxTCB->xStateListItem);
      traceHandle return_value_prvTraceGetTaskNumber$0=prvTraceGetTaskNumber((void *)pxTCB);
      prvTraceStoreTaskReady(return_value_prvTraceGetTaskNumber$0);
      uxTopReadyPriority = uxTopReadyPriority | 1ul << pxTCB->uxPriority;
      vListInsertEnd(&pxReadyTasksLists[(signed long long int)pxTCB->uxPriority], &pxTCB->xStateListItem);
      if(pxTCB->uxPriority >= pxCurrentTCB->uxPriority)
        vPortGenerateSimulatedInterrupt(0ul);

    }

    vPortExitCritical();
  }

}

// vTaskSetTaskNumber
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3271
void vTaskSetTaskNumber(TaskHandle_t xTask, const UBaseType_t uxHandle)
{
  TCB_t *pxTCB;
  if(!(xTask == NULL))
  {
    pxTCB = (TCB_t *)xTask;
    pxTCB->uxTaskNumber = uxHandle;
  }

}

// vTaskSetThreadLocalStoragePointer
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3454
void vTaskSetThreadLocalStoragePointer(TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue)
{
  TCB_t *pxTCB;
  if(!(xIndex >= 3))
  {
    pxTCB = xTaskToSet == NULL ? (TCB_t *)pxCurrentTCB : (TCB_t *)xTaskToSet;
    pxTCB->pvThreadLocalStoragePointers[(signed long long int)xIndex] = pvValue;
  }

}

// vTaskSetTimeOutState
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3157
void vTaskSetTimeOutState(TimeOut_t * const pxTimeOut)
{
  if(pxTimeOut == ((TimeOut_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 3159u);

  vPortEnterCritical();
  pxTimeOut->xOverflowCount = xNumOfOverflows;
  pxTimeOut->xTimeOnEntering = xTickCount;
  vPortExitCritical();
}

// vTaskStartScheduler
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 1912
void vTaskStartScheduler(void)
{
  BaseType_t xReturn;
  StaticTask_t *pxIdleTaskTCBBuffer=((StaticTask_t *)NULL);
  StackType_t *pxIdleTaskStackBuffer=((StackType_t *)NULL);
  uint32_t ulIdleTaskStackSize;
  vApplicationGetIdleTaskMemory(&pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize);
  xIdleTaskHandle=xTaskCreateStatic(prvIdleTask, "IDLE", ulIdleTaskStackSize, NULL, 0u | 0ul, pxIdleTaskStackBuffer, pxIdleTaskTCBBuffer);
  if(!(xIdleTaskHandle == NULL))
    xReturn = 1;

  else
    xReturn = 0;
  if(xReturn == 1)
    xReturn=xTimerCreateTimerTask();

  if(xReturn == 1)
  {
    vPortEnterCritical();
    xNextTaskUnblockTime = 0xFFFFFFFFul;
    xSchedulerRunning = 1;
    xTickCount = 0u;
    vConfigureTimerForRunTimeStats();
    BaseType_t return_value_xPortStartScheduler=xPortStartScheduler();
  }

  else
    if(xReturn == -1)
      vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 2023u);

  (void)xIdleTaskHandle;
}

// vTaskSuspend
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 1641
void vTaskSuspend(TaskHandle_t xTaskToSuspend)
{
  TCB_t *pxTCB;
  vPortEnterCritical();
  pxTCB = xTaskToSuspend == NULL ? (TCB_t *)pxCurrentTCB : (TCB_t *)xTaskToSuspend;
  traceHandle return_value_prvTraceGetTaskNumber=prvTraceGetTaskNumber((void *)pxTCB);
  prvTraceStoreKernelCall(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 2ul, 3, (uint32_t)return_value_prvTraceGetTaskNumber);
  traceHandle return_value_prvTraceGetTaskNumber$0=prvTraceGetTaskNumber((void *)pxTCB);
  prvTraceSetTaskInstanceFinished((uint8_t)return_value_prvTraceGetTaskNumber$0);
  UBaseType_t return_value_uxListRemove=uxListRemove(&pxTCB->xStateListItem);
  if(return_value_uxListRemove == 0ul)
  {
    if(pxReadyTasksLists[(signed long long int)pxTCB->uxPriority].uxNumberOfItems == 0ul)
      uxTopReadyPriority = uxTopReadyPriority & ~(1ul << pxTCB->uxPriority);

  }

  if(!(pxTCB->xEventListItem.pvContainer == NULL))
    uxListRemove(&pxTCB->xEventListItem);

  vListInsertEnd(&xSuspendedTaskList, &pxTCB->xStateListItem);
  if(pxTCB->ucNotifyState == 1)
    pxTCB->ucNotifyState = 0;

  vPortExitCritical();
  if(!(xSchedulerRunning == 0))
  {
    vPortEnterCritical();
    prvResetNextTaskUnblockTime();
    vPortExitCritical();
  }

  if(pxTCB == pxCurrentTCB)
  {
    if(!(xSchedulerRunning == 0))
    {
      if(!(uxSchedulerSuspended == 0u))
        vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 1709u);

      vPortGenerateSimulatedInterrupt(0ul);
    }

    else
      if(xSuspendedTaskList.uxNumberOfItems == uxCurrentNumberOfTasks)
        pxCurrentTCB = ((TCB_t *)NULL);

      else
        vTaskSwitchContext();
  }

}

// vTaskSuspendAll
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 2043
void vTaskSuspendAll(void)
{
  uxSchedulerSuspended = uxSchedulerSuspended + 1ul;
}

// vTaskSwitchContext
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 2908
void vTaskSwitchContext(void)
{
  if(!(uxSchedulerSuspended == 0ul))
    xYieldPending = 1;

  else
  {
    xYieldPending = 0;
    ulTotalRunTime=ulGetRunTimeCounterValue();
    if(!(ulTaskSwitchedInTime >= ulTotalRunTime))
      pxCurrentTCB->ulRunTimeCounter = pxCurrentTCB->ulRunTimeCounter + (ulTotalRunTime - ulTaskSwitchedInTime);

    ulTaskSwitchedInTime = ulTotalRunTime;
    UBaseType_t uxTopPriority;
    _BitScanReverse((DWORD *)&uxTopPriority, uxTopReadyPriority);
    if(!(pxReadyTasksLists[(signed long long int)uxTopPriority].uxNumberOfItems >= 1u))
      vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 2960u);

    List_t * const pxConstList=&pxReadyTasksLists[(signed long long int)uxTopPriority];
    pxConstList->pxIndex = pxConstList->pxIndex->pxNext;
    if((void *)pxConstList->pxIndex == (void *)&pxConstList->xListEnd)
      pxConstList->pxIndex = pxConstList->pxIndex->pxNext;

    pxCurrentTCB = (TCB_t *)pxConstList->pxIndex->pvOwner;
    void *return_value_prvTraceGetCurrentTaskHandle=prvTraceGetCurrentTaskHandle();
    traceHandle return_value_prvTraceGetTaskNumber=prvTraceGetTaskNumber(return_value_prvTraceGetCurrentTaskHandle);
    prvTraceStoreTaskswitch(return_value_prvTraceGetTaskNumber);
  }
}

// vTimerSetTimerID
// file ..\..\..\..\lib\FreeRTOS\timers.c line 983
void vTimerSetTimerID(TimerHandle_t xTimer, void *pvNewID)
{
  Timer_t * const pxTimer=(Timer_t *)xTimer;
  if(xTimer == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\timers.c", 987u);

  vPortEnterCritical();
  pxTimer->pvTimerID = pvNewID;
  vPortExitCritical();
}

// vTimerSetTimerNumber
// file ..\..\..\..\lib\FreeRTOS\timers.c line 1062
void vTimerSetTimerNumber(TimerHandle_t xTimer, UBaseType_t uxTimerNumber)
{
  ((Timer_t *)xTimer)->uxTimerNumber = uxTimerNumber;
}

// vTraceClear
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 277
void vTraceClear(void)
{
  vPortEnterCritical();
  recorder_busy = recorder_busy + 1;
  RecorderDataPtr->absTimeLastEventSecond = 0u;
  RecorderDataPtr->absTimeLastEvent = 0u;
  RecorderDataPtr->nextFreeIndex = 0u;
  RecorderDataPtr->numEvents = 0u;
  RecorderDataPtr->bufferIsFull = 0u;
  traceErrorMessage = ((const char *)NULL);
  RecorderDataPtr->internalErrorOccured = 0u;
  memset((void *)RecorderDataPtr->eventData, 0, (size_t)(RecorderDataPtr->maxEvents * 4u));
  handle_of_last_logged_task = 0;
  recorder_busy = recorder_busy - 1;
  vPortExitCritical();
}

// vTraceClearError
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 398
void vTraceClearError(void)
{
  traceErrorMessage = ((const char *)NULL);
  if(!(RecorderDataPtr == ((RecorderDataType *)NULL)))
    RecorderDataPtr->internalErrorOccured = 0u;

}

// vTraceEnable
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 228
void vTraceEnable(signed int startOption)
{
  prvTraceInitTraceData();
  if(startOption == 1)
    vTraceStart();

  else
    if(startOption == 2)
      prvTraceError("vTraceEnable(TRC_START_AWAIT_HOST) not allowed in Snapshot mode");

    else
      if(!(startOption == 0))
        prvTraceError("Unexpected argument to vTraceEnable (snapshot mode)");

}

// vTraceInitObjectHandleStack
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcKernelPort.c line 515
void vTraceInitObjectHandleStack(void)
{
  objectHandleStacks.lowestIndexOfClass[0ll] = 0;
  objectHandleStacks.indexOfNextAvailableHandle[0ll] = objectHandleStacks.lowestIndexOfClass[0ll];
  objectHandleStacks.lowestIndexOfClass[1ll] = 90;
  objectHandleStacks.indexOfNextAvailableHandle[1ll] = objectHandleStacks.lowestIndexOfClass[1ll];
  objectHandleStacks.lowestIndexOfClass[2ll] = (uint16_t)(90 + 90);
  objectHandleStacks.indexOfNextAvailableHandle[2ll] = objectHandleStacks.lowestIndexOfClass[2ll];
  objectHandleStacks.lowestIndexOfClass[3ll] = (uint16_t)(90 + 90 + 90);
  objectHandleStacks.indexOfNextAvailableHandle[3ll] = objectHandleStacks.lowestIndexOfClass[3ll];
  objectHandleStacks.lowestIndexOfClass[4ll] = (uint16_t)(90 + 90 + 90 + 150);
  objectHandleStacks.indexOfNextAvailableHandle[4ll] = objectHandleStacks.lowestIndexOfClass[4ll];
  objectHandleStacks.lowestIndexOfClass[5ll] = (uint16_t)(90 + 90 + 90 + 150 + 90);
  objectHandleStacks.indexOfNextAvailableHandle[5ll] = objectHandleStacks.lowestIndexOfClass[5ll];
  objectHandleStacks.lowestIndexOfClass[6ll] = (uint16_t)(90 + 90 + 90 + 150 + 90 + 250);
  objectHandleStacks.indexOfNextAvailableHandle[6ll] = objectHandleStacks.lowestIndexOfClass[6ll];
  objectHandleStacks.highestIndexOfClass[0ll] = (uint16_t)(90 - 1);
  objectHandleStacks.highestIndexOfClass[1ll] = (uint16_t)((90 + 90) - 1);
  objectHandleStacks.highestIndexOfClass[2ll] = (uint16_t)((90 + 90 + 90) - 1);
  objectHandleStacks.highestIndexOfClass[3ll] = (uint16_t)((90 + 90 + 90 + 150) - 1);
  objectHandleStacks.highestIndexOfClass[4ll] = (uint16_t)((90 + 90 + 90 + 150 + 90) - 1);
  objectHandleStacks.highestIndexOfClass[5ll] = (uint16_t)((90 + 90 + 90 + 150 + 90 + 250) - 1);
  objectHandleStacks.highestIndexOfClass[6ll] = (uint16_t)((90 + 90 + 90 + 150 + 90 + 250 + 90) - 1);
}

// vTraceInitObjectPropertyTable
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcKernelPort.c line 480
void vTraceInitObjectPropertyTable(void)
{
  RecorderDataPtr->ObjectPropertyTable.NumberOfObjectClasses = 7u;
  RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[0ll] = 90;
  RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[1ll] = 90;
  RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[2ll] = 90;
  RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[3ll] = 150;
  RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[4ll] = 90;
  RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[5ll] = 250;
  RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[6ll] = 90;
  RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[0ll] = 15;
  RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[1ll] = 15;
  RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[2ll] = 15;
  RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[3ll] = 15;
  RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[4ll] = 15;
  RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[5ll] = 15;
  RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[6ll] = 15;
  RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[0ll] = (uint8_t)(15 + 1);
  RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[1ll] = (uint8_t)(15 + 1);
  RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[2ll] = (uint8_t)(15 + 1);
  RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[3ll] = (uint8_t)(15 + 4);
  RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[4ll] = (uint8_t)(15 + 2);
  RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[5ll] = (uint8_t)(15 + 1);
  RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[6ll] = (uint8_t)(15 + 4);
  RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[0ll] = 0;
  RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[1ll] = (uint16_t)(0 + 90 * (15 + 1));
  RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[2ll] = (uint16_t)(0 + 90 * (15 + 1) + 90 * (15 + 1));
  RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[3ll] = (uint16_t)(0 + 90 * (15 + 1) + 90 * (15 + 1) + 90 * (15 + 1));
  RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[4ll] = (uint16_t)(0 + 90 * (15 + 1) + 90 * (15 + 1) + 90 * (15 + 1) + 150 * (15 + 4));
  RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[5ll] = (uint16_t)(0 + 90 * (15 + 1) + 90 * (15 + 1) + 90 * (15 + 1) + 150 * (15 + 4) + 90 * (15 + 2));
  RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[6ll] = (uint16_t)(0 + 90 * (15 + 1) + 90 * (15 + 1) + 90 * (15 + 1) + 150 * (15 + 4) + 90 * (15 + 2) + 250 * (15 + 1));
  RecorderDataPtr->ObjectPropertyTable.ObjectPropertyTableSizeInBytes = (uint32_t)(0 + 90 * (15 + 1) + 90 * (15 + 1) + 90 * (15 + 1) + 150 * (15 + 4) + 90 * (15 + 2) + 250 * (15 + 1) + 90 * (15 + 4));
}

// vTraceInstanceFinishedNext
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 489
void vTraceInstanceFinishedNext(void)
{
  prvTraceTaskInstanceFinish(0);
}

// vTraceInstanceFinishedNow
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 521
void vTraceInstanceFinishedNow(void)
{
  prvTraceTaskInstanceFinish(1);
}

// vTracePrint
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 1447
void vTracePrint(traceString chn, const char *str)
{
  UserEvent *ue;
  uint8_t dts1;
  vPortEnterCritical();
  recorder_busy = recorder_busy + 1;
  if(!(RecorderDataPtr->recorderActive == 0u))
  {
    if(inExcludedTask == 0 || !(nISRactive == 0))
    {
      if(!(handle_of_last_logged_task == 0))
      {
        uint16_t return_value_prvTraceGetDTS=prvTraceGetDTS(255);
        dts1 = (uint8_t)return_value_prvTraceGetDTS;
        void *return_value_prvTraceNextFreeEventBufferSlot=prvTraceNextFreeEventBufferSlot();
        ue = (UserEvent *)return_value_prvTraceNextFreeEventBufferSlot;
        if(!(ue == ((UserEvent *)NULL)))
        {
          ue->dts = dts1;
          ue->type = (uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 0ul);
          ue->payload=prvTraceOpenSymbol(str, chn);
          prvTraceUpdateCounters();
        }

      }

    }

  }

  recorder_busy = recorder_busy - 1;
  vPortExitCritical();
}

// vTracePrintF
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 1311
void vTracePrintF(traceString eventLabel, const char *formatStr, ...)
{
  va_list vl;
	va_start(vl, formatStr);
  vTracePrintF_Helper(eventLabel, formatStr, vl);
  /*vl = ((va_list)NULL);*/
	va_end(vl);
}

// vTracePrintF_Helper
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 1322
static void vTracePrintF_Helper(traceString eventLabel, const char *formatStr, va_list vl)
{
  uint32_t noOfSlots;
  UserEvent *ue1;
  uint32_t tempDataBuffer[9ll];
  if(formatStr == ((const char *)NULL))
    prvTraceError("TRACE_ASSERT: vTracePrintF_Helper: formatStr == NULL");

  else
  {
    vPortEnterCritical();
    recorder_busy = recorder_busy + 1;
    if(!(RecorderDataPtr->recorderActive == 0u))
    {
      if(inExcludedTask == 0 || !(nISRactive == 0))
      {
        if(!(handle_of_last_logged_task == 0))
        {
          ue1 = (UserEvent *)tempDataBuffer;
          ue1->type = (uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 2ul);
          uint8_t return_value_prvTraceUserEventFormat=prvTraceUserEventFormat(formatStr, vl, (uint8_t *)tempDataBuffer, 4);
          noOfSlots = (uint32_t)return_value_prvTraceUserEventFormat;
          ue1->payload=prvTraceOpenSymbol(formatStr, eventLabel);
          uint16_t return_value_prvTraceGetDTS=prvTraceGetDTS(255);
          ue1->dts = (uint8_t)return_value_prvTraceGetDTS;
          if(!(RecorderDataPtr->recorderActive == 0u))
          {
            if(!(RecorderDataPtr->maxEvents >= RecorderDataPtr->nextFreeIndex + noOfSlots))
            {
              memset((void *)&RecorderDataPtr->eventData[(signed long long int)(RecorderDataPtr->nextFreeIndex * 4u)], 0, (size_t)((RecorderDataPtr->maxEvents - RecorderDataPtr->nextFreeIndex) * 4u));
              RecorderDataPtr->nextFreeIndex = 0u;
              RecorderDataPtr->bufferIsFull = 1u;
            }

            if(!(RecorderDataPtr->recorderActive == 0u))
            {
              prvCheckDataToBeOverwrittenForMultiEntryEvents((uint8_t)noOfSlots);
              memcpy((void *)&RecorderDataPtr->eventData[(signed long long int)(RecorderDataPtr->nextFreeIndex * 4u)], (const void *)tempDataBuffer, (size_t)(noOfSlots * 4u));
              RecorderDataPtr->eventData[(signed long long int)(RecorderDataPtr->nextFreeIndex * 4u)] = (uint8_t)((0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 0ul + noOfSlots) - 1u);
              RecorderDataPtr->nextFreeIndex = RecorderDataPtr->nextFreeIndex + noOfSlots;
              RecorderDataPtr->numEvents = RecorderDataPtr->numEvents + noOfSlots;
              if(RecorderDataPtr->nextFreeIndex >= 15000u)
              {
                RecorderDataPtr->bufferIsFull = 1u;
                RecorderDataPtr->nextFreeIndex = 0u;
              }

            }

            prvCheckDataToBeOverwrittenForMultiEntryEvents(1);
          }

        }

      }

    }

    recorder_busy = recorder_busy - 1;
    vPortExitCritical();
  }
}

// vTraceSetFrequency
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 2516
void vTraceSetFrequency(uint32_t frequency)
{
  timestampFrequency = frequency;
}

// vTraceSetMutexName
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcKernelPort.c line 447
void vTraceSetMutexName(void *object, const char *name)
{
  uint8_t return_value_prvTraceGetObjectType=prvTraceGetObjectType(object);
  traceHandle return_value_prvTraceGetObjectNumber=prvTraceGetObjectNumber(object);
  prvTraceSetObjectName(TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType], return_value_prvTraceGetObjectNumber, name);
}

// vTraceSetQueueName
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcKernelPort.c line 421
void vTraceSetQueueName(void *object, const char *name)
{
  uint8_t return_value_prvTraceGetObjectType=prvTraceGetObjectType(object);
  traceHandle return_value_prvTraceGetObjectNumber=prvTraceGetObjectNumber(object);
  prvTraceSetObjectName(TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType], return_value_prvTraceGetObjectNumber, name);
}

// vTraceSetSemaphoreName
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcKernelPort.c line 434
void vTraceSetSemaphoreName(void *object, const char *name)
{
  uint8_t return_value_prvTraceGetObjectType=prvTraceGetObjectType(object);
  traceHandle return_value_prvTraceGetObjectNumber=prvTraceGetObjectNumber(object);
  prvTraceSetObjectName(TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType], return_value_prvTraceGetObjectNumber, name);
}

// vTraceSetStopHook
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 266
void vTraceSetStopHook(TRACE_STOP_HOOK stopHookFunction)
{
  vTraceStopHookPtr = stopHookFunction;
}

// vTraceStart
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 358
void vTraceStart(void)
{
  uiTraceStart();
}

// vTraceStop
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 369
void vTraceStop(void)
{
  RecorderDataPtr->recorderActive = 0u;
  if(!(vTraceStopHookPtr == ((TRACE_STOP_HOOK)NULL)))
    vTraceStopHookPtr();

}

// vTraceStoreISRBegin
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 583
void vTraceStoreISRBegin(traceHandle handle)
{
  if(!(recorder_busy == 0))
    prvTraceError("vTraceStoreISRBegin - recorder busy! See code comment.");

  else
  {
    vPortEnterCritical();
    recorder_busy = recorder_busy + 1;
    if(!(RecorderDataPtr->recorderActive == 0u))
    {
      if(!(handle_of_last_logged_task == 0))
      {
        uint16_t dts4;
        if(!((signed int)RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[4ll] >= (signed int)handle))
        {
          prvTraceError("TRACE_ASSERT: vTraceStoreISRBegin: Invalid value for handle");
          goto __CPROVER_DUMP_L9;
        }

        uint16_t return_value_prvTraceGetDTS=prvTraceGetDTS(65535);
        dts4 = (uint16_t)return_value_prvTraceGetDTS;
        if(!(RecorderDataPtr->recorderActive == 0u))
        {
          if(!((signed int)nISRactive >= 8))
          {
            TSEvent *ts;
            uint8_t hnd8=(uint8_t)handle;
            isrstack[(signed long long int)nISRactive] = handle;
            nISRactive = nISRactive + 1;
            void *return_value_prvTraceNextFreeEventBufferSlot=prvTraceNextFreeEventBufferSlot();
            ts = (TSEvent *)return_value_prvTraceNextFreeEventBufferSlot;
            if(!(ts == ((TSEvent *)NULL)))
            {
              ts->type = (uint8_t)(0x0ul + 1ul + 3ul + 0ul);
              ts->dts = dts4;
              ts->objHandle = hnd8;
              prvTraceUpdateCounters();
            }

          }

          else
            prvTraceError("Too many nested interrupts!");
        }

      }

    }

    recorder_busy = recorder_busy - 1;
    vPortExitCritical();
  }

__CPROVER_DUMP_L9:
  ;
}

// vTraceStoreISREnd
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 662
void vTraceStoreISREnd(signed int pendingISR)
{
  TSEvent *ts;
  uint16_t dts5;
  uint8_t hnd8=0;
  uint8_t type=0;
  _Bool tmp_if_expr;
  unsigned char return_value_prvTraceIsSchedulerSuspended;
  if(!(RecorderDataPtr->recorderActive == 0u) && !(handle_of_last_logged_task == 0))
  {
    if(!(recorder_busy == 0))
      prvTraceError("vTraceStoreISREnd - recorder busy! See code comment.");

    else
      if((signed int)nISRactive == 0)
        prvTraceError("Unmatched call to vTraceStoreISREnd (nISRactive == 0, expected > 0)");

      else
      {
        vPortEnterCritical();
        recorder_busy = recorder_busy + 1;
        isPendingContextSwitch = isPendingContextSwitch | pendingISR;
        nISRactive = nISRactive - 1;
        if((signed int)nISRactive >= 1)
        {
          type = (uint8_t)(0x0ul + 1ul + 3ul + 1ul);
          hnd8 = (uint8_t)isrstack[(signed long long int)((signed int)nISRactive - 1)];
        }

        else
        {
          if(isPendingContextSwitch == 0)
            tmp_if_expr = (_Bool)1;

          else
          {
            return_value_prvTraceIsSchedulerSuspended=prvTraceIsSchedulerSuspended();
            tmp_if_expr = return_value_prvTraceIsSchedulerSuspended != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr)
          {
            type = (uint8_t)(0x0ul + 1ul + 3ul + 3ul);
            hnd8 = (uint8_t)handle_of_last_logged_task;
          }

        }
        if(!((signed int)type == 0))
        {
          uint16_t return_value_prvTraceGetDTS=prvTraceGetDTS(65535);
          dts5 = (uint16_t)return_value_prvTraceGetDTS;
          void *return_value_prvTraceNextFreeEventBufferSlot=prvTraceNextFreeEventBufferSlot();
          ts = (TSEvent *)return_value_prvTraceNextFreeEventBufferSlot;
          if(!(ts == ((TSEvent *)NULL)))
          {
            ts->type = type;
            ts->objHandle = hnd8;
            ts->dts = dts5;
            prvTraceUpdateCounters();
          }

        }

        recorder_busy = recorder_busy - 1;
        vPortExitCritical();
      }
  }

}

// vTraceStoreMemMangEvent
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 1642
extern void vTraceStoreMemMangEvent(uint32_t ecode, uint32_t address, int32_t signed_size)
{
  uint8_t dts1;
  MemEventSize *ms;
  MemEventAddr *ma;
  uint16_t size_low;
  uint16_t addr_low;
  uint8_t addr_high;
  uint32_t size;
  if(!(RecorderDataPtr == ((RecorderDataType *)NULL)))
  {
    if(!(signed_size >= 0))
      size = (uint32_t)-signed_size;

    else
      size = (uint32_t)signed_size;
    vPortEnterCritical();
    recorder_busy = recorder_busy + 1;
    heapMemUsage = heapMemUsage + (uint32_t)signed_size;
    if(!(RecorderDataPtr->recorderActive == 0u))
    {
      if(inExcludedTask == 0 || !(nISRactive == 0))
      {
        uint16_t return_value_prvTraceGetDTS=prvTraceGetDTS(255);
        dts1 = (uint8_t)return_value_prvTraceGetDTS;
        uint32_t return_value_prvTraceGetParam=prvTraceGetParam(65535u, size);
        size_low = (uint16_t)return_value_prvTraceGetParam;
        void *return_value_prvTraceNextFreeEventBufferSlot=prvTraceNextFreeEventBufferSlot();
        ms = (MemEventSize *)return_value_prvTraceNextFreeEventBufferSlot;
        if(!(ms == ((MemEventSize *)NULL)))
        {
          ms->dts = dts1;
          ms->type = 0;
          ms->size = size_low;
          prvTraceUpdateCounters();
          uint32_t return_value_prvTraceGetParam$0=prvTraceGetParam(65535u, address);
          addr_low = (uint16_t)return_value_prvTraceGetParam$0;
          addr_high = 0;
          void *return_value_prvTraceNextFreeEventBufferSlot$0=prvTraceNextFreeEventBufferSlot();
          ma = (MemEventAddr *)return_value_prvTraceNextFreeEventBufferSlot$0;
          if(!(ma == ((MemEventAddr *)NULL)))
          {
            ma->addr_low = addr_low;
            ma->addr_high = addr_high;
            ma->type = (uint8_t)(ecode + 1u);
            ms->type = (uint8_t)ecode;
            prvTraceUpdateCounters();
            RecorderDataPtr->heapMemUsage = heapMemUsage;
          }

        }

      }

    }

    recorder_busy = recorder_busy - 1;
    vPortExitCritical();
  }

}

// value_to_pretty
// file ..\..\..\..\lib\third_party\tinycbor\cborpretty.c line 267
static CborError value_to_pretty(FILE *out, CborValue *it)
{
  CborError err;
  CborType type=cbor_value_get_type$link1(it);
  signed int return_value_hexDump;
  signed int return_value_fprintf$6;
  signed int return_value_utf8EscapedDump;
  signed int return_value_fprintf$8;
  signed short int return_value__fdclass;
  signed int tmp_if_expr$3;
  signed short int return_value__dclass;
  signed short int return_value__ldclass;
  if(!((signed int)type == 128) && !((signed int)type == 160))
  {
    if((signed int)type == 0)
      goto __CPROVER_DUMP_L9;

    if((signed int)type == 64)
      goto __CPROVER_DUMP_L17;

    if((signed int)type == 96)
      goto __CPROVER_DUMP_L23;

    if((signed int)type == 192)
      goto __CPROVER_DUMP_L29;

    if((signed int)type == 224)
      goto __CPROVER_DUMP_L34;

    if((signed int)type == 246)
      goto __CPROVER_DUMP_L36;

    if((signed int)type == 247)
      goto __CPROVER_DUMP_L38;

    if((signed int)type == 245)
      goto __CPROVER_DUMP_L40;

    if((signed int)type == 250)
      goto __CPROVER_DUMP_L43;

    if((signed int)type == 249)
      goto __CPROVER_DUMP_L45;

    if((signed int)type == 251)
      goto __CPROVER_DUMP_L42;

    if((signed int)type == 255)
      goto __CPROVER_DUMP_L57;

  }

  else
  {
    CborValue recursed;
    signed int return_value_fprintf=fprintf(out, (signed int)type == 128 ? "[" : "{");
    if(!(return_value_fprintf >= 0))
      return /*enum*/CborErrorIO;

    _Bool return_value_cbor_value_is_length_known=cbor_value_is_length_known$link1(it);
    if(return_value_cbor_value_is_length_known == (_Bool)0)
    {
      signed int return_value_fprintf$0=fprintf(out, "_ ");
      if(!(return_value_fprintf$0 >= 0))
        return /*enum*/CborErrorIO;

    }

    err=cbor_value_enter_container(it, &recursed);
    if(!(err == /*enum*/CborNoError))
    {
      it->ptr = recursed.ptr;
      return err;
    }

    err=container_to_pretty(out, &recursed, type);
    if(!(err == /*enum*/CborNoError))
    {
      it->ptr = recursed.ptr;
      return err;
    }

    err=cbor_value_leave_container(it, &recursed);
    if(!(err == /*enum*/CborNoError))
      return err;

    signed int return_value_fprintf$1=fprintf(out, (signed int)type == 128 ? "]" : "}");
    if(!(return_value_fprintf$1 >= 0))
      return /*enum*/CborErrorIO;

    return /*enum*/CborNoError;

  __CPROVER_DUMP_L9:
    ;
    uint64_t value_to_pretty$$1$$1$$2$$val;
    cbor_value_get_raw_integer(it, &value_to_pretty$$1$$1$$2$$val);
    _Bool return_value_cbor_value_is_unsigned_integer=cbor_value_is_unsigned_integer(it);
    if(!(return_value_cbor_value_is_unsigned_integer == (_Bool)0))
    {
      signed int return_value_fprintf$2=fprintf(out, "%llu", value_to_pretty$$1$$1$$2$$val);
      if(!(return_value_fprintf$2 >= 0))
        return /*enum*/CborErrorIO;

    }

    else
    {
      value_to_pretty$$1$$1$$2$$val = value_to_pretty$$1$$1$$2$$val + 1ull;
      if(!(value_to_pretty$$1$$1$$2$$val == 0ull))
      {
        signed int return_value_fprintf$3=fprintf(out, "-%llu", value_to_pretty$$1$$1$$2$$val);
        if(!(return_value_fprintf$3 >= 0))
          return /*enum*/CborErrorIO;

      }

      else
      {
        signed int return_value_fprintf$4=fprintf(out, "-18446744073709551616");
        if(!(return_value_fprintf$4 >= 0))
          return /*enum*/CborErrorIO;

      }
    }
    goto __CPROVER_DUMP_L59;

  __CPROVER_DUMP_L17:
    ;
    size_t value_to_pretty$$1$$1$$3$$n=0ull;
    uint8_t *buffer;
    err=cbor_value_dup_byte_string(it, &buffer, &value_to_pretty$$1$$1$$3$$n, it);
    if(!(err == /*enum*/CborNoError))
      return err;

    _Bool failed;
    signed int return_value_fprintf$5=fprintf(out, "h'");
    _Bool tmp_if_expr;
    if(!(return_value_fprintf$5 >= 0))
      tmp_if_expr = (_Bool)1;

    else
    {
      return_value_hexDump=hexDump(out, buffer, value_to_pretty$$1$$1$$3$$n);
      tmp_if_expr = return_value_hexDump < 0 ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr$0;
    if(tmp_if_expr)
      tmp_if_expr$0 = (_Bool)1;

    else
    {
      return_value_fprintf$6=fprintf(out, "'");
      tmp_if_expr$0 = return_value_fprintf$6 < 0 ? (_Bool)1 : (_Bool)0;
    }
    failed = tmp_if_expr$0;
    free((void *)buffer);
    return (CborError)(failed != (_Bool)0 ? 4 : 0);

  __CPROVER_DUMP_L23:
    ;
    size_t n=0ull;
    char *value_to_pretty$$1$$1$$4$$buffer;
    err=cbor_value_dup_text_string(it, &value_to_pretty$$1$$1$$4$$buffer, &n, it);
    if(!(err == /*enum*/CborNoError))
      return err;

    err = /*enum*/CborNoError;
    _Bool value_to_pretty$$1$$1$$4$$failed;
    signed int return_value_fprintf$7=fprintf(out, "\"");
    _Bool tmp_if_expr$1;
    if(!(return_value_fprintf$7 >= 0))
      tmp_if_expr$1 = (_Bool)1;

    else
    {
      return_value_utf8EscapedDump=utf8EscapedDump(out, value_to_pretty$$1$$1$$4$$buffer, n);
      err = (CborError)return_value_utf8EscapedDump;
      tmp_if_expr$1 = (signed int)err != 0 ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr$2;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (_Bool)1;

    else
    {
      return_value_fprintf$8=fprintf(out, "\"");
      tmp_if_expr$2 = return_value_fprintf$8 < 0 ? (_Bool)1 : (_Bool)0;
    }
    value_to_pretty$$1$$1$$4$$failed = tmp_if_expr$2;
    free((void *)value_to_pretty$$1$$1$$4$$buffer);
    return (CborError)((signed int)err != 0 ? (signed int)err : (value_to_pretty$$1$$1$$4$$failed != (_Bool)0 ? 4 : 0));

  __CPROVER_DUMP_L29:
    ;
    CborTag value_to_pretty$$1$$1$$5$$tag;
    cbor_value_get_tag(it, &value_to_pretty$$1$$1$$5$$tag);
    signed int return_value_fprintf$9=fprintf(out, "%llu(", value_to_pretty$$1$$1$$5$$tag);
    if(!(return_value_fprintf$9 >= 0))
      return /*enum*/CborErrorIO;

    err=cbor_value_advance_fixed(it);
    if(!(err == /*enum*/CborNoError))
      return err;

    err=value_to_pretty(out, it);
    if(!(err == /*enum*/CborNoError))
      return err;

    signed int return_value_fprintf$10=fprintf(out, ")");
    if(!(return_value_fprintf$10 >= 0))
      return /*enum*/CborErrorIO;

    return /*enum*/CborNoError;

  __CPROVER_DUMP_L34:
    ;
    uint8_t simple_type;
    cbor_value_get_simple_type(it, &simple_type);
    signed int return_value_fprintf$11=fprintf(out, "simple(%hhu)", simple_type);
    if(!(return_value_fprintf$11 >= 0))
      return /*enum*/CborErrorIO;

    goto __CPROVER_DUMP_L59;

  __CPROVER_DUMP_L36:
    ;
    signed int return_value_fprintf$12=fprintf(out, "null");
    if(!(return_value_fprintf$12 >= 0))
      return /*enum*/CborErrorIO;

    goto __CPROVER_DUMP_L59;

  __CPROVER_DUMP_L38:
    ;
    signed int return_value_fprintf$13=fprintf(out, "undefined");
    if(!(return_value_fprintf$13 >= 0))
      return /*enum*/CborErrorIO;

    goto __CPROVER_DUMP_L59;

  __CPROVER_DUMP_L40:
    ;
    _Bool value_to_pretty$$1$$1$$7$$val;
    cbor_value_get_boolean(it, &value_to_pretty$$1$$1$$7$$val);
    signed int return_value_fprintf$14=fprintf(out, value_to_pretty$$1$$1$$7$$val != (_Bool)0 ? "true" : "false");
    if(!(return_value_fprintf$14 >= 0))
      return /*enum*/CborErrorIO;

    goto __CPROVER_DUMP_L59;

  __CPROVER_DUMP_L42:
    ;
    const char *suffix;
    double val;
    if((_Bool)0)
    {
      float f;

    __CPROVER_DUMP_L43:
      ;
      cbor_value_get_float(it, &f);
      val = (double)f;
      suffix = "f";
    }

    else
    {

    __CPROVER_DUMP_L44:
      ;
      if((_Bool)0)
      {
        uint16_t f16;

      __CPROVER_DUMP_L45:
        ;
        cbor_value_get_half_float(it, (void *)&f16);
        val=decode_half(f16);
        suffix = "f16";
      }

      else
      {
        cbor_value_get_double(it, &val);
        suffix = "";
      }
    }

  __CPROVER_DUMP_L47:
    ;

  __CPROVER_DUMP_L48:
    ;
    signed int r;
    signed int tmp_if_expr$4;
    return_value__dclass=_dclass((double)val);
    tmp_if_expr$3 = (signed int)return_value__dclass;
    tmp_if_expr$4 = tmp_if_expr$3;
    r = tmp_if_expr$4;
    if(r == 1 || r == 2)
      suffix = "";

    uint64_t ival;
    double return_value_fabs=fabs(val);
    ival = (uint64_t)return_value_fabs;
    double return_value_fabs$0=fabs(val);
    if(IEEE_FLOAT_EQUAL((double)ival, return_value_fabs$0))
      r=fprintf(out, "%s%llu.%s", val < 0.0 ? "-" : "", ival, suffix);

    else
      r=fprintf(out, "%.17g%s", val, suffix);
    if(!(r >= 0))
      return /*enum*/CborErrorIO;

    goto __CPROVER_DUMP_L59;

  __CPROVER_DUMP_L57:
    ;
    signed int return_value_fprintf$15=fprintf(out, "invalid");
    if(!(return_value_fprintf$15 >= 0))
      return /*enum*/CborErrorIO;

    return /*enum*/CborErrorUnknownType;
  }

__CPROVER_DUMP_L59:
  ;
  err=cbor_value_advance_fixed(it);
  return err;
}

// vfprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 675
inline signed int vfprintf_s(FILE * const _Stream, const char * const _Format, va_list _ArgList)
{
  signed int return_value__vfprintf_s_l=_vfprintf_s_l(_Stream, _Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vfprintf_s_l;
}

// vfscanf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1100
inline signed int vfscanf_s(FILE * const _Stream, const char * const _Format, va_list _ArgList)
{
  signed int return_value__vfscanf_s_l=_vfscanf_s_l(_Stream, _Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vfscanf_s_l;
}

// vfwprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 340
inline signed int vfwprintf_s(FILE * const _Stream, const wchar_t * const _Format, va_list _ArgList)
{
  signed int return_value__vfwprintf_s_l=_vfwprintf_s_l(_Stream, _Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vfwprintf_s_l;
}

// vfwscanf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 726
inline signed int vfwscanf(FILE * const _Stream, const wchar_t * const _Format, va_list _ArgList)
{
  signed int return_value__vfwscanf_l=_vfwscanf_l(_Stream, _Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vfwscanf_l;
}

// vfwscanf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 759
inline signed int vfwscanf_s(FILE * const _Stream, const wchar_t * const _Format, va_list _ArgList)
{
  signed int return_value__vfwscanf_s_l=_vfwscanf_s_l(_Stream, _Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vfwscanf_s_l;
}

// vprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 763
inline signed int vprintf_s(const char * const _Format, va_list _ArgList)
{
  FILE *return_value___acrt_iob_func=__acrt_iob_func(1u);
  signed int return_value__vfprintf_s_l=_vfprintf_s_l(return_value___acrt_iob_func, _Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vfprintf_s_l;
}

// vscanf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1159
inline signed int vscanf_s(const char * const _Format, va_list _ArgList)
{
  FILE *return_value___acrt_iob_func=__acrt_iob_func(0u);
  signed int return_value__vfscanf_s_l=_vfscanf_s_l(return_value___acrt_iob_func, _Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vfscanf_s_l;
}

// vsnprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1619
inline signed int vsnprintf_s(char * const _Buffer, const size_t _BufferCount, const size_t _MaxCount, const char * const _Format, va_list _ArgList)
{
  signed int return_value__vsnprintf_s_l=_vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vsnprintf_s_l;
}

// vsprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 1506
inline signed int vsprintf_s(char * const _Buffer, const size_t _BufferCount, const char * const _Format, va_list _ArgList)
{
  signed int return_value__vsprintf_s_l=_vsprintf_s_l(_Buffer, _BufferCount, _Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vsprintf_s_l;
}

// vsscanf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h line 2210
inline signed int vsscanf_s(const char * const _Buffer, const char * const _Format, va_list _ArgList)
{
  signed int return_value__vsscanf_s_l=_vsscanf_s_l(_Buffer, _Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vsscanf_s_l;
}

// vswprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1274
inline signed int vswprintf_s(wchar_t * const _Buffer, const size_t _BufferCount, const wchar_t * const _Format, va_list _ArgList)
{
  signed int return_value__vswprintf_s_l=_vswprintf_s_l(_Buffer, _BufferCount, _Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vswprintf_s_l;
}

// vswscanf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1919
inline signed int vswscanf(const wchar_t *_Buffer, const wchar_t *_Format, va_list _ArgList)
{
  signed int return_value__vswscanf_l=_vswscanf_l(_Buffer, _Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vswscanf_l;
}

// vswscanf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 1954
inline signed int vswscanf_s(const wchar_t * const _Buffer, const wchar_t * const _Format, va_list _ArgList)
{
  signed int return_value__vswscanf_s_l=_vswscanf_s_l(_Buffer, _Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vswscanf_s_l;
}

// vwprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 428
inline signed int vwprintf_s(const wchar_t * const _Format, va_list _ArgList)
{
  FILE *return_value___acrt_iob_func=__acrt_iob_func(1u);
  signed int return_value__vfwprintf_s_l=_vfwprintf_s_l(return_value___acrt_iob_func, _Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vfwprintf_s_l;
}

// vwscanf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 788
inline signed int vwscanf(const wchar_t * const _Format, va_list _ArgList)
{
  FILE *return_value___acrt_iob_func=__acrt_iob_func(0u);
  signed int return_value__vfwscanf_l=_vfwscanf_l(return_value___acrt_iob_func, _Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vfwscanf_l;
}

// vwscanf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 817
inline signed int vwscanf_s(const wchar_t * const _Format, va_list _ArgList)
{
  FILE *return_value___acrt_iob_func=__acrt_iob_func(0u);
  signed int return_value__vfwscanf_s_l=_vfwscanf_s_l(return_value___acrt_iob_func, _Format, ((const _locale_t)NULL), _ArgList);
  return return_value__vfwscanf_s_l;
}

// would_overflow
// file ..\..\..\..\lib\third_party\tinycbor\cborencoder.c line 239
static inline _Bool would_overflow(CborEncoder *encoder, size_t len)
{
  ptrdiff_t remaining=(ptrdiff_t)encoder->end;
  ptrdiff_t tmp_if_expr;
  if(!(remaining == 0ll))
    tmp_if_expr = (ptrdiff_t)encoder->data.ptr;

  else
    tmp_if_expr = encoder->data.bytes_needed;
  remaining = remaining - tmp_if_expr;
  remaining = remaining - (ptrdiff_t)len;
  return remaining < 0ll;
}

// wprintf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 640

// writeInt16
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 773
static uint8_t writeInt16(void *buffer, uint8_t i, uint16_t value)
{
  if(buffer == NULL)
  {
    prvTraceError("TRACE_ASSERT: writeInt16: buffer == NULL");
    return 0;
  }

  else
  {
    for( ; !((signed int)i % 2 == 0); i = i + 1)
    {
      if((signed int)i >= 36)
        return 255;

      ((uint8_t *)buffer)[(signed long long int)i] = 0;
    }
    if(2 + (signed int)i >= 37)
      return 255;

    else
    {
      ((uint16_t *)buffer)[(signed long long int)((signed int)i / 2)] = value;
      return (uint8_t)((signed int)i + 2);
    }
  }
}

// writeInt32
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 801
static uint8_t writeInt32(void *buffer, uint8_t i, uint32_t value)
{
  if(buffer == NULL)
  {
    prvTraceError("TRACE_ASSERT: writeInt32: buffer == NULL");
    return 0;
  }

  else
  {
    for( ; !((signed int)i % 4 == 0); i = i + 1)
    {
      if((signed int)i >= 36)
        return 255;

      ((uint8_t *)buffer)[(signed long long int)i] = 0;
    }
    if(4 + (signed int)i >= 37)
      return 255;

    else
    {
      ((uint32_t *)buffer)[(signed long long int)((signed int)i / 4)] = value;
      return (uint8_t)((signed int)i + 4);
    }
  }
}

// writeInt8
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 752
static uint8_t writeInt8(void *buffer, uint8_t i, uint8_t value)
{
  if(buffer == NULL)
  {
    prvTraceError("TRACE_ASSERT: writeInt8: buffer == NULL");
    return 0;
  }

  else
    if((signed int)i >= 36)
      return 255;

    else
    {
      ((uint8_t *)buffer)[(signed long long int)i] = value;
      if(1 + (signed int)i >= 37)
        return 255;

      else
        return (uint8_t)((signed int)i + 1);
    }
}

// wscanf
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 928

// wscanf_s
// file C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h line 965

// x509_check_wildcard
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 1773
static signed int x509_check_wildcard(const char *cn, const mbedtls_x509_buf *name)
{
  size_t i;
  size_t cn_idx=0ull;
  size_t cn_len=strlen(cn);
  _Bool tmp_if_expr;
  if(!(name->len >= 3ull))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = (signed int)name->p[0ll] != 42 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$0;
  if(tmp_if_expr)
    tmp_if_expr$0 = (_Bool)1;

  else
    tmp_if_expr$0 = (signed int)name->p[1ll] != 46 ? (_Bool)1 : (_Bool)0;
  signed int return_value_x509_memcasecmp;
  if(tmp_if_expr$0)
    return -1;

  else
  {
    i = 0ull;
    for( ; !(i >= cn_len); i = i + 1ull)
      if((signed int)cn[(signed long long int)i] == 46)
      {
        cn_idx = i;
        break;
      }

    if(cn_idx == 0ull)
      return -1;

    else
    {
      if(cn_len + -cn_idx == 18446744073709551615ull + name->len)
      {
        return_value_x509_memcasecmp=x509_memcasecmp((const void *)(name->p + 1ll), (const void *)(cn + (signed long long int)cn_idx), name->len - 1ull);
        if(return_value_x509_memcasecmp == 0)
          return 0;

      }

      return -1;
    }
  }
}

// x509_crt_check_cn
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 2218
static signed int x509_crt_check_cn(const mbedtls_x509_buf *name, const char *cn, size_t cn_len)
{
  signed int return_value_x509_memcasecmp;
  if(name->len == cn_len)
  {
    return_value_x509_memcasecmp=x509_memcasecmp((const void *)cn, (const void *)name->p, cn_len);
    if(return_value_x509_memcasecmp == 0)
      return 0;

  }

  signed int return_value_x509_check_wildcard=x509_check_wildcard(cn, name);
  if(return_value_x509_check_wildcard == 0)
    return 0;

  else
    return -1;
}

// x509_crt_check_ee_locally_trusted
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 2064
static signed int x509_crt_check_ee_locally_trusted(mbedtls_x509_crt *crt, mbedtls_x509_crt *trust_ca)
{
  mbedtls_x509_crt *cur;
  signed int return_value_x509_name_cmp=x509_name_cmp(&crt->issuer, &crt->subject);
  signed int return_value_memcmp;
  if(!(return_value_x509_name_cmp == 0))
    return -1;

  else
  {
    cur = trust_ca;
    for( ; !(cur == ((mbedtls_x509_crt *)NULL)); cur = cur->next)
      if(crt->raw.len == cur->raw.len)
      {
        return_value_memcmp=memcmp((const void *)crt->raw.p, (const void *)cur->raw.p, crt->raw.len);
        if(return_value_memcmp == 0)
          return 0;

      }

    return -1;
  }
}

// x509_crt_check_parent
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 1903
static signed int x509_crt_check_parent(const mbedtls_x509_crt *child, const mbedtls_x509_crt *parent, signed int top)
{
  signed int need_ca_bit;
  signed int return_value_x509_name_cmp=x509_name_cmp(&child->issuer, &parent->subject);
  signed int return_value_mbedtls_x509_crt_check_key_usage;
  if(!(return_value_x509_name_cmp == 0))
    return -1;

  else
  {
    need_ca_bit = 1;
    if(!(top == 0))
    {
      if(!(parent->version >= 3))
        need_ca_bit = 0;

    }

    if(!(need_ca_bit == 0))
    {
      if(parent->ca_istrue == 0)
        return -1;

    }

    if(!(need_ca_bit == 0))
    {
      return_value_mbedtls_x509_crt_check_key_usage=mbedtls_x509_crt_check_key_usage(parent, 4u);
      if(!(return_value_mbedtls_x509_crt_check_key_usage == 0))
        return -1;

    }

    return 0;
  }
}

// x509_crt_check_signature
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 1874
static signed int x509_crt_check_signature(const mbedtls_x509_crt *child, mbedtls_x509_crt *parent)
{
  const mbedtls_md_info_t *md_info;
  unsigned char hash[32ll];
  md_info=mbedtls_md_info_from_type(child->sig_md);
  signed int return_value_mbedtls_md=mbedtls_md(md_info, child->tbs.p, child->tbs.len, hash);
  if(!(return_value_mbedtls_md == 0))
    return -1;

  else
  {
    unsigned char return_value_mbedtls_md_get_size=mbedtls_md_get_size(md_info);
    signed int return_value_mbedtls_pk_verify_ext=mbedtls_pk_verify_ext(child->sig_pk, child->sig_opts, &parent->pk, child->sig_md, hash, (size_t)return_value_mbedtls_md_get_size, child->sig.p, child->sig.len);
    if(!(return_value_mbedtls_pk_verify_ext == 0))
      return -1;

    else
      return 0;
  }
}

// x509_crt_find_parent
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 2038
static mbedtls_x509_crt * x509_crt_find_parent(mbedtls_x509_crt *child, mbedtls_x509_crt *trust_ca, signed int *parent_is_trusted, size_t path_cnt, size_t self_cnt)
{
  mbedtls_x509_crt *parent;
  *parent_is_trusted = 1;
  parent=x509_crt_find_parent_in(child, trust_ca, 1, path_cnt, self_cnt);
  if(!(parent == ((mbedtls_x509_crt *)NULL)))
    return parent;

  else
  {
    *parent_is_trusted = 0;
    mbedtls_x509_crt *return_value_x509_crt_find_parent_in=x509_crt_find_parent_in(child, child->next, 0, path_cnt, self_cnt);
    return return_value_x509_crt_find_parent_in;
  }
}

// x509_crt_find_parent_in
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 1973
static mbedtls_x509_crt * x509_crt_find_parent_in(mbedtls_x509_crt *child, mbedtls_x509_crt *candidates, signed int top, size_t path_cnt, size_t self_cnt)
{
  mbedtls_x509_crt *parent;
  mbedtls_x509_crt *badtime_parent=((mbedtls_x509_crt *)NULL);
  parent = candidates;
  signed int return_value_x509_crt_check_signature;
  signed int return_value_mbedtls_x509_time_is_future;
  for( ; !(parent == ((mbedtls_x509_crt *)NULL)); parent = parent->next)
  {
    signed int return_value_x509_crt_check_parent=x509_crt_check_parent(child, parent, top);
    if(return_value_x509_crt_check_parent == 0)
    {
      if(parent->max_pathlen >= 1)
      {
        if(!((size_t)parent->max_pathlen >= 1ull + path_cnt + -self_cnt))
          goto __CPROVER_DUMP_L10;

      }

      if(!(top == 0))
      {
        return_value_x509_crt_check_signature=x509_crt_check_signature(child, parent);
        if(!(return_value_x509_crt_check_signature == 0))
          goto __CPROVER_DUMP_L10;

      }

      signed int return_value_mbedtls_x509_time_is_past=mbedtls_x509_time_is_past(&parent->valid_to);
      _Bool tmp_if_expr;
      if(!(return_value_mbedtls_x509_time_is_past == 0))
        tmp_if_expr = (_Bool)1;

      else
      {
        return_value_mbedtls_x509_time_is_future=mbedtls_x509_time_is_future(&parent->valid_from);
        tmp_if_expr = return_value_mbedtls_x509_time_is_future != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr)
      {
        if(badtime_parent == ((mbedtls_x509_crt *)NULL))
          badtime_parent = parent;

      }

      else
        break;
    }


  __CPROVER_DUMP_L10:
    ;
  }
  if(parent == ((mbedtls_x509_crt *)NULL))
    parent = badtime_parent;

  return parent;
}

// x509_crt_merge_flags_with_cb
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 2278
static signed int x509_crt_merge_flags_with_cb(uint32_t *flags, x509_crt_verify_chain_item *ver_chain, size_t chain_len, signed int (*f_vrfy)(void *, mbedtls_x509_crt *, signed int, uint32_t *), void *p_vrfy)
{
  signed int ret;
  size_t i;
  uint32_t cur_flags;
  i = chain_len;
  for( ; !(i == 0ull); i = i - 1ull)
  {
    cur_flags = (ver_chain + (signed long long int)(i - 1ull))->flags;
    if(!(f_vrfy == ((signed int (*)(void *, mbedtls_x509_crt *, signed int, uint32_t *))NULL)))
    {
      ret=f_vrfy(p_vrfy, (ver_chain + (signed long long int)(i - 1ull))->crt, (signed int)i - 1, &cur_flags);
      if(!(ret == 0))
        return ret;

    }

    *flags = *flags | cur_flags;
  }
  return 0;
}

// x509_crt_parse_der_core
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 684
static signed int x509_crt_parse_der_core(mbedtls_x509_crt *crt, const unsigned char *buf, size_t buflen)
{
  signed int ret;
  size_t len;
  unsigned char *p;
  unsigned char *end;
  unsigned char *crt_end;
  mbedtls_x509_buf sig_params1;
  mbedtls_x509_buf sig_params2;
  mbedtls_x509_buf sig_oid2;
  memset((void *)&sig_params1, 0, sizeof(mbedtls_x509_buf) /*24ull*/ );
  memset((void *)&sig_params2, 0, sizeof(mbedtls_x509_buf) /*24ull*/ );
  memset((void *)&sig_oid2, 0, sizeof(mbedtls_x509_buf) /*24ull*/ );
  signed int return_value_memcmp;
  _Bool tmp_if_expr$5;
  signed int return_value_memcmp$0;
  if(crt == ((mbedtls_x509_crt *)NULL) || buf == ((const unsigned char *)NULL))
    return -0x2800;

  else
  {
    p = (unsigned char *)buf;
    len = buflen;
    end = p + (signed long long int)len;
    ret=mbedtls_asn1_get_tag(&p, end, &len, 0x20 | 0x10);
    if(!(ret == 0))
    {
      mbedtls_x509_crt_free(crt);
      return -0x2180;
    }

    else
      if(!((size_t)(end - p) >= len))
      {
        mbedtls_x509_crt_free(crt);
        return -0x2180 + -0x66;
      }

      else
      {
        crt_end = p + (signed long long int)len;
        crt->raw.len = (size_t)(crt_end - buf);
        void *return_value=mbedtls_calloc(1ull, crt->raw.len);
        p = (unsigned char *)return_value;
        crt->raw.p = p;
        if(p == ((unsigned char *)NULL))
          return -0x2880;

        else
        {
          memcpy((void *)p, (const void *)buf, crt->raw.len);
          p = p + (signed long long int)(crt->raw.len - len);
          crt_end = p + (signed long long int)len;
          end = crt_end;
          crt->tbs.p = p;
          ret=mbedtls_asn1_get_tag(&p, end, &len, 0x20 | 0x10);
          if(!(ret == 0))
          {
            mbedtls_x509_crt_free(crt);
            return -0x2180 + ret;
          }

          else
          {
            end = p + (signed long long int)len;
            crt->tbs.len = (size_t)(end - crt->tbs.p);
            ret=x509_get_version(&p, end, &crt->version);
            _Bool tmp_if_expr;
            if(!(ret == 0))
              tmp_if_expr = (_Bool)1;

            else
            {
              ret=mbedtls_x509_get_serial(&p, end, &crt->serial);
              tmp_if_expr = ret != 0 ? (_Bool)1 : (_Bool)0;
            }
            _Bool tmp_if_expr$0;
            if(tmp_if_expr)
              tmp_if_expr$0 = (_Bool)1;

            else
            {
              ret=mbedtls_x509_get_alg(&p, end, &crt->sig_oid, &sig_params1);
              tmp_if_expr$0 = ret != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$0)
            {
              mbedtls_x509_crt_free(crt);
              return ret;
            }

            else
            {
              _Bool tmp_if_expr$1;
              if(!(crt->version >= 0))
                tmp_if_expr$1 = (_Bool)1;

              else
                tmp_if_expr$1 = crt->version > 2 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$1)
              {
                mbedtls_x509_crt_free(crt);
                return -0x2580;
              }

              else
              {
                crt->version = crt->version + 1;
                ret=mbedtls_x509_get_sig_alg(&crt->sig_oid, &sig_params1, &crt->sig_md, &crt->sig_pk, &crt->sig_opts);
                if(!(ret == 0))
                {
                  mbedtls_x509_crt_free(crt);
                  return ret;
                }

                else
                {
                  crt->issuer_raw.p = p;
                  ret=mbedtls_asn1_get_tag(&p, end, &len, 0x20 | 0x10);
                  if(!(ret == 0))
                  {
                    mbedtls_x509_crt_free(crt);
                    return -0x2180 + ret;
                  }

                  else
                  {
                    ret=mbedtls_x509_get_name(&p, p + (signed long long int)len, &crt->issuer);
                    if(!(ret == 0))
                    {
                      mbedtls_x509_crt_free(crt);
                      return ret;
                    }

                    else
                    {
                      crt->issuer_raw.len = (size_t)(p - crt->issuer_raw.p);
                      ret=x509_get_dates(&p, end, &crt->valid_from, &crt->valid_to);
                      if(!(ret == 0))
                      {
                        mbedtls_x509_crt_free(crt);
                        return ret;
                      }

                      else
                      {
                        crt->subject_raw.p = p;
                        ret=mbedtls_asn1_get_tag(&p, end, &len, 0x20 | 0x10);
                        if(!(ret == 0))
                        {
                          mbedtls_x509_crt_free(crt);
                          return -0x2180 + ret;
                        }

                        else
                        {
                          if(!(len == 0ull))
                          {
                            ret=mbedtls_x509_get_name(&p, p + (signed long long int)len, &crt->subject);
                            if(!(ret == 0))
                            {
                              mbedtls_x509_crt_free(crt);
                              return ret;
                            }

                          }

                          crt->subject_raw.len = (size_t)(p - crt->subject_raw.p);
                          ret=mbedtls_pk_parse_subpubkey(&p, end, &crt->pk);
                          if(!(ret == 0))
                          {
                            mbedtls_x509_crt_free(crt);
                            return ret;
                          }

                          else
                          {
                            _Bool tmp_if_expr$2;
                            if(crt->version == 2)
                              tmp_if_expr$2 = (_Bool)1;

                            else
                              tmp_if_expr$2 = crt->version == 3 ? (_Bool)1 : (_Bool)0;
                            if(tmp_if_expr$2)
                            {
                              ret=x509_get_uid(&p, end, &crt->issuer_id, 1);
                              if(!(ret == 0))
                              {
                                mbedtls_x509_crt_free(crt);
                                return ret;
                              }

                            }

                            _Bool tmp_if_expr$3;
                            if(crt->version == 2)
                              tmp_if_expr$3 = (_Bool)1;

                            else
                              tmp_if_expr$3 = crt->version == 3 ? (_Bool)1 : (_Bool)0;
                            if(tmp_if_expr$3)
                            {
                              ret=x509_get_uid(&p, end, &crt->subject_id, 2);
                              if(!(ret == 0))
                              {
                                mbedtls_x509_crt_free(crt);
                                return ret;
                              }

                            }

                            if(crt->version == 3)
                            {
                              ret=x509_get_crt_ext(&p, end, crt);
                              if(!(ret == 0))
                              {
                                mbedtls_x509_crt_free(crt);
                                return ret;
                              }

                            }

                            if(!(p == end))
                            {
                              mbedtls_x509_crt_free(crt);
                              return -0x2180 + -0x66;
                            }

                            else
                            {
                              end = crt_end;
                              ret=mbedtls_x509_get_alg(&p, end, &sig_oid2, &sig_params2);
                              if(!(ret == 0))
                              {
                                mbedtls_x509_crt_free(crt);
                                return ret;
                              }

                              else
                              {
                                _Bool tmp_if_expr$4;
                                if(!(crt->sig_oid.len == sig_oid2.len))
                                  tmp_if_expr$4 = (_Bool)1;

                                else
                                {
                                  return_value_memcmp=memcmp((const void *)crt->sig_oid.p, (const void *)sig_oid2.p, crt->sig_oid.len);
                                  tmp_if_expr$4 = return_value_memcmp != 0 ? (_Bool)1 : (_Bool)0;
                                }
                                _Bool tmp_if_expr$6;
                                if(!(sig_params1.len == sig_params2.len) || tmp_if_expr$4)
                                  tmp_if_expr$6 = (_Bool)1;

                                else
                                {
                                  if(!(sig_params1.len == 0ull))
                                  {
                                    return_value_memcmp$0=memcmp((const void *)sig_params1.p, (const void *)sig_params2.p, sig_params1.len);
                                    tmp_if_expr$5 = return_value_memcmp$0 != 0 ? (_Bool)1 : (_Bool)0;
                                  }

                                  else
                                    tmp_if_expr$5 = (_Bool)0;
                                  tmp_if_expr$6 = tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
                                }
                                if(tmp_if_expr$6)
                                {
                                  mbedtls_x509_crt_free(crt);
                                  return -0x2680;
                                }

                                else
                                {
                                  ret=mbedtls_x509_get_sig(&p, end, &crt->sig);
                                  if(!(ret == 0))
                                  {
                                    mbedtls_x509_crt_free(crt);
                                    return ret;
                                  }

                                  else
                                    if(!(p == end))
                                    {
                                      mbedtls_x509_crt_free(crt);
                                      return -0x2180 + -0x66;
                                    }

                                    else
                                      return 0;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
  }
}

// x509_crt_verify_chain
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 2115
static signed int x509_crt_verify_chain(mbedtls_x509_crt *crt, mbedtls_x509_crt *trust_ca, mbedtls_x509_crl *ca_crl, const mbedtls_x509_crt_profile *profile, x509_crt_verify_chain_item *ver_chain, size_t *chain_len)
{
  uint32_t *flags;
  mbedtls_x509_crt *child;
  mbedtls_x509_crt *parent;
  signed int parent_is_trusted=0;
  signed int child_is_trusted=0;
  size_t self_cnt=0ull;
  child = crt;
  *chain_len = 0ull;
  signed int return_value_x509_crt_check_ee_locally_trusted;
  signed int return_value_x509_name_cmp;
  signed int return_value_x509_crt_check_signature;
  while((_Bool)1)
  {
    (ver_chain + (signed long long int)*chain_len)->crt = child;
    flags = &(ver_chain + (signed long long int)*chain_len)->flags;
    *chain_len = *chain_len + 1ull;
    signed int return_value_mbedtls_x509_time_is_past=mbedtls_x509_time_is_past(&child->valid_to);
    if(!(return_value_mbedtls_x509_time_is_past == 0))
      *flags = *flags | 1u;

    signed int return_value_mbedtls_x509_time_is_future=mbedtls_x509_time_is_future(&child->valid_from);
    if(!(return_value_mbedtls_x509_time_is_future == 0))
      *flags = *flags | 512u;

    if(!(child_is_trusted == 0))
      return 0;

    signed int return_value_x509_profile_check_md_alg=x509_profile_check_md_alg(profile, child->sig_md);
    if(!(return_value_x509_profile_check_md_alg == 0))
      *flags = *flags | 16384u;

    signed int return_value_x509_profile_check_pk_alg=x509_profile_check_pk_alg(profile, child->sig_pk);
    if(!(return_value_x509_profile_check_pk_alg == 0))
      *flags = *flags | 32768u;

    if(*chain_len == 1ull)
    {
      return_value_x509_crt_check_ee_locally_trusted=x509_crt_check_ee_locally_trusted(child, trust_ca);
      if(return_value_x509_crt_check_ee_locally_trusted == 0)
        return 0;

    }

    parent=x509_crt_find_parent(child, trust_ca, &parent_is_trusted, *chain_len - 1ull, self_cnt);
    if(parent == ((mbedtls_x509_crt *)NULL))
    {
      *flags = *flags | 8u;
      return 0;
    }

    if(!(*chain_len == 1ull))
    {
      return_value_x509_name_cmp=x509_name_cmp(&child->issuer, &child->subject);
      if(return_value_x509_name_cmp == 0)
        self_cnt = self_cnt + 1ull;

    }

    if(parent_is_trusted == 0)
    {
      if(*chain_len >= 9ull)
        return -0x3000;

    }

    if(parent_is_trusted == 0)
    {
      return_value_x509_crt_check_signature=x509_crt_check_signature(child, parent);
      if(!(return_value_x509_crt_check_signature == 0))
        *flags = *flags | 8u;

    }

    signed int return_value_x509_profile_check_key=x509_profile_check_key(profile, &parent->pk);
    if(!(return_value_x509_profile_check_key == 0))
      *flags = *flags | 65536u;

    (void)ca_crl;
    child = parent;
    parent = ((mbedtls_x509_crt *)NULL);
    child_is_trusted = parent_is_trusted;
  }
}

// x509_crt_verify_name
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 2240
static void x509_crt_verify_name(const mbedtls_x509_crt *crt, const char *cn, uint32_t *flags)
{
  const mbedtls_x509_name *name;
  const mbedtls_x509_sequence *cur;
  size_t cn_len=strlen(cn);
  signed int return_value_memcmp;
  signed int return_value_x509_crt_check_cn$0;
  if(!((32 & crt->ext_types) == 0))
  {
    cur = &crt->subject_alt_names;
    for( ; !(cur == ((const mbedtls_x509_sequence *)NULL)); cur = cur->next)
    {
      signed int return_value_x509_crt_check_cn=x509_crt_check_cn(&cur->buf, cn, cn_len);
      if(return_value_x509_crt_check_cn == 0)
        break;

    }
    if(cur == ((const mbedtls_x509_sequence *)NULL))
      *flags = *flags | 4u;

  }

  else
  {
    name = &crt->subject;
    for( ; !(name == ((const mbedtls_x509_name *)NULL)); name = name->next)
    {
      _Bool tmp_if_expr;
      if(!(name->oid.len == 3ull))
        tmp_if_expr = (_Bool)1;

      else
      {
        return_value_memcmp=memcmp((const void *)"U\\", (const void *)(&name->oid)->p, (&name->oid)->len);
        tmp_if_expr = return_value_memcmp != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr)
      {
        return_value_x509_crt_check_cn$0=x509_crt_check_cn(&name->val, cn, cn_len);
        if(return_value_x509_crt_check_cn$0 == 0)
          break;

      }

    }
    if(name == ((const mbedtls_x509_name *)NULL))
      *flags = *flags | 4u;

  }
}

// x509_date_is_valid
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 499
static signed int x509_date_is_valid(const mbedtls_x509_time *t)
{
  signed int ret=-0x2400;
  signed int month_len;
  _Bool tmp_if_expr;
  if(!(t->year >= 0))
    tmp_if_expr = (_Bool)1;

  else
    tmp_if_expr = t->year > 9999 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(tmp_if_expr)
    return ret;

  else
  {
    _Bool tmp_if_expr$0;
    if(!(t->hour >= 0))
      tmp_if_expr$0 = (_Bool)1;

    else
      tmp_if_expr$0 = t->hour > 23 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$0)
      return ret;

    else
    {
      _Bool tmp_if_expr$1;
      if(!(t->min >= 0))
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = t->min > 59 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
        return ret;

      else
      {
        _Bool tmp_if_expr$2;
        if(!(t->sec >= 0))
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = t->sec > 59 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$2)
          return ret;

        else
        {
          switch(t->mon)
          {
            case 1:

            case 3:

            case 5:

            case 7:

            case 8:

            case 10:

            case 12:
            {
              month_len = 31;
              break;
            }
            case 4:

            case 6:

            case 9:

            case 11:
            {
              month_len = 30;
              break;
            }
            case 2:
            {
              if(t->year % 4 == 0)
                tmp_if_expr$3 = t->year % 100 != 0 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$3 = (_Bool)0;
              if(tmp_if_expr$3)
                tmp_if_expr$4 = (_Bool)1;

              else
                tmp_if_expr$4 = !(t->year % 400 != 0) ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$4)
                month_len = 29;

              else
                month_len = 28;
              break;
            }
            default:
              return ret;
          }
          _Bool tmp_if_expr$5;
          if(!(t->day >= 1))
            tmp_if_expr$5 = (_Bool)1;

          else
            tmp_if_expr$5 = t->day > month_len ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$5)
            return ret;

          else
            return 0;
        }
      }
    }
  }
}

// x509_get_attr_type_value
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 356
static signed int x509_get_attr_type_value(unsigned char **p, const unsigned char *end, mbedtls_x509_name *cur)
{
  signed int ret;
  size_t len;
  mbedtls_x509_buf *oid;
  mbedtls_x509_buf *val;
  ret=mbedtls_asn1_get_tag(p, end, &len, 0x20 | 0x10);
  if(!(ret == 0))
    return -0x2380 + ret;

  else
    if(!(end - *p >= 1ll))
      return -0x2380 + -0x60;

    else
    {
      oid = &cur->oid;
      oid->tag = (signed int)*(*p);
      ret=mbedtls_asn1_get_tag(p, end, &oid->len, 0x6);
      if(!(ret == 0))
        return -0x2380 + ret;

      else
      {
        oid->p = *p;
        *p = *p + (signed long long int)oid->len;
        if(!(end - *p >= 1ll))
          return -0x2380 + -0x60;

        else
        {
          if(!((signed int)*(*p) == 0x1E))
          {
            if(!((signed int)*(*p) == 0xC))
            {
              if(!((signed int)*(*p) == 0x14))
              {
                if(!((signed int)*(*p) == 0x13))
                {
                  if(!((signed int)*(*p) == 0x16))
                  {
                    if(!((signed int)*(*p) == 0x1C))
                    {
                      if(!((signed int)*(*p) == 0x3))
                        return -0x2380 + -0x62;

                    }

                  }

                }

              }

            }

          }

          val = &cur->val;
          unsigned char *tmp_post=*p;
          *p = *p + 1ll;
          val->tag = (signed int)*tmp_post;
          ret=mbedtls_asn1_get_len(p, end, &val->len);
          if(!(ret == 0))
            return -0x2380 + ret;

          else
          {
            val->p = *p;
            *p = *p + (signed long long int)val->len;
            cur->next = ((struct mbedtls_asn1_named_data *)NULL);
            return 0;
          }
        }
      }
    }
}

// x509_get_basic_constraints
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 320
static signed int x509_get_basic_constraints(unsigned char **p, const unsigned char *end, signed int *ca_istrue, signed int *max_pathlen)
{
  signed int ret;
  size_t len;
  *ca_istrue = 0;
  *max_pathlen = 0;
  ret=mbedtls_asn1_get_tag(p, end, &len, 0x20 | 0x10);
  if(!(ret == 0))
    return -0x2500 + ret;

  else
    if(*p == end)
      return 0;

    else
    {
      ret=mbedtls_asn1_get_bool(p, end, ca_istrue);
      if(!(ret == 0))
      {
        if(ret == -98)
          ret=mbedtls_asn1_get_int(p, end, ca_istrue);

        if(!(ret == 0))
          return -0x2500 + ret;

        if(!(*ca_istrue == 0))
          *ca_istrue = 1;

      }

      if(*p == end)
        return 0;

      else
      {
        ret=mbedtls_asn1_get_int(p, end, max_pathlen);
        if(!(ret == 0))
          return -0x2500 + ret;

        else
          if(!(*p == end))
            return -0x2500 + -0x66;

          else
          {
            *max_pathlen = *max_pathlen + 1;
            return 0;
          }
      }
    }
}

// x509_get_crt_ext
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 542
static signed int x509_get_crt_ext(unsigned char **p, const unsigned char *end, mbedtls_x509_crt *crt)
{
  signed int ret;
  size_t len;
  unsigned char *end_ext_data;
  unsigned char *end_ext_octet;
  ret=mbedtls_x509_get_ext(p, end, &crt->v3_ext, 3);
  if(!(ret == 0))
  {
    if(ret == -98)
      return 0;

    return ret;
  }

  else
  {
    while(!(*p >= end))
    {
      mbedtls_x509_buf extn_oid={ .tag=0, .len=0ull, .p=((unsigned char *)NULL) };
      signed int is_critical=0;
      signed int ext_type=0;
      ret=mbedtls_asn1_get_tag(p, end, &len, 0x20 | 0x10);
      if(!(ret == 0))
        return -0x2500 + ret;

      end_ext_data = *p + (signed long long int)len;
      extn_oid.tag = (signed int)*(*p);
      ret=mbedtls_asn1_get_tag(p, end, &extn_oid.len, 0x6);
      if(!(ret == 0))
        return -0x2500 + ret;

      extn_oid.p = *p;
      *p = *p + (signed long long int)extn_oid.len;
      if(!(end - *p >= 1ll))
        return -0x2500 + -0x60;

      ret=mbedtls_asn1_get_bool(p, end_ext_data, &is_critical);
      if(!(ret == 0))
      {
        if(!(ret == -98))
          return -0x2500 + ret;

      }

      ret=mbedtls_asn1_get_tag(p, end_ext_data, &len, 0x4);
      if(!(ret == 0))
        return -0x2500 + ret;

      end_ext_octet = *p + (signed long long int)len;
      if(!(end_ext_octet == end_ext_data))
        return -0x2500 + -0x66;

      ret=mbedtls_oid_get_x509_ext_type(&extn_oid, &ext_type);
      if(!(ret == 0))
      {
        *p = end_ext_octet;
        if(!(is_critical == 0))
          return -0x2500 + -0x62;

      }

      else
      {
        if(!((crt->ext_types & ext_type) == 0))
          return -0x2500;

        crt->ext_types = crt->ext_types | ext_type;
        switch(ext_type)
        {
          case 256:
          {
            ret=x509_get_basic_constraints(p, end_ext_octet, &crt->ca_istrue, &crt->max_pathlen);
            if(!(ret == 0))
              return ret;

            break;
          }
          case 4:
          {
            ret=x509_get_key_usage(p, end_ext_octet, &crt->key_usage);
            if(!(ret == 0))
              return ret;

            break;
          }
          case 2048:
          {
            ret=x509_get_ext_key_usage(p, end_ext_octet, &crt->ext_key_usage);
            if(!(ret == 0))
              return ret;

            break;
          }
          case 32:
          {
            ret=x509_get_subject_alt_name(p, end_ext_octet, &crt->subject_alt_names);
            if(!(ret == 0))
              return ret;

            break;
          }
          case 65536:
          {
            ret=x509_get_ns_cert_type(p, end_ext_octet, &crt->ns_cert_type);
            if(!(ret == 0))
              return ret;

            break;
          }
          default:
            return -0x2080;
        }
      }
    }
    if(!(*p == end))
      return -0x2500 + -0x66;

    else
      return 0;
  }
}

// x509_get_dates
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 264
static signed int x509_get_dates(unsigned char **p, const unsigned char *end, mbedtls_x509_time *from, mbedtls_x509_time *to)
{
  signed int ret;
  size_t len;
  ret=mbedtls_asn1_get_tag(p, end, &len, 0x20 | 0x10);
  if(!(ret == 0))
    return -0x2400 + ret;

  else
  {
    end = *p + (signed long long int)len;
    ret=mbedtls_x509_get_time(p, end, from);
    if(!(ret == 0))
      return ret;

    else
    {
      ret=mbedtls_x509_get_time(p, end, to);
      if(!(ret == 0))
        return ret;

      else
        if(!(*p == end))
          return -0x2400 + -0x66;

        else
          return 0;
    }
  }
}

// x509_get_ext_key_usage
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 419
static signed int x509_get_ext_key_usage(unsigned char **p, const unsigned char *end, mbedtls_x509_sequence *ext_key_usage)
{
  signed int ret=mbedtls_asn1_get_sequence_of(p, end, ext_key_usage, 0x6);
  if(!(ret == 0))
    return -0x2500 + ret;

  else
    if(ext_key_usage->buf.p == ((unsigned char *)NULL))
      return -0x2500 + -0x64;

    else
      return 0;
}

// x509_get_key_usage
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 389
static signed int x509_get_key_usage(unsigned char **p, const unsigned char *end, unsigned int *key_usage)
{
  signed int ret;
  size_t i;
  mbedtls_x509_bitstring bs={ .len=0ull, .unused_bits=0, .p=((unsigned char *)NULL) };
  ret=mbedtls_asn1_get_bitstring(p, end, &bs);
  if(!(ret == 0))
    return -0x2500 + ret;

  else
    if(!(bs.len >= 1ull))
      return -0x2500 + -0x64;

    else
    {
      *key_usage = 0u;
      i = 0ull;
      for( ; !(i >= sizeof(unsigned int) /*4ull*/ ) && !(i >= bs.len); i = i + 1ull)
        *key_usage = *key_usage | (unsigned int)bs.p[(signed long long int)i] << 8ull * i;
      return 0;
    }
}

// x509_get_ns_cert_type
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 370
static signed int x509_get_ns_cert_type(unsigned char **p, const unsigned char *end, unsigned char *ns_cert_type)
{
  signed int ret;
  mbedtls_x509_bitstring bs={ .len=0ull, .unused_bits=0, .p=((unsigned char *)NULL) };
  ret=mbedtls_asn1_get_bitstring(p, end, &bs);
  if(!(ret == 0))
    return -0x2500 + ret;

  else
    if(!(bs.len == 1ull))
      return -0x2500 + -0x64;

    else
    {
      *ns_cert_type = *bs.p;
      return 0;
    }
}

// x509_get_subject_alt_name
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 462
static signed int x509_get_subject_alt_name(unsigned char **p, const unsigned char *end, mbedtls_x509_sequence *subject_alt_name)
{
  signed int ret;
  size_t len;
  size_t tag_len;
  mbedtls_asn1_buf *buf;
  unsigned char x509_get_subject_alt_name$$1$$tag;
  mbedtls_asn1_sequence *cur=subject_alt_name;
  ret=mbedtls_asn1_get_tag(p, end, &len, 0x20 | 0x10);
  if(!(ret == 0))
    return -0x2500 + ret;

  else
    if(!(*p + (signed long long int)len == end))
      return -0x2500 + -0x66;

    else
    {
      while(!(*p >= end))
      {
        if(!(end - *p >= 1ll))
          return -0x2500 + -0x60;

        x509_get_subject_alt_name$$1$$tag = *(*p);
        *p = *p + 1ll;
        ret=mbedtls_asn1_get_len(p, end, &tag_len);
        if(!(ret == 0))
          return -0x2500 + ret;

        if(!((0xC0 & (signed int)x509_get_subject_alt_name$$1$$tag) == 0x80))
          return -0x2500 + -0x62;

        if(!((signed int)x509_get_subject_alt_name$$1$$tag == 130))
          *p = *p + (signed long long int)tag_len;

        else
        {
          if(!(cur->buf.p == ((unsigned char *)NULL)))
          {
            if(!(cur->next == ((struct mbedtls_asn1_sequence *)NULL)))
              return -0x2500;

            void *return_value=mbedtls_calloc(1ull, sizeof(mbedtls_asn1_sequence) /*32ull*/ );
            cur->next = (struct mbedtls_asn1_sequence *)return_value;
            if(cur->next == ((struct mbedtls_asn1_sequence *)NULL))
              return -0x2500 + -0x6A;

            cur = cur->next;
          }

          buf = &cur->buf;
          buf->tag = (signed int)x509_get_subject_alt_name$$1$$tag;
          buf->p = *p;
          buf->len = tag_len;
          *p = *p + (signed long long int)buf->len;
        }
      }
      cur->next = ((struct mbedtls_asn1_sequence *)NULL);
      if(!(*p == end))
        return -0x2500 + -0x66;

      else
        return 0;
    }
}

// x509_get_uid
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 294
static signed int x509_get_uid(unsigned char **p, const unsigned char *end, mbedtls_x509_buf *uid, signed int n)
{
  signed int ret;
  if(*p == end)
    return 0;

  else
  {
    uid->tag = (signed int)*(*p);
    ret=mbedtls_asn1_get_tag(p, end, &uid->len, 0x80 | 0x20 | n);
    if(!(ret == 0))
    {
      if(ret == -98)
        return 0;

      return ret;
    }

    else
    {
      uid->p = *p;
      *p = *p + (signed long long int)uid->len;
      return 0;
    }
  }
}

// x509_get_version
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 228
static signed int x509_get_version(unsigned char **p, const unsigned char *end, signed int *ver)
{
  signed int ret;
  size_t len;
  ret=mbedtls_asn1_get_tag(p, end, &len, 0x80 | 0x20 | 0);
  if(!(ret == 0))
  {
    if(ret == -98)
    {
      *ver = 0;
      return 0;
    }

    return ret;
  }

  else
  {
    end = *p + (signed long long int)len;
    ret=mbedtls_asn1_get_int(p, end, ver);
    if(!(ret == 0))
      return -0x2200 + ret;

    else
      if(!(*p == end))
        return -0x2200 + -0x66;

      else
        return 0;
  }
}

// x509_info_cert_type
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 1297
static signed int x509_info_cert_type(char **buf, size_t *size, unsigned char ns_cert_type)
{
  signed int ret;
  size_t n=*size;
  char *p=*buf;
  const char *sep="";
  if(!((0x80 & (signed int)ns_cert_type) == 0))
  {
    ret=mbedtls_snprintf(p, n, "%sSSL Client", sep);
    if((size_t)ret >= n || !(ret >= 0))
      return -0x2980;

    n = n - (size_t)ret;
    p = p + (signed long long int)(size_t)ret;
    sep = ", ";
  }

  if(!((0x40 & (signed int)ns_cert_type) == 0))
  {
    ret=mbedtls_snprintf(p, n, "%sSSL Server", sep);
    if((size_t)ret >= n || !(ret >= 0))
      return -0x2980;

    n = n - (size_t)ret;
    p = p + (signed long long int)(size_t)ret;
    sep = ", ";
  }

  if(!((0x20 & (signed int)ns_cert_type) == 0))
  {
    ret=mbedtls_snprintf(p, n, "%sEmail", sep);
    if((size_t)ret >= n || !(ret >= 0))
      return -0x2980;

    n = n - (size_t)ret;
    p = p + (signed long long int)(size_t)ret;
    sep = ", ";
  }

  if(!((0x10 & (signed int)ns_cert_type) == 0))
  {
    ret=mbedtls_snprintf(p, n, "%sObject Signing", sep);
    if((size_t)ret >= n || !(ret >= 0))
      return -0x2980;

    n = n - (size_t)ret;
    p = p + (signed long long int)(size_t)ret;
    sep = ", ";
  }

  if(!((0x8 & (signed int)ns_cert_type) == 0))
  {
    ret=mbedtls_snprintf(p, n, "%sReserved", sep);
    if((size_t)ret >= n || !(ret >= 0))
      return -0x2980;

    n = n - (size_t)ret;
    p = p + (signed long long int)(size_t)ret;
    sep = ", ";
  }

  if(!((0x4 & (signed int)ns_cert_type) == 0))
  {
    ret=mbedtls_snprintf(p, n, "%sSSL CA", sep);
    if((size_t)ret >= n || !(ret >= 0))
      return -0x2980;

    n = n - (size_t)ret;
    p = p + (signed long long int)(size_t)ret;
    sep = ", ";
  }

  if(!((0x2 & (signed int)ns_cert_type) == 0))
  {
    ret=mbedtls_snprintf(p, n, "%sEmail CA", sep);
    if((size_t)ret >= n || !(ret >= 0))
      return -0x2980;

    n = n - (size_t)ret;
    p = p + (signed long long int)(size_t)ret;
    sep = ", ";
  }

  if(!((0x1 & (signed int)ns_cert_type) == 0))
  {
    ret=mbedtls_snprintf(p, n, "%sObject Signing CA", sep);
    if((size_t)ret >= n || !(ret >= 0))
      return -0x2980;

    n = n - (size_t)ret;
    p = p + (signed long long int)(size_t)ret;
    sep = ", ";
  }

  *size = n;
  *buf = p;
  return 0;
}

// x509_info_ext_key_usage
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 1348
static signed int x509_info_ext_key_usage(char **buf, size_t *size, const mbedtls_x509_sequence *extended_key_usage)
{
  signed int ret;
  const char *desc;
  size_t n=*size;
  char *p=*buf;
  const mbedtls_x509_sequence *cur=extended_key_usage;
  const char *sep="";
  if(!(cur == ((const mbedtls_x509_sequence *)NULL)))
  {
    signed int return_value_mbedtls_oid_get_extended_key_usage=mbedtls_oid_get_extended_key_usage(&cur->buf, &desc);
    if(!(return_value_mbedtls_oid_get_extended_key_usage == 0))
      desc = "???";

    ret=mbedtls_snprintf(p, n, "%s%s", sep, desc);
    if((size_t)ret >= n || !(ret >= 0))
      return -0x2980;

    n = n - (size_t)ret;
    p = p + (signed long long int)(size_t)ret;
    sep = ", ";
    cur = cur->next;
  }

  *size = n;
  *buf = p;
  return 0;
}

// x509_info_key_usage
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 1324
static signed int x509_info_key_usage(char **buf, size_t *size, unsigned int key_usage)
{
  signed int ret;
  size_t n=*size;
  char *p=*buf;
  const char *sep="";
  if(!((128u & key_usage) == 0u))
  {
    ret=mbedtls_snprintf(p, n, "%sDigital Signature", sep);
    if((size_t)ret >= n || !(ret >= 0))
      return -0x2980;

    n = n - (size_t)ret;
    p = p + (signed long long int)(size_t)ret;
    sep = ", ";
  }

  if(!((64u & key_usage) == 0u))
  {
    ret=mbedtls_snprintf(p, n, "%sNon Repudiation", sep);
    if((size_t)ret >= n || !(ret >= 0))
      return -0x2980;

    n = n - (size_t)ret;
    p = p + (signed long long int)(size_t)ret;
    sep = ", ";
  }

  if(!((32u & key_usage) == 0u))
  {
    ret=mbedtls_snprintf(p, n, "%sKey Encipherment", sep);
    if((size_t)ret >= n || !(ret >= 0))
      return -0x2980;

    n = n - (size_t)ret;
    p = p + (signed long long int)(size_t)ret;
    sep = ", ";
  }

  if(!((16u & key_usage) == 0u))
  {
    ret=mbedtls_snprintf(p, n, "%sData Encipherment", sep);
    if((size_t)ret >= n || !(ret >= 0))
      return -0x2980;

    n = n - (size_t)ret;
    p = p + (signed long long int)(size_t)ret;
    sep = ", ";
  }

  if(!((8u & key_usage) == 0u))
  {
    ret=mbedtls_snprintf(p, n, "%sKey Agreement", sep);
    if((size_t)ret >= n || !(ret >= 0))
      return -0x2980;

    n = n - (size_t)ret;
    p = p + (signed long long int)(size_t)ret;
    sep = ", ";
  }

  if(!((4u & key_usage) == 0u))
  {
    ret=mbedtls_snprintf(p, n, "%sKey Cert Sign", sep);
    if((size_t)ret >= n || !(ret >= 0))
      return -0x2980;

    n = n - (size_t)ret;
    p = p + (signed long long int)(size_t)ret;
    sep = ", ";
  }

  if(!((2u & key_usage) == 0u))
  {
    ret=mbedtls_snprintf(p, n, "%sCRL Sign", sep);
    if((size_t)ret >= n || !(ret >= 0))
      return -0x2980;

    n = n - (size_t)ret;
    p = p + (signed long long int)(size_t)ret;
    sep = ", ";
  }

  if(!((1u & key_usage) == 0u))
  {
    ret=mbedtls_snprintf(p, n, "%sEncipher Only", sep);
    if((size_t)ret >= n || !(ret >= 0))
      return -0x2980;

    n = n - (size_t)ret;
    p = p + (signed long long int)(size_t)ret;
    sep = ", ";
  }

  if(!((32768u & key_usage) == 0u))
  {
    ret=mbedtls_snprintf(p, n, "%sDecipher Only", sep);
    if((size_t)ret >= n || !(ret >= 0))
      return -0x2980;

    n = n - (size_t)ret;
    p = p + (signed long long int)(size_t)ret;
    sep = ", ";
  }

  *size = n;
  *buf = p;
  return 0;
}

// x509_info_subject_alt_name
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 1248
static signed int x509_info_subject_alt_name(char **buf, size_t *size, const mbedtls_x509_sequence *subject_alt_name)
{
  size_t i;
  size_t n=*size;
  char *p=*buf;
  const mbedtls_x509_sequence *cur=subject_alt_name;
  const char *sep="";
  size_t sep_len=0ull;
  char *tmp_post;
  char *tmp_post$0;
  for( ; !(cur == ((const mbedtls_x509_sequence *)NULL)); cur = cur->next)
  {
    if(cur->buf.len + sep_len >= n)
    {
      *p = 0;
      return -0x2980;
    }

    n = n - (cur->buf.len + sep_len);
    i = 0ull;
    for( ; !(i >= sep_len); i = i + 1ull)
    {
      tmp_post = p;
      p = p + 1ll;
      *tmp_post = sep[(signed long long int)i];
    }
    i = 0ull;
    for( ; !(i >= cur->buf.len); i = i + 1ull)
    {
      tmp_post$0 = p;
      p = p + 1ll;
      *tmp_post$0 = (char)cur->buf.p[(signed long long int)i];
    }
    sep = ", ";
    sep_len = 2ull;
  }
  *p = 0;
  *size = n;
  *buf = p;
  return 0;
}

// x509_memcasecmp
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 1744
static signed int x509_memcasecmp(const void *s1, const void *s2, size_t len)
{
  size_t i;
  unsigned char diff;
  const unsigned char *n1=(const unsigned char *)s1;
  const unsigned char *n2=(const unsigned char *)s2;
  i = 0ull;
  _Bool tmp_if_expr;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$0;
  for( ; !(i >= len); i = i + 1ull)
  {
    diff = (unsigned char)((signed int)n1[(signed long long int)i] ^ (signed int)n2[(signed long long int)i]);
    if(!((signed int)diff == 0))
    {
      if((signed int)diff == 32)
      {
        if((signed int)n1[(signed long long int)i] >= 97)
          tmp_if_expr = (signed int)n1[(signed long long int)i] <= 122 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr = (_Bool)0;
        if(tmp_if_expr)
          tmp_if_expr$1 = (_Bool)1;

        else
        {
          if((signed int)n1[(signed long long int)i] >= 65)
            tmp_if_expr$0 = (signed int)n1[(signed long long int)i] <= 90 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$0 = (_Bool)0;
          tmp_if_expr$1 = tmp_if_expr$0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$1)
          goto __CPROVER_DUMP_L9;

      }

      return -1;
    }


  __CPROVER_DUMP_L9:
    ;
  }
  return 0;
}

// x509_name_cmp
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 1839
static signed int x509_name_cmp(const mbedtls_x509_name *a, const mbedtls_x509_name *b)
{
  signed int return_value_memcmp;
  while(!(a == ((const mbedtls_x509_name *)NULL)) || !(b == ((const mbedtls_x509_name *)NULL)))
  {
    if(a == ((const mbedtls_x509_name *)NULL) || b == ((const mbedtls_x509_name *)NULL))
      return -1;

    _Bool tmp_if_expr;
    if(!(a->oid.tag == b->oid.tag))
      tmp_if_expr = (_Bool)1;

    else
      tmp_if_expr = a->oid.len != b->oid.len ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$0;
    if(tmp_if_expr)
      tmp_if_expr$0 = (_Bool)1;

    else
    {
      return_value_memcmp=memcmp((const void *)a->oid.p, (const void *)b->oid.p, b->oid.len);
      tmp_if_expr$0 = return_value_memcmp != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$0)
      return -1;

    signed int return_value_x509_string_cmp=x509_string_cmp(&a->val, &b->val);
    if(!(return_value_x509_string_cmp == 0))
      return -1;

    if(!(a->next_merged == b->next_merged))
      return -1;

    a = a->next;
    b = b->next;
  }
  return 0;
}

// x509_parse_int
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 483
static signed int x509_parse_int(unsigned char **p, size_t n, signed int *res)
{
  *res = 0;
  for( ; n >= 1ull; n = n - 1ull)
  {
    _Bool tmp_if_expr;
    if(!((signed int)*(*p) >= 48))
      tmp_if_expr = (_Bool)1;

    else
      tmp_if_expr = (signed int)*(*p) > 57 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr)
      return -0x2400;

    *res = *res * 10;
    unsigned char *tmp_post=*p;
    *p = *p + 1ll;
    *res = *res + ((signed int)*tmp_post - 48);
  }
  return 0;
}

// x509_parse_time
// file ..\..\..\..\lib\third_party\mbedtls\library\x509.c line 536
static signed int x509_parse_time(unsigned char **p, size_t len, size_t yearlen, mbedtls_x509_time *tm)
{
  signed int ret;
  if(!(len >= 8ull + yearlen))
    return -0x2400;

  else
  {
    len = len - (yearlen + 8ull);
    ret=x509_parse_int(p, yearlen, &tm->year);
    if(!(ret == 0))
      return ret;

    else
    {
      if(yearlen == 2ull)
      {
        if(!(tm->year >= 50))
          tm->year = tm->year + 100;

        tm->year = tm->year + 1900;
      }

      ret=x509_parse_int(p, 2ull, &tm->mon);
      if(!(ret == 0))
        return ret;

      else
      {
        ret=x509_parse_int(p, 2ull, &tm->day);
        if(!(ret == 0))
          return ret;

        else
        {
          ret=x509_parse_int(p, 2ull, &tm->hour);
          if(!(ret == 0))
            return ret;

          else
          {
            ret=x509_parse_int(p, 2ull, &tm->min);
            if(!(ret == 0))
              return ret;

            else
            {
              if(len >= 2ull)
              {
                ret=x509_parse_int(p, 2ull, &tm->sec);
                if(!(ret == 0))
                  return ret;

                len = len - 2ull;
              }

              else
                return -0x2400;
              if(len == 1ull)
              {
                if((signed int)*(*p) == 90)
                {
                  *p = *p + 1ll;
                  len = len - 1ull;
                }

              }

              if(!(len == 0ull))
                return -0x2400;

              else
              {
                ret=x509_date_is_valid(tm);
                if(!(ret == 0))
                  return ret;

                else
                  return 0;
              }
            }
          }
        }
      }
    }
  }
}

// x509_profile_check_key
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 193
static signed int x509_profile_check_key(const mbedtls_x509_crt_profile *profile, const mbedtls_pk_context *pk)
{
  const mbedtls_pk_type_t pk_alg=mbedtls_pk_get_type(pk);
  if((signed int)pk_alg == 1 || (signed int)pk_alg == 6)
  {
    size_t return_value_mbedtls_pk_get_bitlen=mbedtls_pk_get_bitlen(pk);
    if(return_value_mbedtls_pk_get_bitlen >= (unsigned long long int)profile->rsa_min_bitlen)
      return 0;

    return -1;
  }

  else
    if((signed int)pk_alg == 2 || (signed int)pk_alg == 3 || (signed int)pk_alg == 4)
    {
      mbedtls_ecp_group_id gid;
      mbedtls_ecp_keypair *return_value_mbedtls_pk_ec=mbedtls_pk_ec$link2(*pk);
      gid = return_value_mbedtls_pk_ec->grp.id;
      if(!((profile->allowed_curves & (unsigned int)(1 << -1 + (signed int)gid)) == 0u))
        return 0;

      return -1;
    }

    else
      return -1;
}

// x509_profile_check_md_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 167
static signed int x509_profile_check_md_alg(const mbedtls_x509_crt_profile *profile, mbedtls_md_type_t md_alg)
{
  if(!((profile->allowed_mds & (unsigned int)(1 << -1 + (signed int)md_alg)) == 0u))
    return 0;

  else
    return -1;
}

// x509_profile_check_pk_alg
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 180
static signed int x509_profile_check_pk_alg(const mbedtls_x509_crt_profile *profile, mbedtls_pk_type_t pk_alg)
{
  if(!((profile->allowed_pks & (unsigned int)(1 << -1 + (signed int)pk_alg)) == 0u))
    return 0;

  else
    return -1;
}

// x509_string_cmp
// file ..\..\..\..\lib\third_party\mbedtls\library\x509_crt.c line 1809
static signed int x509_string_cmp(const mbedtls_x509_buf *a, const mbedtls_x509_buf *b)
{
  signed int return_value_memcmp;
  if(a->tag == b->tag)
  {
    if(a->len == b->len)
    {
      return_value_memcmp=memcmp((const void *)a->p, (const void *)b->p, b->len);
      if(return_value_memcmp == 0)
        return 0;

    }

  }

  _Bool tmp_if_expr$0;
  if(a->tag == 0xC)
    tmp_if_expr$0 = (_Bool)1;

  else
    tmp_if_expr$0 = a->tag == 0x13 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr;
  signed int return_value_x509_memcasecmp;
  if(tmp_if_expr$0)
  {
    if(b->tag == 0xC)
      tmp_if_expr = (_Bool)1;

    else
      tmp_if_expr = b->tag == 0x13 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr)
    {
      if(a->len == b->len)
      {
        return_value_x509_memcasecmp=x509_memcasecmp((const void *)a->p, (const void *)b->p, b->len);
        if(return_value_x509_memcasecmp == 0)
          return 0;

      }

    }

  }

  return -1;
}

// xAreSeparateTaskTCPEchoClientsStillRunning
// file ..\..\..\common\tcp\aws_tcp_echo_client_separate_tasks.c line 408
BaseType_t xAreSeparateTaskTCPEchoClientsStillRunning(void)
{
  BaseType_t xReturn=1;
  static uint32_t ulLastTxTaskCycles=0u;
  if(ulTxTaskCycles == ulLastTxTaskCycles)
    xReturn = 0;

  else
    ulLastTxTaskCycles = ulTxTaskCycles;
  static uint32_t ulLastRxTaskCycles=0u;
  if(ulRxTaskCycles == ulLastRxTaskCycles)
    xReturn = 0;

  else
    ulLastRxTaskCycles = ulRxTaskCycles;
  return xReturn;
}

// xAreSingleTaskTCPEchoClientsStillRunning
// file ..\..\..\common\tcp\aws_tcp_echo_client_single_task.c line 390
BaseType_t xAreSingleTaskTCPEchoClientsStillRunning(void)
{
  BaseType_t xReturn=1;
  BaseType_t x=0;
  for( ; !(x >= 1); x = x + 1l)
  {
    static uint32_t ulLastEchoSocketCount[1ll]={ 0u };
    if(ulTxRxCycles[(signed long long int)x] == ulLastEchoSocketCount[(signed long long int)x])
      xReturn = 0;

    else
      ulLastEchoSocketCount[(signed long long int)x] = ulTxRxCycles[(signed long long int)x];
    static uint32_t ulLastConnections[1ll]={ 0u };
    if(ulConnections[(signed long long int)x] == ulLastConnections[(signed long long int)x])
      xReturn = 0;

    else
      ulConnections[(signed long long int)x] = ulLastConnections[(signed long long int)x];
  }
  return xReturn;
}

// xAreTCPEchoServersStillRunning
// file ..\..\..\common\tcp\aws_simple_tcp_echo_server.c line 230
BaseType_t xAreTCPEchoServersStillRunning(void)
{
  BaseType_t xReturn=1;
  static uint32_t ulLastConnectionCount=0u;
  if(ulConnectionCount == ulLastConnectionCount)
    xReturn = 0;

  else
    ulLastConnectionCount = ulConnectionCount;
  return xReturn;
}

// xEventGroupClearBits
// file ..\..\..\..\lib\FreeRTOS\event_groups.c line 446
EventBits_t xEventGroupClearBits(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear)
{
  EventGroup_t *pxEventBits=(EventGroup_t *)xEventGroup;
  EventBits_t uxReturn;
  if(xEventGroup == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\event_groups.c", 453u);

  if(!((0xFF000000ul & uxBitsToClear) == 0u))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\event_groups.c", 454u);

  vPortEnterCritical();
  UBaseType_t return_value_uxEventGroupGetNumber;
  if(!(uxBitsToClear == 0u))
  {
    return_value_uxEventGroupGetNumber=uxEventGroupGetNumber(xEventGroup);
    prvTraceStoreKernelCallWithParam(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + 18ul + 6ul, 6, (uint32_t)(traceHandle)return_value_uxEventGroupGetNumber, uxBitsToClear);
  }

  uxReturn = pxEventBits->uxEventBits;
  pxEventBits->uxEventBits = pxEventBits->uxEventBits & ~uxBitsToClear;
  vPortExitCritical();
  return uxReturn;
}

// xEventGroupClearBitsFromISR
// file ..\..\..\..\lib\FreeRTOS\event_groups.c line 475
BaseType_t xEventGroupClearBitsFromISR(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear)
{
  BaseType_t xReturn;
  UBaseType_t return_value_uxEventGroupGetNumber;
  if(!(uxBitsToClear == 0u))
  {
    return_value_uxEventGroupGetNumber=uxEventGroupGetNumber(xEventGroup);
    prvTraceStoreKernelCallWithParam(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + 18ul + 7ul, 6, (uint32_t)(traceHandle)return_value_uxEventGroupGetNumber, uxBitsToClear);
  }

  xReturn=xTimerPendFunctionCallFromISR(vEventGroupClearBitsCallback, (void *)xEventGroup, (uint32_t)uxBitsToClear, ((BaseType_t *)NULL));
  return xReturn;
}

// xEventGroupCreate
// file ..\..\..\..\lib\FreeRTOS\event_groups.c line 142
EventGroupHandle_t xEventGroupCreate(void)
{
  EventGroup_t *pxEventBits;
  void *return_value_pvPortMalloc=pvPortMalloc(sizeof(EventGroup_t) /*56ull*/ );
  pxEventBits = (EventGroup_t *)return_value_pvPortMalloc;
  if(!(pxEventBits == ((EventGroup_t *)NULL)))
  {
    pxEventBits->uxEventBits = 0u;
    vListInitialise(&pxEventBits->xTasksWaitingForBits);
    pxEventBits->ucStaticallyAllocated = 0;
    traceHandle return_value_prvTraceGetObjectHandle=prvTraceGetObjectHandle(6);
    ((EventGroup_t *)pxEventBits)->uxEventGroupNumber = (UBaseType_t)return_value_prvTraceGetObjectHandle;
    UBaseType_t return_value_uxEventGroupGetNumber=uxEventGroupGetNumber((void *)pxEventBits);
    prvTraceStoreKernelCall(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + 18ul + 0ul, 6, (uint32_t)(traceHandle)return_value_uxEventGroupGetNumber);
  }

  else
    prvTraceStoreKernelCall(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + 18ul + 1ul, 6, 0u);
  return (EventGroupHandle_t)pxEventBits;
}

// xEventGroupCreateStatic
// file ..\..\..\..\lib\FreeRTOS\event_groups.c line 93
EventGroupHandle_t xEventGroupCreateStatic(StaticEventGroup_t *pxEventGroupBuffer)
{
  EventGroup_t *pxEventBits;
  if(pxEventGroupBuffer == ((StaticEventGroup_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\event_groups.c", 98u);

  volatile size_t xSize=sizeof(StaticEventGroup_t) /*56ull*/ ;
  if(!(xSize == sizeof(EventGroup_t) /*56ull*/ ))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\event_groups.c", 106u);

  pxEventBits = (EventGroup_t *)pxEventGroupBuffer;
  if(!(pxEventBits == ((EventGroup_t *)NULL)))
  {
    pxEventBits->uxEventBits = 0u;
    vListInitialise(&pxEventBits->xTasksWaitingForBits);
    pxEventBits->ucStaticallyAllocated = 1;
    traceHandle return_value_prvTraceGetObjectHandle=prvTraceGetObjectHandle(6);
    ((EventGroup_t *)pxEventBits)->uxEventGroupNumber = (UBaseType_t)return_value_prvTraceGetObjectHandle;
    UBaseType_t return_value_uxEventGroupGetNumber=uxEventGroupGetNumber((void *)pxEventBits);
    prvTraceStoreKernelCall(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + 18ul + 0ul, 6, (uint32_t)(traceHandle)return_value_uxEventGroupGetNumber);
  }

  else
    prvTraceStoreKernelCall(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + 18ul + 1ul, 6, 0u);
  return (EventGroupHandle_t)pxEventBits;
}

// xEventGroupGetBitsFromISR
// file ..\..\..\..\lib\FreeRTOS\event_groups.c line 488
EventBits_t xEventGroupGetBitsFromISR(EventGroupHandle_t xEventGroup)
{
  UBaseType_t uxSavedInterruptStatus;
  EventGroup_t *pxEventBits=(EventGroup_t *)xEventGroup;
  EventBits_t uxReturn;
  uxSavedInterruptStatus = 0ul;
  uxReturn = pxEventBits->uxEventBits;
  (void)uxSavedInterruptStatus;
  return uxReturn;
}

// xEventGroupSetBits
// file ..\..\..\..\lib\FreeRTOS\event_groups.c line 504
EventBits_t xEventGroupSetBits(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet)
{
  ListItem_t *pxListItem;
  ListItem_t *pxNext;
  const ListItem_t *pxListEnd;
  List_t *pxList;
  EventBits_t uxBitsToClear=0u;
  EventBits_t uxBitsWaitedFor;
  EventBits_t uxControlBits;
  EventGroup_t *pxEventBits=(EventGroup_t *)xEventGroup;
  BaseType_t xMatchFound=0;
  if(xEventGroup == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\event_groups.c", 515u);

  if(!((0xFF000000ul & uxBitsToSet) == 0u))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\event_groups.c", 516u);

  pxList = &pxEventBits->xTasksWaitingForBits;
  pxListEnd = (const ListItem_t *)&pxList->xListEnd;
  vTaskSuspendAll();
  UBaseType_t return_value_uxEventGroupGetNumber=uxEventGroupGetNumber(xEventGroup);
  prvTraceStoreKernelCallWithParam(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + 18ul + 8ul, 6, (uint32_t)(traceHandle)return_value_uxEventGroupGetNumber, uxBitsToSet);
  pxListItem = pxList->xListEnd.pxNext;
  pxEventBits->uxEventBits = pxEventBits->uxEventBits | uxBitsToSet;
  for( ; !(pxListItem == pxListEnd); pxListItem = pxNext)
  {
    pxNext = pxListItem->pxNext;
    uxBitsWaitedFor = pxListItem->xItemValue;
    xMatchFound = 0;
    uxControlBits = uxBitsWaitedFor & 0xFF000000ul;
    uxBitsWaitedFor = uxBitsWaitedFor & ~0xFF000000ul;
    if((0x4000000ul & uxControlBits) == 0u)
    {
      if(!((pxEventBits->uxEventBits & uxBitsWaitedFor) == 0u))
        xMatchFound = 1;

    }

    else
      if((pxEventBits->uxEventBits & uxBitsWaitedFor) == uxBitsWaitedFor)
        xMatchFound = 1;

    if(!(xMatchFound == 0))
    {
      if(!((0x1000000ul & uxControlBits) == 0u))
        uxBitsToClear = uxBitsToClear | uxBitsWaitedFor;

      vTaskRemoveFromUnorderedEventList(pxListItem, pxEventBits->uxEventBits | 0x2000000ul);
    }

  }
  pxEventBits->uxEventBits = pxEventBits->uxEventBits & ~uxBitsToClear;
  xTaskResumeAll();
  return pxEventBits->uxEventBits;
}

// xEventGroupSetBitsFromISR
// file ..\..\..\..\lib\FreeRTOS\event_groups.c line 693
BaseType_t xEventGroupSetBitsFromISR(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken)
{
  BaseType_t xReturn;
  UBaseType_t return_value_uxEventGroupGetNumber=uxEventGroupGetNumber(xEventGroup);
  prvTraceStoreKernelCallWithParam(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + 18ul + 12ul, 6, (uint32_t)(traceHandle)return_value_uxEventGroupGetNumber, uxBitsToSet);
  uiInEventGroupSetBitsFromISR = 1;
  xReturn=xTimerPendFunctionCallFromISR(vEventGroupSetBitsCallback, (void *)xEventGroup, (uint32_t)uxBitsToSet, pxHigherPriorityTaskWoken);
  return xReturn;
}

// xEventGroupSync
// file ..\..\..\..\lib\FreeRTOS\event_groups.c line 176
EventBits_t xEventGroupSync(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait)
{
  EventBits_t uxOriginalBitValue;
  EventBits_t uxReturn;
  EventGroup_t *pxEventBits=(EventGroup_t *)xEventGroup;
  BaseType_t xAlreadyYielded;
  BaseType_t xTimeoutOccurred=0;
  if(!((0xFF000000ul & uxBitsToWaitFor) == 0u))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\event_groups.c", 183u);

  if(uxBitsToWaitFor == 0u)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\event_groups.c", 184u);

  BaseType_t return_value_xTaskGetSchedulerState=xTaskGetSchedulerState();
  if(return_value_xTaskGetSchedulerState == 0 && !(xTicksToWait == 0u))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\event_groups.c", 187u);

  vTaskSuspendAll();
  uxOriginalBitValue = pxEventBits->uxEventBits;
  xEventGroupSetBits(xEventGroup, uxBitsToSet);
  if(((uxOriginalBitValue | uxBitsToSet) & uxBitsToWaitFor) == uxBitsToWaitFor)
  {
    uxReturn = uxOriginalBitValue | uxBitsToSet;
    pxEventBits->uxEventBits = pxEventBits->uxEventBits & ~uxBitsToWaitFor;
    xTicksToWait = 0u;
  }

  else
    if(!(xTicksToWait == 0u))
    {
      UBaseType_t return_value_uxEventGroupGetNumber=uxEventGroupGetNumber(xEventGroup);
      prvTraceStoreKernelCallWithParam(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + 18ul + 2ul, 6, (uint32_t)(traceHandle)return_value_uxEventGroupGetNumber, uxBitsToWaitFor);
      vTaskPlaceOnUnorderedEventList(&pxEventBits->xTasksWaitingForBits, uxBitsToWaitFor | 0x1000000ul | 0x4000000ul, xTicksToWait);
      uxReturn = 0u;
    }

    else
    {
      uxReturn = pxEventBits->uxEventBits;
      xTimeoutOccurred = 1;
    }
  xAlreadyYielded=xTaskResumeAll();
  if(!(xTicksToWait == 0u))
  {
    if(xAlreadyYielded == 0)
      vPortGenerateSimulatedInterrupt(0ul);

    uxReturn=uxTaskResetEventItemValue();
    if((0x2000000ul & uxReturn) == 0u)
    {
      vPortEnterCritical();
      uxReturn = pxEventBits->uxEventBits;
      if((uxReturn & uxBitsToWaitFor) == uxBitsToWaitFor)
        pxEventBits->uxEventBits = pxEventBits->uxEventBits & ~uxBitsToWaitFor;

      vPortExitCritical();
      xTimeoutOccurred = 1;
    }

    uxReturn = uxReturn & ~0xFF000000ul;
  }

  if(!(xTimeoutOccurred == 0l))
  {
    UBaseType_t return_value_uxEventGroupGetNumber$0=uxEventGroupGetNumber(xEventGroup);
    prvTraceStoreKernelCallWithParam(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + 18ul + 10ul, 6, (uint32_t)(traceHandle)return_value_uxEventGroupGetNumber$0, uxBitsToWaitFor);
  }

  else
  {
    UBaseType_t return_value_uxEventGroupGetNumber$1=uxEventGroupGetNumber(xEventGroup);
    prvTraceStoreKernelCallWithParam(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + 18ul + 3ul, 6, (uint32_t)(traceHandle)return_value_uxEventGroupGetNumber$1, uxBitsToWaitFor);
  }
  (void)xTimeoutOccurred;
  return uxReturn;
}

// xEventGroupWaitBits
// file ..\..\..\..\lib\FreeRTOS\event_groups.c line 296
EventBits_t xEventGroupWaitBits(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait)
{
  EventGroup_t *pxEventBits=(EventGroup_t *)xEventGroup;
  EventBits_t uxReturn;
  EventBits_t uxControlBits=0u;
  BaseType_t xWaitConditionMet;
  BaseType_t xAlreadyYielded;
  BaseType_t xTimeoutOccurred=0;
  if(xEventGroup == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\event_groups.c", 305u);

  if(!((0xFF000000ul & uxBitsToWaitFor) == 0u))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\event_groups.c", 306u);

  if(uxBitsToWaitFor == 0u)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\event_groups.c", 307u);

  BaseType_t return_value_xTaskGetSchedulerState=xTaskGetSchedulerState();
  if(return_value_xTaskGetSchedulerState == 0 && !(xTicksToWait == 0u))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\event_groups.c", 310u);

  vTaskSuspendAll();
  const EventBits_t uxCurrentEventBits=pxEventBits->uxEventBits;
  xWaitConditionMet=prvTestWaitCondition(uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits);
  if(!(xWaitConditionMet == 0))
  {
    uxReturn = uxCurrentEventBits;
    xTicksToWait = 0u;
    if(!(xClearOnExit == 0))
      pxEventBits->uxEventBits = pxEventBits->uxEventBits & ~uxBitsToWaitFor;

  }

  else
    if(xTicksToWait == 0u)
    {
      uxReturn = uxCurrentEventBits;
      xTimeoutOccurred = 1;
    }

    else
    {
      if(!(xClearOnExit == 0))
        uxControlBits = uxControlBits | 0x1000000ul;

      if(!(xWaitForAllBits == 0))
        uxControlBits = uxControlBits | 0x4000000ul;

      vTaskPlaceOnUnorderedEventList(&pxEventBits->xTasksWaitingForBits, uxBitsToWaitFor | uxControlBits, xTicksToWait);
      uxReturn = 0u;
      UBaseType_t return_value_uxEventGroupGetNumber=uxEventGroupGetNumber(xEventGroup);
      prvTraceStoreKernelCallWithParam(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + 18ul + 4ul, 6, (uint32_t)(traceHandle)return_value_uxEventGroupGetNumber, uxBitsToWaitFor);
      void *return_value_prvTraceGetCurrentTaskHandle=prvTraceGetCurrentTaskHandle();
      traceHandle return_value_prvTraceGetTaskNumber=prvTraceGetTaskNumber(return_value_prvTraceGetCurrentTaskHandle);
      prvTraceSetTaskInstanceFinished(return_value_prvTraceGetTaskNumber);
    }
  xAlreadyYielded=xTaskResumeAll();
  if(!(xTicksToWait == 0u))
  {
    if(xAlreadyYielded == 0)
      vPortGenerateSimulatedInterrupt(0ul);

    uxReturn=uxTaskResetEventItemValue();
    if((0x2000000ul & uxReturn) == 0u)
    {
      vPortEnterCritical();
      uxReturn = pxEventBits->uxEventBits;
      BaseType_t return_value_prvTestWaitCondition=prvTestWaitCondition(uxReturn, uxBitsToWaitFor, xWaitForAllBits);
      if(!(return_value_prvTestWaitCondition == 0))
      {
        if(!(xClearOnExit == 0))
          pxEventBits->uxEventBits = pxEventBits->uxEventBits & ~uxBitsToWaitFor;

      }

      xTimeoutOccurred = 1;
      vPortExitCritical();
    }

    uxReturn = uxReturn & ~0xFF000000ul;
  }

  if(!(xTimeoutOccurred == 0l))
  {
    UBaseType_t return_value_uxEventGroupGetNumber$0=uxEventGroupGetNumber(xEventGroup);
    prvTraceStoreKernelCallWithParam(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + 18ul + 11ul, 6, (uint32_t)(traceHandle)return_value_uxEventGroupGetNumber$0, uxBitsToWaitFor);
  }

  else
  {
    UBaseType_t return_value_uxEventGroupGetNumber$1=uxEventGroupGetNumber(xEventGroup);
    prvTraceStoreKernelCallWithParam(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + 18ul + 5ul, 6, (uint32_t)(traceHandle)return_value_uxEventGroupGetNumber$1, uxBitsToWaitFor);
  }
  (void)xTimeoutOccurred;
  return uxReturn;
}

// xIPIsNetworkTaskReady
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 2298
BaseType_t xIPIsNetworkTaskReady(void)
{
  return xIPTaskInitialised;
}

// xIsCallingFromIPTask
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 517
BaseType_t xIsCallingFromIPTask(void)
{
  BaseType_t xReturn;
  TaskHandle_t return_value_xTaskGetCurrentTaskHandle=xTaskGetCurrentTaskHandle();
  if(return_value_xTaskGetCurrentTaskHandle == xIPTaskHandle)
    xReturn = 1;

  else
    xReturn = 0;
  return xReturn;
}

// xIsDHCPSocket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_DHCP.c line 246
BaseType_t xIsDHCPSocket(Socket_t xSocket)
{
  BaseType_t xReturn;
  if(xDHCPData.xDHCPSocket == xSocket)
    xReturn = 1;

  else
    xReturn = 0;
  return xReturn;
}

// xNetworkBuffersInitialise
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\BufferManagement\BufferAllocation_2.c line 96
BaseType_t xNetworkBuffersInitialise(void)
{
  BaseType_t xReturn;
  BaseType_t x;
  if(xNetworkBufferSemaphore == NULL)
  {
    xNetworkBufferSemaphore=xQueueCreateCountingSemaphore(60ul, 60ul);
    if(xNetworkBufferSemaphore == NULL)
      vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS-Plus-TCP\\source\\portable\\BufferManagement\\BufferAllocation_2.c", 105u);

    if(!(xNetworkBufferSemaphore == NULL))
    {
      vListInitialise(&xFreeBuffersList);
      x = 0;
      for( ; !(x >= 60); x = x + 1l)
      {
        xNetworkBufferDescriptors[(signed long long int)x].pucEthernetBuffer = ((uint8_t *)NULL);
        vListInitialiseItem(&xNetworkBufferDescriptors[(signed long long int)x].xBufferListItem);
        (&xNetworkBufferDescriptors[(signed long long int)x].xBufferListItem)->pvOwner = (void *)&xNetworkBufferDescriptors[(signed long long int)x];
        vListInsert(&xFreeBuffersList, &xNetworkBufferDescriptors[(signed long long int)x].xBufferListItem);
      }
      uxMinimumFreeNetworkBuffers = 60ull;
    }

  }

  if(xNetworkBufferSemaphore == NULL)
    xReturn = 0;

  else
    xReturn = 1;
  return xReturn;
}

// xNetworkInterfaceInitialise
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 139
BaseType_t xNetworkInterfaceInitialise(void)
{
  BaseType_t xReturn=0;
  pcap_if_t *pxAllNetworkInterfaces=prvPrintAvailableNetworkInterfaces();
  if(!(pxAllNetworkInterfaces == ((pcap_if_t *)NULL)))
    prvOpenSelectedNetworkInterface(pxAllNetworkInterfaces);

  if(!(pxOpenedInterfaceHandle == ((pcap_t *)NULL)))
    xReturn = 1;

  return xReturn;
}

// xNetworkInterfaceOutput
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\portable\NetworkInterface\WinPCap\NetworkInterface.c line 191
BaseType_t xNetworkInterfaceOutput(NetworkBufferDescriptor_t * const pxNetworkBuffer, BaseType_t bReleaseAfterSend)
{
  size_t xSpace;
  BaseType_t return_value_xIsCallingFromIPTask=xIsCallingFromIPTask();
  if(!(return_value_xIsCallingFromIPTask == 1))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS-Plus-TCP\\source\\portable\\NetworkInterface\\WinPCap\\NetworkInterface.c", 196u);

  xSpace=uxStreamBufferGetSpace$link3(xSendBuffer);
  _Bool tmp_if_expr;
  if(!(pxNetworkBuffer->xDataLength >= 1215ull))
    tmp_if_expr = xSpace >= pxNetworkBuffer->xDataLength + sizeof(size_t) /*8ull*/  ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr = (_Bool)0;
  if(tmp_if_expr)
  {
    uxStreamBufferAdd(xSendBuffer, 0ull, (const uint8_t *)&pxNetworkBuffer->xDataLength, sizeof(size_t) /*8ull*/ );
    uxStreamBufferAdd(xSendBuffer, 0ull, (const uint8_t *)pxNetworkBuffer->pucEthernetBuffer, pxNetworkBuffer->xDataLength);
  }

  else
    while((_Bool)0)
      ;
  SetEvent(pvSendEvent);
  if(!(bReleaseAfterSend == 0))
    vReleaseNetworkBufferAndDescriptor(pxNetworkBuffer);

  return 1;
}

// xPortGetFreeHeapSize
// file ..\..\..\..\lib\FreeRTOS\portable\MemMang\heap_4.c line 311
size_t xPortGetFreeHeapSize(void)
{
  return xFreeBytesRemaining;
}

// xPortGetMinimumEverFreeHeapSize
// file ..\..\..\..\lib\FreeRTOS\portable\MemMang\heap_4.c line 317
size_t xPortGetMinimumEverFreeHeapSize(void)
{
  return xMinimumEverFreeBytesRemaining;
}

// xPortStartScheduler
// file ..\..\..\..\lib\FreeRTOS\portable\MSVC-MingW\port.c line 235
BaseType_t xPortStartScheduler(void)
{
  void *pvHandle=NULL;
  int32_t lSuccess;
  xThreadState *pxThreadState=((xThreadState *)NULL);
  SYSTEM_INFO xSystemInfo;
  GetSystemInfo(&xSystemInfo);
  if(!(xSystemInfo.dwNumberOfProcessors >= 2u))
  {
    printf("This version of the FreeRTOS Windows port can only be used on multi-core hosts.\r\n");
    lSuccess = 0;
  }

  else
  {
    lSuccess = 1;
    HANDLE return_value_GetCurrentProcess=GetCurrentProcess();
    BOOL return_value_SetPriorityClass=SetPriorityClass(return_value_GetCurrentProcess, 256ul);
    if(return_value_SetPriorityClass == 0)
      printf("SetPriorityClass() failed\r\n");

    vPortSetInterruptHandler(0ul, prvProcessYieldInterrupt);
    vPortSetInterruptHandler(1ul, prvProcessTickInterrupt);
    pvInterruptEventMutex=CreateMutexA(((LPSECURITY_ATTRIBUTES)NULL), 0, ((LPCSTR)NULL));
    pvInterruptEvent=CreateEventA(((LPSECURITY_ATTRIBUTES)NULL), 0, 0, ((LPCSTR)NULL));
    if(pvInterruptEvent == NULL || pvInterruptEventMutex == NULL)
      lSuccess = 0;

    pvHandle=GetCurrentThread();
    if(pvHandle == NULL)
      lSuccess = 0;

  }
  if(lSuccess == 1)
  {
    BOOL return_value_SetThreadPriority=SetThreadPriority(pvHandle, 15);
    if(return_value_SetThreadPriority == 0)
      lSuccess = 0;

    SetThreadPriorityBoost(pvHandle, 1);
    SetThreadAffinityMask(pvHandle, 1ull);
  }

  if(lSuccess == 1)
  {
    pvHandle=CreateThread(((LPSECURITY_ATTRIBUTES)NULL), 0ull, prvSimulatedPeripheralTimer, NULL, 4ul, ((LPDWORD)NULL));
    if(!(pvHandle == NULL))
    {
      SetThreadPriority(pvHandle, 2);
      SetThreadPriorityBoost(pvHandle, 1);
      SetThreadAffinityMask(pvHandle, 1ull);
      ResumeThread(pvHandle);
    }

    pxThreadState = (xThreadState *)*((size_t *)pxCurrentTCB);
    ulCriticalNesting = 0u;
    ResumeThread(pxThreadState->pvThread);
    prvProcessSimulatedInterrupts();
  }

  return 0;
}

// xProcessReceivedTCPPacket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 2897
BaseType_t xProcessReceivedTCPPacket(NetworkBufferDescriptor_t *pxNetworkBuffer)
{
  FreeRTOS_Socket_t *pxSocket;
  TCPPacket_t *pxTCPPacket=(TCPPacket_t *)pxNetworkBuffer->pucEthernetBuffer;
  uint16_t ucTCPFlags;
  uint32_t ulLocalIP;
  uint16_t xLocalPort;
  uint32_t ulRemoteIP;
  uint16_t xRemotePort;
  BaseType_t xResult=1;
  if(pxNetworkBuffer->xDataLength >= 54ull)
  {
    ucTCPFlags = (uint16_t)pxTCPPacket->xTCPHeader.ucTCPFlags;
    ulLocalIP = (uint32_t)((uint32_t)pxTCPPacket->xIPHeader.ulDestinationIPAddress << 24 | ((uint32_t)pxTCPPacket->xIPHeader.ulDestinationIPAddress & 0xFF00ul) << 8 | ((uint32_t)pxTCPPacket->xIPHeader.ulDestinationIPAddress & 0xFF0000ul) >> 8 | (uint32_t)pxTCPPacket->xIPHeader.ulDestinationIPAddress >> 24);
    xLocalPort = (uint16_t)((signed int)pxTCPPacket->xTCPHeader.usDestinationPort << 8u | (signed int)pxTCPPacket->xTCPHeader.usDestinationPort >> 8u);
    ulRemoteIP = (uint32_t)((uint32_t)pxTCPPacket->xIPHeader.ulSourceIPAddress << 24 | ((uint32_t)pxTCPPacket->xIPHeader.ulSourceIPAddress & 0xFF00ul) << 8 | ((uint32_t)pxTCPPacket->xIPHeader.ulSourceIPAddress & 0xFF0000ul) >> 8 | (uint32_t)pxTCPPacket->xIPHeader.ulSourceIPAddress >> 24);
    xRemotePort = (uint16_t)((signed int)pxTCPPacket->xTCPHeader.usSourcePort << 8u | (signed int)pxTCPPacket->xTCPHeader.usSourcePort >> 8u);
    FreeRTOS_Socket_t *return_value_pxTCPSocketLookup=pxTCPSocketLookup(ulLocalIP, (UBaseType_t)xLocalPort, ulRemoteIP, (UBaseType_t)xRemotePort);
    pxSocket = (FreeRTOS_Socket_t *)return_value_pxTCPSocketLookup;
  }

  else
    return 0;
  _Bool tmp_if_expr$0;
  BaseType_t return_value_prvTCPSocketIsActive;
  if(pxSocket == ((FreeRTOS_Socket_t *)NULL))
    tmp_if_expr$0 = (_Bool)1;

  else
  {
    return_value_prvTCPSocketIsActive=prvTCPSocketIsActive((UBaseType_t)pxSocket->u.xTCP.ucTCPState);
    tmp_if_expr$0 = return_value_prvTCPSocketIsActive == 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr;
  if(tmp_if_expr$0)
  {
    while((_Bool)0)
      ;
    if((0x4u & (unsigned int)ucTCPFlags) == 0u && !((0x1Fu & (unsigned int)ucTCPFlags) == 0x10u))
      prvTCPSendReset(pxNetworkBuffer);

    xResult = 0;
  }

  else
  {
    pxSocket->u.xTCP.ucRepCount = 0;
    if((signed int)pxSocket->u.xTCP.ucTCPState == 1)
    {
      if(!((0x1Fu & (unsigned int)ucTCPFlags) == 0x2u))
      {
        if((0x4u & (unsigned int)ucTCPFlags) == 0u)
          prvTCPSendReset(pxNetworkBuffer);

        xResult = 0;
      }

      else
      {
        pxSocket=prvHandleListen(pxSocket, pxNetworkBuffer);
        if(pxSocket == ((FreeRTOS_Socket_t *)NULL))
          xResult = 0;

      }
    }

    else
      if(!((0x4u & (unsigned int)ucTCPFlags) == 0u))
      {
        while((_Bool)0)
          ;
        vTCPStateChange(pxSocket, /*enum*/eCLOSED);
        xResult = 0;
      }

      else
      {
        if((0x1Fu & (unsigned int)ucTCPFlags) == 0x2u)
          tmp_if_expr = (signed int)pxSocket->u.xTCP.ucTCPState >= 5 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr = (_Bool)0;
        if(tmp_if_expr)
        {
          while((_Bool)0)
            ;
          xResult = 0;
        }

        else
        {
          const BaseType_t lOffset=(BaseType_t)(14u + 20u);
          memcpy((void *)(pxSocket->u.xTCP.xPacket.u.ucLastPacket + (signed long long int)lOffset), (const void *)(pxNetworkBuffer->pucEthernetBuffer + (signed long long int)lOffset), 20ull);
        }
      }
  }
  if(!(xResult == 0))
  {
    prvTCPTouchSocket(pxSocket);
    if((0xF0u & (unsigned int)pxTCPPacket->xTCPHeader.ucTCPOffset) >= 81u)
      prvCheckOptions(pxSocket, pxNetworkBuffer);

    pxSocket->u.xTCP.ulWindowSize = (uint32_t)(uint16_t)((signed int)pxTCPPacket->xTCPHeader.usWindow << 8u | (signed int)pxTCPPacket->xTCPHeader.usWindow >> 8u);
    pxSocket->u.xTCP.ulWindowSize = pxSocket->u.xTCP.ulWindowSize << (signed int)pxSocket->u.xTCP.ucPeerWinScaleFactor;
    BaseType_t return_value_prvTCPHandleState=prvTCPHandleState(pxSocket, &pxNetworkBuffer);
    if(return_value_prvTCPHandleState >= 1)
      prvTCPSendRepeated(pxSocket, &pxNetworkBuffer);

    if(!(pxNetworkBuffer == ((NetworkBufferDescriptor_t *)NULL)))
    {
      vReleaseNetworkBufferAndDescriptor(pxNetworkBuffer);
      pxNetworkBuffer = ((NetworkBufferDescriptor_t *)NULL);
    }

    prvTCPNextTimeout(pxSocket);
    xResult = 1;
  }

  return xResult;
}

// xProcessReceivedUDPPacket
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_UDP_IP.c line 239
BaseType_t xProcessReceivedUDPPacket(NetworkBufferDescriptor_t *pxNetworkBuffer, uint16_t usPort)
{
  BaseType_t xReturn=1;
  FreeRTOS_Socket_t *pxSocket;
  UDPPacket_t *pxUDPPacket=(UDPPacket_t *)pxNetworkBuffer->pucEthernetBuffer;
  if(pxNetworkBuffer->xDataLength >= 42ull)
    pxSocket=pxUDPSocketLookup((UBaseType_t)usPort);

  else
    return 0;
  if(!(pxSocket == ((FreeRTOS_Socket_t *)NULL)))
  {
    vARPRefreshCacheEntry(&pxUDPPacket->xEthernetHeader.xSourceAddress, pxUDPPacket->xIPHeader.ulSourceIPAddress);
    if(xReturn == 1)
    {
      vTaskSuspendAll();
      if(xReturn == 1)
      {
        vPortEnterCritical();
        vListInsertEnd(&pxSocket->u.xUDP.xWaitingPacketsList, &pxNetworkBuffer->xBufferListItem);
        vPortExitCritical();
      }

      xTaskResumeAll();
      if(!(pxSocket->xEventGroup == NULL))
        xEventGroupSetBits(pxSocket->xEventGroup, 1u);

      BaseType_t return_value_xIsDHCPSocket=xIsDHCPSocket((Socket_t)pxSocket);
      if(!(return_value_xIsDHCPSocket == 0l))
        xSendEventToIPTask(/*enum*/eDHCPEvent);

    }

  }

  else
    if((signed int)((uint16_t)((signed int)pxUDPPacket->xUDPHeader.usSourcePort >> 8u) | (uint16_t)((signed int)pxUDPPacket->xUDPHeader.usSourcePort << 8u)) == 53)
    {
      vARPRefreshCacheEntry(&pxUDPPacket->xEthernetHeader.xSourceAddress, pxUDPPacket->xIPHeader.ulSourceIPAddress);
      uint32_t return_value_ulDNSHandlePacket=ulDNSHandlePacket(pxNetworkBuffer);
      xReturn = (BaseType_t)return_value_ulDNSHandlePacket;
    }

    else
      xReturn = 0;
  return xReturn;
}

// xQueueCreateCountingSemaphore
// file ..\..\..\..\lib\FreeRTOS\queue.c line 699
QueueHandle_t xQueueCreateCountingSemaphore(const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount)
{
  QueueHandle_t xHandle;
  if(uxMaxCount == 0u)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 703u);

  if(!(uxMaxCount >= uxInitialCount))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 704u);

  xHandle=xQueueGenericCreate(uxMaxCount, 0ul, 2);
  if(!(xHandle == NULL))
    ((Queue_t *)xHandle)->uxMessagesWaiting = uxInitialCount;

  return xHandle;
}

// xQueueCreateCountingSemaphoreStatic
// file ..\..\..\..\lib\FreeRTOS\queue.c line 671
QueueHandle_t xQueueCreateCountingSemaphoreStatic(const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue)
{
  QueueHandle_t xHandle;
  if(uxMaxCount == 0u)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 675u);

  if(!(uxMaxCount >= uxInitialCount))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 676u);

  xHandle=xQueueGenericCreateStatic(uxMaxCount, 0ul, ((uint8_t *)NULL), pxStaticQueue, 2);
  if(!(xHandle == NULL))
    ((Queue_t *)xHandle)->uxMessagesWaiting = uxInitialCount;

  return xHandle;
}

// xQueueCreateMutex
// file ..\..\..\..\lib\FreeRTOS\queue.c line 482
QueueHandle_t xQueueCreateMutex(const uint8_t ucQueueType)
{
  Queue_t *pxNewQueue;
  const UBaseType_t uxMutexLength=1ul;
  const UBaseType_t uxMutexSize=0ul;
  QueueHandle_t return_value_xQueueGenericCreate=xQueueGenericCreate(uxMutexLength, uxMutexSize, ucQueueType);
  pxNewQueue = (Queue_t *)return_value_xQueueGenericCreate;
  prvInitialiseMutex(pxNewQueue);
  return (QueueHandle_t)pxNewQueue;
}

// xQueueCreateMutexStatic
// file ..\..\..\..\lib\FreeRTOS\queue.c line 498
QueueHandle_t xQueueCreateMutexStatic(const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue)
{
  Queue_t *pxNewQueue;
  const UBaseType_t uxMutexLength=1ul;
  const UBaseType_t uxMutexSize=0ul;
  (void)ucQueueType;
  QueueHandle_t return_value_xQueueGenericCreateStatic=xQueueGenericCreateStatic(uxMutexLength, uxMutexSize, ((uint8_t *)NULL), pxStaticQueue, ucQueueType);
  pxNewQueue = (Queue_t *)return_value_xQueueGenericCreateStatic;
  prvInitialiseMutex(pxNewQueue);
  return (QueueHandle_t)pxNewQueue;
}

// xQueueGenericCreate
// file ..\..\..\..\lib\FreeRTOS\queue.c line 358
QueueHandle_t xQueueGenericCreate(const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType)
{
  Queue_t *pxNewQueue;
  size_t xQueueSizeInBytes;
  uint8_t *pucQueueStorage;
  if(!(uxQueueLength >= 1ul))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 364u);

  if(uxItemSize == 0ul)
    xQueueSizeInBytes = 0ull;

  else
    xQueueSizeInBytes = (size_t)(uxQueueLength * uxItemSize);
  void *return_value_pvPortMalloc=pvPortMalloc(sizeof(Queue_t) /*136ull*/  + xQueueSizeInBytes);
  pxNewQueue = (Queue_t *)return_value_pvPortMalloc;
  if(!(pxNewQueue == ((Queue_t *)NULL)))
  {
    pucQueueStorage = (uint8_t *)pxNewQueue + (signed long long int)sizeof(Queue_t) /*136ll*/ ;
    pxNewQueue->ucStaticallyAllocated = 0;
    prvInitialiseNewQueue(uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue);
  }

  else
    prvTraceStoreKernelCall((uint32_t)(uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + (unsigned int)TraceObjectClassTable[(signed long long int)ucQueueType]), TraceObjectClassTable[(signed long long int)ucQueueType], 0u);
  return (QueueHandle_t)pxNewQueue;
}

// xQueueGenericCreateStatic
// file ..\..\..\..\lib\FreeRTOS\queue.c line 302
QueueHandle_t xQueueGenericCreateStatic(const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType)
{
  Queue_t *pxNewQueue;
  if(!(uxQueueLength >= 1ul))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 306u);

  if(pxStaticQueue == ((StaticQueue_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 310u);

  if(uxItemSize == 0u && !(pucQueueStorage == ((uint8_t *)NULL)))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 314u);

  if(pucQueueStorage == ((uint8_t *)NULL) && !(uxItemSize == 0u))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 315u);

  volatile size_t xSize=sizeof(StaticQueue_t) /*136ull*/ ;
  if(!(xSize == sizeof(Queue_t) /*136ull*/ ))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 323u);

  pxNewQueue = (Queue_t *)pxStaticQueue;
  if(!(pxNewQueue == ((Queue_t *)NULL)))
  {
    pxNewQueue->ucStaticallyAllocated = 1;
    prvInitialiseNewQueue(uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue);
  }

  else
    prvTraceStoreKernelCall((uint32_t)(uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + (unsigned int)TraceObjectClassTable[(signed long long int)ucQueueType]), TraceObjectClassTable[(signed long long int)ucQueueType], 0u);
  return (QueueHandle_t)pxNewQueue;
}

// xQueueGenericReset
// file ..\..\..\..\lib\FreeRTOS\queue.c line 247
BaseType_t xQueueGenericReset(QueueHandle_t xQueue, BaseType_t xNewQueue)
{
  Queue_t * const pxQueue=(Queue_t *)xQueue;
  if(pxQueue == ((Queue_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 251u);

  vPortEnterCritical();
  pxQueue->pcTail = pxQueue->pcHead + (signed long long int)(pxQueue->uxLength * pxQueue->uxItemSize);
  pxQueue->uxMessagesWaiting = 0u;
  pxQueue->pcWriteTo = pxQueue->pcHead;
  pxQueue->u.pcReadFrom = pxQueue->pcHead + (signed long long int)((pxQueue->uxLength - 1u) * pxQueue->uxItemSize);
  pxQueue->cRxLock = (int8_t)-1;
  pxQueue->cTxLock = (int8_t)-1;
  if(xNewQueue == 0)
  {
    if(!(pxQueue->xTasksWaitingToSend.uxNumberOfItems == 0ul))
    {
      BaseType_t return_value_xTaskRemoveFromEventList=xTaskRemoveFromEventList(&pxQueue->xTasksWaitingToSend);
      if(!(return_value_xTaskRemoveFromEventList == 0))
        vPortGenerateSimulatedInterrupt(0ul);

    }

  }

  else
  {
    vListInitialise(&pxQueue->xTasksWaitingToSend);
    vListInitialise(&pxQueue->xTasksWaitingToReceive);
  }
  vPortExitCritical();
  return 1;
}

// xQueueGenericSend
// file ..\..\..\..\lib\FreeRTOS\queue.c line 725
BaseType_t xQueueGenericSend(QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition)
{
  BaseType_t xEntryTimeSet=0;
  BaseType_t xYieldRequired;
  TimeOut_t xTimeOut;
  Queue_t * const pxQueue=(Queue_t *)xQueue;
  if(pxQueue == ((Queue_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 731u);

  _Bool tmp_if_expr;
  if(pvItemToQueue == NULL)
    tmp_if_expr = pxQueue->uxItemSize != 0u ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr = (_Bool)0;
  if(tmp_if_expr)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 732u);

  _Bool tmp_if_expr$0;
  if(xCopyPosition == 2)
    tmp_if_expr$0 = pxQueue->uxLength != 1u ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$0 = (_Bool)0;
  if(tmp_if_expr$0)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 733u);

  BaseType_t return_value_xTaskGetSchedulerState=xTaskGetSchedulerState();
  if(return_value_xTaskGetSchedulerState == 0 && !(xTicksToWait == 0u))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 736u);

  while((_Bool)1)
  {
    vPortEnterCritical();
    if(xCopyPosition == 2 || !(pxQueue->uxMessagesWaiting >= pxQueue->uxLength))
    {
      uint8_t return_value_prvTraceGetObjectType=prvTraceGetObjectType((void *)pxQueue);
      uint8_t return_value_prvTraceGetObjectType$0=prvTraceGetObjectType((void *)pxQueue);
      traceHandle return_value_prvTraceGetObjectNumber=prvTraceGetObjectNumber((void *)pxQueue);
      prvTraceStoreKernelCall((uint32_t)(uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + (unsigned int)TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType]), TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$0], (uint32_t)return_value_prvTraceGetObjectNumber);
      uint8_t return_value_prvTraceGetObjectType$1=prvTraceGetObjectType((void *)pxQueue);
      traceHandle return_value_prvTraceGetObjectNumber$0=prvTraceGetObjectNumber((void *)pxQueue);
      uint8_t return_value_prvTraceGetObjectType$2=prvTraceGetObjectType((void *)pxQueue);
      signed int tmp_if_expr$1;
      if(TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$2] == 2)
        tmp_if_expr$1 = 0;

      else
        tmp_if_expr$1 = (signed int)(uint8_t)(pxQueue->uxMessagesWaiting + 1u);
      prvTraceSetObjectState(TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$1], return_value_prvTraceGetObjectNumber$0, (uint8_t)tmp_if_expr$1);
      xYieldRequired=prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
      if(!(pxQueue->xTasksWaitingToReceive.uxNumberOfItems == 0ul))
      {
        BaseType_t return_value_xTaskRemoveFromEventList=xTaskRemoveFromEventList(&pxQueue->xTasksWaitingToReceive);
        if(!(return_value_xTaskRemoveFromEventList == 0))
          vPortGenerateSimulatedInterrupt(0ul);

      }

      else
        if(!(xYieldRequired == 0))
          vPortGenerateSimulatedInterrupt(0ul);

      vPortExitCritical();
      return 1;
    }

    else
      if(xTicksToWait == 0u)
      {
        vPortExitCritical();
        uint8_t return_value_prvTraceGetObjectType$3=prvTraceGetObjectType((void *)pxQueue);
        uint8_t return_value_prvTraceGetObjectType$4=prvTraceGetObjectType((void *)pxQueue);
        traceHandle return_value_prvTraceGetObjectNumber$1=prvTraceGetObjectNumber((void *)pxQueue);
        prvTraceStoreKernelCall((uint32_t)(uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + (unsigned int)TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$3]), TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$4], (uint32_t)return_value_prvTraceGetObjectNumber$1);
        return 0;
      }

      else
        if(xEntryTimeSet == 0)
        {
          vTaskInternalSetTimeOutState(&xTimeOut);
          xEntryTimeSet = 1;
        }

    vPortExitCritical();
    vTaskSuspendAll();
    vPortEnterCritical();
    if(pxQueue->cRxLock == -1)
      pxQueue->cRxLock = 0;

    if(pxQueue->cTxLock == -1)
      pxQueue->cTxLock = 0;

    vPortExitCritical();
    BaseType_t return_value_xTaskCheckForTimeOut=xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait);
    if(return_value_xTaskCheckForTimeOut == 0)
    {
      BaseType_t return_value_prvIsQueueFull=prvIsQueueFull(pxQueue);
      if(!(return_value_prvIsQueueFull == 0))
      {
        uint8_t return_value_prvTraceGetObjectType$5=prvTraceGetObjectType((void *)pxQueue);
        uint8_t return_value_prvTraceGetObjectType$6=prvTraceGetObjectType((void *)pxQueue);
        traceHandle return_value_prvTraceGetObjectNumber$2=prvTraceGetObjectNumber((void *)pxQueue);
        prvTraceStoreKernelCall((uint32_t)(uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + (unsigned int)TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$5]), TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$6], (uint32_t)return_value_prvTraceGetObjectNumber$2);
        vTaskPlaceOnEventList(&pxQueue->xTasksWaitingToSend, xTicksToWait);
        prvUnlockQueue(pxQueue);
        BaseType_t return_value_xTaskResumeAll=xTaskResumeAll();
        if(return_value_xTaskResumeAll == 0)
          vPortGenerateSimulatedInterrupt(0ul);

      }

      else
      {
        prvUnlockQueue(pxQueue);
        xTaskResumeAll();
      }
    }

    else
    {
      prvUnlockQueue(pxQueue);
      xTaskResumeAll();
      uint8_t return_value_prvTraceGetObjectType$7=prvTraceGetObjectType((void *)pxQueue);
      uint8_t return_value_prvTraceGetObjectType$8=prvTraceGetObjectType((void *)pxQueue);
      traceHandle return_value_prvTraceGetObjectNumber$3=prvTraceGetObjectNumber((void *)pxQueue);
      prvTraceStoreKernelCall((uint32_t)(uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + (unsigned int)TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$7]), TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$8], (uint32_t)return_value_prvTraceGetObjectNumber$3);
      return 0;
    }
  }
}

// xQueueGenericSendFromISR
// file ..\..\..\..\lib\FreeRTOS\queue.c line 923
BaseType_t xQueueGenericSendFromISR(QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition)
{
  BaseType_t xReturn;
  UBaseType_t uxSavedInterruptStatus;
  Queue_t * const pxQueue=(Queue_t *)xQueue;
  if(pxQueue == ((Queue_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 929u);

  _Bool tmp_if_expr;
  if(pvItemToQueue == NULL)
    tmp_if_expr = pxQueue->uxItemSize != 0u ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr = (_Bool)0;
  if(tmp_if_expr)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 930u);

  _Bool tmp_if_expr$0;
  if(xCopyPosition == 2)
    tmp_if_expr$0 = pxQueue->uxLength != 1u ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$0 = (_Bool)0;
  if(tmp_if_expr$0)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 931u);

  uxSavedInterruptStatus = 0ul;
  if(xCopyPosition == 2 || !(pxQueue->uxMessagesWaiting >= pxQueue->uxLength))
  {
    const int8_t cTxLock=pxQueue->cTxLock;
    uint8_t return_value_prvTraceGetObjectType=prvTraceGetObjectType((void *)pxQueue);
    uint8_t return_value_prvTraceGetObjectType$0=prvTraceGetObjectType((void *)pxQueue);
    traceHandle return_value_prvTraceGetObjectNumber=prvTraceGetObjectNumber((void *)pxQueue);
    prvTraceStoreKernelCall((uint32_t)(uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + (unsigned int)TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType]), TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$0], (uint32_t)return_value_prvTraceGetObjectNumber);
    uint8_t return_value_prvTraceGetObjectType$1=prvTraceGetObjectType((void *)pxQueue);
    traceHandle return_value_prvTraceGetObjectNumber$0=prvTraceGetObjectNumber((void *)pxQueue);
    prvTraceSetObjectState(TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$1], return_value_prvTraceGetObjectNumber$0, (uint8_t)(pxQueue->uxMessagesWaiting + 1u));
    prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
    if(cTxLock == -1)
    {
      if(!(pxQueue->xTasksWaitingToReceive.uxNumberOfItems == 0ul))
      {
        BaseType_t return_value_xTaskRemoveFromEventList=xTaskRemoveFromEventList(&pxQueue->xTasksWaitingToReceive);
        if(!(return_value_xTaskRemoveFromEventList == 0))
        {
          if(!(pxHigherPriorityTaskWoken == ((BaseType_t *)NULL)))
            *pxHigherPriorityTaskWoken = 1;

        }

      }

    }

    else
      pxQueue->cTxLock = (int8_t)((signed int)cTxLock + 1);
    xReturn = 1;
  }

  else
  {
    uint8_t return_value_prvTraceGetObjectType$2=prvTraceGetObjectType((void *)pxQueue);
    uint8_t return_value_prvTraceGetObjectType$3=prvTraceGetObjectType((void *)pxQueue);
    traceHandle return_value_prvTraceGetObjectNumber$1=prvTraceGetObjectNumber((void *)pxQueue);
    prvTraceStoreKernelCall((uint32_t)(uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + (unsigned int)TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$2]), TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$3], (uint32_t)return_value_prvTraceGetObjectNumber$1);
    xReturn = 0;
  }
  (void)uxSavedInterruptStatus;
  return xReturn;
}

// xQueueGetMutexHolder
// file ..\..\..\..\lib\FreeRTOS\queue.c line 518
void * xQueueGetMutexHolder(QueueHandle_t xSemaphore)
{
  void *pxReturn;
  vPortEnterCritical();
  if(((Queue_t *)xSemaphore)->pcHead == ((int8_t *)NULL))
    pxReturn = (void *)((Queue_t *)xSemaphore)->pcTail;

  else
    pxReturn = NULL;
  vPortExitCritical();
  return pxReturn;
}

// xQueueGetMutexHolderFromISR
// file ..\..\..\..\lib\FreeRTOS\queue.c line 548
void * xQueueGetMutexHolderFromISR(QueueHandle_t xSemaphore)
{
  void *pxReturn;
  if(xSemaphore == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 552u);

  if(((Queue_t *)xSemaphore)->pcHead == ((int8_t *)NULL))
    pxReturn = (void *)((Queue_t *)xSemaphore)->pcTail;

  else
    pxReturn = NULL;
  return pxReturn;
}

// xQueueGiveFromISR
// file ..\..\..\..\lib\FreeRTOS\queue.c line 1074
BaseType_t xQueueGiveFromISR(QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken)
{
  BaseType_t xReturn;
  UBaseType_t uxSavedInterruptStatus;
  Queue_t * const pxQueue=(Queue_t *)xQueue;
  if(pxQueue == ((Queue_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 1086u);

  if(!(pxQueue->uxItemSize == 0u))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 1090u);

  _Bool tmp_if_expr;
  if(pxQueue->pcHead == ((int8_t *)NULL))
    tmp_if_expr = pxQueue->pcTail != ((int8_t *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr = (_Bool)0;
  if(tmp_if_expr)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 1095u);

  uxSavedInterruptStatus = 0ul;
  const UBaseType_t uxMessagesWaiting=pxQueue->uxMessagesWaiting;
  if(!(uxMessagesWaiting >= pxQueue->uxLength))
  {
    const int8_t cTxLock=pxQueue->cTxLock;
    uint8_t return_value_prvTraceGetObjectType=prvTraceGetObjectType((void *)pxQueue);
    uint8_t return_value_prvTraceGetObjectType$0=prvTraceGetObjectType((void *)pxQueue);
    traceHandle return_value_prvTraceGetObjectNumber=prvTraceGetObjectNumber((void *)pxQueue);
    prvTraceStoreKernelCall((uint32_t)(uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + (unsigned int)TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType]), TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$0], (uint32_t)return_value_prvTraceGetObjectNumber);
    uint8_t return_value_prvTraceGetObjectType$1=prvTraceGetObjectType((void *)pxQueue);
    traceHandle return_value_prvTraceGetObjectNumber$0=prvTraceGetObjectNumber((void *)pxQueue);
    prvTraceSetObjectState(TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$1], return_value_prvTraceGetObjectNumber$0, (uint8_t)(pxQueue->uxMessagesWaiting + 1u));
    pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1ul;
    if(cTxLock == -1)
    {
      if(!(pxQueue->xTasksWaitingToReceive.uxNumberOfItems == 0ul))
      {
        BaseType_t return_value_xTaskRemoveFromEventList=xTaskRemoveFromEventList(&pxQueue->xTasksWaitingToReceive);
        if(!(return_value_xTaskRemoveFromEventList == 0))
        {
          if(!(pxHigherPriorityTaskWoken == ((BaseType_t *)NULL)))
            *pxHigherPriorityTaskWoken = 1;

        }

      }

    }

    else
      pxQueue->cTxLock = (int8_t)((signed int)cTxLock + 1);
    xReturn = 1;
  }

  else
  {
    uint8_t return_value_prvTraceGetObjectType$2=prvTraceGetObjectType((void *)pxQueue);
    uint8_t return_value_prvTraceGetObjectType$3=prvTraceGetObjectType((void *)pxQueue);
    traceHandle return_value_prvTraceGetObjectNumber$1=prvTraceGetObjectNumber((void *)pxQueue);
    prvTraceStoreKernelCall((uint32_t)(uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + (unsigned int)TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$2]), TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$3], (uint32_t)return_value_prvTraceGetObjectNumber$1);
    xReturn = 0;
  }
  (void)uxSavedInterruptStatus;
  return xReturn;
}

// xQueueGiveMutexRecursive
// file ..\..\..\..\lib\FreeRTOS\queue.c line 574
BaseType_t xQueueGiveMutexRecursive(QueueHandle_t xMutex)
{
  BaseType_t xReturn;
  Queue_t * const pxMutex=(Queue_t *)xMutex;
  if(pxMutex == ((Queue_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 579u);

  TaskHandle_t return_value_xTaskGetCurrentTaskHandle=xTaskGetCurrentTaskHandle();
  if(pxMutex->pcTail == (int8_t *)return_value_xTaskGetCurrentTaskHandle)
  {
    pxMutex->u.uxRecursiveCallCount = pxMutex->u.uxRecursiveCallCount - 1ul;
    if(pxMutex->u.uxRecursiveCallCount == 0ul)
      xQueueGenericSend((QueueHandle_t)pxMutex, NULL, 0u, 0);

    xReturn = 1;
  }

  else
  {
    xReturn = 0;
    uint8_t return_value_prvTraceGetObjectType=prvTraceGetObjectType((void *)pxMutex);
    uint8_t return_value_prvTraceGetObjectType$0=prvTraceGetObjectType((void *)pxMutex);
    traceHandle return_value_prvTraceGetObjectNumber=prvTraceGetObjectNumber((void *)pxMutex);
    prvTraceStoreKernelCall((uint32_t)(uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + (unsigned int)TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType]), TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$0], (uint32_t)return_value_prvTraceGetObjectNumber);
  }
  return xReturn;
}

// xQueueIsQueueEmptyFromISR
// file ..\..\..\..\lib\FreeRTOS\queue.c line 2279
BaseType_t xQueueIsQueueEmptyFromISR(const QueueHandle_t xQueue)
{
  BaseType_t xReturn;
  if(xQueue == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 2283u);

  if(((Queue_t *)xQueue)->uxMessagesWaiting == 0ul)
    xReturn = 1;

  else
    xReturn = 0;
  return xReturn;
}

// xQueueIsQueueFullFromISR
// file ..\..\..\..\lib\FreeRTOS\queue.c line 2318
BaseType_t xQueueIsQueueFullFromISR(const QueueHandle_t xQueue)
{
  BaseType_t xReturn;
  if(xQueue == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 2322u);

  if(((Queue_t *)xQueue)->uxMessagesWaiting == ((Queue_t *)xQueue)->uxLength)
    xReturn = 1;

  else
    xReturn = 0;
  return xReturn;
}

// xQueuePeek
// file ..\..\..\..\lib\FreeRTOS\queue.c line 1601
BaseType_t xQueuePeek(QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait)
{
  BaseType_t xEntryTimeSet=0;
  TimeOut_t xTimeOut;
  int8_t *pcOriginalReadPosition;
  Queue_t * const pxQueue=(Queue_t *)xQueue;
  if(pxQueue == ((Queue_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 1609u);

  _Bool tmp_if_expr;
  if(pvBuffer == NULL)
    tmp_if_expr = pxQueue->uxItemSize != 0u ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr = (_Bool)0;
  if(tmp_if_expr)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 1613u);

  BaseType_t return_value_xTaskGetSchedulerState=xTaskGetSchedulerState();
  if(return_value_xTaskGetSchedulerState == 0 && !(xTicksToWait == 0u))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 1618u);

  while((_Bool)1)
  {
    vPortEnterCritical();
    const UBaseType_t uxMessagesWaiting=pxQueue->uxMessagesWaiting;
    if(uxMessagesWaiting >= 1ul)
    {
      pcOriginalReadPosition = pxQueue->u.pcReadFrom;
      prvCopyDataFromQueue(pxQueue, pvBuffer);
      uint8_t return_value_prvTraceGetObjectType=prvTraceGetObjectType((void *)pxQueue);
      uint8_t return_value_prvTraceGetObjectType$0=prvTraceGetObjectType((void *)pxQueue);
      traceHandle return_value_prvTraceGetObjectNumber=prvTraceGetObjectNumber((void *)pxQueue);
      prvTraceStoreKernelCall((uint32_t)(uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + (unsigned int)TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType]), TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$0], (uint32_t)return_value_prvTraceGetObjectNumber);
      pxQueue->u.pcReadFrom = pcOriginalReadPosition;
      if(!(pxQueue->xTasksWaitingToReceive.uxNumberOfItems == 0ul))
      {
        BaseType_t return_value_xTaskRemoveFromEventList=xTaskRemoveFromEventList(&pxQueue->xTasksWaitingToReceive);
        if(!(return_value_xTaskRemoveFromEventList == 0))
          vPortGenerateSimulatedInterrupt(0ul);

      }

      vPortExitCritical();
      return 1;
    }

    else
      if(xTicksToWait == 0u)
      {
        vPortExitCritical();
        return 0;
      }

      else
        if(xEntryTimeSet == 0)
        {
          vTaskInternalSetTimeOutState(&xTimeOut);
          xEntryTimeSet = 1;
        }

    vPortExitCritical();
    vTaskSuspendAll();
    vPortEnterCritical();
    if(pxQueue->cRxLock == -1)
      pxQueue->cRxLock = 0;

    if(pxQueue->cTxLock == -1)
      pxQueue->cTxLock = 0;

    vPortExitCritical();
    BaseType_t return_value_xTaskCheckForTimeOut=xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait);
    if(return_value_xTaskCheckForTimeOut == 0)
    {
      BaseType_t return_value_prvIsQueueEmpty=prvIsQueueEmpty(pxQueue);
      if(!(return_value_prvIsQueueEmpty == 0))
      {
        vTaskPlaceOnEventList(&pxQueue->xTasksWaitingToReceive, xTicksToWait);
        prvUnlockQueue(pxQueue);
        BaseType_t return_value_xTaskResumeAll=xTaskResumeAll();
        if(return_value_xTaskResumeAll == 0)
          vPortGenerateSimulatedInterrupt(0ul);

      }

      else
      {
        prvUnlockQueue(pxQueue);
        xTaskResumeAll();
      }
    }

    else
    {
      prvUnlockQueue(pxQueue);
      xTaskResumeAll();
      BaseType_t return_value_prvIsQueueEmpty$0=prvIsQueueEmpty(pxQueue);
      if(!(return_value_prvIsQueueEmpty$0 == 0))
        return 0;

    }
  }
}

// xQueuePeekFromISR
// file ..\..\..\..\lib\FreeRTOS\queue.c line 1842
BaseType_t xQueuePeekFromISR(QueueHandle_t xQueue, void * const pvBuffer)
{
  BaseType_t xReturn;
  UBaseType_t uxSavedInterruptStatus;
  int8_t *pcOriginalReadPosition;
  Queue_t * const pxQueue=(Queue_t *)xQueue;
  if(pxQueue == ((Queue_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 1849u);

  _Bool tmp_if_expr;
  if(pvBuffer == NULL)
    tmp_if_expr = pxQueue->uxItemSize != 0u ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr = (_Bool)0;
  if(tmp_if_expr)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 1850u);

  if(pxQueue->uxItemSize == 0u)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 1851u);

  uxSavedInterruptStatus = 0ul;
  if(pxQueue->uxMessagesWaiting >= 1ul)
  {
    pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    prvCopyDataFromQueue(pxQueue, pvBuffer);
    pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    xReturn = 1;
  }

  else
    xReturn = 0;
  (void)uxSavedInterruptStatus;
  return xReturn;
}

// xQueueReceive
// file ..\..\..\..\lib\FreeRTOS\queue.c line 1240
BaseType_t xQueueReceive(QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait)
{
  BaseType_t xEntryTimeSet=0;
  TimeOut_t xTimeOut;
  Queue_t * const pxQueue=(Queue_t *)xQueue;
  if(pxQueue == ((Queue_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 1247u);

  _Bool tmp_if_expr;
  if(pvBuffer == NULL)
    tmp_if_expr = pxQueue->uxItemSize != 0u ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr = (_Bool)0;
  if(tmp_if_expr)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 1251u);

  BaseType_t return_value_xTaskGetSchedulerState=xTaskGetSchedulerState();
  if(return_value_xTaskGetSchedulerState == 0 && !(xTicksToWait == 0u))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 1256u);

  void *return_value_prvTraceGetCurrentTaskHandle;
  traceHandle return_value_prvTraceGetTaskNumber;
  while((_Bool)1)
  {
    vPortEnterCritical();
    const UBaseType_t uxMessagesWaiting=pxQueue->uxMessagesWaiting;
    if(uxMessagesWaiting >= 1ul)
    {
      prvCopyDataFromQueue(pxQueue, pvBuffer);
      uint8_t return_value_prvTraceGetObjectType=prvTraceGetObjectType((void *)pxQueue);
      uint8_t return_value_prvTraceGetObjectType$0=prvTraceGetObjectType((void *)pxQueue);
      traceHandle return_value_prvTraceGetObjectNumber=prvTraceGetObjectNumber((void *)pxQueue);
      prvTraceStoreKernelCall((uint32_t)(uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + (unsigned int)TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType]), TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$0], (uint32_t)return_value_prvTraceGetObjectNumber);
      uint8_t return_value_prvTraceGetObjectType$1=prvTraceGetObjectType((void *)pxQueue);
      traceHandle return_value_prvTraceGetObjectNumber$0=prvTraceGetObjectNumber((void *)pxQueue);
      uint8_t return_value_prvTraceGetObjectType$2=prvTraceGetObjectType((void *)pxQueue);
      signed int tmp_if_expr$0;
      if(TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$2] == 2)
      {
        return_value_prvTraceGetCurrentTaskHandle=prvTraceGetCurrentTaskHandle();
        return_value_prvTraceGetTaskNumber=prvTraceGetTaskNumber(return_value_prvTraceGetCurrentTaskHandle);
        tmp_if_expr$0 = (signed int)(uint8_t)return_value_prvTraceGetTaskNumber;
      }

      else
        tmp_if_expr$0 = (signed int)(uint8_t)(pxQueue->uxMessagesWaiting - 1u);
      prvTraceSetObjectState(TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$1], return_value_prvTraceGetObjectNumber$0, (uint8_t)tmp_if_expr$0);
      pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1ul;
      if(!(pxQueue->xTasksWaitingToSend.uxNumberOfItems == 0ul))
      {
        BaseType_t return_value_xTaskRemoveFromEventList=xTaskRemoveFromEventList(&pxQueue->xTasksWaitingToSend);
        if(!(return_value_xTaskRemoveFromEventList == 0))
          vPortGenerateSimulatedInterrupt(0ul);

      }

      vPortExitCritical();
      return 1;
    }

    else
      if(xTicksToWait == 0u)
      {
        vPortExitCritical();
        uint8_t return_value_prvTraceGetObjectType$3=prvTraceGetObjectType((void *)pxQueue);
        uint8_t return_value_prvTraceGetObjectType$4=prvTraceGetObjectType((void *)pxQueue);
        traceHandle return_value_prvTraceGetObjectNumber$1=prvTraceGetObjectNumber((void *)pxQueue);
        prvTraceStoreKernelCall((uint32_t)(uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + (unsigned int)TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$3]), TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$4], (uint32_t)return_value_prvTraceGetObjectNumber$1);
        return 0;
      }

      else
        if(xEntryTimeSet == 0)
        {
          vTaskInternalSetTimeOutState(&xTimeOut);
          xEntryTimeSet = 1;
        }

    vPortExitCritical();
    vTaskSuspendAll();
    vPortEnterCritical();
    if(pxQueue->cRxLock == -1)
      pxQueue->cRxLock = 0;

    if(pxQueue->cTxLock == -1)
      pxQueue->cTxLock = 0;

    vPortExitCritical();
    BaseType_t return_value_xTaskCheckForTimeOut=xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait);
    if(return_value_xTaskCheckForTimeOut == 0)
    {
      BaseType_t return_value_prvIsQueueEmpty=prvIsQueueEmpty(pxQueue);
      if(!(return_value_prvIsQueueEmpty == 0))
      {
        uint8_t return_value_prvTraceGetObjectType$5=prvTraceGetObjectType((void *)pxQueue);
        uint8_t return_value_prvTraceGetObjectType$6=prvTraceGetObjectType((void *)pxQueue);
        traceHandle return_value_prvTraceGetObjectNumber$2=prvTraceGetObjectNumber((void *)pxQueue);
        prvTraceStoreKernelCall((uint32_t)(uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + (unsigned int)TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$5]), TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$6], (uint32_t)return_value_prvTraceGetObjectNumber$2);
        uint8_t return_value_prvTraceGetObjectType$7=prvTraceGetObjectType((void *)pxQueue);
        if(!(TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$7] == 2))
        {
          void *return_value_prvTraceGetCurrentTaskHandle$0=prvTraceGetCurrentTaskHandle();
          traceHandle return_value_prvTraceGetTaskNumber$0=prvTraceGetTaskNumber(return_value_prvTraceGetCurrentTaskHandle$0);
          prvTraceSetTaskInstanceFinished(return_value_prvTraceGetTaskNumber$0);
        }

        vTaskPlaceOnEventList(&pxQueue->xTasksWaitingToReceive, xTicksToWait);
        prvUnlockQueue(pxQueue);
        BaseType_t return_value_xTaskResumeAll=xTaskResumeAll();
        if(return_value_xTaskResumeAll == 0)
          vPortGenerateSimulatedInterrupt(0ul);

      }

      else
      {
        prvUnlockQueue(pxQueue);
        xTaskResumeAll();
      }
    }

    else
    {
      prvUnlockQueue(pxQueue);
      xTaskResumeAll();
      BaseType_t return_value_prvIsQueueEmpty$0=prvIsQueueEmpty(pxQueue);
      if(!(return_value_prvIsQueueEmpty$0 == 0))
      {
        uint8_t return_value_prvTraceGetObjectType$8=prvTraceGetObjectType((void *)pxQueue);
        uint8_t return_value_prvTraceGetObjectType$9=prvTraceGetObjectType((void *)pxQueue);
        traceHandle return_value_prvTraceGetObjectNumber$3=prvTraceGetObjectNumber((void *)pxQueue);
        prvTraceStoreKernelCall((uint32_t)(uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + (unsigned int)TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$8]), TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$9], (uint32_t)return_value_prvTraceGetObjectNumber$3);
        return 0;
      }

    }
  }
}

// xQueueReceiveFromISR
// file ..\..\..\..\lib\FreeRTOS\queue.c line 1751
BaseType_t xQueueReceiveFromISR(QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken)
{
  BaseType_t xReturn;
  UBaseType_t uxSavedInterruptStatus;
  Queue_t * const pxQueue=(Queue_t *)xQueue;
  if(pxQueue == ((Queue_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 1757u);

  _Bool tmp_if_expr;
  if(pvBuffer == NULL)
    tmp_if_expr = pxQueue->uxItemSize != 0u ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr = (_Bool)0;
  if(tmp_if_expr)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 1758u);

  uxSavedInterruptStatus = 0ul;
  const UBaseType_t uxMessagesWaiting=pxQueue->uxMessagesWaiting;
  if(uxMessagesWaiting >= 1ul)
  {
    const int8_t cRxLock=pxQueue->cRxLock;
    uint8_t return_value_prvTraceGetObjectType=prvTraceGetObjectType((void *)pxQueue);
    uint8_t return_value_prvTraceGetObjectType$0=prvTraceGetObjectType((void *)pxQueue);
    traceHandle return_value_prvTraceGetObjectNumber=prvTraceGetObjectNumber((void *)pxQueue);
    prvTraceStoreKernelCall((uint32_t)(uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + (unsigned int)TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType]), TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$0], (uint32_t)return_value_prvTraceGetObjectNumber);
    uint8_t return_value_prvTraceGetObjectType$1=prvTraceGetObjectType((void *)pxQueue);
    traceHandle return_value_prvTraceGetObjectNumber$0=prvTraceGetObjectNumber((void *)pxQueue);
    prvTraceSetObjectState(TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$1], return_value_prvTraceGetObjectNumber$0, (uint8_t)(pxQueue->uxMessagesWaiting - 1u));
    prvCopyDataFromQueue(pxQueue, pvBuffer);
    pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1ul;
    if(cRxLock == -1)
    {
      if(!(pxQueue->xTasksWaitingToSend.uxNumberOfItems == 0ul))
      {
        BaseType_t return_value_xTaskRemoveFromEventList=xTaskRemoveFromEventList(&pxQueue->xTasksWaitingToSend);
        if(!(return_value_xTaskRemoveFromEventList == 0))
        {
          if(!(pxHigherPriorityTaskWoken == ((BaseType_t *)NULL)))
            *pxHigherPriorityTaskWoken = 1;

        }

      }

    }

    else
      pxQueue->cRxLock = (int8_t)((signed int)cRxLock + 1);
    xReturn = 1;
  }

  else
  {
    xReturn = 0;
    uint8_t return_value_prvTraceGetObjectType$2=prvTraceGetObjectType((void *)pxQueue);
    uint8_t return_value_prvTraceGetObjectType$3=prvTraceGetObjectType((void *)pxQueue);
    traceHandle return_value_prvTraceGetObjectNumber$1=prvTraceGetObjectNumber((void *)pxQueue);
    prvTraceStoreKernelCall((uint32_t)(uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + (unsigned int)TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$2]), TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$3], (uint32_t)return_value_prvTraceGetObjectNumber$1);
  }
  (void)uxSavedInterruptStatus;
  return xReturn;
}

// xQueueSemaphoreTake
// file ..\..\..\..\lib\FreeRTOS\queue.c line 1382
BaseType_t xQueueSemaphoreTake(QueueHandle_t xQueue, TickType_t xTicksToWait)
{
  BaseType_t xEntryTimeSet=0;
  TimeOut_t xTimeOut;
  Queue_t * const pxQueue=(Queue_t *)xQueue;
  BaseType_t xInheritanceOccurred=0;
  if(pxQueue == ((Queue_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 1393u);

  if(!(pxQueue->uxItemSize == 0u))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 1397u);

  BaseType_t return_value_xTaskGetSchedulerState=xTaskGetSchedulerState();
  if(return_value_xTaskGetSchedulerState == 0 && !(xTicksToWait == 0u))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 1402u);

  void *return_value_prvTraceGetCurrentTaskHandle;
  traceHandle return_value_prvTraceGetTaskNumber;
  while((_Bool)1)
  {
    vPortEnterCritical();
    const UBaseType_t uxSemaphoreCount=pxQueue->uxMessagesWaiting;
    if(uxSemaphoreCount >= 1ul)
    {
      uint8_t return_value_prvTraceGetObjectType=prvTraceGetObjectType((void *)pxQueue);
      uint8_t return_value_prvTraceGetObjectType$0=prvTraceGetObjectType((void *)pxQueue);
      traceHandle return_value_prvTraceGetObjectNumber=prvTraceGetObjectNumber((void *)pxQueue);
      prvTraceStoreKernelCall((uint32_t)(uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + (unsigned int)TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType]), TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$0], (uint32_t)return_value_prvTraceGetObjectNumber);
      uint8_t return_value_prvTraceGetObjectType$1=prvTraceGetObjectType((void *)pxQueue);
      traceHandle return_value_prvTraceGetObjectNumber$0=prvTraceGetObjectNumber((void *)pxQueue);
      uint8_t return_value_prvTraceGetObjectType$2=prvTraceGetObjectType((void *)pxQueue);
      signed int tmp_if_expr;
      if(TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$2] == 2)
      {
        return_value_prvTraceGetCurrentTaskHandle=prvTraceGetCurrentTaskHandle();
        return_value_prvTraceGetTaskNumber=prvTraceGetTaskNumber(return_value_prvTraceGetCurrentTaskHandle);
        tmp_if_expr = (signed int)(uint8_t)return_value_prvTraceGetTaskNumber;
      }

      else
        tmp_if_expr = (signed int)(uint8_t)(pxQueue->uxMessagesWaiting - 1u);
      prvTraceSetObjectState(TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$1], return_value_prvTraceGetObjectNumber$0, (uint8_t)tmp_if_expr);
      pxQueue->uxMessagesWaiting = uxSemaphoreCount - 1ul;
      if(pxQueue->pcHead == ((int8_t *)NULL))
      {
        void *return_value_pvTaskIncrementMutexHeldCount=pvTaskIncrementMutexHeldCount();
        pxQueue->pcTail = (int8_t *)return_value_pvTaskIncrementMutexHeldCount;
      }

      if(!(pxQueue->xTasksWaitingToSend.uxNumberOfItems == 0ul))
      {
        BaseType_t return_value_xTaskRemoveFromEventList=xTaskRemoveFromEventList(&pxQueue->xTasksWaitingToSend);
        if(!(return_value_xTaskRemoveFromEventList == 0))
          vPortGenerateSimulatedInterrupt(0ul);

      }

      vPortExitCritical();
      return 1;
    }

    else
      if(xTicksToWait == 0u)
      {
        if(!(xInheritanceOccurred == 0))
          vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 1474u);

        vPortExitCritical();
        uint8_t return_value_prvTraceGetObjectType$3=prvTraceGetObjectType((void *)pxQueue);
        uint8_t return_value_prvTraceGetObjectType$4=prvTraceGetObjectType((void *)pxQueue);
        traceHandle return_value_prvTraceGetObjectNumber$1=prvTraceGetObjectNumber((void *)pxQueue);
        prvTraceStoreKernelCall((uint32_t)(uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + (unsigned int)TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$3]), TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$4], (uint32_t)return_value_prvTraceGetObjectNumber$1);
        return 0;
      }

      else
        if(xEntryTimeSet == 0)
        {
          vTaskInternalSetTimeOutState(&xTimeOut);
          xEntryTimeSet = 1;
        }

    vPortExitCritical();
    vTaskSuspendAll();
    vPortEnterCritical();
    if(pxQueue->cRxLock == -1)
      pxQueue->cRxLock = 0;

    if(pxQueue->cTxLock == -1)
      pxQueue->cTxLock = 0;

    vPortExitCritical();
    BaseType_t return_value_xTaskCheckForTimeOut=xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait);
    if(return_value_xTaskCheckForTimeOut == 0)
    {
      BaseType_t return_value_prvIsQueueEmpty=prvIsQueueEmpty(pxQueue);
      if(!(return_value_prvIsQueueEmpty == 0))
      {
        uint8_t return_value_prvTraceGetObjectType$5=prvTraceGetObjectType((void *)pxQueue);
        uint8_t return_value_prvTraceGetObjectType$6=prvTraceGetObjectType((void *)pxQueue);
        traceHandle return_value_prvTraceGetObjectNumber$2=prvTraceGetObjectNumber((void *)pxQueue);
        prvTraceStoreKernelCall((uint32_t)(uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + (unsigned int)TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$5]), TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$6], (uint32_t)return_value_prvTraceGetObjectNumber$2);
        uint8_t return_value_prvTraceGetObjectType$7=prvTraceGetObjectType((void *)pxQueue);
        if(!(TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$7] == 2))
        {
          void *return_value_prvTraceGetCurrentTaskHandle$0=prvTraceGetCurrentTaskHandle();
          traceHandle return_value_prvTraceGetTaskNumber$0=prvTraceGetTaskNumber(return_value_prvTraceGetCurrentTaskHandle$0);
          prvTraceSetTaskInstanceFinished(return_value_prvTraceGetTaskNumber$0);
        }

        if(pxQueue->pcHead == ((int8_t *)NULL))
        {
          vPortEnterCritical();
          xInheritanceOccurred=xTaskPriorityInherit((void *)pxQueue->pcTail);
          vPortExitCritical();
        }

        vTaskPlaceOnEventList(&pxQueue->xTasksWaitingToReceive, xTicksToWait);
        prvUnlockQueue(pxQueue);
        BaseType_t return_value_xTaskResumeAll=xTaskResumeAll();
        if(return_value_xTaskResumeAll == 0)
          vPortGenerateSimulatedInterrupt(0ul);

      }

      else
      {
        prvUnlockQueue(pxQueue);
        xTaskResumeAll();
      }
    }

    else
    {
      prvUnlockQueue(pxQueue);
      xTaskResumeAll();
      BaseType_t return_value_prvIsQueueEmpty$0=prvIsQueueEmpty(pxQueue);
      if(!(return_value_prvIsQueueEmpty$0 == 0))
      {
        if(!(xInheritanceOccurred == 0))
        {
          vPortEnterCritical();
          UBaseType_t uxHighestWaitingPriority=prvGetDisinheritPriorityAfterTimeout(pxQueue);
          vTaskPriorityDisinheritAfterTimeout((void *)pxQueue->pcTail, uxHighestWaitingPriority);
          vPortExitCritical();
        }

        uint8_t return_value_prvTraceGetObjectType$8=prvTraceGetObjectType((void *)pxQueue);
        uint8_t return_value_prvTraceGetObjectType$9=prvTraceGetObjectType((void *)pxQueue);
        traceHandle return_value_prvTraceGetObjectNumber$3=prvTraceGetObjectNumber((void *)pxQueue);
        prvTraceStoreKernelCall((uint32_t)(uint8_t)(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + (unsigned int)TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$8]), TraceObjectClassTable[(signed long long int)return_value_prvTraceGetObjectType$9], (uint32_t)return_value_prvTraceGetObjectNumber$3);
        return 0;
      }

    }
  }
}

// xQueueTakeMutexRecursive
// file ..\..\..\..\lib\FreeRTOS\queue.c line 629
BaseType_t xQueueTakeMutexRecursive(QueueHandle_t xMutex, TickType_t xTicksToWait)
{
  BaseType_t xReturn;
  Queue_t * const pxMutex=(Queue_t *)xMutex;
  if(pxMutex == ((Queue_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\queue.c", 634u);

  TaskHandle_t return_value_xTaskGetCurrentTaskHandle=xTaskGetCurrentTaskHandle();
  if(pxMutex->pcTail == (int8_t *)return_value_xTaskGetCurrentTaskHandle)
  {
    pxMutex->u.uxRecursiveCallCount = pxMutex->u.uxRecursiveCallCount + 1ul;
    xReturn = 1;
  }

  else
  {
    xReturn=xQueueSemaphoreTake((QueueHandle_t)pxMutex, xTicksToWait);
    if(!(xReturn == 0))
      pxMutex->u.uxRecursiveCallCount = pxMutex->u.uxRecursiveCallCount + 1ul;

  }
  return xReturn;
}

// xSendEventStructToIPTask
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 1154
BaseType_t xSendEventStructToIPTask(const IPStackEvent_t *pxEvent, TickType_t xTimeout)
{
  BaseType_t xReturn;
  BaseType_t xSendMessage;
  BaseType_t return_value_xIPIsNetworkTaskReady=xIPIsNetworkTaskReady();
  _Bool tmp_if_expr;
  if(return_value_xIPIsNetworkTaskReady == 0)
    tmp_if_expr = (signed int)pxEvent->eEventType != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr = (_Bool)0;
  if(tmp_if_expr)
    xReturn = 0;

  else
  {
    xSendMessage = 1;
    if((signed int)pxEvent->eEventType == 5)
    {
      xTCPTimer.bExpired = 1u;
      UBaseType_t return_value_uxQueueMessagesWaiting=uxQueueMessagesWaiting(xNetworkEventQueue);
      if(!(return_value_uxQueueMessagesWaiting == 0u))
        xSendMessage = 0;

    }

    if(!(xSendMessage == 0))
    {
      BaseType_t return_value_xIsCallingFromIPTask=xIsCallingFromIPTask();
      if(return_value_xIsCallingFromIPTask == 1)
      {
        if(xTimeout >= 1u)
          xTimeout = 0u;

      }

      xReturn=xQueueGenericSend(xNetworkEventQueue, (const void *)pxEvent, xTimeout, 0);
      if(xReturn == 0)
        while((_Bool)0)
          ;

    }

    else
      xReturn = 1;
  }
  return xReturn;
}

// xSendEventToIPTask
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_IP.c line 1142
BaseType_t xSendEventToIPTask(eIPEvent_t eEvent)
{
  IPStackEvent_t xEventMessage;
  const TickType_t xDontBlock=0u;
  xEventMessage.eEventType = eEvent;
  xEventMessage.pvData = NULL;
  BaseType_t return_value_xSendEventStructToIPTask=xSendEventStructToIPTask(&xEventMessage, xDontBlock);
  return return_value_xSendEventStructToIPTask;
}

// xSequenceGreaterThan
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 240
static inline BaseType_t xSequenceGreaterThan(uint32_t a, uint32_t b)
{
  return (BaseType_t)(((a - b) - 1ul & 0x80000000ul) == 0ul);
}

// xSequenceGreaterThanOrEqual
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 249
static inline BaseType_t xSequenceGreaterThanOrEqual(uint32_t a, uint32_t b)
{
  return (BaseType_t)((a - b & 0x80000000ul) == 0ul);
}

// xSequenceLessThan
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 230
static inline BaseType_t xSequenceLessThan(uint32_t a, uint32_t b)
{
  return (BaseType_t)(((b - a) - 1ul & 0x80000000ul) == 0ul);
}

// xSequenceLessThanOrEqual
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 218
static inline BaseType_t xSequenceLessThanOrEqual(uint32_t a, uint32_t b)
{
  return (BaseType_t)((b - a & 0x80000000ul) == 0ul);
}

// xStreamBufferBytesAvailable
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 475
size_t xStreamBufferBytesAvailable(StreamBufferHandle_t xStreamBuffer)
{
  const StreamBuffer_t * const pxStreamBuffer=(StreamBuffer_t *)xStreamBuffer;
  size_t xReturn;
  if(pxStreamBuffer == ((const StreamBuffer_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 480u);

  xReturn=prvBytesInBuffer(pxStreamBuffer);
  return xReturn;
}

// xStreamBufferGenericCreate
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 219
StreamBufferHandle_t xStreamBufferGenericCreate(size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer)
{
  uint8_t *pucAllocatedMemory;
  if(!(xBufferSizeBytes >= 9ull))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 227u);

  if(!(xBufferSizeBytes >= xTriggerLevelBytes))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 228u);

  if(xTriggerLevelBytes == 0ull)
    xTriggerLevelBytes = 1ull;

  xBufferSizeBytes = xBufferSizeBytes + 1ull;
  void *return_value_pvPortMalloc=pvPortMalloc(xBufferSizeBytes + sizeof(StreamBuffer_t) /*64ull*/ );
  pucAllocatedMemory = (uint8_t *)return_value_pvPortMalloc;
  if(!(pucAllocatedMemory == ((uint8_t *)NULL)))
    prvInitialiseNewStreamBuffer((StreamBuffer_t *)pucAllocatedMemory, pucAllocatedMemory + (signed long long int)sizeof(StreamBuffer_t) /*64ll*/ , xBufferSizeBytes, xTriggerLevelBytes, xIsMessageBuffer);

  return (StreamBufferHandle_t)(StreamBufferHandle_t *)pucAllocatedMemory;
}

// xStreamBufferGenericCreateStatic
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 271
StreamBufferHandle_t xStreamBufferGenericCreateStatic(size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer, uint8_t * const pucStreamBufferStorageArea, StaticStreamBuffer_t * const pxStaticStreamBuffer)
{
  StreamBuffer_t1 * pxStreamBuffer=(StreamBuffer_t1 *)pxStaticStreamBuffer;
  StreamBufferHandle_t xReturn;
  if(pucStreamBufferStorageArea == ((uint8_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 280u);

  if(pxStaticStreamBuffer == ((StaticStreamBuffer_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 281u);

  if(!(xBufferSizeBytes >= xTriggerLevelBytes))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 282u);

  if(xTriggerLevelBytes == 0ull)
    xTriggerLevelBytes = 1ull;

  if(!(xBufferSizeBytes >= 9ull))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 295u);

  volatile size_t xSize=sizeof(StaticStreamBuffer_t) /*64ull*/ ;
  if(!(xSize == sizeof(StreamBuffer_t) /*64ull*/ ))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 303u);

  if(!(pxStaticStreamBuffer == ((StaticStreamBuffer_t *)NULL)) && !(pucStreamBufferStorageArea == ((uint8_t *)NULL)))
  {
    prvInitialiseNewStreamBuffer(pxStreamBuffer, pucStreamBufferStorageArea, xBufferSizeBytes, xTriggerLevelBytes, xIsMessageBuffer);
    pxStreamBuffer->ucFlags = pxStreamBuffer->ucFlags | 2;
    xReturn = (StreamBufferHandle_t)pxStaticStreamBuffer;
  }

  else
    xReturn = NULL;
  return xReturn;
}

// xStreamBufferIsEmpty
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 902
BaseType_t xStreamBufferIsEmpty(StreamBufferHandle_t xStreamBuffer)
{
  const StreamBuffer_t1 * pxStreamBuffer=(StreamBuffer_t1 *)xStreamBuffer;
  BaseType_t xReturn;
  size_t xTail;
  if(pxStreamBuffer == ((StreamBuffer_t1 *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 908u);

  xTail = pxStreamBuffer->xTail;
  if(pxStreamBuffer->xHead == xTail)
    xReturn = 1;

  else
    xReturn = 0;
  return xReturn;
}

// xStreamBufferIsFull
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 925
BaseType_t xStreamBufferIsFull(StreamBufferHandle_t xStreamBuffer)
{
  BaseType_t xReturn;
  size_t xBytesToStoreMessageLength;
  const StreamBuffer_t1 * pxStreamBuffer=(StreamBuffer_t1 *)xStreamBuffer;
  if(pxStreamBuffer == ((StreamBuffer_t1 *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 931u);

  if(!((1 & (signed int)pxStreamBuffer->ucFlags) == 0))
    xBytesToStoreMessageLength = sizeof(size_t) /*8ull*/ ;

  else
    xBytesToStoreMessageLength = 0ull;
  size_t return_value_xStreamBufferSpacesAvailable=xStreamBufferSpacesAvailable(xStreamBuffer);
  if(xBytesToStoreMessageLength >= return_value_xStreamBufferSpacesAvailable)
    xReturn = 1;

  else
    xReturn = 0;
  return xReturn;
}

// xStreamBufferLessThenEqual
// file d:\tuttle\freertos\lib\freertos-plus-tcp\include\FreeRTOS_Stream_Buffer.h line 246
static inline BaseType_t xStreamBufferLessThenEqual(const StreamBuffer_t *pxBuffer, const size_t uxLeft, const size_t uxRight)
{
  BaseType_t xReturn;
  size_t uxTail=pxBuffer->uxTail;
  if(!(uxLeft >= uxTail) ^ !(uxRight >= uxTail))
  {
    if(!(uxRight >= uxTail))
      xReturn = 1;

    else
      xReturn = 0;
  }

  else
    if(uxRight >= uxLeft)
      xReturn = 1;

    else
      xReturn = 0;
  return xReturn;
}

// xStreamBufferReceive
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 691
size_t xStreamBufferReceive(StreamBufferHandle_t xStreamBuffer, void *pvRxData, size_t xBufferLengthBytes, TickType_t xTicksToWait)
{
  StreamBuffer_t1 * pxStreamBuffer=(StreamBuffer_t1 *)xStreamBuffer;
  size_t xReceivedLength=0ull;
  size_t xBytesAvailable;
  size_t xBytesToStoreMessageLength;
  if(pvRxData == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 699u);

  if(pxStreamBuffer == ((StreamBuffer_t1 *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 700u);

  if(!((1 & (signed int)pxStreamBuffer->ucFlags) == 0))
    xBytesToStoreMessageLength = sizeof(size_t) /*8ull*/ ;

  else
    xBytesToStoreMessageLength = 0ull;
  if(!(xTicksToWait == 0u))
  {
    vPortEnterCritical();
    xBytesAvailable=prvBytesInBuffer(pxStreamBuffer);
    if(xBytesToStoreMessageLength >= xBytesAvailable)
    {
      xTaskNotifyStateClear(NULL);
      if(!(pxStreamBuffer->xTaskWaitingToReceive == NULL))
        vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 735u);

      pxStreamBuffer->xTaskWaitingToReceive=xTaskGetCurrentTaskHandle();
    }

    vPortExitCritical();
    if(xBytesToStoreMessageLength >= xBytesAvailable)
    {
      xTaskNotifyWait(0u, 4294967295u, ((uint32_t *)NULL), xTicksToWait);
      pxStreamBuffer->xTaskWaitingToReceive = NULL;
      xBytesAvailable=prvBytesInBuffer(pxStreamBuffer);
    }

  }

  else
    xBytesAvailable=prvBytesInBuffer(pxStreamBuffer);
  if(!(xBytesToStoreMessageLength >= xBytesAvailable))
  {
    xReceivedLength=prvReadMessageFromBuffer(pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength);
    if(!(xReceivedLength == 0ull))
    {
      vTaskSuspendAll();
      if(!(pxStreamBuffer->xTaskWaitingToSend == NULL))
      {
        xTaskGenericNotify(pxStreamBuffer->xTaskWaitingToSend, 0u, /*enum*/eNoAction, ((uint32_t *)NULL));
        pxStreamBuffer->xTaskWaitingToSend = NULL;
      }

      xTaskResumeAll();
    }

  }

  return xReceivedLength;
}

// xStreamBufferReceiveCompletedFromISR
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 990
BaseType_t xStreamBufferReceiveCompletedFromISR(StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken)
{
  StreamBuffer_t1 *  pxStreamBuffer=(StreamBuffer_t1 *)xStreamBuffer;
  BaseType_t xReturn;
  UBaseType_t uxSavedInterruptStatus;
  if(pxStreamBuffer == ((StreamBuffer_t1 *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 996u);

  uxSavedInterruptStatus = 0ul;
  if(!(pxStreamBuffer->xTaskWaitingToSend == NULL))
  {
    xTaskGenericNotifyFromISR(pxStreamBuffer->xTaskWaitingToSend, 0u, /*enum*/eNoAction, ((uint32_t *)NULL), pxHigherPriorityTaskWoken);
    pxStreamBuffer->xTaskWaitingToSend = NULL;
    xReturn = 1;
  }

  else
    xReturn = 0;
  (void)uxSavedInterruptStatus;
  return xReturn;
}

// xStreamBufferReceiveFromISR
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 795
size_t xStreamBufferReceiveFromISR(StreamBufferHandle_t xStreamBuffer, void *pvRxData, size_t xBufferLengthBytes, BaseType_t * const pxHigherPriorityTaskWoken)
{
  StreamBuffer_t1 *  pxStreamBuffer=(StreamBuffer_t1 *)xStreamBuffer;
  size_t xReceivedLength=0ull;
  size_t xBytesAvailable;
  size_t xBytesToStoreMessageLength;
  if(pvRxData == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 803u);

  if(pxStreamBuffer == ((StreamBuffer_t1 *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 804u);

  if(!((1 & (signed int)pxStreamBuffer->ucFlags) == 0))
    xBytesToStoreMessageLength = sizeof(size_t) /*8ull*/ ;

  else
    xBytesToStoreMessageLength = 0ull;
  xBytesAvailable=prvBytesInBuffer(pxStreamBuffer);
  if(!(xBytesToStoreMessageLength >= xBytesAvailable))
  {
    xReceivedLength=prvReadMessageFromBuffer(pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength);
    if(!(xReceivedLength == 0ull))
    {
      UBaseType_t uxSavedInterruptStatus=0ul;
      if(!(pxStreamBuffer->xTaskWaitingToSend == NULL))
      {
        xTaskGenericNotifyFromISR(pxStreamBuffer->xTaskWaitingToSend, 0u, /*enum*/eNoAction, ((uint32_t *)NULL), pxHigherPriorityTaskWoken);
        pxStreamBuffer->xTaskWaitingToSend = NULL;
      }

      (void)uxSavedInterruptStatus;
    }

  }

  return xReceivedLength;
}

// xStreamBufferReset
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 368
BaseType_t xStreamBufferReset(StreamBufferHandle_t xStreamBuffer)
{
  StreamBuffer_t1 * pxStreamBuffer=(StreamBuffer_t1 *)xStreamBuffer;
  BaseType_t xReturn=0;
  BaseType_t xIsMessageBuffer;
  UBaseType_t uxStreamBufferNumber;
  if(pxStreamBuffer == ((StreamBuffer_t1 *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 377u);

  uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
  if(pxStreamBuffer->xTaskWaitingToReceive == NULL)
  {
    if(pxStreamBuffer->xTaskWaitingToSend == NULL)
    {
      if(!((1 & (signed int)pxStreamBuffer->ucFlags) == 0))
        xIsMessageBuffer = 1;

      else
        xIsMessageBuffer = 0;
      prvInitialiseNewStreamBuffer(pxStreamBuffer, pxStreamBuffer->pucBuffer, pxStreamBuffer->xLength, pxStreamBuffer->xTriggerLevelBytes, xIsMessageBuffer);
      xReturn = 1;
      pxStreamBuffer->uxStreamBufferNumber = uxStreamBufferNumber;
    }

  }

  return xReturn;
}

// xStreamBufferSend
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 487
size_t xStreamBufferSend(StreamBufferHandle_t xStreamBuffer, const void *pvTxData, size_t xDataLengthBytes, TickType_t xTicksToWait)
{
  StreamBuffer_t1 *  pxStreamBuffer=(StreamBuffer_t1 *)xStreamBuffer;
  size_t xReturn;
  size_t xSpace=0ull;
  size_t xRequiredSpace=xDataLengthBytes;
  TimeOut_t xTimeOut;
  if(pvTxData == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 497u);

  if(pxStreamBuffer == ((StreamBuffer_t1 *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 498u);

  if(!((1 & (signed int)pxStreamBuffer->ucFlags) == 0))
    xRequiredSpace = xRequiredSpace + sizeof(size_t) /*8ull*/ ;

  BaseType_t return_value_xTaskCheckForTimeOut;
  if(!(xTicksToWait == 0u))
  {
    vTaskSetTimeOutState(&xTimeOut);
    do
    {
      vPortEnterCritical();
      xSpace=xStreamBufferSpacesAvailable((StreamBufferHandle_t)pxStreamBuffer);
      if(!(xSpace >= xRequiredSpace))
      {
        xTaskNotifyStateClear(NULL);
        if(!(pxStreamBuffer->xTaskWaitingToSend == NULL))
          vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 531u);

        pxStreamBuffer->xTaskWaitingToSend=xTaskGetCurrentTaskHandle();
      }

      else
      {
        vPortExitCritical();
        break;
      }
      vPortExitCritical();
      xTaskNotifyWait(0u, 4294967295u, ((uint32_t *)NULL), xTicksToWait);
      pxStreamBuffer->xTaskWaitingToSend = NULL;
      return_value_xTaskCheckForTimeOut=xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait);
    }
    while(return_value_xTaskCheckForTimeOut == 0);
  }

  if(xSpace == 0ull)
    xSpace=xStreamBufferSpacesAvailable((StreamBufferHandle_t)pxStreamBuffer);

  xReturn=prvWriteMessageToBuffer(pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace);
  if(xReturn >= 1ull)
  {
    size_t return_value_prvBytesInBuffer=prvBytesInBuffer(pxStreamBuffer);
    if(return_value_prvBytesInBuffer >= pxStreamBuffer->xTriggerLevelBytes)
    {
      vTaskSuspendAll();
      if(!(pxStreamBuffer->xTaskWaitingToReceive == NULL))
      {
        xTaskGenericNotify(pxStreamBuffer->xTaskWaitingToReceive, 0u, /*enum*/eNoAction, ((uint32_t *)NULL));
        pxStreamBuffer->xTaskWaitingToReceive = NULL;
      }

      xTaskResumeAll();
    }

  }

  return xReturn;
}

// xStreamBufferSendCompletedFromISR
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 960
BaseType_t xStreamBufferSendCompletedFromISR(StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken)
{
  StreamBuffer_t1 *  pxStreamBuffer=(StreamBuffer_t1 *)xStreamBuffer;
  BaseType_t xReturn;
  UBaseType_t uxSavedInterruptStatus;
  if(pxStreamBuffer == ((StreamBuffer_t1 *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 966u);

  uxSavedInterruptStatus = 0ul;
  if(!(pxStreamBuffer->xTaskWaitingToReceive == NULL))
  {
    xTaskGenericNotifyFromISR(pxStreamBuffer->xTaskWaitingToReceive, 0u, /*enum*/eNoAction, ((uint32_t *)NULL), pxHigherPriorityTaskWoken);
    pxStreamBuffer->xTaskWaitingToReceive = NULL;
    xReturn = 1;
  }

  else
    xReturn = 0;
  (void)uxSavedInterruptStatus;
  return xReturn;
}

// xStreamBufferSendFromISR
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 588
size_t xStreamBufferSendFromISR(StreamBufferHandle_t xStreamBuffer, const void *pvTxData, size_t xDataLengthBytes, BaseType_t * const pxHigherPriorityTaskWoken)
{
  StreamBuffer_t1 *  pxStreamBuffer=(StreamBuffer_t1 *)xStreamBuffer;
  size_t xReturn;
  size_t xSpace;
  size_t xRequiredSpace=xDataLengthBytes;
  if(pvTxData == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 597u);

  if(pxStreamBuffer == ((StreamBuffer_t1 *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 598u);

  if(!((1 & (signed int)pxStreamBuffer->ucFlags) == 0))
    xRequiredSpace = xRequiredSpace + sizeof(size_t) /*8ull*/ ;

  xSpace=xStreamBufferSpacesAvailable((StreamBufferHandle_t)pxStreamBuffer);
  xReturn=prvWriteMessageToBuffer(pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace);
  if(xReturn >= 1ull)
  {
    size_t return_value_prvBytesInBuffer=prvBytesInBuffer(pxStreamBuffer);
    if(return_value_prvBytesInBuffer >= pxStreamBuffer->xTriggerLevelBytes)
    {
      UBaseType_t uxSavedInterruptStatus=0ul;
      if(!(pxStreamBuffer->xTaskWaitingToReceive == NULL))
      {
        xTaskGenericNotifyFromISR(pxStreamBuffer->xTaskWaitingToReceive, 0u, /*enum*/eNoAction, ((uint32_t *)NULL), pxHigherPriorityTaskWoken);
        pxStreamBuffer->xTaskWaitingToReceive = NULL;
      }

      (void)uxSavedInterruptStatus;
    }

  }

  return xReturn;
}

// xStreamBufferSetTriggerLevel
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 422
BaseType_t xStreamBufferSetTriggerLevel(StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel)
{
  StreamBuffer_t1 *  pxStreamBuffer=(StreamBuffer_t1 *)xStreamBuffer;
  BaseType_t xReturn;
  if(pxStreamBuffer == ((StreamBuffer_t1 *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 427u);

  if(xTriggerLevel == 0ull)
    xTriggerLevel = 1ull;

  if(pxStreamBuffer->xLength >= xTriggerLevel)
  {
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    xReturn = 1;
  }

  else
    xReturn = 0;
  return xReturn;
}

// xStreamBufferSpacesAvailable
// file ..\..\..\..\lib\FreeRTOS\stream_buffer.c line 451
size_t xStreamBufferSpacesAvailable(StreamBufferHandle_t xStreamBuffer)
{
   StreamBuffer_t1 *  pxStreamBuffer=(StreamBuffer_t1 *)xStreamBuffer;
  size_t xSpace;
  if(pxStreamBuffer == (( StreamBuffer_t1 *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\stream_buffer.c", 456u);

  xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
  xSpace = xSpace - pxStreamBuffer->xHead;
  xSpace = xSpace - 1ull;
  if(xSpace >= pxStreamBuffer->xLength)
    xSpace = xSpace - pxStreamBuffer->xLength;

  return xSpace;
}

// xTCPCheckNewClient
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 3280
BaseType_t xTCPCheckNewClient(FreeRTOS_Socket_t *pxSocket)
{
  TickType_t xLocalPort=(TickType_t)(uint16_t)((signed int)pxSocket->usLocalPort << 8u | (signed int)pxSocket->usLocalPort >> 8u);
  ListItem_t *pxIterator;
  FreeRTOS_Socket_t *pxFound;
  BaseType_t xResult=0;
  pxIterator = (ListItem_t *)(&xBoundTCPSocketsList)->xListEnd.pxNext;
  for( ; !(pxIterator == (const ListItem_t *)&(&xBoundTCPSocketsList)->xListEnd); pxIterator = (ListItem_t *)pxIterator->pxNext)
    if(pxIterator->xItemValue == xLocalPort)
    {
      pxFound = (FreeRTOS_Socket_t *)pxIterator->pvOwner;
      if((signed int)pxFound->ucProtocol == 6)
      {
        if(!((unsigned int)pxFound->u.xTCP.bits.bPassAccept == 0u))
        {
          pxSocket->u.xTCP.pxPeerSocket = pxFound;
          while((_Bool)0)
            ;
          xResult = 1;
          break;
        }

      }

    }

  return xResult;
}

// xTCPSocketCheck
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_IP.c line 466
BaseType_t xTCPSocketCheck(FreeRTOS_Socket_t *pxSocket)
{
  BaseType_t xResult=0;
  BaseType_t xReady=0;
  if((signed int)pxSocket->u.xTCP.ucTCPState >= 5)
  {
    if(!(pxSocket->u.xTCP.txStream == ((const StreamBuffer_t *)NULL)))
      prvTCPAddTxData(pxSocket);

  }

  if(!(pxSocket->u.xTCP.pxAckMessage == ((NetworkBufferDescriptor_t *)NULL)))
  {
    if((unsigned int)pxSocket->u.xTCP.bits.bUserShutdown == 0u)
    {
      if(!((signed int)pxSocket->u.xTCP.ucTCPState == 0))
      {
        if(xTCPWindowLoggingLevel >= 2)
        {
          if(!((unsigned int)pxSocket->usLocalPort == 23u))
            while((_Bool)0)
              ;

        }

        prvTCPReturnPacket(pxSocket, pxSocket->u.xTCP.pxAckMessage, 20u + 20u, 0);
      }

      TickType_t return_value_prvTCPNextTimeout=prvTCPNextTimeout(pxSocket);
      if(return_value_prvTCPNextTimeout >= 2u)
        xReady = 1;

    }

    if(!(pxSocket->u.xTCP.pxAckMessage == ((NetworkBufferDescriptor_t *)NULL)))
    {
      vReleaseNetworkBufferAndDescriptor(pxSocket->u.xTCP.pxAckMessage);
      pxSocket->u.xTCP.pxAckMessage = ((NetworkBufferDescriptor_t *)NULL);
    }

  }

  if(xReady == 0)
  {
    _Bool tmp_if_expr;
    if((signed int)pxSocket->u.xTCP.ucTCPState >= 5)
      tmp_if_expr = (_Bool)1;

    else
      tmp_if_expr = (signed int)pxSocket->u.xTCP.ucTCPState == 2 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr)
      prvTCPSendPacket(pxSocket);

    prvTCPNextTimeout(pxSocket);
    xResult=prvTCPStatusAgeCheck(pxSocket);
  }

  return xResult;
}

// xTCPTimerCheck
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_Sockets.c line 2734
TickType_t xTCPTimerCheck(BaseType_t xWillSleep)
{
  FreeRTOS_Socket_t *pxSocket;
  TickType_t xShortest=(TickType_t)((1000u * 1000u) / 1000u);
  TickType_t xNow=xTaskGetTickCount();
  static TickType_t xLastTime=0u;
  TickType_t xDelta=xNow - xLastTime;
  ListItem_t *xTCPTimerCheck$$1$$pxEnd=(const ListItem_t *)&(&xBoundTCPSocketsList)->xListEnd;
  ListItem_t *pxIterator=(ListItem_t *)(&xBoundTCPSocketsList)->xListEnd.pxNext;
  xLastTime = xNow;
  if(xDelta == 0u)
    xDelta = 1u;

  while(!(pxIterator == xTCPTimerCheck$$1$$pxEnd))
  {
    pxSocket = (FreeRTOS_Socket_t *)pxIterator->pvOwner;
    pxIterator = (ListItem_t *)pxIterator->pxNext;
    if(!((unsigned int)pxSocket->u.xTCP.usTimeout == 0u))
    {
      if(!(xDelta >= (TickType_t)pxSocket->u.xTCP.usTimeout))
        pxSocket->u.xTCP.usTimeout = (uint16_t)((TickType_t)pxSocket->u.xTCP.usTimeout - xDelta);

      else
      {
        signed int rc;
        pxSocket->u.xTCP.usTimeout = 0;
        rc=xTCPSocketCheck(pxSocket);
        if(!(rc >= 0))
          continue;

      }
      if(!(pxSocket->xEventBits == 0u))
      {
        if(!(xWillSleep == 0))
          vSocketWakeUpUser(pxSocket);

        else
          xShortest = 0u;
      }

      if(!((unsigned int)pxSocket->u.xTCP.usTimeout == 0u))
      {
        if(!((TickType_t)pxSocket->u.xTCP.usTimeout >= xShortest))
          xShortest = (TickType_t)pxSocket->u.xTCP.usTimeout;

      }

    }

  }
  return xShortest;
}

// xTCPWindowGetHead
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 473
static TCPSegment_t * xTCPWindowGetHead(List_t *pxList)
{
  TCPSegment_t *pxSegment;
  ListItem_t *pxItem;
  if(pxList->uxNumberOfItems == 0ul)
    pxSegment = ((TCPSegment_t *)NULL);

  else
  {
    pxItem = (ListItem_t *)pxList->xListEnd.pxNext;
    pxSegment = (TCPSegment_t *)pxItem->pvOwner;
    uxListRemove(pxItem);
  }
  return pxSegment;
}

// xTCPWindowNew
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 378
static TCPSegment_t * xTCPWindowNew(TCPWindow_t *pxWindow, uint32_t ulSequenceNumber, int32_t lCount, BaseType_t xIsForRx)
{
  TCPSegment_t *pxSegment;
  ListItem_t *pxItem;
  if(xSegmentList.uxNumberOfItems == 0ul)
  {
    while((_Bool)0)
      ;
    pxSegment = ((TCPSegment_t *)NULL);
  }

  else
  {
    pxItem = (ListItem_t *)(&xSegmentList)->xListEnd.pxNext;
    pxSegment = (TCPSegment_t *)pxItem->pvOwner;
    if(pxItem == ((ListItem_t *)NULL))
      vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS-Plus-TCP\\source\\FreeRTOS_TCP_WIN.c", 399u);

    if(pxSegment == ((TCPSegment_t *)NULL))
      vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS-Plus-TCP\\source\\FreeRTOS_TCP_WIN.c", 400u);

    uxListRemove(pxItem);
    List_t *tmp_if_expr;
    if(!(xIsForRx == 0l))
      tmp_if_expr = &pxWindow->xRxSegments;

    else
      tmp_if_expr = &pxWindow->xTxSegments;
    vListInsertFifo(tmp_if_expr, pxItem);
    vTCPTimerSet(&pxSegment->xTransmitTimer);
    pxSegment->u.ulFlags = 0u;
    pxSegment->u.bits.bIsForRx = (uint32_t)(xIsForRx != 0);
    pxSegment->lMaxLength = lCount;
    pxSegment->lDataLength = lCount;
    pxSegment->ulSequenceNumber = ulSequenceNumber;
  }
  return pxSegment;
}

// xTCPWindowPeekHead
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 499
static TCPSegment_t * xTCPWindowPeekHead(List_t *pxList)
{
  ListItem_t *pxItem;
  TCPSegment_t *pxReturn;
  if(pxList->uxNumberOfItems == 0ul)
    pxReturn = ((TCPSegment_t *)NULL);

  else
  {
    pxItem = (ListItem_t *)pxList->xListEnd.pxNext;
    pxReturn = (TCPSegment_t *)pxItem->pvOwner;
  }
  return pxReturn;
}

// xTCPWindowRxConfirm
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 693
static TCPSegment_t * xTCPWindowRxConfirm(TCPWindow_t *pxWindow, uint32_t ulSequenceNumber, uint32_t ulLength)
{
  TCPSegment_t *pxBest=((TCPSegment_t *)NULL);
  const ListItem_t *pxIterator;
  uint32_t ulNextSequenceNumber=ulSequenceNumber + ulLength;
  const MiniListItem_t *xTCPWindowRxConfirm$$1$$pxEnd=(const MiniListItem_t *)(const ListItem_t *)&(&pxWindow->xRxSegments)->xListEnd;
  TCPSegment_t *pxSegment;
  pxIterator = (const ListItem_t *)xTCPWindowRxConfirm$$1$$pxEnd->pxNext;
  BaseType_t return_value_xSequenceLessThan$0;
  BaseType_t return_value_xSequenceLessThan;
  for( ; !(pxIterator == (const ListItem_t *)xTCPWindowRxConfirm$$1$$pxEnd); pxIterator = (const ListItem_t *)pxIterator->pxNext)
  {
    pxSegment = (TCPSegment_t *)pxIterator->pvOwner;
    BaseType_t return_value_xSequenceGreaterThanOrEqual=xSequenceGreaterThanOrEqual(pxSegment->ulSequenceNumber, ulSequenceNumber);
    if(!(return_value_xSequenceGreaterThanOrEqual == 0))
    {
      return_value_xSequenceLessThan$0=xSequenceLessThan(pxSegment->ulSequenceNumber, ulNextSequenceNumber);
      if(!(return_value_xSequenceLessThan$0 == 0))
      {
        _Bool tmp_if_expr;
        if(pxBest == ((TCPSegment_t *)NULL))
          tmp_if_expr = (_Bool)1;

        else
        {
          return_value_xSequenceLessThan=xSequenceLessThan(pxSegment->ulSequenceNumber, pxBest->ulSequenceNumber);
          tmp_if_expr = return_value_xSequenceLessThan != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr)
          pxBest = pxSegment;

      }

    }

  }
  _Bool tmp_if_expr$0;
  if(!(pxBest == ((TCPSegment_t *)NULL)))
  {
    if(!(pxBest->ulSequenceNumber == ulSequenceNumber))
      tmp_if_expr$0 = (_Bool)1;

    else
      tmp_if_expr$0 = pxBest->lDataLength != (int32_t)ulLength ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$0)
    {
      while((_Bool)0)
        ;
      while((_Bool)0)
        ;
    }

  }

  return pxBest;
}

// xTCPWindowRxEmpty
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 437
BaseType_t xTCPWindowRxEmpty(TCPWindow_t *pxWindow)
{
  BaseType_t xReturn;
  BaseType_t return_value_xSequenceGreaterThanOrEqual;
  if(!(pxWindow->xRxSegments.uxNumberOfItems == 0ul))
    xReturn = 0;

  else
  {
    return_value_xSequenceGreaterThanOrEqual=xSequenceGreaterThanOrEqual(pxWindow->rx.ulCurrentSequenceNumber, pxWindow->rx.ulHighestSequenceNumber);
    if(!(return_value_xSequenceGreaterThanOrEqual == 0))
      xReturn = 1;

    else
    {
      while((_Bool)0)
        ;
      xReturn = 0;
    }
  }
  return xReturn;
}

// xTCPWindowRxFind
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 346
static TCPSegment_t * xTCPWindowRxFind(TCPWindow_t *pxWindow, uint32_t ulSequenceNumber)
{
  const ListItem_t *pxIterator;
  const MiniListItem_t *xTCPWindowRxFind$$1$$pxEnd;
  TCPSegment_t *pxSegment;
  TCPSegment_t *pxReturn=((TCPSegment_t *)NULL);
  xTCPWindowRxFind$$1$$pxEnd = (const MiniListItem_t *)(const ListItem_t *)&(&pxWindow->xRxSegments)->xListEnd;
  pxIterator = (const ListItem_t *)xTCPWindowRxFind$$1$$pxEnd->pxNext;
  for( ; !(pxIterator == (const ListItem_t *)xTCPWindowRxFind$$1$$pxEnd); pxIterator = (const ListItem_t *)pxIterator->pxNext)
  {
    pxSegment = (TCPSegment_t *)pxIterator->pvOwner;
    if(pxSegment->ulSequenceNumber == ulSequenceNumber)
    {
      pxReturn = pxSegment;
      break;
    }

  }
  return pxReturn;
}

// xTCPWindowTxDone
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 1114
BaseType_t xTCPWindowTxDone(TCPWindow_t *pxWindow)
{
  return (BaseType_t)((&pxWindow->xTxSegments)->uxNumberOfItems == 0ul);
}

// xTCPWindowTxHasData
// file ..\..\..\..\lib\FreeRTOS-Plus-TCP\source\FreeRTOS_TCP_WIN.c line 1183
BaseType_t xTCPWindowTxHasData(TCPWindow_t *pxWindow, uint32_t ulWindowSize, TickType_t *pulDelay)
{
  TCPSegment_t *pxSegment;
  BaseType_t xReturn;
  TickType_t ulAge;
  TickType_t ulMaxAge;
  *pulDelay = 0u;
  BaseType_t return_value_prvTCPWindowTxHasSpace;
  _Bool tmp_if_expr;
  if(!(pxWindow->xPriorityQueue.uxNumberOfItems == 0ul))
    xReturn = 1;

  else
  {
    pxSegment=xTCPWindowPeekHead(&pxWindow->xWaitQueue);
    if(!(pxSegment == ((TCPSegment_t *)NULL)))
    {
      ulAge=ulTimerGetAge(&pxSegment->xTransmitTimer);
      ulMaxAge = (1u << (signed int)pxSegment->u.bits.ucTransmitCount) * (uint32_t)pxWindow->lSRTT;
      if(!(ulAge >= ulMaxAge))
        *pulDelay = ulMaxAge - ulAge;

      xReturn = 1;
    }

    else
    {
      pxSegment=xTCPWindowPeekHead(&pxWindow->xTxQueue);
      if(pxSegment == ((TCPSegment_t *)NULL))
        xReturn = 0;

      else
      {
        return_value_prvTCPWindowTxHasSpace=prvTCPWindowTxHasSpace(pxWindow, ulWindowSize);
        if(return_value_prvTCPWindowTxHasSpace == 0)
          xReturn = 0;

        else
        {
          if(!((unsigned int)pxWindow->u.bits.bSendFullSize == 0u))
            tmp_if_expr = pxSegment->lDataLength < pxSegment->lMaxLength ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr = (_Bool)0;
          if(tmp_if_expr)
            xReturn = 0;

          else
            xReturn = 1;
        }
      }
    }
  }
  return xReturn;
}

// xTaskAbortDelay
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 2572
BaseType_t xTaskAbortDelay(TaskHandle_t xTask)
{
  TCB_t *pxTCB=(TCB_t *)xTask;
  BaseType_t xReturn;
  if(pxTCB == ((TCB_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 2577u);

  vTaskSuspendAll();
  eTaskState return_value_eTaskGetState=eTaskGetState(xTask);
  if((signed int)return_value_eTaskGetState == 2)
  {
    xReturn = 1;
    uxListRemove(&pxTCB->xStateListItem);
    vPortEnterCritical();
    if(!(pxTCB->xEventListItem.pvContainer == NULL))
    {
      uxListRemove(&pxTCB->xEventListItem);
      pxTCB->ucDelayAborted = 1;
    }

    vPortExitCritical();
    traceHandle return_value_prvTraceGetTaskNumber=prvTraceGetTaskNumber((void *)pxTCB);
    prvTraceStoreTaskReady(return_value_prvTraceGetTaskNumber);
    uxTopReadyPriority = uxTopReadyPriority | 1ul << pxTCB->uxPriority;
    vListInsertEnd(&pxReadyTasksLists[(signed long long int)pxTCB->uxPriority], &pxTCB->xStateListItem);
    if(!(pxCurrentTCB->uxPriority >= pxTCB->uxPriority))
      xYieldPending = 1;

  }

  else
    xReturn = 0;
  xTaskResumeAll();
  return xReturn;
}

// xTaskCheckForTimeOut
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3177
BaseType_t xTaskCheckForTimeOut(TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait)
{
  BaseType_t xReturn;
  if(pxTimeOut == ((TimeOut_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 3181u);

  if(pxTicksToWait == ((TickType_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 3182u);

  vPortEnterCritical();
  const TickType_t xConstTickCount=xTickCount;
  const TickType_t xElapsedTime=xConstTickCount - pxTimeOut->xTimeOnEntering;
  _Bool tmp_if_expr;
  if(!((signed int)pxCurrentTCB->ucDelayAborted == 0))
  {
    pxCurrentTCB->ucDelayAborted = 0;
    xReturn = 1;
  }

  else
    if(*pxTicksToWait == 0xFFFFFFFFul)
      xReturn = 0;

    else
    {
      if(!(xNumOfOverflows == pxTimeOut->xOverflowCount))
        tmp_if_expr = xConstTickCount >= pxTimeOut->xTimeOnEntering ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr = (_Bool)0;
      if(tmp_if_expr)
        xReturn = 1;

      else
        if(!(xElapsedTime >= *pxTicksToWait))
        {
          *pxTicksToWait = *pxTicksToWait - xElapsedTime;
          vTaskInternalSetTimeOutState(pxTimeOut);
          xReturn = 0;
        }

        else
        {
          *pxTicksToWait = 0u;
          xReturn = 1;
        }
    }
  vPortExitCritical();
  return xReturn;
}

// xTaskCreate
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 743
BaseType_t xTaskCreate(TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask)
{
  TCB_t *pxNewTCB;
  BaseType_t xReturn;
  StackType_t *pxStack;
  void *return_value_pvPortMalloc=pvPortMalloc((size_t)usStackDepth * sizeof(StackType_t) /*8ull*/ );
  pxStack = (StackType_t *)return_value_pvPortMalloc;
  if(!(pxStack == ((StackType_t *)NULL)))
  {
    void *return_value_pvPortMalloc$0=pvPortMalloc(sizeof(TCB_t) /*184ull*/ );
    pxNewTCB = (TCB_t *)return_value_pvPortMalloc$0;
    if(!(pxNewTCB == ((TCB_t *)NULL)))
      pxNewTCB->pxStack = pxStack;

    else
      vPortFree((void *)pxStack);
  }

  else
    pxNewTCB = ((TCB_t *)NULL);
  if(!(pxNewTCB == ((TCB_t *)NULL)))
  {
    pxNewTCB->ucStaticallyAllocated = 0;
    prvInitialiseNewTask(pxTaskCode, pcName, (uint32_t)usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, ((const MemoryRegion_t *)NULL));
    prvAddNewTaskToReadyList(pxNewTCB);
    xReturn = 1;
  }

  else
    xReturn = -1;
  return xReturn;
}

// xTaskCreateStatic
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 592
TaskHandle_t xTaskCreateStatic(TaskFunction_t pxTaskCode, const char * const pcName, const uint32_t ulStackDepth, void * const pvParameters, UBaseType_t uxPriority, StackType_t * const puxStackBuffer, StaticTask_t * const pxTaskBuffer)
{
  TCB_t *pxNewTCB;
  TaskHandle_t xReturn;
  if(puxStackBuffer == ((StackType_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 603u);

  if(pxTaskBuffer == ((StaticTask_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 604u);

  volatile size_t xSize=sizeof(StaticTask_t) /*184ull*/ ;
  if(!(xSize == sizeof(TCB_t) /*184ull*/ ))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 612u);

  if(!(pxTaskBuffer == ((StaticTask_t *)NULL)) && !(puxStackBuffer == ((StackType_t *)NULL)))
  {
    pxNewTCB = (TCB_t *)pxTaskBuffer;
    pxNewTCB->pxStack = (StackType_t *)puxStackBuffer;
    pxNewTCB->ucStaticallyAllocated = 2;
    prvInitialiseNewTask(pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, ((const MemoryRegion_t *)NULL));
    prvAddNewTaskToReadyList(pxNewTCB);
  }

  else
    xReturn = NULL;
  return xReturn;
}

// xTaskGenericNotify
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 4634
BaseType_t xTaskGenericNotify(TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue)
{
  TCB_t *pxTCB;
  BaseType_t xReturn=1;
  uint8_t ucOriginalNotifyState;
  if(xTaskToNotify == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 4640u);

  pxTCB = (TCB_t *)xTaskToNotify;
  vPortEnterCritical();
  if(!(pulPreviousNotificationValue == ((uint32_t *)NULL)))
    *pulPreviousNotificationValue = pxTCB->ulNotifiedValue;

  ucOriginalNotifyState = pxTCB->ucNotifyState;
  pxTCB->ucNotifyState = 2;
  switch((signed int)eAction)
  {
    case 1:
    {
      pxTCB->ulNotifiedValue = pxTCB->ulNotifiedValue | ulValue;
      break;
    }
    case 2:
    {
      pxTCB->ulNotifiedValue = pxTCB->ulNotifiedValue + 1u;
      break;
    }
    case 3:
    {
      pxTCB->ulNotifiedValue = ulValue;
      break;
    }
    case 4:
    {
      if(!(ucOriginalNotifyState == 2))
        pxTCB->ulNotifiedValue = ulValue;

      else
        xReturn = 0;
      break;
    }
    case 0:
      ;
  }
  UBaseType_t return_value_uxTaskGetTaskNumber=uxTaskGetTaskNumber(xTaskToNotify);
  prvTraceStoreKernelCall(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + 18ul + 16ul + 0ul, 3, return_value_uxTaskGetTaskNumber);
  if(ucOriginalNotifyState == 1)
  {
    uxListRemove(&pxTCB->xStateListItem);
    traceHandle return_value_prvTraceGetTaskNumber=prvTraceGetTaskNumber((void *)pxTCB);
    prvTraceStoreTaskReady(return_value_prvTraceGetTaskNumber);
    uxTopReadyPriority = uxTopReadyPriority | 1ul << pxTCB->uxPriority;
    vListInsertEnd(&pxReadyTasksLists[(signed long long int)pxTCB->uxPriority], &pxTCB->xStateListItem);
    if(!(pxTCB->xEventListItem.pvContainer == NULL))
      vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 4696u);

    if(!(pxCurrentTCB->uxPriority >= pxTCB->uxPriority))
      vPortGenerateSimulatedInterrupt(0ul);

  }

  vPortExitCritical();
  return xReturn;
}

// xTaskGenericNotifyFromISR
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 4740
BaseType_t xTaskGenericNotifyFromISR(TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken)
{
  TCB_t *pxTCB;
  uint8_t ucOriginalNotifyState;
  BaseType_t xReturn=1;
  UBaseType_t uxSavedInterruptStatus;
  if(xTaskToNotify == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 4747u);

  pxTCB = (TCB_t *)xTaskToNotify;
  uxSavedInterruptStatus = 0ul;
  if(!(pulPreviousNotificationValue == ((uint32_t *)NULL)))
    *pulPreviousNotificationValue = pxTCB->ulNotifiedValue;

  ucOriginalNotifyState = pxTCB->ucNotifyState;
  pxTCB->ucNotifyState = 2;
  switch((signed int)eAction)
  {
    case 1:
    {
      pxTCB->ulNotifiedValue = pxTCB->ulNotifiedValue | ulValue;
      break;
    }
    case 2:
    {
      pxTCB->ulNotifiedValue = pxTCB->ulNotifiedValue + 1u;
      break;
    }
    case 3:
    {
      pxTCB->ulNotifiedValue = ulValue;
      break;
    }
    case 4:
    {
      if(!(ucOriginalNotifyState == 2))
        pxTCB->ulNotifiedValue = ulValue;

      else
        xReturn = 0;
      break;
    }
    case 0:
      ;
  }
  UBaseType_t return_value_uxTaskGetTaskNumber=uxTaskGetTaskNumber(xTaskToNotify);
  prvTraceStoreKernelCall(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + 18ul + 16ul + 7ul, 3, return_value_uxTaskGetTaskNumber);
  if(ucOriginalNotifyState == 1)
  {
    if(!(pxTCB->xEventListItem.pvContainer == NULL))
      vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 4818u);

    if(uxSchedulerSuspended == 0ul)
    {
      uxListRemove(&pxTCB->xStateListItem);
      traceHandle return_value_prvTraceGetTaskNumber=prvTraceGetTaskNumber((void *)pxTCB);
      prvTraceStoreTaskReady(return_value_prvTraceGetTaskNumber);
      uxTopReadyPriority = uxTopReadyPriority | 1ul << pxTCB->uxPriority;
      vListInsertEnd(&pxReadyTasksLists[(signed long long int)pxTCB->uxPriority], &pxTCB->xStateListItem);
    }

    else
      vListInsertEnd(&xPendingReadyList, &pxTCB->xEventListItem);
    if(!(pxCurrentTCB->uxPriority >= pxTCB->uxPriority))
    {
      if(!(pxHigherPriorityTaskWoken == ((BaseType_t *)NULL)))
        *pxHigherPriorityTaskWoken = 1;

      else
        xYieldPending = 1;
    }

  }

  (void)uxSavedInterruptStatus;
  return xReturn;
}

// xTaskGetCurrentTaskHandle
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3827
TaskHandle_t xTaskGetCurrentTaskHandle(void)
{
  TaskHandle_t xReturn=(TaskHandle_t)pxCurrentTCB;
  return xReturn;
}

// xTaskGetIdleTickCount
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 2241
TickType_t xTaskGetIdleTickCount(void)
{
  TickType_t xTicks;
  xTicks = xIdleTickCount;
  return xTicks;
}

// xTaskGetIdleTickCountFromISR
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 2287
TickType_t xTaskGetIdleTickCountFromISR(void)
{
  TickType_t xReturn;
  UBaseType_t uxSavedInterruptStatus;
  uxSavedInterruptStatus = 0ul;
  xReturn = xIdleTickCount;
  (void)uxSavedInterruptStatus;
  return xReturn;
}

// xTaskGetSchedulerState
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3844
BaseType_t xTaskGetSchedulerState(void)
{
  BaseType_t xReturn;
  if(xSchedulerRunning == 0)
    xReturn = 1;

  else
    if(uxSchedulerSuspended == 0ul)
      xReturn = 2;

    else
      xReturn = 0;
  return xReturn;
}

// xTaskGetTickCount
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 2226
TickType_t xTaskGetTickCount(void)
{
  TickType_t xTicks;
  xTicks = xTickCount;
  return xTicks;
}

// xTaskGetTickCountFromISR
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 2256
TickType_t xTaskGetTickCountFromISR(void)
{
  TickType_t xReturn;
  UBaseType_t uxSavedInterruptStatus;
  uxSavedInterruptStatus = 0ul;
  xReturn = xTickCount;
  (void)uxSavedInterruptStatus;
  return xReturn;
}

// xTaskIncrementTick
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 2646
BaseType_t xTaskIncrementTick(void)
{
  TCB_t *pxTCB;
  TickType_t xItemValue;
  BaseType_t xSwitchRequired=0;
  if(uxPendedTicks == 0u || uxSchedulerSuspended == 1ul)
  {
    uiTraceTickCount = uiTraceTickCount + 1u;
    prvTracePortGetTimeStamp(((uint32_t *)NULL));
  }

  if(uxSchedulerSuspended == 0ul)
    prvTraceStoreKernelCallWithNumericParamOnly(0x0ul + 1ul + 2ul, xTickCount + 1u);

  if(uxSchedulerSuspended == 0ul)
  {
    const TickType_t xConstTickCount=xTickCount + 1u;
    xTickCount = xConstTickCount;
    if(xConstTickCount == 0u)
    {
      List_t *pxTemp;
      if(!(pxDelayedTaskList->uxNumberOfItems == 0ul))
        vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 2668u);

      pxTemp = pxDelayedTaskList;
      pxDelayedTaskList = pxOverflowDelayedTaskList;
      pxOverflowDelayedTaskList = pxTemp;
      xNumOfOverflows = xNumOfOverflows + 1l;
      prvResetNextTaskUnblockTime();
    }

    if(xConstTickCount >= xNextTaskUnblockTime)
      while((_Bool)1)
        if(pxDelayedTaskList->uxNumberOfItems == 0ul)
        {
          xNextTaskUnblockTime = 0xFFFFFFFFul;
          break;
        }

        else
        {
          pxTCB = (TCB_t *)(&pxDelayedTaskList->xListEnd)->pxNext->pvOwner;
          xItemValue = (&pxTCB->xStateListItem)->xItemValue;
          if(!(xConstTickCount >= xItemValue))
          {
            xNextTaskUnblockTime = xItemValue;
            break;
          }

          uxListRemove(&pxTCB->xStateListItem);
          if(!(pxTCB->xEventListItem.pvContainer == NULL))
            uxListRemove(&pxTCB->xEventListItem);

          traceHandle return_value_prvTraceGetTaskNumber=prvTraceGetTaskNumber((void *)pxTCB);
          prvTraceStoreTaskReady(return_value_prvTraceGetTaskNumber);
          uxTopReadyPriority = uxTopReadyPriority | 1ul << pxTCB->uxPriority;
          vListInsertEnd(&pxReadyTasksLists[(signed long long int)pxTCB->uxPriority], &pxTCB->xStateListItem);
          if(pxTCB->uxPriority >= pxCurrentTCB->uxPriority)
            xSwitchRequired = 1;

        }

    if(pxReadyTasksLists[(signed long long int)pxCurrentTCB->uxPriority].uxNumberOfItems >= 2ul)
      xSwitchRequired = 1;

  }

  else
    uxPendedTicks = uxPendedTicks + 1ul;
  if(!(xYieldPending == 0))
    xSwitchRequired = 1;

  return xSwitchRequired;
}

// xTaskNotifyStateClear
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 4953
BaseType_t xTaskNotifyStateClear(TaskHandle_t xTask)
{
  TCB_t *pxTCB;
  BaseType_t xReturn;
  pxTCB = xTask == NULL ? (TCB_t *)pxCurrentTCB : (TCB_t *)xTask;
  vPortEnterCritical();
  if(pxTCB->ucNotifyState == 2)
  {
    pxTCB->ucNotifyState = 0;
    xReturn = 1;
  }

  else
    xReturn = 0;
  vPortExitCritical();
  return xReturn;
}

// xTaskNotifyWait
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 4554
BaseType_t xTaskNotifyWait(uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait)
{
  BaseType_t xReturn;
  vPortEnterCritical();
  if(!(pxCurrentTCB->ucNotifyState == 2))
  {
    pxCurrentTCB->ulNotifiedValue = pxCurrentTCB->ulNotifiedValue & ~ulBitsToClearOnEntry;
    pxCurrentTCB->ucNotifyState = 1;
    if(xTicksToWait >= 1u)
    {
      prvAddCurrentTaskToDelayedList(xTicksToWait, 1);
      UBaseType_t return_value_uxTaskGetTaskNumber=uxTaskGetTaskNumber((TaskHandle_t)pxCurrentTCB);
      prvTraceStoreKernelCallWithParam(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + 18ul + 16ul + 5ul, 3, return_value_uxTaskGetTaskNumber, xTicksToWait);
      void *return_value_prvTraceGetCurrentTaskHandle=prvTraceGetCurrentTaskHandle();
      traceHandle return_value_prvTraceGetTaskNumber=prvTraceGetTaskNumber(return_value_prvTraceGetCurrentTaskHandle);
      prvTraceSetTaskInstanceFinished(return_value_prvTraceGetTaskNumber);
      vPortGenerateSimulatedInterrupt(0ul);
    }

  }

  vPortExitCritical();
  vPortEnterCritical();
  if(pxCurrentTCB->ucNotifyState == 2)
  {
    UBaseType_t return_value_uxTaskGetTaskNumber$0=uxTaskGetTaskNumber((TaskHandle_t)pxCurrentTCB);
    prvTraceStoreKernelCallWithParam(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + 18ul + 16ul + 4ul, 3, return_value_uxTaskGetTaskNumber$0, xTicksToWait);
  }

  else
  {
    UBaseType_t return_value_uxTaskGetTaskNumber$1=uxTaskGetTaskNumber((TaskHandle_t)pxCurrentTCB);
    prvTraceStoreKernelCallWithParam(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + 18ul + 16ul + 6ul, 3, return_value_uxTaskGetTaskNumber$1, xTicksToWait);
  }
  if(!(pulNotificationValue == ((uint32_t *)NULL)))
    *pulNotificationValue = pxCurrentTCB->ulNotifiedValue;

  if(!(pxCurrentTCB->ucNotifyState == 2))
    xReturn = 0;

  else
  {
    pxCurrentTCB->ulNotifiedValue = pxCurrentTCB->ulNotifiedValue & ~ulBitsToClearOnExit;
    xReturn = 1;
  }
  pxCurrentTCB->ucNotifyState = 0;
  vPortExitCritical();
  return xReturn;
}

// xTaskPriorityDisinherit
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3959
BaseType_t xTaskPriorityDisinherit(const TaskHandle_t pxMutexHolder)
{
  TCB_t * const pxTCB=(TCB_t *)pxMutexHolder;
  BaseType_t xReturn=0;
  if(!(pxMutexHolder == NULL))
  {
    if(!(pxTCB == pxCurrentTCB))
      vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 3970u);

    if(pxTCB->uxMutexesHeld == 0u)
      vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 3971u);

    pxTCB->uxMutexesHeld = pxTCB->uxMutexesHeld - 1ul;
    if(!(pxTCB->uxPriority == pxTCB->uxBasePriority))
    {
      if(pxTCB->uxMutexesHeld == 0ul)
      {
        UBaseType_t return_value_uxListRemove=uxListRemove(&pxTCB->xStateListItem);
        if(return_value_uxListRemove == 0ul)
        {
          if(pxReadyTasksLists[(signed long long int)pxTCB->uxPriority].uxNumberOfItems == 0ul)
            uxTopReadyPriority = uxTopReadyPriority & ~(1ul << pxTCB->uxPriority);

        }

        traceHandle return_value_prvTraceGetTaskNumber=prvTraceGetTaskNumber((void *)pxTCB);
        traceHandle return_value_prvTraceGetTaskNumber$0=prvTraceGetTaskNumber((void *)pxTCB);
        uint8_t return_value_prvTraceGetPriorityProperty=prvTraceGetPriorityProperty(3, return_value_prvTraceGetTaskNumber$0);
        prvTraceStoreKernelCallWithParam(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 7ul, 3, (uint32_t)return_value_prvTraceGetTaskNumber, (uint32_t)return_value_prvTraceGetPriorityProperty);
        traceHandle return_value_prvTraceGetTaskNumber$1=prvTraceGetTaskNumber((void *)pxTCB);
        prvTraceSetPriorityProperty(3, return_value_prvTraceGetTaskNumber$1, (uint8_t)pxTCB->uxBasePriority);
        pxTCB->uxPriority = pxTCB->uxBasePriority;
        (&pxTCB->xEventListItem)->xItemValue = 7u - (TickType_t)pxTCB->uxPriority;
        traceHandle return_value_prvTraceGetTaskNumber$2=prvTraceGetTaskNumber((void *)pxTCB);
        prvTraceStoreTaskReady(return_value_prvTraceGetTaskNumber$2);
        uxTopReadyPriority = uxTopReadyPriority | 1ul << pxTCB->uxPriority;
        vListInsertEnd(&pxReadyTasksLists[(signed long long int)pxTCB->uxPriority], &pxTCB->xStateListItem);
        xReturn = 1;
      }

    }

  }

  return xReturn;
}

// xTaskPriorityInherit
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3872
BaseType_t xTaskPriorityInherit(const TaskHandle_t pxMutexHolder)
{
  TCB_t * const pxMutexHolderTCB=(TCB_t *)pxMutexHolder;
  BaseType_t xReturn=0;
  if(!(pxMutexHolder == NULL))
  {
    if(!(pxMutexHolderTCB->uxPriority >= pxCurrentTCB->uxPriority))
    {
      if((0x80000000ul & pxMutexHolderTCB->xEventListItem.xItemValue) == 0ul)
        (&pxMutexHolderTCB->xEventListItem)->xItemValue = 7u - (TickType_t)pxCurrentTCB->uxPriority;

      if(pxMutexHolderTCB->xStateListItem.pvContainer == (void *)(pxReadyTasksLists + (signed long long int)pxMutexHolderTCB->uxPriority))
      {
        UBaseType_t return_value_uxListRemove=uxListRemove(&pxMutexHolderTCB->xStateListItem);
        if(return_value_uxListRemove == 0ul)
        {
          if(pxReadyTasksLists[(signed long long int)pxMutexHolderTCB->uxPriority].uxNumberOfItems == 0ul)
            uxTopReadyPriority = uxTopReadyPriority & ~(1ul << pxMutexHolderTCB->uxPriority);

        }

        pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
        traceHandle return_value_prvTraceGetTaskNumber=prvTraceGetTaskNumber((void *)pxMutexHolderTCB);
        prvTraceStoreTaskReady(return_value_prvTraceGetTaskNumber);
        uxTopReadyPriority = uxTopReadyPriority | 1ul << pxMutexHolderTCB->uxPriority;
        vListInsertEnd(&pxReadyTasksLists[(signed long long int)pxMutexHolderTCB->uxPriority], &pxMutexHolderTCB->xStateListItem);
      }

      else
        pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
      traceHandle return_value_prvTraceGetTaskNumber$0=prvTraceGetTaskNumber((void *)pxMutexHolderTCB);
      traceHandle return_value_prvTraceGetTaskNumber$1=prvTraceGetTaskNumber((void *)pxMutexHolderTCB);
      uint8_t return_value_prvTraceGetPriorityProperty=prvTraceGetPriorityProperty(3, return_value_prvTraceGetTaskNumber$1);
      prvTraceStoreKernelCallWithParam(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 6ul, 3, (uint32_t)return_value_prvTraceGetTaskNumber$0, (uint32_t)return_value_prvTraceGetPriorityProperty);
      traceHandle return_value_prvTraceGetTaskNumber$2=prvTraceGetTaskNumber((void *)pxMutexHolderTCB);
      prvTraceSetPriorityProperty(3, return_value_prvTraceGetTaskNumber$2, (uint8_t)pxCurrentTCB->uxPriority);
      xReturn = 1;
    }

    else
      if(!(pxMutexHolderTCB->uxBasePriority >= pxCurrentTCB->uxPriority))
        xReturn = 1;

  }

  return xReturn;
}

// xTaskRemoveFromEventList
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 3055
BaseType_t xTaskRemoveFromEventList(const List_t * const pxEventList)
{
  TCB_t *pxUnblockedTCB;
  BaseType_t xReturn;
  pxUnblockedTCB = (TCB_t *)(&pxEventList->xListEnd)->pxNext->pvOwner;
  if(pxUnblockedTCB == ((TCB_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 3074u);

  uxListRemove(&pxUnblockedTCB->xEventListItem);
  if(uxSchedulerSuspended == 0ul)
  {
    uxListRemove(&pxUnblockedTCB->xStateListItem);
    traceHandle return_value_prvTraceGetTaskNumber=prvTraceGetTaskNumber((void *)pxUnblockedTCB);
    prvTraceStoreTaskReady(return_value_prvTraceGetTaskNumber);
    uxTopReadyPriority = uxTopReadyPriority | 1ul << pxUnblockedTCB->uxPriority;
    vListInsertEnd(&pxReadyTasksLists[(signed long long int)pxUnblockedTCB->uxPriority], &pxUnblockedTCB->xStateListItem);
  }

  else
    vListInsertEnd(&xPendingReadyList, &pxUnblockedTCB->xEventListItem);
  if(!(pxCurrentTCB->uxPriority >= pxUnblockedTCB->uxPriority))
  {
    xReturn = 1;
    xYieldPending = 1;
  }

  else
    xReturn = 0;
  return xReturn;
}

// xTaskResumeAll
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 2116
BaseType_t xTaskResumeAll(void)
{
  TCB_t *pxTCB=((TCB_t *)NULL);
  BaseType_t xAlreadyYielded=0;
  if(uxSchedulerSuspended == 0u)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 2123u);

  vPortEnterCritical();
  uxSchedulerSuspended = uxSchedulerSuspended - 1ul;
  if(uxSchedulerSuspended == 0ul)
  {
    if(uxCurrentNumberOfTasks >= 1u)
    {
      while(!(xPendingReadyList.uxNumberOfItems == 0ul))
      {
        pxTCB = (TCB_t *)(&(&xPendingReadyList)->xListEnd)->pxNext->pvOwner;
        uxListRemove(&pxTCB->xEventListItem);
        uxListRemove(&pxTCB->xStateListItem);
        traceHandle return_value_prvTraceGetTaskNumber=prvTraceGetTaskNumber((void *)pxTCB);
        prvTraceStoreTaskReady(return_value_prvTraceGetTaskNumber);
        uxTopReadyPriority = uxTopReadyPriority | 1ul << pxTCB->uxPriority;
        vListInsertEnd(&pxReadyTasksLists[(signed long long int)pxTCB->uxPriority], &pxTCB->xStateListItem);
        if(pxTCB->uxPriority >= pxCurrentTCB->uxPriority)
          xYieldPending = 1;

      }
      if(!(pxTCB == ((TCB_t *)NULL)))
        prvResetNextTaskUnblockTime();

      UBaseType_t uxPendedCounts=uxPendedTicks;
      if(uxPendedCounts >= 1u)
      {
        do
        {
          BaseType_t return_value_xTaskIncrementTick=xTaskIncrementTick();
          if(!(return_value_xTaskIncrementTick == 0))
            xYieldPending = 1;

          uxPendedCounts = uxPendedCounts - 1ul;
        }
        while(uxPendedCounts >= 1u);
        uxPendedTicks = 0ul;
      }

      if(!(xYieldPending == 0))
      {
        xAlreadyYielded = 1;
        vPortGenerateSimulatedInterrupt(0ul);
      }

    }

  }

  vPortExitCritical();
  return xAlreadyYielded;
}

// xTaskResumeFromISR
// file ..\..\..\..\lib\FreeRTOS\tasks.c line 1842
BaseType_t xTaskResumeFromISR(TaskHandle_t xTaskToResume)
{
  BaseType_t xYieldRequired=0;
  TCB_t * const pxTCB=(TCB_t *)xTaskToResume;
  UBaseType_t uxSavedInterruptStatus;
  if(xTaskToResume == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\tasks.c", 1848u);

  uxSavedInterruptStatus = 0ul;
  BaseType_t return_value_prvTaskIsTaskSuspended=prvTaskIsTaskSuspended((const TaskHandle_t)pxTCB);
  if(!(return_value_prvTaskIsTaskSuspended == 0))
  {
    traceHandle return_value_prvTraceGetTaskNumber=prvTraceGetTaskNumber((void *)pxTCB);
    prvTraceStoreKernelCall(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 4ul, 3, (uint32_t)return_value_prvTraceGetTaskNumber);
    if(uxSchedulerSuspended == 0ul)
    {
      if(pxTCB->uxPriority >= pxCurrentTCB->uxPriority)
        xYieldRequired = 1;

      uxListRemove(&pxTCB->xStateListItem);
      traceHandle return_value_prvTraceGetTaskNumber$0=prvTraceGetTaskNumber((void *)pxTCB);
      prvTraceStoreTaskReady(return_value_prvTraceGetTaskNumber$0);
      uxTopReadyPriority = uxTopReadyPriority | 1ul << pxTCB->uxPriority;
      vListInsertEnd(&pxReadyTasksLists[(signed long long int)pxTCB->uxPriority], &pxTCB->xStateListItem);
    }

    else
      vListInsertEnd(&xPendingReadyList, &pxTCB->xEventListItem);
  }

  (void)uxSavedInterruptStatus;
  return xYieldRequired;
}

// xTimerCreate
// file ..\..\..\..\lib\FreeRTOS\timers.c line 278
TimerHandle_t xTimerCreate(const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction)
{
  Timer_t *pxNewTimer;
  void *return_value_pvPortMalloc=pvPortMalloc(sizeof(Timer_t) /*80ull*/ );
  pxNewTimer = (Timer_t *)return_value_pvPortMalloc;
  if(!(pxNewTimer == ((Timer_t *)NULL)))
  {
    prvInitialiseNewTimer(pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer);
    pxNewTimer->ucStaticallyAllocated = 0;
  }

  return (TimerHandle_t)pxNewTimer;
}

// xTimerCreateStatic
// file ..\..\..\..\lib\FreeRTOS\timers.c line 310
TimerHandle_t xTimerCreateStatic(const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction, StaticTimer_t *pxTimerBuffer)
{
  Timer_t *pxNewTimer;
  volatile size_t xSize=sizeof(StaticTimer_t) /*80ull*/ ;
  if(!(xSize == sizeof(Timer_t) /*80ull*/ ))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\timers.c", 325u);

  if(pxTimerBuffer == ((StaticTimer_t *)NULL))
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\timers.c", 330u);

  pxNewTimer = (Timer_t *)pxTimerBuffer;
  if(!(pxNewTimer == ((Timer_t *)NULL)))
  {
    prvInitialiseNewTimer(pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer);
    pxNewTimer->ucStaticallyAllocated = 1;
  }

  return (TimerHandle_t)pxNewTimer;
}

// xTimerCreateTimerTask
// file ..\..\..\..\lib\FreeRTOS\timers.c line 223
BaseType_t xTimerCreateTimerTask(void)
{
  BaseType_t xReturn=0;
  prvCheckForValidListAndQueue();
  if(!(xTimerQueue == NULL))
  {
    StaticTask_t *pxTimerTaskTCBBuffer=((StaticTask_t *)NULL);
    StackType_t *pxTimerTaskStackBuffer=((StackType_t *)NULL);
    uint32_t ulTimerTaskStackSize;
    vApplicationGetTimerTaskMemory(&pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize);
    xTimerTaskHandle=xTaskCreateStatic(prvTimerTask, "Tmr Svc", ulTimerTaskStackSize, NULL, (UBaseType_t)(7 - 1) | 0ul, pxTimerTaskStackBuffer, pxTimerTaskTCBBuffer);
    if(!(xTimerTaskHandle == NULL))
      xReturn = 1;

  }

  if(xReturn == 0)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\timers.c", 271u);

  return xReturn;
}

// xTimerGenericCommand
// file ..\..\..\..\lib\FreeRTOS\timers.c line 381
BaseType_t xTimerGenericCommand(TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait)
{
  BaseType_t xReturn=0;
  DaemonTaskMessage_t xMessage;
  if(xTimer == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\timers.c", 386u);

  if(!(xTimerQueue == NULL))
  {
    xMessage.xMessageID = xCommandID;
    xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    xMessage.u.xTimerParameters.pxTimer = (Timer_t *)xTimer;
    if(!(xCommandID >= 6))
    {
      BaseType_t return_value_xTaskGetSchedulerState=xTaskGetSchedulerState();
      if(return_value_xTaskGetSchedulerState == 2)
        xReturn=xQueueGenericSend(xTimerQueue, (const void *)&xMessage, xTicksToWait, 0);

      else
        xReturn=xQueueGenericSend(xTimerQueue, (const void *)&xMessage, 0u, 0);
    }

    else
      xReturn=xQueueGenericSendFromISR(xTimerQueue, (const void *)&xMessage, pxHigherPriorityTaskWoken, 0);
    if(xCommandID >= 1)
    {
      if(xCommandID == 4)
      {
        signed int tmp_if_expr;
        if(!((uint32_t)xTimer == 0u))
          tmp_if_expr = (signed int)(traceHandle)((Timer_t *)xTimer)->uxTimerNumber;

        else
          tmp_if_expr = 0;
        prvTraceStoreKernelCallWithParam(xReturn == 1 ? 0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + 4ul : 0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + 13ul, 5, (uint32_t)tmp_if_expr, xOptionalValue);
      }

      else
        if(xReturn == 1 && xCommandID == 5)
        {
          signed int tmp_if_expr$0;
          if(!((uint32_t)xTimer == 0u))
            tmp_if_expr$0 = (signed int)(traceHandle)((Timer_t *)xTimer)->uxTimerNumber;

          else
            tmp_if_expr$0 = 0;
          prvTraceStoreKernelCall(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + 5ul, 5, (uint32_t)tmp_if_expr$0);
          signed int tmp_if_expr$1;
          if(!((uint32_t)xTimer == 0u))
            tmp_if_expr$1 = (signed int)(traceHandle)((Timer_t *)xTimer)->uxTimerNumber;

          else
            tmp_if_expr$1 = 0;
          prvTraceStoreObjectNameOnCloseEvent((traceHandle)tmp_if_expr$1, 5);
          signed int tmp_if_expr$2;
          if(!((uint32_t)xTimer == 0u))
            tmp_if_expr$2 = (signed int)(traceHandle)((Timer_t *)xTimer)->uxTimerNumber;

          else
            tmp_if_expr$2 = 0;
          prvTraceStoreObjectPropertiesOnCloseEvent((traceHandle)tmp_if_expr$2, 5);
          signed int tmp_if_expr$3;
          if(!((uint32_t)xTimer == 0u))
            tmp_if_expr$3 = (signed int)(traceHandle)((Timer_t *)xTimer)->uxTimerNumber;

          else
            tmp_if_expr$3 = 0;
          prvTraceFreeObjectHandle(5, (traceHandle)tmp_if_expr$3);
        }

        else
        {
          signed int tmp_if_expr$4;
          if(!((uint32_t)xTimer == 0u))
            tmp_if_expr$4 = (signed int)(traceHandle)((Timer_t *)xTimer)->uxTimerNumber;

          else
            tmp_if_expr$4 = 0;
          prvTraceStoreKernelCall(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + (uint32_t)xCommandID + (xReturn == 1 ? 0u : (0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + 9ul) - (0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 16ul + 8ul + 0ul)), 5, (uint32_t)tmp_if_expr$4);
        }
    }

  }

  return xReturn;
}

// xTimerGetExpiryTime
// file ..\..\..\..\lib\FreeRTOS\timers.c line 442
TickType_t xTimerGetExpiryTime(TimerHandle_t xTimer)
{
  Timer_t *pxTimer=(Timer_t *)xTimer;
  TickType_t xReturn;
  if(xTimer == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\timers.c", 447u);

  xReturn = (&pxTimer->xTimerListItem)->xItemValue;
  return xReturn;
}

// xTimerGetPeriod
// file ..\..\..\..\lib\FreeRTOS\timers.c line 433
TickType_t xTimerGetPeriod(TimerHandle_t xTimer)
{
  Timer_t *pxTimer=(Timer_t *)xTimer;
  if(xTimer == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\timers.c", 437u);

  return pxTimer->xTimerPeriodInTicks;
}

// xTimerGetTimerDaemonTaskHandle
// file ..\..\..\..\lib\FreeRTOS\timers.c line 424
TaskHandle_t xTimerGetTimerDaemonTaskHandle(void)
{
  if(xTimerTaskHandle == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\timers.c", 428u);

  return xTimerTaskHandle;
}

// xTimerIsTimerActive
// file ..\..\..\..\lib\FreeRTOS\timers.c line 945
BaseType_t xTimerIsTimerActive(TimerHandle_t xTimer)
{
  BaseType_t xTimerIsInActiveList;
  Timer_t *pxTimer=(Timer_t *)xTimer;
  if(xTimer == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\timers.c", 950u);

  vPortEnterCritical();
  xTimerIsInActiveList = (BaseType_t)!((BaseType_t)((&pxTimer->xTimerListItem)->pvContainer == NULL) != 0l);
  vPortExitCritical();
  return xTimerIsInActiveList;
}

// xTimerPendFunctionCall
// file ..\..\..\..\lib\FreeRTOS\timers.c line 1023
BaseType_t xTimerPendFunctionCall(PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait)
{
  DaemonTaskMessage_t xMessage;
  BaseType_t xReturn;
  if(xTimerQueue == NULL)
    vAssertCalled("..\\..\\..\\..\\lib\\FreeRTOS\\timers.c", 1031u);

  xMessage.xMessageID = (BaseType_t)-1;
  xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
  xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
  xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
  xReturn=xQueueGenericSend(xTimerQueue, (const void *)&xMessage, xTicksToWait, 0);
  if(xReturn == 1)
  {
    TaskHandle_t return_value_xTimerGetTimerDaemonTaskHandle=xTimerGetTimerDaemonTaskHandle();
    UBaseType_t return_value_uxTaskGetTaskNumber=uxTaskGetTaskNumber(return_value_xTimerGetTimerDaemonTaskHandle);
    prvTraceStoreKernelCall(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 0ul, 3, return_value_uxTaskGetTaskNumber);
  }

  else
  {
    TaskHandle_t return_value_xTimerGetTimerDaemonTaskHandle$0=xTimerGetTimerDaemonTaskHandle();
    UBaseType_t return_value_uxTaskGetTaskNumber$0=uxTaskGetTaskNumber(return_value_xTimerGetTimerDaemonTaskHandle$0);
    prvTraceStoreKernelCall(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 2ul, 3, return_value_uxTaskGetTaskNumber$0);
  }
  return xReturn;
}

// xTimerPendFunctionCallFromISR
// file ..\..\..\..\lib\FreeRTOS\timers.c line 999
BaseType_t xTimerPendFunctionCallFromISR(PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken)
{
  DaemonTaskMessage_t xMessage;
  BaseType_t xReturn;
  xMessage.xMessageID = (BaseType_t)-2;
  xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
  xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
  xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
  xReturn=xQueueGenericSendFromISR(xTimerQueue, (const void *)&xMessage, pxHigherPriorityTaskWoken, 0);
  if(uiInEventGroupSetBitsFromISR == 0)
  {
    TaskHandle_t return_value_xTimerGetTimerDaemonTaskHandle=xTimerGetTimerDaemonTaskHandle();
    UBaseType_t return_value_uxTaskGetTaskNumber=uxTaskGetTaskNumber(return_value_xTimerGetTimerDaemonTaskHandle);
    prvTraceStoreKernelCall(0x0ul + 1ul + 3ul + 4ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 8ul + 1ul, 3, return_value_uxTaskGetTaskNumber);
  }

  uiInEventGroupSetBitsFromISR = 0;
  return xReturn;
}

// xTraceGetLastError
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 385
const char * xTraceGetLastError(void)
{
  return traceErrorMessage;
}

// xTraceGetTraceBuffer
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 415
void * xTraceGetTraceBuffer(void)
{
  return (void *)RecorderDataPtr;
}

// xTraceRegisterString
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 1504
traceString xTraceRegisterString(const char *label)
{
  if(label == ((const char *)NULL))
  {
    prvTraceError("TRACE_ASSERT: xTraceRegisterString: label == NULL");
    return 0;
  }

  else
  {
    traceString return_value_prvTraceOpenSymbol=prvTraceOpenSymbol(label, 0);
    return return_value_prvTraceOpenSymbol;
  }
}

// xTraceSetISRProperties
// file ..\..\..\..\lib\third_party\tracealyzer_recorder\trcSnapshotRecorder.c line 551
traceHandle xTraceSetISRProperties(const char *name, uint8_t priority)
{
  static traceHandle handle=0;
  handle = handle + 1;
  if(!((signed int)RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[4ll] >= (signed int)handle))
  {
    prvTraceError("TRACE_ASSERT: xTraceSetISRProperties: Invalid value for handle");
    return 0;
  }

  else
    if(name == ((const char *)NULL))
    {
      prvTraceError("TRACE_ASSERT: xTraceSetISRProperties: name == NULL");
      return 0;
    }

    else
    {
      prvTraceSetObjectName(4, handle, name);
      prvTraceSetPriorityProperty(4, handle, priority);
      return handle;
    }
}

